<Type Name="Uri" FullName="System.Uri">
  <Metadata><Meta Name="ms.openlocfilehash" Value="738c474c9be14f9776308231a921b3c5531b864e" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53567737" /></Metadata><TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona una representación de objeto de un identificador de recursos uniforme (URI) y un acceso sencillo a las partes del identificador URI.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un URI es una representación compacta de un recurso disponible para la aplicación en la intranet o Internet. La <xref:System.Uri> clase define las propiedades y métodos para controlar los URI, que se incluyen análisis, la comparación y combinación. El <xref:System.Uri> propiedades de la clase son de solo lectura; para crear un objeto modificable, use la <xref:System.UriBuilder> clase.  
  
 Los identificadores URI relativos (por ejemplo, "/ /New/index.htm") debe ampliarse con respecto a un URI base para que sean absolutas. El <xref:System.Uri.MakeRelative%2A> se proporciona el método para convertir los identificadores URI absolutos en identificadores URI relativos, cuando sea necesario.  
  
 El <xref:System.Uri> constructores no convierte las cadenas URI si la cadena es un URI bien formado incluye un identificador de esquema.  
  
 El <xref:System.Uri> propiedades devuelven una representación de datos canónicos en codificación de escape, y todos los caracteres con valores de Unicode mayores que 127 se reemplazan por su equivalente hexadecimal. Para poner el identificador URI en forma canónica, la <xref:System.Uri> constructor realiza los pasos siguientes:  
  
-   El esquema de URI se convierte a minúsculas.  
  
-   El nombre de host se convierte a minúsculas.  
  
-   Si el nombre de host es una dirección IPv6, se usa la dirección IPv6 canónica. Se quitan ScopeId y otros datos opcionales de IPv6.  
  
-   Quita de forma predeterminada y los números de puerto vacío.
  
-   Convierte las rutas de acceso de archivo implícito sin el esquema file:// (por ejemplo, "C:\my\file") en rutas de acceso explícita con el esquema file://.
  
-   Descodificación de caracteres de escape (también conocido como octetos codificados por porcentaje) que no tienen un propósito reservado (también conocido como sin escape). Estos caracteres reservados se encuentran en mayúsculas y minúsculas (% 41-% 5A y % 61-% 7), los dígitos decimales (30-% 39), guión (% 2D), el período (% 2E), un carácter de subrayado (% 5F) y tilde (% 7E).

-   Canoniza la ruta de acceso para un URI jerárquico mediante la compactación de secuencias como /., / /... /, y / / (si la secuencia de escape). Tenga en cuenta que hay algunos esquemas para los que no se compactan estas secuencias.
  
-   Para los identificadores URI jerárquico, si el host no se termina con una barra diagonal (/), se agrega uno.  
  
-   De forma predeterminada, los caracteres reservados en el URI se escapan RFC 2396. Este comportamiento cambia si está habilitado el análisis de identificadores internacionales de recursos o nombre de dominio internacional en qué caso los caracteres reservados en el URI se escapan con arreglo a RFC 3986 y RFC 3987.

 Como parte de canonización en el constructor para algunos esquemas, segmentos de punto y vacío (o., / /.. /, y / /) se compactan (en otras palabras, se eliminan). Los esquemas para los que el URI compactará estas secuencias son http, https, tcp, net.pipe y net.tcp. Para algunos otros esquemas, no se compactan estas secuencias. Aquí es cómo esta compactación se ve en la práctica.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Cuando se ejecuta este código, devuelve el resultado siguiente, con las secuencias de escape escape en caso necesario y, a continuación, se compactan.

```  
http://myUrl/  
/  
```  
  
 Puede transformar el contenido de la <xref:System.Uri> clase a partir de una referencia de URI codificada de escape en una referencia URI legible utilizando el <xref:System.Uri.ToString%2A> método. Tenga en cuenta que algunos caracteres reservados aún pueden convertirse en la salida de la <xref:System.Uri.ToString%2A> método. Esto es para facilitar la reconstrucción inequívoca de un identificador URI del valor devuelto por <xref:System.Uri.ToString%2A>.  
  
 Algunos identificadores URI incluyen una consulta o un identificador de fragmento. Un identificador de fragmento es cualquier texto que sigue a un signo de número (#), sin incluir el signo de número; el texto del fragmento se almacena en el <xref:System.Uri.Fragment%2A> propiedad. Información de consulta es cualquier texto que sigue a un signo de interrogación (?) en el URI; el texto de consulta se almacena en el <xref:System.Uri.Query%2A> propiedad.  
  
 En .NET Framework versión 1.1, si la cadena especificada a un constructor contiene un esquema desconocido y "c:\\", las inserciones de la clase Uri "/ /" después de los dos puntos. Por ejemplo, el URI `xyz:c:\abc` se convierte en `xyz://c:/abc`. En la versión 2.0 de .NET Framework, este comportamiento se ha eliminado y el ejemplo de cadena se convierte en `xyz:c:/abc`.  
  
> [!NOTE]
>  La clase URI admite el uso de direcciones IP en ambas notación de cuatro para el protocolo IPv4 y hexadecimal con dos puntos para el protocolo IPv6. No olvide incluir la dirección IPv6 en los corchetes, como en http://[::1].  
  
## <a name="international-resource-identifier-support"></a>Compatibilidad de identificadores internacionales de recursos  
 Las direcciones Web normalmente se expresan mediante identificadores uniformes de recursos que se componen de un conjunto muy restringido de caracteres:  
  
-   Letras ASCII mayúsculas y minúsculas del alfabeto inglés.  
  
-   Dígitos del 0 al 9.  
  
-   Un número reducido de otros símbolos ASCII.  
  
 Las especificaciones de los URI se documentan en RFC 2396, RFC 2732, RFC 3986 y RFC 3987, publicado por Internet Engineering Task Force (IETF).  
  
 Debido a la expansión de Internet, hay una creciente necesidad de identificar los recursos mediante el uso de idiomas distintos del inglés. Los identificadores que responden a esta necesidad y permiten caracteres que no son ASCII (caracteres del juego de caracteres Unicode/ISO 10646) se conocen como Identificadores de recursos internacionales (IRI). Las especificaciones de los IRI están documentadas en RFC 3987, publicado por el IETF. El uso de IRI permite que una dirección URL contenga caracteres Unicode.  
  
 Existente <xref:System.Uri> se ha ampliado la clase en .NET Framework 3.5, 3.0 SP1 y 2.0 SP1 para proporcionar compatibilidad con IRI basada en RFC 3987. Los usuarios de versiones de .NET Framework anteriores a la versión 4.5 no verán ningún cambio respecto al comportamiento de .NET Framework 2.0, a menos que habiliten IRI específicamente. Esto garantiza la compatibilidad de las aplicaciones con versiones anteriores de .NET Framework.  
  
 Para habilitar la compatibilidad con IRI, se requiere el cambio siguiente:  
  
-   Especifique si desea analizar el nombre de dominio internacionalizado (IDN) aplicado en el nombre de dominio y si debe aplicarse las reglas de análisis de IRI. Esto puede hacerse el *machine.config* o en el *app.config* archivo. Por ejemplo, agregue lo siguiente:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Los usuarios de .NET Framework 4.5 y versiones más recientes siempre tienen IRI habilitado. Análisis de IRI no puede cambiarse mediante una *.config* archivo.  
  
 La activación de IDN convertirá todas la etiquetas Unicode de un nombre de dominio en sus equivalentes de Punycode. Los nombres de Punycode solo contienen caracteres ASCII y siempre empiezan con el prefijo xn--. De este modo, se admiten los servidores DNS existentes en Internet, ya que la mayoría de los servidores DNS solo admite caracteres ASCII (vea RFC 3940).  
  
 La activación de IRI e IDN afecta al valor de la propiedad <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType>. Cuando se habilitan IRI e IDN, también puede cambiar el comportamiento de los métodos <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> y <xref:System.Uri.IsWellFormedOriginalString%2A>.  
  
 Hay tres valores posibles para IDN dependiendo de los servidores DNS que se usan:  
  
-   IDN habilitado = All  
  
     Este valor convierte cualquier nombre de dominio Unicode a su equivalente Punycode (nombres IDN).  
  
-   IDN habilitado = AllExceptIntranet  
  
     Este valor convertirá todos los nombres de dominio Unicode no en la Intranet local para que utilicen sus equivalentes Punycode (nombres IDN). En este caso para controlar los nombres internacionales en la Intranet local, los servidores DNS que se usan para la Intranet deben admitir la resolución de nombre de Unicode.  
  
-   IDN habilitado = ninguno  
  
     Este valor no convierte ningún nombre de dominio Unicode para que se use Punycode. Este es el valor predeterminado que es coherente con el comportamiento de .NET Framework 2.0.  
  
 Cuando se habilita el análisis de IRI (iriParsing habilitado = `true`) se realizan la normalización y comprobación de caracteres según las últimas reglas IRI en RFC 3986 y RFC 3987. Cuando se deshabilita el análisis de IRI, normalización y comprobación de caracteres se realizan según RFC 2396 y RFC 2732 (para literales de IPv6).  En las versiones de .NET Framework anteriores a la versión 4.5, el valor predeterminado es `false`. En .NET Framework versión 4.5 y versiones más reciente, el valor predeterminado es `true`, y el estado habilitado del análisis de IRI no se puede modificar la configuración de un *.config* archivo.  
  
 IRI e IDN procesamiento en el <xref:System.Uri> clase también puede controlarse mediante el <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, y <xref:System.Configuration.UriSection?displayProperty=nameWithType> clases de valores de configuración. El valor <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> habilita o deshabilita el procesamiento de IRI en la clase <xref:System.Uri>. El valor <xref:System.Configuration.IdnElement?displayProperty=nameWithType> habilita o deshabilita el procesamiento de IDN en la clase <xref:System.Uri>. El valor <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> también controla indirectamente IDN. El procesamiento de IRI debe estar habilitado para que el procesamiento de IDN sea posible. Si el procesamiento de IRI está deshabilitado, el procesamiento de IDN se establecerá en el valor predeterminado, según el cual se usa el comportamiento de .NET Framework 2.0 para la compatibilidad y no se usan nombres IDN.  
  
 El valor de configuración para el <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> y <xref:System.Configuration.IdnElement?displayProperty=nameWithType> se leerá una vez cuando el primer <xref:System.Uri?displayProperty=nameWithType> se construye la clase. Después, se omitirán los cambios realizados en los valores de configuración.  
  
 La clase <xref:System.GenericUriParser?displayProperty=nameWithType> también se ha ampliado para permitir la creación de un analizador personalizable que admita IRI e IDN. Para especificar el comportamiento de un objeto <xref:System.GenericUriParser?displayProperty=nameWithType>, se pasa una combinación bit a bit de los valores disponibles en la enumeración <xref:System.GenericUriParserOptions?displayProperty=nameWithType> al constructor <xref:System.GenericUriParser?displayProperty=nameWithType>. El tipo <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> indica que el analizador admite las reglas de análisis especificadas en RFC 3987 para los Identificadores de recursos internacionales (IRI). El uso de IRI viene determinado por los valores de configuración que se ha indicado anteriormente.  
  
 El tipo <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> indica que el analizador admite el análisis del Nombre de dominio internacionalizado (IDN) de los nombres de host. El uso de IDN viene determinado por los valores de configuración que se ha indicado anteriormente.  
  
## <a name="implicit-file-path-support"></a>Soporte técnico de ruta de acceso de archivo implícitas
 <xref:System.Uri> También puede utilizarse para representar las rutas de acceso del sistema de archivos local. Estas rutas de acceso se pueden representar *explícitamente* en los URI que comienzan con el esquema file://, y *implícitamente* en identificadores URI que no tiene el esquema file://. Como ejemplo concreto, los dos URI siguientes son ambas válidas y representan la misma ruta de acceso de archivo:
```csharp
Uri uri1 = new Uri("C:/test/path/file.txt") // Implicit file path.
Uri uri2 = new Uri("file:///C:/test/path/file.txt") // Explicit file path.
```
 Estas rutas de acceso de archivo implícitas no son compatibles con la especificación de URI y por lo tanto deberían evitarse siempre que sea posible. Cuando se usa .NET Core en sistemas basados en Unix, las rutas de acceso de archivo implícita pueden ser especialmente problemáticos, porque es una ruta de acceso absoluta del archivo implícita *distinguir* desde una ruta de acceso relativa. Cuando está presente, esta ambigüedad <xref:System.Uri> predeterminado para interpretar la ruta de acceso como un URI absoluto.
  
## <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 Si usa un *Web.config * archivo que contiene los URI para inicializar el tiempo de aplicación, adicional es necesario para procesar los URI si sus identificadores de esquema son no estándares. En tal caso, inicialice las partes afectadas de la aplicación cuando se necesitan los URI, no a la hora de inicio.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una instancia de la <xref:System.Uri> clase y se utiliza para crear un <xref:System.Net.WebRequest> instancia.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>Por motivos de seguridad, la aplicación debe tener cuidado al aceptar <see cref="T:System.Uri" /> instancias de orígenes de confianza y con <paramref name="dontEscape" /> establecido en <see langword="true" />. Puede comprobar la validez de una cadena URI mediante una llamada a la <see cref="M:System.Uri.IsWellFormedOriginalString" /> método.</para></block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
    <related type="Article" href="https://msdn.microsoft.com/library/35883fe9-2d09-4d8b-80ca-cf23a941e459">Cambios realizados en el espacio de nombres System.Uri de la versión 2.0</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b5e994c3-3535-4aff-8e1b-b69be22e9a22">Compatibilidad de identificadores de recursos internacionales en System.UriSystem.Uri</related>
    <related type="Article" href="~/docs/framework/network-programming/index.md">Programación para redes en .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Cadena que identifica el recurso que la instancia de <see cref="T:System.Uri" /> va a representar. Tenga en cuenta que las direcciones IPv6 en forma de cadena deben indicarse entre corchetes. Por ejemplo, "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Uri" /> con el identificador URI especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un <xref:System.Uri> instancia de una cadena URI. Analiza el identificador URI, lo pone en formato canónico y realiza las codificaciones de escape necesarias.  
  
 Este constructor no garantiza que el <xref:System.Uri> hace referencia a un recurso accesible.  
  
 Este constructor supone que el `string` parámetro hace referencia a un URI absoluto y es equivalente a llamar a la <xref:System.Uri.%23ctor%2A> constructor con <xref:System.UriKind> establecido en <xref:System.UriKind.Absolute>. Si el `string` parámetro pasado al constructor es un URI relativo, este constructor iniciará un <xref:System.UriFormatException>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> instancia con el URI "http://www.contoso.com/".  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="uriString" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> está vacía.  
  
O bien 
El esquema especificado en <paramref name="uriString" /> no está formado correctamente. Vea <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
O bien 
 <paramref name="uriString" /> contiene demasiadas barras diagonales.  
  
O bien 
La contraseña especificada en <paramref name="uriString" /> no es válida.  
  
O bien 
El nombre de host especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
El nombre de archivo especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
El nombre de usuario especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
El nombre de host o de autoridad especificado en <paramref name="uriString" /> no puede terminar con barras diagonales inversas.  
  
O bien 
El número de puerto especificado en <paramref name="uriString" /> no es válido o no se puede analizar.  
  
O bien 
La longitud de <paramref name="uriString" /> es superior a 65 519 caracteres.  
  
O bien 
La longitud del esquema especificado en <paramref name="uriString" /> supera los 1023 caracteres.  
  
O bien 
Existe una secuencia de caracteres no válida en <paramref name="uriString" />.  
  
O bien 
La ruta de acceso a MS-DOS especificada en <paramref name="uriString" /> debe comenzar por c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Instancia de la clase <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene la información necesaria para serializar la nueva instancia de <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Instancia de la clase <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene el origen del flujo serializado asociado a la nueva instancia de <see cref="T:System.Uri" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Uri" /> desde las instancias especificadas de las clases <see cref="T:System.Runtime.Serialization.SerializationInfo" /> y <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor implementa la <xref:System.Runtime.Serialization.ISerializable> interfaz para el <xref:System.Uri> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="serializationInfo" /> contiene un URI <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">El <paramref name="serializationInfo" /> parámetro contiene un URI que está vacío.  
  
O bien 
El esquema especificado no tiene el formato correcto. Vea <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
O bien 
El URI contiene demasiadas barras diagonales.  
  
O bien 
La contraseña especificada en el URI no es válida.  
  
O bien 
El nombre de host especificado en el URI no es válido.  
  
O bien 
El nombre de archivo especificado en el URI no es válido.  
  
O bien 
El nombre de usuario especificado en el URI no es válido.  
  
O bien 
El nombre de host o de autoridad especificado en el URI no puede terminar con barras diagonales inversas.  
  
O bien 
El número de puerto especificado en el URI no es válido o no se puede analizar.  
  
O bien 
La longitud del URI supera los 65 519 caracteres.  
  
O bien 
La longitud del esquema especificado en el URI supera los 1023 caracteres.  
  
O bien 
Existe una secuencia de caracteres no válida en el URI.  
  
O bien 
La ruta de acceso a MS-DOS especificada en el URI debe comenzar por c:\\\\.</exception>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serialización de SOAP y XML</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Cadena que identifica el recurso que la instancia de <see cref="T:System.Uri" /> va a representar. Tenga en cuenta que las direcciones IPv6 en forma de cadena deben indicarse entre corchetes. Por ejemplo, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape">Es <see langword="true" /> si <paramref name="uriString" /> es totalmente de escape; en caso contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Uri" /> con el identificador URI especificado, con control explícito de la secuencia de escape de carácter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un <xref:System.Uri> instancia de una cadena URI. Analiza el identificador URI y lo coloca en formato canónico.  
  
 El `dontEscape` parámetro controla si los caracteres reservados se traducen en secuencias de escape. Este parámetro debe establecerse en `true` solo si está seguro de que se ha realizado todos los caracteres reservados en el URI. El valor `true` para un URI que no se ha realizado por completo puede provocar un comportamiento inesperado. Se recomienda encarecidamente que siempre establezca este parámetro en `false`.  
  
 Si `dontEscape` está establecido en `false`, el constructor escapes de caracteres reservados comprobando que todas las apariciones de porcentaje (%) van seguidas de una secuencia de escape válida. Si la secuencia de caracteres que sigue a un porcentaje no es válida, el porcentaje se reemplaza en un 25%.  
  
 Este constructor no garantiza que el <xref:System.Uri> hace referencia a un recurso accesible.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> instancia para el URI http://www.contoso.com/Hello%20World.htm. Dado que el identificador URI incluido completamente la secuencia de escape y se encuentra en forma canónica, el `dontEscape` parámetro puede establecerse en `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="uriString" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="uriString" /> está vacío o sólo contiene espacios.  
  
O bien 
El esquema especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
 <paramref name="uriString" /> contiene demasiadas barras diagonales.  
  
O bien 
La contraseña especificada en <paramref name="uriString" /> no es válida.  
  
O bien 
El nombre de host especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
El nombre de archivo especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
El nombre de usuario especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
El nombre de host o de autoridad especificado en <paramref name="uriString" /> no puede terminar con barras diagonales inversas.  
  
O bien 
El número de puerto especificado en <paramref name="uriString" /> no es válido o no se puede analizar.  
  
O bien 
La longitud de <paramref name="uriString" /> es superior a 65 519 caracteres.  
  
O bien 
La longitud del esquema especificado en <paramref name="uriString" /> supera los 1023 caracteres.  
  
O bien 
Existe una secuencia de caracteres no válida en <paramref name="uriString" />.  
  
O bien 
La ruta de acceso a MS-DOS especificada en <paramref name="uriString" /> debe comenzar por c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Cadena que identifica el recurso que la instancia de <see cref="T:System.Uri" /> va a representar. Tenga en cuenta que las direcciones IPv6 en forma de cadena deben indicarse entre corchetes. Por ejemplo, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Especifica si la cadena URI es un identificador URI relativo, un identificador URI absoluto, o si está sin determinar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Uri" /> con el identificador URI especificado. Este constructor permite especificar si la cadena URI corresponde a un identificador URI relativo, a un identificador URI absoluto, o si está sin determinar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI relativas y absolutas tienen distintas restricciones en su formato. Por ejemplo, un URI relativo no requiere un esquema o una entidad. El valor especificado en `uriKind` debe coincidir con el tipo de identificador URI pasado en `uriString`. Sin embargo, si <xref:System.UriKind.RelativeOrAbsolute> se especifica, la cadena URI puede ser relativa o absoluta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uriKind" /> no es válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="uriString" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> contiene un URI relativo y <paramref name="uriKind" /> es <see cref="F:System.UriKind.Absolute" />.  
  
o 
 <paramref name="uriString" /> contiene un URI absoluto y <paramref name="uriKind" /> es <see cref="F:System.UriKind.Relative" />.  
  
o 
 <paramref name="uriString" /> está vacía.  
  
O bien 
El esquema especificado en <paramref name="uriString" /> no está formado correctamente. Vea <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
O bien 
 <paramref name="uriString" /> contiene demasiadas barras diagonales.  
  
O bien 
La contraseña especificada en <paramref name="uriString" /> no es válida.  
  
O bien 
El nombre de host especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
El nombre de archivo especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
El nombre de usuario especificado en <paramref name="uriString" /> no es válido.  
  
O bien 
El nombre de host o de autoridad especificado en <paramref name="uriString" /> no puede terminar con barras diagonales inversas.  
  
O bien 
El número de puerto especificado en <paramref name="uriString" /> no es válido o no se puede analizar.  
  
O bien 
La longitud de <paramref name="uriString" /> es superior a 65 519 caracteres.  
  
O bien 
La longitud del esquema especificado en <paramref name="uriString" /> supera los 1023 caracteres.  
  
O bien 
Existe una secuencia de caracteres no válida en <paramref name="uriString" />.  
  
O bien 
La ruta de acceso a MS-DOS especificada en <paramref name="uriString" /> debe comenzar por c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">Identificador URI base.</param>
        <param name="relativeUri">Identificador URI relativo que se va a agregar al identificador URI base.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Uri" /> basada en la cadena especificada de identificador URI base y relativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un <xref:System.Uri> instancia mediante la combinación del `baseUri` y `relativeUri`. Si `relativeUri` es un URI absoluto (que contiene un esquema, nombre de host y, opcionalmente, un número de puerto), el <xref:System.Uri> instancia se crea utilizando únicamente `relativeUri`.  
 
 Si el `baseUri` tiene partes relativas (como `/api`), a continuación, la parte relativa debe terminar con una barra diagonal, (como `/api/`), si la parte relativa de `baseUri` va a ser conservan en construido <xref:System.Uri>. 

 Además, si la `relativeUri` comienza con una barra diagonal, a continuación, se reemplazará cualquier parte relativa de la `baseUri`

 Este constructor no garantiza que el <xref:System.Uri> hace referencia a un recurso accesible.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una nueva instancia de la <xref:System.Uri> clase mediante la combinación de los URI relativos http://www.contoso.com y /catalog/shownew.htm para formar el URI absoluto http://www.contoso.com/catalog/shownew.htm.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="baseUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> no es una instancia <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.FormatException" />.</para>
          </block>
El URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> está vacío o solo contiene espacios en blanco.  
  
O bien 
El esquema especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> contiene demasiadas barras diagonales.  
  
O bien 
La contraseña especificada en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válida.  
  
O bien 
El nombre de host especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El nombre de archivo especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El nombre de usuario especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El nombre de host o de autoridad especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no puede terminar con barras diagonales inversas.  
  
O bien 
El número de puerto especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido o no se puede analizar.  
  
O bien 
La longitud del URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> supera los 65519 caracteres.  
  
O bien 
La longitud del esquema especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> supera los 1023 caracteres.  
  
O bien 
Hay una secuencia de caracteres no válida en el URI formado mediante la combinación <paramref name="baseUri" /> y <paramref name="relativeUri" />.  
  
O bien 
La ruta de acceso a MS-DOS especificada en <paramref name="uriString" /> debe comenzar por c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri"><see cref="T:System.Uri" /> absoluto que es la base de la nueva instancia de <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Instancia de <see cref="T:System.Uri" /> relativo que se combina con <paramref name="baseUri" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Uri" /> basada en la combinación de una instancia especificada de <see cref="T:System.Uri" /> base y una instancia de <see cref="T:System.Uri" /> relativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Uri> instancia combinando absoluta <xref:System.Uri> instancia, `baseUri`, con relativa <xref:System.Uri> instancia, `relativeUri`. Si `relativeUri` es absoluto <xref:System.Uri> instancia (que contiene un esquema, nombre de host y, opcionalmente, un número de puerto), el <xref:System.Uri> instancia se crea utilizando únicamente `relativeUri`.  
 
 Si el `baseUri` tiene partes relativas (como `/api`), a continuación, la parte relativa debe terminar con una barra diagonal, (como `/api/`), si la parte relativa de `baseUri` va a ser conservan en construido <xref:System.Uri>. 

 Además, si la `relativeUri` comienza con una barra diagonal, a continuación, se reemplazará cualquier parte relativa de la `baseUri`
 
 Este constructor no garantiza que el <xref:System.Uri> hace referencia a un recurso accesible.  
  
   
  
## Examples  
 Este ejemplo crea un absoluto <xref:System.Uri> instancia, `absoluteUri`, relativa <xref:System.Uri> instancia, `relativeUri`. Un nuevo <xref:System.Uri> instancia, `combinedUri`, a continuación, se crea desde estas dos instancias.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseUri" /> no es una instancia <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="baseUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> no es una instancia <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.FormatException" />.</para>
          </block>
El URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> está vacío o solo contiene espacios en blanco.  
  
O bien 
El esquema especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> contiene demasiadas barras diagonales.  
  
O bien 
La contraseña especificada en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válida.  
  
O bien 
El nombre de host especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El nombre de archivo especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El nombre de usuario especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El nombre de host o de autoridad especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no puede terminar con barras diagonales inversas.  
  
O bien 
El número de puerto especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido o no se puede analizar.  
  
O bien 
La longitud del URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> supera los 65519 caracteres.  
  
O bien 
La longitud del esquema especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> supera los 1023 caracteres.  
  
O bien 
Hay una secuencia de caracteres no válida en el URI formado mediante la combinación <paramref name="baseUri" /> y <paramref name="relativeUri" />.  
  
O bien 
La ruta de acceso a MS-DOS especificada en <paramref name="uriString" /> debe comenzar por c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">Identificador URI base.</param>
        <param name="relativeUri">Identificador URI relativo que se va a agregar al identificador URI base.</param>
        <param name="dontEscape">Es <see langword="true" /> si <paramref name="uriString" /> es totalmente de escape; en caso contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Uri" /> basada en los identificadores URI base y relativo especificados, con control explícito de la secuencia de escape de carácter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un <xref:System.Uri> instancia mediante la combinación `baseUri` y `relativeUri`. Si el URI pasado en `relativeUri` es un URI absoluto (que contiene un esquema, nombre de host y, opcionalmente, un número de puerto), el <xref:System.Uri> instancia se crea utilizando únicamente `relativeUri`.  
  
 El `dontEscape` parámetro controla si los caracteres reservados se traducen en secuencias de escape. Este parámetro debe establecerse en `true` solo si está seguro de que se ha realizado todos los caracteres reservados en el URI. El valor `true` para un URI que no se ha realizado por completo puede provocar un comportamiento inesperado. Se recomienda encarecidamente que siempre establezca este parámetro en `false`. Si `dontEscape` está establecido en `false`, el constructor escapes de caracteres reservados comprobando que todas las apariciones de porcentaje (%) van seguidas de una secuencia de escape válida. Si la secuencia de caracteres que sigue a un porcentaje no es válida, el porcentaje se reemplaza en un 25%.  
  
 Este constructor no garantiza que el <xref:System.Uri> hace referencia a un recurso accesible.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una nueva instancia de la <xref:System.Uri> clase mediante la combinación de los URI relativos http://www.contoso.com y Hello%20World.htm para formar un URI absoluto.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="baseUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> no es una instancia <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.UriFormatException">El URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> está vacío o solo contiene espacios en blanco.  
  
O bien 
El esquema especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> contiene demasiadas barras diagonales.  
  
O bien 
La contraseña especificada en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válida.  
  
O bien 
El nombre de host especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El nombre de archivo especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El nombre de usuario especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido.  
  
O bien 
El nombre de host o de autoridad especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no puede terminar con barras diagonales inversas.  
  
O bien 
El número de puerto especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> no es válido o no se puede analizar.  
  
O bien 
La longitud del URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> supera los 65519 caracteres.  
  
O bien 
La longitud del esquema especificado en el URI formado mediante la combinación de <paramref name="baseUri" /> y <paramref name="relativeUri" /> supera los 1023 caracteres.  
  
O bien 
Hay una secuencia de caracteres no válida en el URI formado mediante la combinación <paramref name="baseUri" /> y <paramref name="relativeUri" />.  
  
O bien 
La ruta de acceso a MS-DOS especificada en <paramref name="uriString" /> debe comenzar por c:\\\\.</exception>
        <block subset="none" type="usage"><para>Por motivos de seguridad, la aplicación no debe llamar a este constructor con cadenas URI de fuentes no confiables y con <paramref name="dontEscape" /> establecido en <see langword="true" />. Como alternativa, puede comprobar la validez de una cadena URI mediante una llamada a la <see cref="M:System.Uri.IsWellFormedOriginalString" /> método antes de llamar a este constructor.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso absoluta del identificador URI.</summary>
        <value><see cref="T:System.String" /> que contiene la ruta de acceso absoluta al recurso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.AbsolutePath%2A> propiedad contiene la información de ruta de acceso que el servidor utiliza para resolver solicitudes de información. Normalmente, esto es la ruta de acceso a la información deseada en el sistema de archivos del servidor, aunque también puede indicar la aplicación o el servidor debe ejecutar para proporcionar la información de la secuencia de comandos.  
  
 La información de ruta de acceso no incluye el esquema, nombre de host o parte de la consulta del URI.  
  
   
  
## Examples  
 El ejemplo siguiente escribe la ruta de acceso /catalog/shownew.htm en la consola.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador URI absoluto.</summary>
        <value><see cref="T:System.String" /> que contiene el identificador URI completo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.AbsoluteUri%2A> propiedad incluye el identificador URI completo almacenado en el <xref:System.Uri> instancia, incluidos todos los fragmentos y cadenas de consulta.  
  
   
  
## Examples  
 El ejemplo siguiente escribe el contenido completo de la <xref:System.Uri> instancia en la consola. En el ejemplo se muestra, http://www.contoso.com/catalog/shownew.htm?date=today se escribe en la consola.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de host DNS (Sistema de nombres de dominio) o la dirección IP y el número de puerto de un servidor.</summary>
        <value><see cref="T:System.String" /> que contiene el componente de autoridad del identificador URI representado por esta instancia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.Authority%2A> propiedad suele ser un nombre de host de servidor DNS o dirección IP. Esta propiedad puede incluir el número de puerto de servicio si es diferente del puerto predeterminado para el URI. Si el <xref:System.Uri.Authority%2A> componente contiene caracteres reservados, estos son secuencias de escape en el valor de cadena devuelto por esta propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente escribe el nombre de host (www.contoso.com) y el número de puerto (8080) del servidor en la consola.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el identificador URI almacenado internamente en formato canónico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Almacena internamente la versión canónica del URI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y este método sólo es válido para identificadores URI absolutos.</exception>
        <exception cref="T:System.UriFormatException">El identificador URI no tiene el formato correcto.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de host que se va a validar. Puede ser una dirección IPv4 o IPv6, o un nombre de host de Internet.</param>
        <summary>Determina si el nombre de host especificado es un nombre DNS válido.</summary>
        <returns><see cref="T:System.UriHostNameType" /> que indica el tipo del nombre de host. Si no puede determinarse el tipo del nombre de host o si el nombre del host es <see langword="null" /> o una cadena de longitud cero, este método devuelve <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.CheckHostName%2A> método comprueba que el nombre de host proporcionado cumple los requisitos para un nombre de host de Internet válido. Sin embargo, no es así, realizar una búsqueda de nombre de host para comprobar la existencia del host.  
  
   
  
## Examples  
 El ejemplo siguiente comprueba si el nombre de host es válido.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Nombre de esquema que se va a validar.</param>
        <summary>Determina si el nombre de esquema especificado es válido.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si el nombre de esquema es válido; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba el nombre de esquema para la validez de acuerdo con RFC 2396 de forma predeterminada. Si están habilitado el análisis de nombres de dominio internacionalizados (IDN) o identificadores de recursos internacionales (IRI), este método comprueba el nombre de esquema para la validez de acuerdo con RFC 3986. El nombre de esquema debe comenzar con una letra y debe contener solo letras, dígitos y los caracteres ".", "+" o "-".  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y comprueba si el nombre de esquema es válido.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Llamar a este método no tiene ningún efecto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">Primer objeto <see cref="T:System.Uri" />.</param>
        <param name="uri2">Segundo objeto <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Combinación bit a bit de los valores <see cref="T:System.UriComponents" /> que especifica las partes de <paramref name="uri1" /> y <paramref name="uri2" /> que se van a comparar.</param>
        <param name="compareFormat">Uno de los valores <see cref="T:System.UriFormat" /> que especifica la secuencia de escape de carácter usada al comparar los componentes del identificador URI.</param>
        <param name="comparisonType">Uno de los valores de <see cref="T:System.StringComparison" />.</param>
        <summary>Compara las partes especificadas de dos identificadores URI utilizando las reglas de comparación especificadas.</summary>
        <returns>Valor <see cref="T:System.Int32" /> que indica la relación léxica entre los componentes <see cref="T:System.Uri" /> comparados.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Significado 
 </description></listheader><item><term> Menor que cero 
 </term><description><paramref name="uri1" /> es menor que <paramref name="uri2" />.  
  
 </description></item><item><term> Cero 
 </term><description><paramref name="uri1" /> es igual que <paramref name="uri2" />.  
  
 </description></item><item><term> Mayor que cero 
 </term><description><paramref name="uri1" /> es mayor que <paramref name="uri2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ambos `uri1` y `uri2` son `null`, este método devuelve 0. Al comparar los valores de URI, un URI relativo es siempre menor que un URI absoluto y un URI distinto de null siempre es mayor que un URI nulo. Para los casos donde ambos `uri1` y `uri2` no `null` y son los identificadores URI relativos o URI absolutos, el <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método realiza la comparación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un nombre de host que, una vez convertido en nombre de host sin escape en caso necesario, se puede usar de forma segura para la resolución DNS.</summary>
        <value>Un <see cref="T:System.String" /> que contiene la parte del host del URI en un formato adecuado para la resolución de DNS, o la cadena de host original, si ya es adecuada para la resolución.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para las direcciones IPv6, se quitan los corchetes ([]) y el <xref:System.Net.IPAddress.ScopeId%2A> se establece la propiedad, si se especificó cuando se construyó esta instancia.

Si usa una cadena de escape para construir esta instancia (por ejemplo, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), DnsSafeHost, a continuación, devuelve una cadena de escape. Unescape devuelto desde cualquier cadena de escape `DnsSafeHost` antes de usar esa cadena para la resolución DNS (vea el ejemplo). Si usa una cadena sin escape no válida para construir esta instancia (por ejemplo, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), DnsSafeHost, a continuación, devuelve una cadena sin escape.
  
 El <xref:System.Uri.DnsSafeHost%2A> propiedad es dependiente de los valores de configuración, como se describe más adelante en este tema. Opciones de configuración no se puede cambiar las aplicaciones de Windows Store, que puede producir resultados incoherentes al usar <xref:System.Uri.DnsSafeHost%2A>. El <xref:System.Uri.IdnHost%2A> propiedad se proporciona como la alternativa preferida para usar <xref:System.Uri.DnsSafeHost%2A>, porque <xref:System.Uri.IdnHost%2A> se garantiza que siempre es seguro, con independencia de qué actual DNS *app.config* podría ser la configuración.  
  
 El <xref:System.Uri.DnsSafeHost%2A> propiedad se ha ampliado en .NET Framework 3.5, 3.0 SP1 y 2.0 SP1 para proporcionar el identificador de recursos internacionales (IRI) admite según RFC 3987. Los usuarios actuales no percibirán ningún cambio respecto al comportamiento de .NET Framework 2.0, a menos que habiliten IRI específicamente. Esto garantiza la compatibilidad de las aplicaciones con versiones anteriores de .NET Framework.  
  
 Para habilitar la compatibilidad con IRI, se requieren los siguientes dos cambios:  
  
1.  Agregue la siguiente línea a la *machine.config* archivo bajo el directorio de .NET Framework 2.0  
  
     \<nombre de sección = "uri" type="System.Configuration.UriSection, sistema, versión = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089" / >  
  
2.  Especifique si desea analizar el nombre de dominio internacionalizado (IDN) aplicado en el nombre de dominio y si debe aplicarse las reglas de análisis de IRI. Esto puede hacerse el *machine.config* o en el *app.config* archivo. Por ejemplo, agregue lo siguiente:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 La activación de IDN convertirá todas la etiquetas Unicode de un nombre de dominio en sus equivalentes de Punycode. Los nombres de Punycode solo contienen caracteres ASCII y siempre empiezan con el prefijo xn--. De este modo, se admiten los servidores DNS existentes en Internet, ya que la mayoría de los servidores DNS solo admite caracteres ASCII (vea RFC 3940).  
  
 La activación de IDN afecta únicamente al valor de la <xref:System.Uri.DnsSafeHost%2A> propiedad.  
  
 Hay tres valores posibles para IDN dependiendo de los servidores DNS que se usan:  
  
-   IDN habilitado = All  
  
     Este valor convierte cualquier nombre de dominio Unicode a su equivalente Punycode (nombres IDN).  
  
-   IDN habilitado = AllExceptIntranet  
  
     Este valor convertirá todos los nombres de dominio Unicode externos para que se utilicen sus equivalentes Punycode (nombres IDN). En este caso, para administrar los nombres internacionales en la intranet local, los servidores DNS que se utilizan para la intranet deben admitir los nombres Unicode.  
  
-   IDN habilitado = ninguno  
  
     Este valor no convierte ningún nombre de dominio Unicode para que se use Punycode. Este es el valor predeterminado que es coherente con el comportamiento de .NET Framework 2.0.  
  
 Habilitar análisis de IRI (iriParsing habilitado = `true`) llevará a cabo normalización y reglas de carácter de comprobación en función de la última IRI en RFC 3987. El valor predeterminado es `false` y se la normalización y comprobación de acuerdo con RFC 2396 y RFC 2732 (para literales de IPv6) de caracteres.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> instancia de una cadena. Se muestra la diferencia entre el valor devuelto de <xref:System.Uri.Host%2A>, que devuelve el nombre de host o la dirección especificada en el URI y devuelve el valor de <xref:System.Uri.DnsSafeHost%2A>, que devuelve una dirección que es segura utilizar en la resolución DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Como se explicó en la sección Comentarios, unescape el nombre de host antes de resolver el problema. Puede usar el <xref:System.Uri.UnescapeDataString%2A> método unescape el nombre de host y puede resolver mediante una llamada a la <xref:System.Net.Dns.GetHostEntry%2A> método.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Instancia de <see cref="T:System.Uri" /> o identificador URI que se va a comparar con la instancia actual.</param>
        <summary>Compara dos instancias de <see cref="T:System.Uri" /> para determinar si sus valores son iguales.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si las dos instancias representan el mismo identificador URI; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.Equals%2A> método compara las dos instancias sin tener en cuenta información de usuario (<xref:System.Uri.UserInfo%2A>) y el fragmento (<xref:System.Uri.Fragment%2A>) las partes que pudieran contener. Por ejemplo, dadas las direcciones URI http://www.contoso.com/index.htm#search y http://user:password@www.contoso.com/index.htm, <xref:System.Uri.Equals%2A> método devolvería `true`.  
  
 Si uno <xref:System.Uri> instancia está formada por un nombre de host de Unicode y `comparand` parámetro contiene un <xref:System.Uri> instancia o identificador que se forma con un nombre de host que tiene el nombre de host Punycode equivalente, a continuación, <xref:System.Uri.Equals%2A> devuelve `true` solo si se admiten identificadores de recursos internacionales (IRI) y el nombre de dominio internacionalizado (IDN) están habilitadas. Los nombres de Punycode solo contienen caracteres ASCII y siempre empiezan con el prefijo xn--.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
> [!NOTE]
>  En las versiones de .NET Framework 1.0 y 1.1, el <xref:System.Uri.Query%2A> también se omite.  
  
> [!NOTE]
>  El <xref:System.Uri.Equals%2A> método se puede invalidar en una clase derivada; cuidado, ya que una entidad malintencionada podría modificar el método. No debe usar este método para realizar comprobaciones de seguridad a menos que sepa que esta instancia procede de un origen de confianza.  
  
   
  
## Examples  
 En este ejemplo se crea dos <xref:System.Uri> instancias de cadenas y las compara para determinar si representan el mismo valor. `address1` y `address2` son iguales, porque el <xref:System.Uri.Fragment%2A> parte se omite para esta comparación. El resultado se escribe en la consola.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para evitar que código de confianza parcial de derivar de <see cref="T:System.Uri" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte cualquier carácter no seguro o reservado del componente de ruta de acceso en su representación de carácter hexadecimal.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">El identificador URI pasado desde el constructor no es válido. Esta excepción se puede producir si un identificador URI tiene demasiados caracteres o si es relativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Cadena a la que se van a aplicar secuencias de escape.</param>
        <summary>Convierte una cadena en su representación de escape.</summary>
        <returns><see cref="T:System.String" /> que contiene la representación de escape de <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, el <xref:System.Uri.EscapeDataString%2A> método convierte todos los caracteres excepto los caracteres reservados de RFC 2396 en su representación hexadecimal. Si están habilitado el análisis de nombres de dominio internacionalizados (IDN) o identificadores de recursos internacionales (IRI), el <xref:System.Uri.EscapeDataString%2A> método convierte todos los caracteres, excepto para RFC 3986 caracteres reservados, en su representación hexadecimal. Todos los caracteres Unicode se convierten al formato UTF-8 antes de establecer secuencias de escape.  
  
 Este método supone que `stringToEscape` no tiene secuencias de escape en ella.  
  
 De forma predeterminada, la cadena de escape de acuerdo con RFC 2396. Si están habilitado el análisis de nombres de dominio internacionalizados (IDN) o identificadores de recursos internacionales (IRI), la cadena de caracteres de escape según RFC 3986 y RFC 3987. Consulte estos RFC para una definición de los caracteres reservados y no reservados.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="stringToEscape" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.FormatException" />.</para>
          </block>  
  
 La longitud de <paramref name="stringToEscape" /> supera los 32 766 caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Cadena que se va a transformar a su representación de escape.</param>
        <summary>Convierte una cadena en su representación de escape.</summary>
        <returns>Representación de escape de la cadena.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.EscapeString%2A> método convierte los caracteres reservados de RFC 2396 y todos los caracteres con un valor de caracteres mayor que 127 en representación hexadecimal. Todos los caracteres Unicode se convierten al formato UTF-8 antes de establecer secuencias de escape.  
  
 De forma predeterminada, la cadena de escape de acuerdo con RFC 2396. Si están habilitado el análisis de nombres de dominio internacionalizados (IDN) o identificadores de recursos internacionales (IRI), la cadena de caracteres de escape según RFC 3986 y RFC 3987.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Cadena a la que se van a aplicar secuencias de escape.</param>
        <summary>Convierte una cadena URI en su representación con secuencias de escape.</summary>
        <returns><see cref="T:System.String" /> que contiene la representación de escape de <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Uri.EscapeUriString%2A> método para preparar una cadena URI sin secuencias de escape para ser un parámetro de la <xref:System.Uri.%23ctor%2A> constructor.  
  
 De forma predeterminada, el <xref:System.Uri.EscapeUriString%2A> método convierte todos los caracteres, excepto los caracteres reservados de RFC 2396, en su representación hexadecimal. Si están habilitado el análisis de nombres de dominio internacionalizados (IDN) o identificadores de recursos internacionales (IRI), el <xref:System.Uri.EscapeUriString%2A> método convierte todos los caracteres, excepto para RFC 3986 caracteres reservados, en su representación hexadecimal. Todos los caracteres Unicode se convierten al formato UTF-8 antes de establecer secuencias de escape.  
  
 Este método supone que `stringToEscape` no tiene secuencias de escape en ella.  
  
 De forma predeterminada, la cadena de escape de acuerdo con RFC 2396. Si están habilitado el análisis de nombres de dominio internacionalizados (IDN) o identificadores de recursos internacionales (IRI), la cadena de caracteres de escape según RFC 3986 y RFC 3987. Consulte estos RFC para una definición de los caracteres reservados y no reservados.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="stringToEscape" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.FormatException" />.</para>
          </block>  
  
 La longitud de <paramref name="stringToEscape" /> supera los 32 766 caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el fragmento de URI de escape.</summary>
        <value><see cref="T:System.String" /> que contiene información del fragmento de URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.Fragment%2A> propiedad obtiene cualquier texto que sigue a un identificador de fragmento (#) en el URI, incluido el propio identificador de fragmento. El URI proporcionado http://www.contoso.com/index.htm#main, el <xref:System.Uri.Fragment%2A> propiedad devolvería #main.  
  
 El <xref:System.Uri.Fragment%2A> propiedad no se considera en cualquier <xref:System.Uri.Equals%2A> comparación.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y escribe la información de fragmento en la consola.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Dígito hexadecimal (0-9, a-f, A-F) que se va a convertir.</param>
        <summary>Obtiene el valor decimal de un dígito hexadecimal.</summary>
        <returns>Valor <see cref="T:System.Int32" /> que contiene un número de 0 a 15 que se corresponde con el dígito hexadecimal especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.FromHex%2A> método convierte un carácter que representa un dígito hexadecimal (0-9, a-f, A-F) en su valor decimal (0 a 15). Si `digit` no es un dígito hexadecimal válido, un <xref:System.ArgumentException> es una excepción.  
  
   
  
## Examples  
 El ejemplo siguiente determina si un carácter es un carácter hexadecimal y, si es así, escribe el valor decimal correspondiente a la consola.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="digit" /> no es un dígito hexadecimal válido (0 a 9, "a" a "f", "A" a "F").</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Combinación bit a bit de los valores <see cref="T:System.UriComponents" /> que especifica qué partes de la instancia actual se van a devolver al llamador.</param>
        <param name="format">Uno de los valores <see cref="T:System.UriFormat" /> que controla cómo se utiliza una secuencia de escape para los caracteres especiales.</param>
        <summary>Obtiene los componentes especificados de la instancia actual utilizando las secuencias de escape especificadas para los caracteres especiales.</summary>
        <returns><see cref="T:System.String" /> que contiene los componentes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, y <xref:System.UriComponents.Path> componentes no incluyen el delimitador. Puede combinar el <xref:System.UriComponents.KeepDelimiter> marca (mediante el operador OR bit a bit) con cualquiera de esos valores para obtener el valor con el delimitador. Para todos los demás <xref:System.UriComponents> valores y combinaciones de valores, los delimitadores se incluyen en el valor devuelto.  
  
 Los componentes se devuelven en el orden que aparecen en el URI. Por ejemplo, si <xref:System.UriComponents.Scheme> se especifica, aparece en primer lugar.  
  
 Cuando se habilita la compatibilidad de identificadores de recursos internacionales (IRI) y el nombre de dominio internacionalizado (IDN), el número de caracteres devuelto en el <xref:System.String> aumenta. Nombres de Punycode utilizados para admitir los IRI contienen únicamente caracteres ASCII y siempre empiezan con el prefijo xn--. Cuando se habilitan IRI e IDN, caracteres suplentes de Unicode se controlan correctamente la <xref:System.Uri.GetComponents%2A> método.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
> [!NOTE]
>  Si el <xref:System.Uri.GetComponents%2A> se llama al método con `format` establecido en <xref:System.UriFormat.Unescaped> , no se puede usar el valor devuelto como argumento a un <xref:System.Uri.%23ctor%2A> constructor para crear un equivalente <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="components" /> no es una combinación de valores de <see cref="T:System.UriComponents" /> válidos.</exception>
        <exception cref="T:System.InvalidOperationException">El <see cref="T:System.Uri" /> actual no es un identificador URI absoluto. Los identificadores URI relativos no se pueden utilizar con este método.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el código hash del identificador URI.</summary>
        <returns><see cref="T:System.Int32" /> que contiene el valor hash generado por este identificador URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y escribe el código hash en la consola.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">Uno de los valores de <see cref="T:System.UriPartial" /> que especifica el final de la porción de identificador URI que se va a devolver.</param>
        <summary>Obtiene la porción especificada de una instancia de <see cref="T:System.Uri" />.</summary>
        <returns><see cref="T:System.String" /> que contiene la porción especificada de la instancia de <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.GetLeftPart%2A> método devuelve una cadena que contiene la parte izquierda de la cadena URI termina con la parte especificada por `part`.  
  
 <xref:System.Uri.GetLeftPart%2A> incluye los delimitadores en los casos siguientes:  
  
-   <xref:System.UriPartial.Scheme> incluye el delimitador del servicio.  
  
-   <xref:System.UriPartial.Authority> no incluye el delimitador de ruta de acceso.  
  
-   <xref:System.UriPartial.Path> incluye los delimitadores en el identificador URI original hasta el delimitador de campo o de consulta.  
  
-   <xref:System.UriPartial.Query> incluye el <xref:System.UriPartial.Path>, además de la consulta y su delimitador.  
  
 Los ejemplos siguientes muestran un URI y los resultados de llamar a <xref:System.Uri.GetLeftPart%2A> con <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, o <xref:System.UriPartial.Query>.  
  
|Identificador URI|Scheme|Autoridad|Ruta de acceso|Consulta|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com? subject = uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com? subject = uri|\<Ninguno >|  
|nntp://news.contoso.com/123456@contoso.com|NNTP: / /|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|noticias:|news:123456@contoso.com|news:123456@contoso.com|\<Ninguno >|  
|File://Server/filename.ext|File://|File://Server|File://Server/filename.ext|File://Server/filename.ext|  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y escribe la ruta de acceso en la consola.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La instancia de <see cref="T:System.Uri" /> actual no es una instancia absoluta.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado en <paramref name="part" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene la información necesaria para serializar el <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene el origen y el destino de la secuencia serializada asociada al <see cref="T:System.Uri" />.</param>
        <summary>Devuelve los datos necesarios para serializar la instancia actual.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar los métodos de serialización. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Carácter que se va a convertir en representación hexadecimal.</param>
        <summary>Convierte un carácter especificado en su equivalente en representación hexadecimal.</summary>
        <returns>Representación hexadecimal del carácter especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente convierte un carácter en su equivalente hexadecimal y lo escribe en la consola.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="character" /> es mayor que 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string *  -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">Representación hexadecimal de un carácter.</param>
        <param name="index">Ubicación en <paramref name="pattern" /> donde comienza la representación hexadecimal de un carácter.</param>
        <summary>Convierte una representación hexadecimal especificada de un carácter en el carácter.</summary>
        <returns>Carácter representado por la codificación hexadecimal en la posición <paramref name="index" />. Si el carácter de <paramref name="index" /> no tiene codificación hexadecimal, se devuelve el carácter de <paramref name="index" />. El valor de <paramref name="index" /> se aumenta para que apunte al carácter siguiente al devuelto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El ejemplo de código siguiente determina si es un carácter hexadecimal codificada y, si es así, escribe el carácter equivalente en la consola.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0 ó mayor o igual que el número de caracteres de <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el componente de host de esta instancia.</summary>
        <value><see cref="T:System.String" /> que contiene el nombre del host. Suele ser el nombre del host DNS o la dirección IP del servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la <xref:System.Uri.Authority%2A> propiedad, este valor de propiedad no incluye el número de puerto.  
  
   
  
## Examples  
 El ejemplo siguiente escribe el nombre de host (www.contoso.com) del servidor en la consola.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo del nombre de host especificado en el identificador URI.</summary>
        <value>Miembro de la enumeración <see cref="T:System.UriHostNameType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> instancia y escribe el <xref:System.Uri.HostNameType%2A> en la consola.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nombre de dominio internacional del host compatible con RFC 3490, mediante Punycode según corresponda. Esta cadena, una vez convertida en cadena sin escape en caso necesario, se puede usar de forma segura para la resolución DNS.</summary>
        <value>El nombre de host, formateado con Punycode según el estándar IDN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se proporciona para el uso de protocolos de red de nivel inferior que requieren el nombre de dominio en forma de Punycode. Si el código no necesita ese formato específico, use <xref:System.Uri.Host%2A> para el nombre de host.  
  
 El desuso <xref:System.Uri.DnsSafeHost%2A> es dependiente de la propiedad *app.config* configuración, que no se puede cambiar las aplicaciones de Windows Store. IdnHost se proporciona como la alternativa preferida para usar <xref:System.Uri.DnsSafeHost%2A>, porque <xref:System.Uri.IdnHost%2A> se garantiza que siempre es seguro, con independencia de qué actual DNS *app.config* podría ser la configuración.  

 Si usa una cadena de escape para construir esta instancia (por ejemplo, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), IdnHost, a continuación, devuelve una cadena de escape. Debe unescape cualquier cadena de escape devuelva IdnHost antes de usar esa cadena para la resolución DNS. Tenga en cuenta que if usa una cadena sin escape no válida para construir esta instancia (por ejemplo, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm") y, a continuación, IdnHost devuelve una cadena sin escape.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la instancia de <see cref="T:System.Uri" /> es absoluta.</summary>
        <value>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si la instancia de <see cref="T:System.Uri" /> es absoluta; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es `true` si la cadena o <xref:System.Uri> instancia que se pasó al constructor se puede analizar como un absoluto <xref:System.Uri> instancia, que contiene un esquema, una entidad y una ruta de acceso. En caso contrario, el <xref:System.Uri> instancia se trata como relativa y podría omitir el esquema u otros componentes del identificador URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character"><see cref="T:System.Char" /> que se va a probar.</param>
        <summary>Obtiene un valor que indica si un carácter en un nombre del sistema de archivos no es válido.</summary>
        <returns><see langword="true" /> si el carácter especificado no es válido; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El carácter se analiza según las reglas para el sistema de archivos NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Instancia de <see cref="T:System.Uri" /> especificada que se va a probar.</param>
        <summary>Determina si la instancia de <see cref="T:System.Uri" /> actual es una base de la instancia de <see cref="T:System.Uri" /> especificada.</summary>
        <returns><see langword="true" /> si la instancia <see cref="T:System.Uri" /> actual es una base de <paramref name="uri" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> se utiliza para comparar actual <xref:System.Uri> instancia a un determinado <xref:System.Uri> para determinar si este URI es una base para el elemento especificado <xref:System.Uri>. Cuando se comparan dos <xref:System.Uri> objetos para determinar una relación base, la información de usuario (<xref:System.Uri.UserInfo%2A>) no se evalúa. Cuando se comparan a dos identificadores URI (uri1 y uri2), uri1 es la base de uri2 si, cuando se omiten todos los elementos de uri2 después de la última barra (/), dos identificadores URI es idénticos. Uso de http://host/path/path/file?query como el URI base, la tabla siguiente se muestra ya sea una base de otros identificadores URI.  
  
|Identificador URI|http://host/path/path/file?query es la base de|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|sí|  
|http://host/path/path/#fragment|sí|  
|http://host/path/path/MoreDir/"|sí|  
|http://host/path/path/OtherFile?Query|sí|  
|http://host/path/path/|sí|  
|http://host/path/path/file|sí|  
|http://host/path/path|No|  
|http://host/path/path?query|No|  
|http://host/path/path#Fragment|No|  
|http://host/path/path2/|No|  
: //host/path/path2/MoreDir|No|  
|http://host/path/File|No|  
  
   
  
## Examples  
 Este ejemplo se crea un <xref:System.Uri> instancia que representa una base de <xref:System.Uri> instancia. A continuación, crea un segundo <xref:System.Uri> instancia de una cadena. Llama a <xref:System.Uri.IsBaseOf%2A> para determinar si la instancia de base es la base de la segunda instancia. El resultado se escribe en la consola.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="uri" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el valor de puerto del identificador URI es el valor predeterminado para este esquema.</summary>
        <value>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si el valor de la propiedad <see cref="P:System.Uri.Port" /> es el puerto predeterminado para este esquema; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y comprueba si usa el puerto predeterminado.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character"><see cref="T:System.Char" /> que se va a probar.</param>
        <summary>Obtiene un valor que indica si se deben utilizar secuencias de escape para el carácter especificado.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si se deben utilizar secuencias de escape para el carácter especificado; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el <see cref="T:System.Uri" /> especificado es un identificador URI de archivo.</summary>
        <value>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si el <see cref="T:System.Uri" /> es un identificador URI de archivo; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.IsFile%2A> propiedad es `true` cuando el <xref:System.Uri.Scheme%2A> igual a la propiedad <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si es un URI de archivo.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Carácter que se va a validar.</param>
        <summary>Determina si un carácter especificado es un dígito hexadecimal válido.</summary>
        <returns><see langword="true" /> si el carácter es un dígito hexadecimal válido; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los dígitos hexadecimales son los dígitos 0 a 9 y las letras A-F o a-f.  
  
   
  
## Examples  
 El ejemplo siguiente determina si un carácter es un carácter hexadecimal y, si es así, escribe el valor decimal correspondiente a la consola.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">Cadena que se va a comprobar.</param>
        <param name="index">Ubicación en <paramref name="pattern" /> donde se va a buscar la codificación hexadecimal.</param>
        <summary>Determina si un carácter de una cadena tiene codificación hexadecimal.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si <paramref name="pattern" /> tiene codificación hexadecimal en la ubicación especificada; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.IsHexEncoding%2A> método comprueba para la codificación hexadecimal que sigue el modelo "% hexhex" en una cadena, donde "hex" es un dígito comprendido entre 0 y 9 o una letra de A-F (mayúsculas y minúsculas).  
  
   
  
## Examples  
 El ejemplo de código siguiente determina si es un carácter hexadecimal codificada y, si es así, escribe el carácter equivalente en la consola.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el <see cref="T:System.Uri" /> especificado hace referencia al host local.</summary>
        <value>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si este <see cref="T:System.Uri" /> hace referencia a un host local; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> Devuelve `true` si el URI especificado cuando se creó esta instancia se ha de bucle invertido, 127.0.0.1 o localhost, o si no especificó el URI la información (por ejemplo, file:///c:Dir/file.txt) del host. Todos los demás devuelven URI `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si hace referencia a un host local.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character"><see cref="T:System.Char" /> que se va a probar.</param>
        <summary>Obtiene un valor que indica si el carácter especificado es un carácter reservado.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si el carácter especificado es un carácter reservado; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el <see cref="T:System.Uri" /> especificado es una ruta de acceso UNC (Convención de nomenclatura universal).</summary>
        <value>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si el <see cref="T:System.Uri" /> es una ruta de acceso UNC; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.IsUnc%2A> propiedad es `true` si especificado <xref:System.Uri> instancia es una ruta de acceso UNC (como \\\server\folder o file://server/folder). Esta propiedad siempre devuelve `true` si el identificador URI tiene el esquema file:// y especifica un componente de host.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si es una ruta de acceso UNC.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica si la cadena usada para construir este <see cref="T:System.Uri" /> tiene el formato correcto y no hay que utilizar más secuencias de escape.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si la cadena tiene el formato correcto; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cadena se considera que esté bien formada con arreglo a RFC 2396 y RFC 2732 de forma predeterminada. Si están habilitado el análisis de nombres de dominio internacionalizados (IDN) o identificadores de recursos internacionales (IRI), la cadena se considera bien formada de acuerdo con RFC 3986 y RFC 3987  
  
 La cadena se considera un formato incorrecto, lo que el método devuelva false, si se produce alguna de las condiciones siguientes.  
  
|Error|Ejemplo|  
|-----------|-------------|  
|La cadena no es el escape adecuado.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nombre|  
|La cadena es absoluta <xref:System.Uri> que representa un archivo implícito <xref:System.Uri>.|c:\\\directory\filename|  
|La cadena es un URI absoluto que le falta una barra diagonal antes de la ruta de acceso.|File://c:/Directory/FileName|  
|La cadena contiene las barras diagonales inversas sin escape, incluso si se tratan como barras diagonales.|http:\\\host/path/file|  
|La cadena representa un absoluto jerárquica <xref:System.Uri> y no contiene "://".|www.contoso.com/path/file|  
|El analizador para el <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> indica que la cadena original no tenía el formato correcto.|El ejemplo depende del esquema del URI.|  
  
 De forma predeterminada, esta cadena se usa para construir este <xref:System.Uri> se consideran bien formadas de acuerdo con RFC 2396 y RFC 2732.  
  
 Cuando se habilitan los identificadores de recursos internacionales (IRI) y compatibilidad con nombres de dominio internacionalizados (IDN), la cadena utilizada para construir este <xref:System.Uri> se consideran bien formadas de acuerdo con RFC 3986 y RFC 3987. Nombres de Punycode utilizados para admitir los IRI contienen únicamente caracteres ASCII y siempre empiezan con el prefijo xn--.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Cadena usada para intentar construir un <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Tipo del <see cref="T:System.Uri" /> en <paramref name="uriString" />.</param>
        <summary>Indica si la cadena tiene el formato correcto al intentar construir un URI con ella y garantiza que la cadena no requiere después secuencias de escape.</summary>
        <returns><see langword="true" /> si la cadena tiene el formato correcto; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En versiones de .NET antes de la versión 4.5, de forma predeterminada la cadena se considera bien formada de acuerdo con RFC 2396 y RFC 2732. Si se habilitan los identificadores de recursos internacionales (IRI) o el nombre de dominio internacionalizado (IDN) de análisis, la cadena se considera bien formada de acuerdo con RFC 3986 y RFC 3987.  
  
 A partir de .NET 4.5, las cadenas se consideran siempre bien formadas de acuerdo con RFC 3986 y RFC 3987, o no IRI o IDN están habilitados. Sin embargo, tenga en cuenta que esto sólo es cierto para las aplicaciones que tienen como destino .NET 4.5 o posterior. Las aplicaciones que tienen como destino .NET 4.0 invocan código de compatibilidad y experimentan el antiguo comportamiento (pre-4.5).  
  
 La cadena se considera un formato incorrecto, lo que el método devuelva false, si se produce alguna de las condiciones siguientes  
  
|Error|Ejemplo|  
|-----------|-------------|  
|La cadena no es el escape adecuado.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nombre|  
|La cadena es absoluta <xref:System.Uri> que representa un archivo implícito <xref:System.Uri>.|c:\\\directory\filename|  
|La cadena es un URI absoluto que le falta una barra diagonal antes de la ruta de acceso.|File://c:/Directory/FileName|  
|La cadena contiene las barras diagonales inversas sin escape, incluso si se tratará como barras diagonales|http:\\\host/path/file|  
|La cadena representa un absoluto jerárquica <xref:System.Uri> y no contiene "://"|www.contoso.com/path/file|  
|El analizador para el <xref:System.Uri.Scheme%2A> indica que la cadena original no tenía el formato correcto.|El ejemplo depende del esquema del URI.|  
|A partir de .NET 4.5, URI relativos con un signo de dos puntos (': ') no se consideran en el primer segmento tiene el formato correcto.|2013.05.29_14:33:41|  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una representación del sistema operativo local de un nombre de archivo.</summary>
        <value><see cref="T:System.String" /> que contiene la representación local del sistema operativo de un nombre de archivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad es con escape. Si la ruta de acceso se reconoce como una ruta de acceso del archivo de Windows, todas las barras diagonales (/) se reemplazan por barras diagonales inversas (\\).  
  
 Para el URI `file://computer/file.ext`, la ruta de acceso absoluta es `/file.ext` y es la ruta de acceso local `\\computer\file.ext`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y escribe la ruta de acceso local en la consola.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">Identificador URI que se va a comparar con el identificador URI actual.</param>
        <summary>Determina la diferencia que existe entre dos instancias de <see cref="T:System.Uri" />.</summary>
        <returns>Si el nombre de host y el esquema de esta instancia de identificador URI y <paramref name="toUri" /> son iguales, este método devuelve un <see cref="T:System.String" /> que representa un identificador URI relativo que, cuando se anexa a la instancia de identificador URI actual, genera el parámetro <paramref name="toUri" />.  
  
Si el nombre de host o el esquema son diferentes, este método devuelve un <see cref="T:System.String" /> que representa el parámetro <paramref name="toUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instancia de URI, `toUri`y los resultados de llamar a <xref:System.Uri.MakeRelative%2A>.  
  
|Instancia actual de URI|`toUri`|Valor devuelto|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1.txt/test1|  
  
 Información de usuario, si está presente en el URI, se omite.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea 2 <xref:System.Uri> instancias. La diferencia en la información de ruta de acceso se escribe en la consola.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="toUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y este método sólo es válido para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Identificador URI que se va a comparar con el identificador URI actual.</param>
        <summary>Determina la diferencia que existe entre dos instancias de <see cref="T:System.Uri" />.</summary>
        <returns>Si el nombre de host y el esquema de esta instancia de identificador URI y <paramref name="uri" /> son iguales, este método devuelve un <see cref="T:System.Uri" /> relativo que, cuando se anexa a la instancia de identificador URI actual, genera <paramref name="uri" />.  
  
Si el nombre de host o el esquema son diferentes, este método devuelve un <see cref="T:System.Uri" /> que representa el parámetro <paramref name="uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instancia de URI, `toUri`y los resultados de llamar a <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Instancia actual de URI|`toUri`|Valor devuelto|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1.txt/test1|  
  
 Información de usuario, si está presente en el URI, se omite.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea 2 <xref:System.Uri> instancias. La diferencia en la información de ruta de acceso se escribe en la consola.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="uri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Instancia de <see cref="T:System.Uri" /> que se va a comparar con <paramref name="uri2" />.</param>
        <param name="uri2">Instancia de <see cref="T:System.Uri" /> que se va a comparar con <paramref name="uri1" />.</param>
        <summary>Determina si dos instancias de <see cref="T:System.Uri" /> tienen el mismo valor.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si las instancias de <see cref="T:System.Uri" /> son equivalentes; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga utiliza el <xref:System.Uri.Equals%2A> método para determinar si los dos <xref:System.Uri> las instancias son equivalentes. <xref:System.Uri.UserInfo%2A> y <xref:System.Uri.Fragment%2A> contenido se omite al realizar la comparación.  
  
   
  
## Examples  
 En este ejemplo crea tres <xref:System.Uri> instancias de cadenas y las compara para determinar si representan el mismo valor. `Address1` y `Address2` son iguales, porque el <xref:System.Uri.Fragment%2A> parte se omite para esta comparación. El resultado se escribe en la consola.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Instancia de <see cref="T:System.Uri" /> que se va a comparar con <paramref name="uri2" />.</param>
        <param name="uri2">Instancia de <see cref="T:System.Uri" /> que se va a comparar con <paramref name="uri1" />.</param>
        <summary>Determina si dos instancias de <see cref="T:System.Uri" /> no tienen el mismo valor.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si las dos instancias de <see cref="T:System.Uri" /> no son iguales; en caso contrario, <see langword="false" />. Si alguno de los parámetros es <see langword="null" />, este método devuelve <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga utiliza el <xref:System.Uri.Equals%2A> método para determinar si los dos <xref:System.Uri> instancias no son equivalentes. <xref:System.Uri.UserInfo%2A> y <xref:System.Uri.Fragment%2A> contenido se omite al realizar la comparación.  
  
   
  
## Examples  
 En este ejemplo crea tres <xref:System.Uri> instancias de cadenas y las compara para determinar si representan el mismo valor. `Address2` y `Address3` no son iguales porque `Address3` contiene un <xref:System.Uri.Query%2A> que no se encuentra en `Address2`. El resultado se escribe en la consola.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cadena de identificador URI original que se pasó al constructor <see cref="T:System.Uri" />.</summary>
        <value><see cref="T:System.String" /> que contiene el identificador URI exacto que se especificó al construir esta instancia; en caso contrario, <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el URI especificado para el constructor contenía espacios iniciales o finales, estos espacios se conservan.  
  
 El valor devuelto por esta propiedad difiere <xref:System.Uri.ToString%2A> y <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A> Devuelve la forma canónica sin escape del identificador URI. <xref:System.Uri.AbsoluteUri%2A> Devuelve la forma canónica del URI.  
  
 Cuando se habilita la compatibilidad de identificadores de recursos internacionales (IRI) y el nombre de dominio internacionalizado (IDN), <xref:System.Uri.OriginalString%2A> devuelve la cadena no normalizada original con el nombre de host Punycode si uno se usó para inicializar el <xref:System.Uri> instancia. Los nombres de Punycode solo contienen caracteres ASCII y siempre empiezan con el prefijo xn--.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
 Cuando un <xref:System.Uri> se serializa el objeto, el <xref:System.Uri.OriginalString%2A> no se conserva. El proceso de serialización usa por completo con escape y con formato canónico <xref:System.Uri.AbsoluteUri%2A> propiedad al serializar. Para un <xref:System.Uri> que contiene una dirección IPv6, la dirección IPv6 y el identificador de ámbito se incluyen en el número de serie <xref:System.Uri> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Uri> instancia de una cadena. Se muestra la diferencia entre el valor devuelto de <xref:System.Uri.OriginalString%2A>, que devuelve la cadena que se pasó al constructor y en una llamada a <xref:System.Uri.ToString%2A>, que devuelve la forma canónica de la cadena.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analiza el identificador URI de la instancia actual para garantizar que contiene todas las partes requeridas para que un URI sea válido.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">El identificador URI pasado desde el constructor no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las propiedades <see cref="P:System.Uri.AbsolutePath" /> y <see cref="P:System.Uri.Query" /> separadas por un signo de interrogación (?).</summary>
        <value><see cref="T:System.String" /> que contiene las propiedades <see cref="P:System.Uri.AbsolutePath" /> y <see cref="P:System.Uri.Query" /> separadas por un signo de interrogación (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.PathAndQuery%2A> propiedad contiene la ruta de acceso absoluta en el servidor y la información de la consulta enviada con la solicitud. Es idéntico al concatenar la <xref:System.Uri.AbsolutePath%2A> y <xref:System.Uri.Query%2A> propiedades.  
  
 El <xref:System.Uri.PathAndQuery%2A> propiedad escape de acuerdo con RFC 2396 de forma predeterminada. Si están habilitado el análisis de nombres de dominio internacionalizados (IDN) o identificadores de recursos internacionales (IRI), el <xref:System.Uri.PathAndQuery%2A> se escapa la propiedad de acuerdo con RFC 3986 y RFC 3987.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe la ruta de acceso URI (/ /catalog/shownew.htm) y consulta (date = today) información en la consola.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de puerto de este identificador URI.</summary>
        <value>Valor <see cref="T:System.Int32" /> que contiene el número de puerto de este identificador URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de puerto define el puerto de protocolo usado para ponerse en contacto con el servidor al que hace referencia en el URI. Si no se especifica un puerto como parte del URI, el <xref:System.Uri.Port%2A> propiedad devuelve el valor predeterminado para el protocolo. Si no hay ningún número de puerto predeterminado, esta propiedad devuelve -1.  
  
   
  
## Examples  
 El ejemplo siguiente escribe el número de puerto URI en la consola. En este caso, el valor es el número de puerto predeterminado para HTTP, el puerto 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la información de consulta incluida en el identificador URI especificado.</summary>
        <value><see cref="T:System.String" /> que contiene la información de consulta incluida en el identificador URI especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.Query%2A> propiedad contiene información de consulta incluida en el URI. Información de la consulta se separa de la información de ruta de acceso por un signo de interrogación (?) y continúa hasta el final del URI. La información de consulta devuelta incluye el un signo de interrogación.  
  
 La información de la consulta se escape de acuerdo con RFC 2396 de forma predeterminada. Si están habilitado el análisis de nombres de dominio internacionalizados (IDN) o identificadores de recursos internacionales (IRI), la información de la consulta se escape según RFC 3986 y RFC 3987.  
  
 Para obtener más información sobre la compatibilidad con IRI, vea la sección Comentarios para el <xref:System.Uri> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe la consulta? date = today en la consola.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de esquema de este identificador URI.</summary>
        <value><see cref="T:System.String" /> que contiene el esquema de este identificador URI, convertido a minúsculas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.Scheme%2A> propiedad devuelve el esquema utilizado para inicializar el <xref:System.Uri> instancia. Esta propiedad no indica que el esquema utilizado para inicializar el <xref:System.Uri> se reconoció la instancia.  
  
 En la tabla siguiente se muestra ejemplos de algunos posibles valores devueltos por la <xref:System.Uri.Scheme%2A> propiedad.  
  
|Scheme|Descripción|  
|------------|-----------------|  
|archivo|El recurso es un archivo en el equipo local.|  
|ftp|El recurso se accede a través de FTP.|  
|gopher|El recurso se accede a través del protocolo Gopher.|  
|http|El recurso se accede a través de HTTP.|  
|https|El recurso se accede a través de HTTP cifrada con SSL.|  
|LDAP|El recurso se accede a través del protocolo LDAP.|  
|mailto|El recurso es una dirección de correo electrónico y tener acceso a través del protocolo SMTP.|  
|net.pipe|El recurso se accede a través de una canalización con nombre.|  
|net.tcp|El recurso se accede desde el punto de conexión TCP.|  
|noticias|El recurso se tiene acceso mediante el protocolo NNTP.|  
|NNTP|El recurso se tiene acceso mediante el protocolo NNTP.|  
|telnet|Se tiene acceso a los recursos mediante el protocolo TELNET.|  
|uuid|El recurso se accede a través de un nombre de extremo UUID único para comunicarse con un servicio.|  
  
   
  
## Examples  
 El ejemplo siguiente escribe el nombre de esquema (http) en la consola para el http://www.contoso.com/ URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica los caracteres que separan el servicio de protocolo de comunicaciones de la parte correspondiente a la dirección del identificador URI. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea una cadena de <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>y una dirección. Un <xref:System.Uri> , a continuación, se crea la instancia de la cadena.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una matriz que contiene los segmentos de ruta de acceso que componen el identificador URI especificado.</summary>
        <value>Matriz de <see cref="T:System.String" /> que contiene los segmentos de ruta de acceso que componen el identificador URI especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.Segments%2A> propiedad devuelve una matriz de cadenas que contienen los "segmentos" (subcadenas) que forman la ruta de acceso absoluta del URI. El primer segmento se obtiene mediante el análisis de la ruta de acceso absoluta de su primer carácter hasta que llegue a una barra diagonal (/) o el final de la ruta de acceso. Cada segmento adicional comienza en el primer carácter después del segmento anterior y termina con la siguiente barra diagonal o al final de la ruta de acceso. (Ruta de acceso absoluta de un URI contiene todo el contenido después del host y puerto y antes de la consulta y fragmento).  
  
 El ejemplo siguiente muestra la ruta de acceso absoluta y segmentos de dos identificadores URI. El segundo ejemplo se muestra que el fragmento y la consulta no forman parte de la ruta de acceso absoluta y, por tanto, no son segmentos.  
  
 URI absoluto:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Ruta de acceso absoluta:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmentos:  
 - /
 - Capítulos /
 - Chapter1 /
 - Las secciones /
 - Section1.htm  
  
 URI absoluto:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 Ruta de acceso absoluta:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmentos:  
 - /
 - Capítulos /
 - Chapter1 /
 - Las secciones /
 - Section1.htm  
  
 Tenga en cuenta que dado que la ruta de acceso absoluta empieza con '/', el primer segmento contiene y nada más.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> instancia con 3 segmentos y muestra los segmentos en la pantalla.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene la información necesaria para serializar el <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene el origen y el destino de la secuencia serializada asociada al <see cref="T:System.Uri" />.</param>
        <summary>Devuelve los datos necesarios para serializar la instancia actual.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar los métodos de serialización. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una representación de cadena canónica para la instancia de <see cref="T:System.Uri" /> especificada.</summary>
        <returns>Instancia de <see cref="T:System.String" /> que contiene la representación canónica sin escape de la instancia de <see cref="T:System.Uri" />. Todos son caracteres sin escape, excepto #, ? y %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cadena devuelta por este método no contiene información de puerto cuando el puerto es el puerto predeterminado para el esquema.  
  
> [!NOTE]
>  La cadena devuelta por la <xref:System.Uri.ToString%2A> método puede contener caracteres de control, que pueden dañar el estado de una aplicación de consola. Puede usar el <xref:System.Uri.GetComponents%2A> método con el <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> formato para quitar los caracteres de control de la cadena devuelta.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Uri> instancia de una cadena. Se muestra la diferencia entre el valor devuelto de <xref:System.Uri.OriginalString%2A>, que devuelve la cadena que se pasó al constructor y en una llamada a <xref:System.Uri.ToString%2A>, que devuelve la forma canónica de la cadena.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para evitar que código de confianza parcial de derivar de <see cref="T:System.Uri" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Uri" />. No se produce una excepción si no se puede crear el <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind *  -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString"><see cref="T:System.String" /> que representa el <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Tipo de URI.</param>
        <param name="result">Cuando este método finaliza, contiene el <see cref="T:System.Uri" /> construido.</param>
        <summary>Crea un nuevo <see cref="T:System.Uri" /> usando la <see cref="T:System.String" /> especificada y un <see cref="T:System.UriKind" />.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si el <see cref="T:System.Uri" /> se creó correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este método devuelve `true`, el nuevo <xref:System.Uri> en `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri"><see cref="T:System.Uri" /> base.</param>
        <param name="relativeUri"><see cref="T:System.Uri" /> relativo representado como <see cref="T:System.String" />, que se va a agregar al <see cref="T:System.Uri" /> base.</param>
        <param name="result">Cuando este método finaliza, contiene un objeto <see cref="T:System.Uri" /> construido a partir del <paramref name="baseUri" /> y el <paramref name="relativeUri" />. Este parámetro se pasa sin inicializar.</param>
        <summary>Crea un nuevo <see cref="T:System.Uri" /> usando la base especificada y las instancias de <see cref="T:System.String" /> relativo.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si el <see cref="T:System.Uri" /> se creó correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este método devuelve `true`, el nuevo <xref:System.Uri> en `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri"><see cref="T:System.Uri" /> base.</param>
        <param name="relativeUri"><see cref="T:System.Uri" /> relativo que se va a agregar al <see cref="T:System.Uri" /> base.</param>
        <param name="result">Cuando este método finaliza, contiene un objeto <see cref="T:System.Uri" /> construido a partir del <paramref name="baseUri" /> y el <paramref name="relativeUri" />. Este parámetro se pasa sin inicializar.</param>
        <summary>Crea un nuevo <see cref="T:System.Uri" /> usando la base especificada y las instancias de <see cref="T:System.Uri" /> relativo.</summary>
        <returns>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si el <see cref="T:System.Uri" /> se creó correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este método devuelve `true`, el nuevo <xref:System.Uri> en `result`.  
  
 Este método crea el identificador URI, lo pone en formato canónico y lo valida. Si se produce una excepción no controlada, este método lo detecta. Si desea crear un <xref:System.Uri> y obtener las excepciones use uno de los <xref:System.Uri.%23ctor%2A> constructores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="baseUri" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><see cref="T:System.String" /> que se va a convertir.</param>
        <summary>Convierte la cadena especificada, reemplazando cualquier secuencia de escape por su representación sin escape.</summary>
        <returns><see cref="T:System.String" /> que contiene el valor sin escape del parámetro <paramref name="path" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Cadena a la que se van a quitar las secuencias de escape.</param>
        <summary>Convierte una cadena en su representación sin secuencias de escape.</summary>
        <returns><see cref="T:System.String" /> que contiene la representación sin secuencias de escape de <paramref name="stringToUnescape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe usar este método con cuidado. No escape de una cadena que ha sido previamente sin escape puede dar lugar a ambigüedades y errores.  
  
 Muchos exploradores Web espacios dentro de los URI de escape en el signo más ("+") caracteres. Sin embargo, el método UnescapeDataString no convierte los caracteres en espacios porque este comportamiento no es estándar en todos los esquemas de URI.  
  
   
  
## Examples  
 El ejemplo de código siguiente convierte un URI y, a continuación, convierte los caracteres ("+") en espacios.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="stringToUnescape" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que el identificador URI es un puntero a un archivo. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En .NET Framework versión 1.1, un "`file:///path`"URI se ha traducido a"`file:/path`". Se ha corregido para la versión 2.0.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si el esquema es <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que se puede tener acceso al identificador URI mediante FTP (Protocolo de transferencia de archivos). Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si el esquema es <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que se puede tener acceso al identificador URI mediante el protocolo Gopher. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si el esquema es <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que se puede obtener acceso al identificador URI mediante HTTP (Protocolo de transferencia de hipertexto). Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si el esquema es <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que se puede obtener acceso al identificador URI mediante HTTPS (Protocolo de transferencia segura de hipertexto). Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si el esquema es <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que el URI sea una dirección de correo electrónico a la que se acceda por SMTP (Protocolo simple de transferencia de correo). Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si el esquema es <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que se tiene acceso al URI a través del esquema NetPipe utilizado por Windows Communication Foundation (WCF). Este campo es de solo lectura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que se tiene acceso al URI a través del esquema NetTcp utilizado por Windows Communication Foundation (WCF). Este campo es de solo lectura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que el identificador URI es un grupo de noticias de Internet accesible a través de NNTP (Protocolo de transferencia de noticias en red). Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si el esquema es <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que el identificador URI es un grupo de noticias de Internet accesible a través de NNTP (Protocolo de transferencia de noticias en red). Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El NNTP <xref:System.Uri> analizar errores en .NET Framework versión 1.1 se han corregido.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si el esquema es <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que se utilizó una secuencia de escape completa para la cadena de identificador URI antes de crear la instancia de <see cref="T:System.Uri" />.</summary>
        <value>Valor <see cref="T:System.Boolean" /> que es <see langword="true" /> si el parámetro <paramref name="dontEscape" /> se estableció en <see langword="true" /> al crear la instancia de <see cref="T:System.Uri" />; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri.UserEscaped%2A> propiedad está establecida en `true` para indicar que esta cadena se usa para crear el <xref:System.Uri> instancia era totalmente de escape antes de que se pasó al constructor; es decir, el `dontEscape` se estableció el parámetro de la llamada al constructor para `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y determina si se escape completamente cuando se creó.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de usuario, la contraseña u otra información específica del usuario asociada al identificador URI especificado.</summary>
        <value><see cref="T:System.String" /> que contiene información del usuario asociada al identificador URI. El valor devuelto no incluye el carácter reservado "\@" para delimitar la parte de información de usuario del identificador URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad suele tener el formato "nombreDeUsuario: contraseña".  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Uri> de instancia y escribe la información de usuario en la consola.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instancia representa un identificador URI relativo, y esta propiedad sólo es válida para identificadores URI absolutos.</exception>
      </Docs>
    </Member>
  </Members>
</Type>