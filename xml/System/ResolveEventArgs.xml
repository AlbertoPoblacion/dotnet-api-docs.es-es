<Type Name="ResolveEventArgs" FullName="System.ResolveEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76d4ee17a80d107d2454484d8498d79b8e36b598" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39809957" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResolveEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ResolveEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.ResolveEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class ResolveEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResolveEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type ResolveEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona los datos para los eventos de resolución del cargador, como los eventos <see cref="E:System.AppDomain.TypeResolve" />, <see cref="E:System.AppDomain.ResourceResolve" />, <see cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" /> y <see cref="E:System.AppDomain.AssemblyResolve" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el cargador no puede resolver una referencia de ensamblado y un controlador se ha proporcionado para el evento de resolución del cargador adecuado, se genera el evento y el <xref:System.ResolveEventArgs> contiene información sobre el elemento que se resuelva.  
  
-   El <xref:System.ResolveEventArgs.Name%2A> propiedad contiene el nombre del elemento que se puede resolver.  
  
-   A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.ResolveEventArgs.RequestingAssembly%2A> propiedad contiene el ensamblado que solicitó un ensamblado que puede proporcionar el elemento con nombre. Para obtener más información, vea la propiedad <xref:System.ResolveEventArgs.RequestingAssembly%2A>.  
  
 ]]></format>
    </remarks>
    <altmember cref="E:System.AppDomain.TypeResolve" />
    <altmember cref="E:System.AppDomain.ResourceResolve" />
    <altmember cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
    <altmember cref="E:System.AppDomain.AssemblyResolve" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ResolveEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ResolveEventArgs.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResolveEventArgs(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new ResolveEventArgs : string -&gt; ResolveEventArgs" Usage="new System.ResolveEventArgs name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del elemento que se va a resolver.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ResolveEventArgs" />, que especifica el nombre del elemento que se va a resolver.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, se llama a este constructor sólo por common language runtime.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name, System.Reflection.Assembly requestingAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Reflection.Assembly requestingAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ResolveEventArgs.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, requestingAssembly As Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResolveEventArgs(System::String ^ name, System::Reflection::Assembly ^ requestingAssembly);" />
      <MemberSignature Language="F#" Value="new ResolveEventArgs : string * System.Reflection.Assembly -&gt; ResolveEventArgs" Usage="new System.ResolveEventArgs (name, requestingAssembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="requestingAssembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del elemento que se va a resolver.</param>
        <param name="requestingAssembly">Ensamblado cuya dependencia se resuelve.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ResolveEventArgs" />, que especifica el nombre del elemento que se va a resolver y el ensamblado cuya dependencia se resuelve.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ResolveEventArgs.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.ResolveEventArgs.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del elemento que se va resolver.</summary>
        <value>Nombre del elemento que se va a resolver.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para el <xref:System.AppDomain.AssemblyResolve> eventos, <xref:System.ResolveEventArgs.Name%2A> es el nombre del ensamblado antes de aplicar directivas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestingAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly RequestingAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly RequestingAssembly" />
      <MemberSignature Language="DocId" Value="P:System.ResolveEventArgs.RequestingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestingAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ RequestingAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestingAssembly : System.Reflection.Assembly" Usage="System.ResolveEventArgs.RequestingAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el ensamblado cuya dependencia se resuelve.</summary>
        <value>Ensamblado que solicitó el elemento especificado por la propiedad <see cref="P:System.ResolveEventArgs.Name" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El ensamblado devuelto por esta propiedad es un ensamblado que no pudo resolver el elemento especificado por el <xref:System.ResolveEventArgs.Name%2A> propiedad, porque el elemento no existía en ese ensamblado, en cualquiera de sus dependencias cargadas o en cualquier dependencia que el cargador se encontró a través del sondeo.  
  
 Por ejemplo, supongamos que los usos de ensamblado actual el <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> para cargar un ensamblado desde un directorio fuera de la ruta de acceso de sondeo, para poder usar la clase de entidad de certificación. Supongamos que aún más esa entidad de certificación de clase utiliza la clase CB, en el ensamblado B, y que un ensamblado tiene una referencia de tiempo de compilación al ensamblado B, también ubican fuera de la ruta de acceso de sondeo. Cuando el ensamblado actual intenta crear una instancia de entidad de certificación, el cargador intenta resolver la referencia al ensamblado B. Sin embargo, dado que se cargó un ensamblado mediante el uso de la <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> método, el cargador no puede resolver la dependencia. Si hay un controlador para el <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> se genera el evento, el evento y el <xref:System.ResolveEventArgs.RequestingAssembly%2A> propiedad del resultante <xref:System.ResolveEventArgs> objeto contiene un ensamblado, porque un ensamblado es el ensamblado que falta una dependencia.  
  
 La semántica de la <xref:System.ResolveEventArgs.RequestingAssembly%2A> propiedad varían en función de cómo se cargó el ensamblado solicitante:  
  
-   Contexto de carga: el valor de la propiedad puede ser `null`. El contexto de carga es independiente del orden de carga y la identidad de la solicitud de ensamblado no es necesariamente significativo. Un ejemplo que no sean null se produce cuando el <xref:System.Type.GetType%2A?displayProperty=nameWithType> se llama al método y no se conoce el tipo especificado para el ensamblado para solicitar o cualquiera de sus dependencias.  
  
-   Contexto de carga: la propiedad puede usarse como una sugerencia de sondeo, pero el controlador de eventos, no debe aparecer más de una solicitud para un nombre de ensamblado dado.  
  
-   Ningún contexto (es decir, se cargó el ensamblado solicitante mediante el uso de la <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> método, o como una secuencia de bytes o en modo mixto): puede usar el controlador de la <xref:System.ResolveEventArgs.RequestingAssembly%2A> propiedad que se va a cargar las implementaciones diferentes del mismo ensamblado en función de la identidad de la ensamblado solicitante.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.AppDomain.TypeResolve" />
        <altmember cref="E:System.AppDomain.ResourceResolve" />
        <altmember cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
        <altmember cref="E:System.AppDomain.AssemblyResolve" />
      </Docs>
    </Member>
  </Members>
</Type>