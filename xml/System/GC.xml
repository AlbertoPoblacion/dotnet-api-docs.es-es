<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="GC.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-567ae5a" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3cf4df88-236b-4f49-aebe-6184303eadc311996d97bef6121bce982a8368bef5e8197c8a44.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">11996d97bef6121bce982a8368bef5e8197c8a44</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1465f1a9bce3970cd9e95769eaa641b92a0a22d5</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/18/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Controls the system garbage collector, a service that automatically reclaims unused memory.</source>
          <target state="translated">Controla el recolector de elementos no utilizados del sistema, un servicio que recupera de forma automática la memoria que no se utiliza.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</source>
          <target state="translated">El recolector de elementos no utilizados es un componente de common language runtime que controla la asignación y liberación de memoria administrada.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</source>
          <target state="translated">Influir en los métodos de esta clase cuando se realiza la recolección de elementos no utilizados en un objeto y, cuando se liberan los recursos asignados por un objeto.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</source>
          <target state="translated">Propiedades de esta clase proporcionan información acerca de la cantidad total de memoria disponible en el sistema y la categoría de edad o la generación de memoria asignada a un objeto.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tracks and reclaims objects allocated in managed memory.</source>
          <target state="translated">El recolector de elementos no utilizados realiza un seguimiento y recupera los objetos asignados en la memoria administrada.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</source>
          <target state="translated">El recolector de elementos no utilizados realiza periódicamente, colección de elementos no utilizados para reclamar la memoria asignada a objetos para los que no hay ninguna referencia válida.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</source>
          <target state="translated">Colección de elementos no utilizados se produce automáticamente cuando no se puede satisfacer una solicitud de memoria utilizando la memoria libre disponible.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Alternatively, an application can force garbage collection using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">O bien, una aplicación puede forzar la colección de elementos no utilizados mediante la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection consists of the following steps:</source>
          <target state="translated">Colección de elementos no utilizados consta de los siguientes pasos:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector searches for managed objects that are referenced in managed code.</source>
          <target state="translated">El recolector de elementos no utilizados busca objetos administrados a los que se hace referencia en código administrado.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tries to finalize objects that are not referenced.</source>
          <target state="translated">El recolector de elementos no utilizados intenta finalizar los objetos que no se hace referencia.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector frees objects that are not referenced and reclaims their memory.</source>
          <target state="translated">El recolector de elementos no utilizados libera los objetos que no se hace referencia y recupera su memoria.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This topic includes the following sections:</source>
          <target state="translated">En este tema, se incluyen las siguientes secciones:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>The garbage collector and unmanaged resources<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>El recolector de elementos no utilizados y los recursos no administrados<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Object aging and generations<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Generaciones y edad de los objetos<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Disallowing garbage collection<ept id="p1">](#NoGCRegion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Impedir la recolección de elementos<ept id="p1">](#NoGCRegion)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector and unmanaged resources</source>
          <target state="translated">El recolector de elementos no utilizados y los recursos no administrados</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</source>
          <target state="translated">Durante una recolección, el recolector de elementos no utilizados no liberar un objeto si encuentra una o varias referencias al objeto en el código administrado.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</source>
          <target state="translated">Sin embargo, el recolector de elementos no utilizados no reconoce las referencias a un objeto de código no administrado y puede liberar objetos que se utilizan exclusivamente en código no administrado, a menos que se impide explícitamente hacerlo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> método proporciona un mecanismo que impide que el recolector de elementos no utilizados recoja objetos que aún estén en uso en código no administrado.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</source>
          <target state="translated">Además de las asignaciones de memoria administrada, las implementaciones del recolector de elementos no utilizados no mantienen información acerca de los recursos mantenidos por un objeto, como los identificadores de archivo o las conexiones de base de datos.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</source>
          <target state="translated">Cuando un tipo utiliza recursos no administrados que deben liberarse antes de que se reclaman instancias del tipo, el tipo puede implementar un finalizador.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, finalizers are implemented by overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">En la mayoría de los casos, los finalizadores se implementan reemplazando el <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> método; sin embargo, los tipos escritos en C# o C++ implementan destructores, que los compiladores convierten en un reemplazo del <ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</source>
          <target state="translated">En la mayoría de los casos, si un objeto tiene un finalizador, el recolector de elementos no utilizados lo llama antes de liberar el objeto.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector is not required to call finalizers in all situations; for example, the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method explicitly prevents an object's finalizer from being called.</source>
          <target state="translated">Sin embargo, el recolector de elementos no utilizados no es necesario llamar a los finalizadores en todas las situaciones; Por ejemplo, el <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> método explícitamente impide que un finalizador del objeto que se va a llamar.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</source>
          <target state="translated">Además, el recolector de elementos no utilizados no tiene que utilizar un subproceso concreto para finalizar los objetos o garantiza el orden en el que se llama a los finalizadores para los objetos que hacen referencia entre sí, pero están disponibles para la recolección.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In scenarios where resources must be released at a specific time, classes can implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, which contains the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method that performs resource management and cleanup tasks.</source>
          <target state="translated">En escenarios donde se deben liberar los recursos en un momento determinado, las clases pueden implementar la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaz, que contiene el <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> método que realiza tareas de administración y limpieza de recursos.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Classes that implement <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</source>
          <target state="translated">Las clases que implementan <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> especifique, como parte de su contrato de clase, si y cuando los consumidores de la clase llama al método para limpiar el objeto.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector does not, by default, call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method; however, implementations of the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method can call methods in the <ph id="ph3">&lt;xref:System.GC&gt;</ph> class to customize the finalization behavior of the garbage collector.</source>
          <target state="translated">El recolector de elementos no utilizados no es así, de forma predeterminada, llame a la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> método; sin embargo, las implementaciones de la <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> método puede llamar a métodos la <ph id="ph3">&lt;xref:System.GC&gt;</ph> clase para personalizar el comportamiento de finalización del recolector de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>For more information on object finalization and the dispose pattern, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre la finalización del objeto y el patrón de dispose, vea <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging and generations</source>
          <target state="translated">Generaciones y edad de los objetos</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector in the common language runtime supports object aging using generations.</source>
          <target state="translated">El recolector de elementos no utilizados de common language runtime admite la edad de los objetos mediante las generaciones.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>A generation is a unit of measure of the relative age of objects in memory.</source>
          <target state="translated">Una generación es una unidad de medida de la antigüedad relativa de los objetos en la memoria.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The generation number, or age, of an object indicates the generation to which an object belongs.</source>
          <target state="translated">El número de generación o la edad de un objeto indica la generación a la que pertenece un objeto.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</source>
          <target state="translated">Objetos creados más recientemente forman parte de las generaciones más recientes y tienen los números más bajos de generación de ciclo de objetos creados anteriormente en la vida de las aplicaciones.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects in the most recent generation are in generation 0.</source>
          <target state="translated">Objetos de la generación más reciente están en la generación 0.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</source>
          <target state="translated">Esta implementación del recolector de elementos no utilizados admite tres generaciones de objetos, las generaciones 0, 1 y 2.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum generation number supported by the system.</source>
          <target state="translated">Puede recuperar el valor de la <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propiedad para determinar el número de generación máximo admitido por el sistema.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</source>
          <target state="translated">Caducidad de objetos permite a las aplicaciones dirijan la recolección en un conjunto específico de generaciones en lugar de requerir el recolector de elementos no utilizados evaluar todas las generaciones.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method that include a <ph id="ph2">`generation`</ph> parameter allow you to specify the oldest generation to be garbage collected.</source>
          <target state="translated">Sobrecargas de la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> método que incluyen un <ph id="ph2">`generation`</ph> parámetro le permiten especificar la generación más antigua se recolecte.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Disallowing garbage collection</source>
          <target state="translated">Impedir la recolección de elementos</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, el recolector de elementos no utilizados no admite un GC región modo de latencia que se puede usar durante la ejecución de las rutas de acceso críticas en los elementos no utilizados colección puede afectar negativamente el rendimiento de una aplicación.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</source>
          <target state="translated">El modo de latencia ninguna región de GC requiere que especifique una cantidad de memoria que puede asignar sin interferencias del recolector de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</source>
          <target state="translated">Si el tiempo de ejecución puede asignar esa memoria, el runtime no realizará una colección de elementos no utilizados mientras se está ejecutando código en la ruta crítica.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You define the beginning of the critical path of the no GC region by calling one of the overloads of the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>.</source>
          <target state="translated">Definir el principio de la ruta crítica de la región de GC no mediante una llamada a una de las sobrecargas de los <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You specify the end of its critical path by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">Especifique el final de su ruta de acceso crítica mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">No se pueden anidar las llamadas a la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> método y se debería llamar a la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En otras palabras, no debe llamar <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> sea correcta sólo porque la primera llamada a <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</source>
          <target state="translated">En el ejemplo siguiente se usa varios métodos de GC para obtener información de memoria sobre un bloque de objetos no utilizados y la generación e imprimirlo en la consola.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The unused objects are then collected, and the resulting memory totals are displayed.</source>
          <target state="translated">Los objetos no utilizados, a continuación, se recopilan y se muestran los totales de memoria resultantes.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The incremental amount of unmanaged memory that has been allocated.</source>
          <target state="translated">Cantidad incremental de memoria no administrada que se ha asignado.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</source>
          <target state="translated">Informa al tiempo de ejecución de una asignación grande de memoria no administrada que se debe tener en cuenta al programar la recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">Para determinar cuándo se debe programar la recopilación de elementos no utilizados, el tiempo de ejecución tiene en cuenta la cantidad de memoria administrada se asigna.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">Si un objeto administrado pequeño asigna una gran cantidad de memoria no administrada, el tiempo de ejecución tiene en cuenta sólo la memoria administrada y, por tanto, subestima la urgencia de programar la recolección.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> método informa el tiempo de ejecución de esta necesidad adicional de memoria del sistema.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">En el patrón de uso más simple, un objeto administrado asigna la memoria no administrada en el constructor y lo libera de la <ph id="ph1">`Dispose`</ph> o <ph id="ph2">`Finalize`</ph> método.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> método después de asignar la memoria no administrada y llamar a la <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> método después de liberarla.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">En escenarios más complicados, donde la asignación de memoria no administrada cambia substancialmente durante la duración del objeto administrado, puede llamar a la <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> métodos para comunicar estos cambios incrementales en el tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">Debe asegurarse de que quita exactamente la cantidad de memoria que agrega.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">Si no lo puede afectar negativamente el rendimiento del sistema en las aplicaciones que se ejecutan durante largos períodos de tiempo.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> es menor o igual que 0.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">En un equipo de 32 bits, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">Para poder llamar a código no administrado al manipular la prioridad de la colección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>Cancels the registration of a garbage collection notification.</source>
          <target state="translated">Cancela el registro de una notificación de recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This method cancels a garbage collection notification that was registered by using the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Este método cancela una notificación de la colección de elementos no utilizados que se registró mediante el <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">No es necesario llamar a este método antes de ajustar los valores de parámetro de umbral en llamadas posteriores a la <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>The following example cancels a garbage collection registration.</source>
          <target state="translated">En el ejemplo siguiente se cancela un registro de la colección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This example is part of a larger example provided for the <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">Este ejemplo forma parte de un ejemplo mayor proporcionado para el <bpt id="p1">[</bpt>notificaciones de la colección de elementos no utilizados<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> tema.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>This member is not available when concurrent garbage collection is enabled.</source>
          <target state="translated">Este miembro no está disponible cuando la recolección de elementos no utilizados simultánea está habilitada.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>See the <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> runtime setting for information about how to disable concurrent garbage collection.</source>
          <target state="translated">Vea la configuración en tiempo de ejecución <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> para obtener información sobre cómo deshabilitar la recolección de elementos no utilizados simultánea.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">De plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Un código de confianza parcial no puede utilizar este miembro.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Forces garbage collection.</source>
          <target state="translated">Fuerza a que se lleve a cabo la recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.GC.Collect">
          <source>Forces an immediate garbage collection of all generations.</source>
          <target state="translated">Fuerza a que se lleve a cabo una recolección de elementos no utilizados de todas las generaciones.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to try to reclaim all memory that is inaccessible.</source>
          <target state="translated">Utilice este método para intentar reclamar toda la memoria que no es accesible.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>It performs a blocking garbage collection of all generations.</source>
          <target state="translated">Realiza una recolección de elementos no utilizados de bloqueo de todas las generaciones.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</source>
          <target state="translated">Todos los objetos, independientemente de cuánto tiempo llevan en memoria, se consideran para la colección; Sin embargo, no se recopilan los objetos que se hace referencia en código administrado.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to force the system to try to reclaim the maximum amount of available memory.</source>
          <target state="translated">Utilice este método para forzar el sistema para intentar obtener la máxima cantidad de memoria disponible.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, you can compact the large object heap (LOH) by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method, as the following example illustrates.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, también puede compactar el montón de objetos grandes (LOH) estableciendo el <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> propiedad a <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> antes de llamar a la <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> método, como en el ejemplo siguiente se muestra.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on all generations of memory.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> método para realizar una recolección en todas las generaciones de memoria.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">El código genera un número de objetos no utilizados y, a continuación, llama a la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> método para limpiarlos de la memoria.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">El número de la generación más antigua de elementos no usados para recolectar.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>Forces an immediate garbage collection from generation 0 through a specified generation.</source>
          <target state="translated">Fuerza a que se lleve a cabo inmediatamente la recolección de elementos no utilizados desde la generación 0 hasta la generación especificada.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use this method to try to reclaim memory that is inaccessible.</source>
          <target state="translated">Utilice este método para intentar reclamar la memoria que no es accesible.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">Sin embargo, con este método no garantiza que se reclame toda la memoria puede tener acceso en la generación especificada.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</source>
          <target state="translated">Si se implementa la edad de los objetos, el recolector de elementos no utilizados no recoge objetos con un número de generación que es mayor que la generación especificada.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</source>
          <target state="translated">Si no se implementa la edad de los objetos, el recolector de elementos no utilizados considera que todos los objetos durante la recolección.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of the <ph id="ph2">`generation`</ph> parameter.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propiedad para determinar el máximo valor válido de la <ph id="ph2">`generation`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">Para que el recolector de elementos no utilizados tenga en cuenta todos los objetos independientemente de su generación, utilice la versión de este método que no toma ningún parámetro.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector reclaim objects based on a <ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph> setting, use the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Para que el recolector de elementos no utilizados recupera los objetos en función de un <ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph> configuración, use la <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on individual layers of memory.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> método para realizar una recolección en capas individuales de memoria.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">El código genera un número de objetos no utilizados y, a continuación, llama a la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> método para limpiarlos de la memoria.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">El número de la generación más antigua de elementos no usados para recolectar.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) o si será optimizada (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value.</source>
          <target state="translated">Fuerza una recolección de elementos no utilizados desde la generación 0 hasta la generación especificada, en el momento especificado por el valor <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">`mode`</ph> parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</source>
          <target state="translated">Use el <ph id="ph1">`mode`</ph> para especificar si la colección de elementos no utilizados debería producirse inmediatamente o solo si la hora es adecuada para reclamar objetos.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">Con este método no garantiza que se reclame toda la memoria puede tener acceso en la generación especificada.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To adjust the intrusiveness of garbage collection during critical periods in your application, set the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph> property.</source>
          <target state="translated">Para ajustar la tendencia a la intrusión de la recolección durante los períodos críticos en la aplicación, establezca el <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The garbage collector does not collect objects with a generation number higher than specified by the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">El recolector de elementos no utilizados no recoge objetos con un número de generación superior al especificado en el <ph id="ph1">`generation`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of <ph id="ph2">`generation`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propiedad para determinar el máximo valor válido de <ph id="ph2">`generation`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">Para que el recolector de elementos no utilizados tenga en cuenta todos los objetos independientemente de su generación, utilice la versión de este método que no toma ningún parámetro.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector reclaim objects up to a specified generation of objects, use the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Para que el recolector de elementos no utilizados recupera los objetos hasta una generación especificada de objetos, siga el <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>When you specify the maximum generation, all objects are collected.</source>
          <target state="translated">Al especificar la generación máxima, se recopilan todos los objetos.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The following example forces a garbage collection for generation 2 objects with the <ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph> setting.</source>
          <target state="translated">En el ejemplo siguiente se fuerza una recolección de elementos no utilizados para los objetos de generación 2 con el <ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph> configuración.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> no es uno de los valores de <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">El número de la generación más antigua de elementos no usados para recolectar.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) o si será optimizada (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para realizar una recolección de elementos no utilizados de bloqueo; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para realizar una recolección de elementos no utilizados en segundo plano cuando sea posible.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with a value specifying whether the collection should be blocking.</source>
          <target state="translated">Fuerza una recolección de elementos no utilizados de generación 0 en una generación especificada, en un momento especificado por un valor de <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>, con un valor que especifica si la recolección debe ser de bloqueo.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The following table summarizes the interaction of the <ph id="ph1">`mode`</ph> and <ph id="ph2">`blocking`</ph> parameters:</source>
          <target state="translated">En la tabla siguiente se resume la interacción de la <ph id="ph1">`mode`</ph> y <ph id="ph2">`blocking`</ph> parámetros:</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`true`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph> es <ph id="ph2">`true`</ph></target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph> es <ph id="ph2">`false`</ph></target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> or <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> o <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection is performed as soon as possible.</source>
          <target state="translated">Se realiza una recolección de bloqueo lo antes posible.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 0 or 1, the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method immediately triggers a blocking collection and returns when the collection is finished.</source>
          <target state="translated">Si una recolección en segundo plano está en curso y <ph id="ph1">`generation`</ph> es 0 o 1, el <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> método desencadena una recolección de bloqueo inmediatamente y vuelve cuando finaliza la colección.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</source>
          <target state="translated">Si una recolección en segundo plano está en curso y <ph id="ph1">`generation`</ph> es 2, el método espera hasta que la recolección en segundo plano finalice, desencadena una recolección de generación 2 de bloqueo y, a continuación, se devuelve.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection is performed as soon as possible.</source>
          <target state="translated">Se realiza una recolección lo antes posible.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated">El método <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> solicita una colección en segundo plano, pero esto no se garantiza; puede que aún se realice una colección de bloqueo, dependiendo de las circunstancias.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection may be performed, depending on the state of the garbage collector and the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">Se puede realizar una recolección de bloqueo, dependiendo del estado del recolector de elementos no utilizados y del parámetro <ph id="ph1">`generation`</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection may be performed, depending on the state of the garbage collector.</source>
          <target state="translated">Se puede realizar una recolección, según el estado del recolector de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated">El método <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> solicita una colección en segundo plano, pero esto no se garantiza; puede que aún se realice una colección de bloqueo, dependiendo de las circunstancias.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a call to the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">Si una llamada a la <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> método realiza una recolección de elementos no utilizados de bloqueo completa, también puede compactar el montón de objetos grandes si establece la <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> propiedad <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> antes de llamar a la <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> no es uno de los valores de <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">El número de la generación más antigua de elementos no usados para recolectar.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) o si será optimizada (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para realizar una recolección de elementos no utilizados de bloqueo; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para realizar una recolección de elementos no utilizados en segundo plano cuando sea posible.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to compact the small object heap; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to sweep only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para compactar el montón de objetos pequeños; <ph id="ph2">&lt;see langword="false" /&gt;</ph> solo para limpiar.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with values that specify whether the collection should be blocking and compacting.</source>
          <target state="translated">Fuerza una recolección de elementos no utilizados de generación 0 en una generación especificada, en un momento especificado por un valor de <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph>, con valores que especifican si la recolección debe ser de bloqueo y compactante.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph>, the GC decides whether to perform a background or a blocking garbage collection.</source>
          <target state="translated">Si <ph id="ph1">`blocking`</ph> es <ph id="ph2">`false`</ph>, el catálogo global decide si se debe realizar una recolección de elementos no utilizados de bloqueo o de un fondo.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, it performs a blocking garbage collection.</source>
          <target state="translated">Si <ph id="ph1">`compacting`</ph> es <ph id="ph2">`true`</ph>, que realiza una recolección de elementos no utilizados de bloqueo.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, the runtime compacts the small object heap (SOH).</source>
          <target state="translated">Si <ph id="ph1">`compacting`</ph> es <ph id="ph2">`true`</ph>, el tiempo de ejecución compacta el montón de objetos pequeños (SOH).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The large object heap (LOH) is not compacted unless the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property is set to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No se compacta el montón de objetos grandes (LOH) a menos que la <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> propiedad está establecida en <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Note that this includes all blocking garbage collections, not just full blocking garbage collections.</source>
          <target state="translated">Tenga en cuenta que esto incluye todos los elementos no utilizados colecciones de bloqueo, no solo completas colecciones de elementos no utilizados de bloqueo.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</source>
          <target state="translated">Puede llamar a la <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> método para reducir el montón administrado a las posibles de tamaño más pequeña, como se muestra en el siguiente fragmento de código.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">`true`</ph> for the <ph id="ph2">`compacting`</ph> argument guarantees a compacting, full blocking garbage collection.</source>
          <target state="translated">Especificar <ph id="ph1">`true`</ph> para el <ph id="ph2">`compacting`</ph> argumento garantiza una recolección de elementos no utilizados de bloqueo compactación, completa.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Setting the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> ensures that both the LOH and SOH are compacted.</source>
          <target state="translated">Establecer el <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> propiedad <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> garantiza que se compactan el montón de objeto grande y el SOH.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The generation of objects for which the garbage collection count is to be determined.</source>
          <target state="translated">La generación de objetos para la que se va a determinar el número de recolecciones de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Returns the number of times garbage collection has occurred for the specified generation of objects.</source>
          <target state="translated">Devuelve el número de veces que se ha producido la recolección de elementos no utilizados para la generación de objetos especificada.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The number of times garbage collection has occurred for the specified generation since the process was started.</source>
          <target state="translated">El número de veces que se ha realizado la recolección de elementos no utilizados para la generación especificada desde que se inició el proceso.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If you implement your own resource management, you might need to force garbage collection periodically by calling the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">Si implementa su propia administración de recursos, deberá forzar la recolección periódicamente mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</source>
          <target state="translated">Dado que se trata de una operación costosa, puede mejorar el rendimiento evitando la llamada cuando se ha producido recientemente a una colección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Save the value returned by <ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> immediately after calling <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>.</source>
          <target state="translated">Guarde el valor devuelto por <ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> inmediatamente después de llamar a <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The next time you need to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>, compare the current value returned by <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> to the saved value.</source>
          <target state="translated">La próxima vez que se debe llamar a <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>, compare el valor actual devuelto por <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> en el valor guardado.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If the two values are equal, no collection has occurred in the interim and it is reasonable to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> again.</source>
          <target state="translated">Si los dos valores son iguales, no se ha producido ninguna colección en la versión preliminar y es razonable llamar a <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> nuevo.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>Ends the no GC region latency mode.</source>
          <target state="translated">Finaliza el modo de no latencia en la región GC.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> if the garbage collector is not in no GC region latency mode.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método produce una <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> si el recolector de elementos no utilizados no está en modo de no latencia de la región de GC.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>This occurs under any of the following conditions:</source>
          <target state="translated">Esto se produce en cualquiera de las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method was not called previously.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> método no se llamó anteriormente.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method returned <ph id="ph2">`false`</ph>.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> el método devolvió <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method threw an exception.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> método produjo una excepción.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>You can prevent an exception for any of these reasons by using code such as the following:</source>
          <target state="translated">Puede evitar una excepción por alguno de estos motivos mediante código como el siguiente:</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The garbage collector is not in no GC region latency mode.</source>
          <target state="translated">El recolector de elementos no utilizados no está en modo de no latencia en la región GC.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The no GC region latency mode was ended previously because a garbage collection was induced.</source>
          <target state="translated">El modo de no latencia en la región GC se terminó prematuramente porque se indujo una recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>A memory allocation exceeded the amount specified in the call to the <ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph> method.</source>
          <target state="translated">Una asignación de memoria superó la cantidad especificada en la llamada al método <ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the current generation number of an object.</source>
          <target state="translated">Devuelve el número de generación actual de un objeto.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The object that generation information is retrieved for.</source>
          <target state="translated">El objeto cuya información sobre generación se recupera.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Returns the current generation number of the specified object.</source>
          <target state="translated">Devuelve el número de generación actual del objeto especificado.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The current generation number of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">El número de generación actual de <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Use this method to determine the age of an object, and then use that information with the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to force the garbage collector to collect objects in the same generation.</source>
          <target state="translated">Utilice este método para determinar la edad de un objeto y, a continuación, utilizar esa información con el <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> método para forzar que el recolector de elementos no utilizados para recopilar los objetos de la misma generación.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</source>
          <target state="translated">Por ejemplo, use este método cuando tiene un conjunto de objetos que se crean como un grupo y que dejan de estar accesibles al mismo tiempo.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of an object.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> método para determinar la antigüedad de un objeto.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</source>
          <target state="translated">En el ejemplo, a continuación, realiza recolecciones de elementos no utilizados para limpiar la memoria y comparar el anterior y registrar los totales de memoria de colección en la consola.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>A <ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph> that refers to the target object whose generation number is to be determined.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph> que hace referencia al objeto de destino cuyo número de generación debe determinarse.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Returns the current generation number of the target of a specified weak reference.</source>
          <target state="translated">Devuelve el número de generación actual del destino de una referencia débil especificada.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The current generation number of the target of <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated">El número de generación actual del destino de <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of a weak reference object.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> método para determinar la antigüedad de un objeto de referencia débil.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Garbage collection has already been performed on <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated">Ya se ha realizado la recolección de elementos no utilizados en <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para indicar que este método puede esperar a que se produzca la recolección de elementos no utilizados antes de regresar; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>Retrieves the number of bytes currently thought to be allocated.</source>
          <target state="translated">Recupera el número de bytes que se considera que están asignados en la actualidad.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</source>
          <target state="translated">Un parámetro indica si este método puede esperar un breve intervalo de tiempo antes de regresar, para permitir que el sistema recoja los elementos no utilizados y finalice los objetos.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A number that is the best available approximation of the number of bytes currently allocated in managed memory.</source>
          <target state="translated">Número que representa la aproximación más exacta disponible del número de bytes actualmente asignados en la memoria administrada.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>If the <ph id="ph1">`forceFullCollection`</ph> parameter is <ph id="ph2">`true`</ph>, this method waits a short interval before returning while the system collects garbage and finalizes objects.</source>
          <target state="translated">Si el <ph id="ph1">`forceFullCollection`</ph> parámetro es <ph id="ph2">`true`</ph>, este método espera un breve intervalo antes de devolver mientras el sistema recopila elementos no utilizados y finaliza los objetos.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</source>
          <target state="translated">La duración del intervalo es un límite especificado internamente determinado por el número de ciclos de la colección de elementos no utilizados completa y el cambio en la cantidad de memoria recuperada entre los ciclos.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The garbage collector does not guarantee that all inaccessible memory is collected.</source>
          <target state="translated">El recolector de elementos no utilizados no garantiza que se recopila toda la memoria inaccesible.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> method to get and display the number of bytes currently allocated in managed memory.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> método para obtener y mostrar el número de bytes actualmente asignados en la memoria administrada.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object to reference.</source>
          <target state="translated">El objeto al que se va a hacer referencia.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</source>
          <target state="translated">Hace referencia al objeto especificado, convirtiéndolo en un objeto no válido para la recolección de elementos no utilizados desde el principio de la rutina actual hasta el momento en que se llamó a este método.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The purpose of the <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</source>
          <target state="translated">El propósito de la <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> método consiste en asegurarse de la existencia de una referencia a un objeto que tenga probabilidades de ser reclamado prematuramente por el recolector de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</source>
          <target state="translated">Un escenario común donde esto puede ocurrir es cuando no hay ninguna referencia al objeto en código administrado o datos, pero el objeto aún está en uso en código no administrado, como las API de Win32, archivos DLL no administrados, o métodos que utilizan COM.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>This method references the <ph id="ph1">`obj`</ph> parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</source>
          <target state="translated">Este método hace referencia el <ph id="ph1">`obj`</ph> parámetro, convirtiéndolo ese objeto elegible para la recolección de elementos desde el principio de la rutina hasta el punto, en orden de ejecución, que se llama a este método.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>Code this method at the end, not the beginning, of the range of instructions where <ph id="ph1">`obj`</ph> must be available.</source>
          <target state="translated">Este método al final, y no al principio del intervalo de instrucciones de código donde <ph id="ph1">`obj`</ph> deben estar disponibles.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> método no realiza ninguna operación ni no produce ningún efecto secundario aparte de ampliar la duración del objeto pasado como un parámetro.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The following code example creates an object at the beginning of its <ph id="ph1">`Main`</ph> method and does not refer to the object again until the end, when the <ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is called.</source>
          <target state="translated">En el ejemplo de código siguiente se crea un objeto al principio de su <ph id="ph1">`Main`</ph> método y no hace referencia al objeto nuevo hasta el final, cuando el <ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> se llama al método.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object persists for the 30-second duration of the <ph id="ph1">`Main`</ph> method, despite calls to the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> methods.</source>
          <target state="translated">El objeto persiste durante 30 segundos de la <ph id="ph1">`Main`</ph> método, a pesar de las llamadas a la <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.GC.MaxGeneration">
          <source>Gets the maximum number of generations that the system currently supports.</source>
          <target state="translated">Obtiene el número máximo de generaciones que el sistema admite en la actualidad.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>A value that ranges from zero to the maximum number of supported generations.</source>
          <target state="translated">Un valor comprendido entre cero y el número máximo de generaciones admitidas.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</source>
          <target state="translated">El número de generación o la edad de un objeto es una medida relativa de tiempo de vida de un objeto definido por la implementación.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property.</source>
          <target state="translated">Son los objetos creados más recientemente en la generación 0 y los objetos más antiguos pertenecen a una generación menor o igual a la generación devuelta por la <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</source>
          <target state="translated">El recolector de elementos no utilizados se da por supuesto que es más probable que sea apto para la recolección de elementos no utilizados de memoria anterior memoria más reciente.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property value can grow over time.</source>
          <target state="translated">Por lo tanto, el recolector de elementos no utilizados mejora su rendimiento ajustando los números de generación cada vez que recupera de la memoria, y el <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> puede alcanzar el valor de la propiedad con el tiempo.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>If object aging is implemented, the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property returns the maximum generation number used by the system; otherwise, this property returns zero.</source>
          <target state="translated">Si se implementa la edad de los objetos, la <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> propiedad devuelve el número de generación máximo utilizado por el sistema; en caso contrario, esta propiedad devuelve cero.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo usar la propiedad MaxGeneration para mostrar el mayor número de generación que está actualmente en uso.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>For this implementation, the value returned by the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property is guaranteed to remain constant for the lifetime of an executing application.</source>
          <target state="translated">Para esta implementación, el valor devuelto por el <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> se garantiza que la propiedad permanece constante para la duración de una aplicación en ejecución.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property to determine the maximum value you can specify when calling the <ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph> method that takes a generation parameter.</source>
          <target state="translated">Use la <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> propiedad para determinar el valor máximo que puede especificar cuando se llama a la <ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph> método que toma un parámetro de generación.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</source>
          <target state="translated">Número comprendido entre 1 y 99 que especifica cuándo debe emitirse la notificación basándose en los objetos asignados en la generación 2.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</source>
          <target state="translated">Un número comprendido entre 1 y 99 que especifica cuándo debe emitirse la notificación basándose en los objetos asignados en el montón de objetos grandes.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</source>
          <target state="translated">Especifica que debe emitirse una notificación de recolección de elementos no utilizados cuando las condiciones favorecen la recolección completa de elementos no utilizados y cuando se ha completado la recolección.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For each generation, the garbage collector sets a threshold for allocations into that generation.</source>
          <target state="translated">Por cada generación, el recolector de elementos no utilizados establece un umbral para las asignaciones en esa generación.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</source>
          <target state="translated">Cuando el tamaño de las asignaciones de supera este umbral, se desencadena una recolección en esa generación.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</source>
          <target state="translated">De ejemplo, si el umbral de generación 2 es 20MB (lo que significa que 20MB sobrevive a las recolecciones de generación 1 y se promueven a la generación 2) y más de 20MB ha sobrevivido a la generación 1 y se solicita a la generación 2, la siguiente recolección se tratará como una recolección de generación 2.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</source>
          <target state="translated">De forma similar, si el montón de objetos grandes (LOH) Value de umbral es de 20MB y la aplicación ha asignado más de 20MB de objetos grandes, la siguiente recolección también se tratará como una recolección de generación 2 (ya que solo se recopila el montón de objeto grande en colecciones de elementos no utilizados de gen2).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> thresholds control how much in advance you are notified before a full garbage collection occurs.</source>
          <target state="translated">El <ph id="ph1">`maxGenerationThreshold`</ph> y <ph id="ph2">`largeObjectHeapThreshold`</ph> umbrales de controlan la cantidad de antemano se le notifique antes de que se produce una recolección completa.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</source>
          <target state="translated">Cuanto mayor sea el umbral, las asignaciones más que se pueden producir entre la notificación y la recolección de elementos no utilizados completa siguiente.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method) when conditions are still favorable.</source>
          <target state="translated">Si tiene situaciones en que una colección de elementos no utilizados completa por common language runtime negativamente afectaría al rendimiento de la aplicación, puede pedir que se le notifique cuando el tiempo de ejecución está a punto de realizar una recolección completa y eludir esa recolección mediante la inducción de una colección usted mismo (mediante el <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> método) cuando las condiciones todavía sean favorables.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</source>
          <target state="translated">Además de cambiar la programación de la colección de elementos no utilizados, notificación de GC completo es útil en los escenarios siguientes:</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</source>
          <target state="translated">Supervisar para el enfoque de una colección de elementos no utilizados completa y, cuando se le notifique que se acerca uno, reducir el tamaño de los datos en directo (por ejemplo, al liberar algunas entradas de caché).</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>As a result, when the garbage collection occurs, it is able to reclaim more memory.</source>
          <target state="translated">Como resultado, cuando la recolección de elementos no utilizados se produce, es capaz de recuperar más memoria.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the completion of a full garbage collection so that you can collect some statistics.</source>
          <target state="translated">Supervisar la finalización de una colección de elementos no utilizados completa para que pueda recopilar estadísticas.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</source>
          <target state="translated">Por ejemplo, puede medir el tamaño del montón al término de catálogo global para que sepa el tamaño de los datos en directo.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>(After a full GC, the heap is at its smallest size.)</source>
          <target state="translated">(Después de un GC completo, el montón tiene en su tamaño más pequeño).</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For more information about what represents a full garbage collection, see <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre lo que representa una colección de elementos no utilizados completa, consulte <bpt id="p1">[</bpt>notificaciones de la colección de elementos no utilizados<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</source>
          <target state="translated">Al registrarse para una notificación de recolección, puede recibir una notificación cuando una recolección de elementos no utilizados completa está próxima y cuando se completan.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This pattern resembles how the operating system monitors for low memory notifications.</source>
          <target state="translated">Este patrón es similar a cómo se supervisa el sistema operativo para notificaciones de memoria insuficiente.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Use the following guidelines for specifying the <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> parameters:</source>
          <target state="translated">Utilice las instrucciones siguientes para especificar el <ph id="ph1">`maxGenerationThreshold`</ph> y <ph id="ph2">`largeObjectHeapThreshold`</ph> parámetros:</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</source>
          <target state="translated">Cuanto mayor sea el valor de umbral, se producen más asignaciones entre la notificación y la colección de elementos no utilizados completa.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</source>
          <target state="translated">Un valor de umbral mayor proporciona más oportunidades para el tiempo de ejecución comprobar si una recolección próxima.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This increases the likelihood that you will be notified.</source>
          <target state="translated">Esto aumenta la probabilidad de que se le notificará.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</source>
          <target state="translated">Sin embargo, no debería establecer el umbral demasiado alto, ya tiene como resultado en una asignaciones más antes de que el tiempo de ejecución induce la recolección siguiente.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</source>
          <target state="translated">Cuando induce la recolección usted mismo tras la notificación mediante un valor de umbral alta, menos objetos se reclaman que podría ser reclamado por la recolección siguiente del runtime.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</source>
          <target state="translated">Cuanto menor sea el valor de umbral, menos las asignaciones entre la notificación y la colección de elementos no utilizados completa.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo registrar una notificación de recolección e iniciar un subproceso para supervisar el estado de la notificación de la colección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo más extenso de <bpt id="p1">[</bpt>notificaciones de la colección de elementos no utilizados<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> tema.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> or <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph> is not between 1 and 99.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> o <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph> no está entre 1 y 99.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">De plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Un código de confianza parcial no puede utilizar este miembro.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The amount of unmanaged memory that has been released.</source>
          <target state="translated">Cantidad de memoria no administrada que se ha liberado.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</source>
          <target state="translated">Informa al tiempo de ejecución de que se ha liberado la memoria no administrada y ya no se necesita tener en cuenta al programar la recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">Para determinar cuándo se debe programar la recopilación de elementos no utilizados, el tiempo de ejecución tiene en cuenta la cantidad de memoria administrada se asigna.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">Si un objeto administrado pequeño asigna una gran cantidad de memoria no administrada, el tiempo de ejecución tiene en cuenta sólo la memoria administrada y, por tanto, subestima la urgencia de programar la recolección.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory, and the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method informs the runtime that the additional pressure has been released.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> método informa el tiempo de ejecución de esta necesidad adicional de memoria del sistema y el <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> método informa que el tiempo de ejecución que se ha liberado la presión adicional.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">En el patrón de uso más simple, un objeto administrado asigna la memoria no administrada en el constructor y lo libera de la <ph id="ph1">`Dispose`</ph> o <ph id="ph2">`Finalize`</ph> método.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> método después de asignar la memoria no administrada y llamar a la <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> método después de liberarla.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">En escenarios más complicados, donde la asignación de memoria no administrada cambia substancialmente durante la duración del objeto administrado, puede llamar a la <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> métodos para comunicar estos cambios incrementales en el tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">Debe asegurarse de que quita exactamente la cantidad de memoria que agrega.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">Si no lo puede afectar negativamente el rendimiento del sistema en las aplicaciones que se ejecutan durante largos períodos de tiempo.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> es menor o igual que 0.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">En un equipo de 32 bits, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">Para poder llamar a código no administrado al manipular la prioridad de la colección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The object that a finalizer must be called for.</source>
          <target state="translated">El objeto cuyo finalizador debe llamarse.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Requests that the system call the finalizer for the specified object for which <ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph> has previously been called.</source>
          <target state="translated">Solicita que el sistema llame al finalizador del objeto especificado, para el que previamente se ha llamado a <ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method adds the <ph id="ph2">`obj`</ph> parameter to the list of objects that request finalization before the garbage collector frees the object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> método agrega la <ph id="ph2">`obj`</ph> parámetro a la lista de objetos que solicitan una finalización antes de que el recolector de elementos no utilizados libera el objeto.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">`obj`</ph> parameter must be the caller of this method.</source>
          <target state="translated">El <ph id="ph1">`obj`</ph> parámetro debe ser el llamador de este método.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method does not guarantee that the garbage collector will call an object's finalizer.</source>
          <target state="translated">Llamar a la <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> método no garantiza que el recolector de elementos no utilizados llame al finalizador de un objeto.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method.</source>
          <target state="translated">De forma predeterminada, todos los objetos que implementan los finalizadores se agregan a la lista de objetos que requieren finalización; Sin embargo, un objeto podría ya ha finalizado o que haya deshabilitado la finalización mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>A finalizer can use this method to resurrect itself or an object that it references.</source>
          <target state="translated">Un finalizador puede utilizar este método para restablecerse consigo mismo ni con un objeto que hace referencia.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el método ReRegisterForFinalize para finalizar un objeto una segunda vez después de la recolección de elementos.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The object whose finalizer must not be executed.</source>
          <target state="translated">El objeto cuyo finalizador no debe ejecutarse.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Requests that the common language runtime not call the finalizer for the specified object.</source>
          <target state="translated">Solicita que Common Language Runtime no llame al finalizador del objeto especificado.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>This method sets a bit in the object header of <ph id="ph1">`obj`</ph>, which the runtime checks when calling finalizers.</source>
          <target state="translated">Este método establece un bit en el encabezado del objeto de <ph id="ph1">`obj`</ph>, lo que el tiempo de ejecución comprueba cuando se llama a los finalizadores.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>A finalizer, which is represented by the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method, is used to release unmanaged resources before an object is garbage-collected.</source>
          <target state="translated">Un finalizador, que se representa mediante el <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> método, se utiliza para liberar recursos no administrados antes de que un objeto se recopilan de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>If <ph id="ph1">`obj`</ph> does not have a finalizer, the call to the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method has no effect.</source>
          <target state="translated">Si <ph id="ph1">`obj`</ph> no tiene un finalizador, la llamada a la <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> método no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Objects that implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface can call this method from the object's <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation to prevent the garbage collector from calling <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> on an object that does not require it.</source>
          <target state="translated">Objetos que implementan la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaz puede llamar a este método desde el objeto <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementación para evitar que el recolector de elementos no utilizados que realiza la llamada <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> en un objeto que no la necesita.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">Normalmente, esto se hace para evitar que el finalizador de liberar recursos no administrados que ya se ha liberado mediante el <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementación.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method in a resource class to prevent a redundant garbage collection from being called.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> método en una clase de recurso para evitar una redundancia de recolección de elementos que se la llame.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> to free both managed resources (that is, objects that implement <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) and unmanaged resources.</source>
          <target state="translated">El ejemplo se utiliza la <bpt id="p1">[</bpt>patrón de dispose<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> liberar tanto recursos administrados (es decir, los objetos que implementan <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) y los recursos no administrados.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Attempts to disallow garbage collection during the execution of a critical path.</source>
          <target state="translated">Intenta suspender la recolección de elementos durante la ejecución de una ruta crítica.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">No se pueden anidar las llamadas a la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> método y se debería llamar a la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En otras palabras, no debe llamar <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> sea correcta sólo porque la primera llamada a <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">Debe ser menor o igual que el tamaño de un segmento efímero.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo <bpt id="p1">[</bpt>Fundamentos de la recolección de elementos no utilizados<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</source>
          <target state="translated">Intenta suspender la recolección de elementos durante la ejecución de una ruta crítica si una cantidad específica de memoria está disponible.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph> método intenta colocar el recolector de elementos no utilizados en ningún modo de latencia de región de GC, que no permite la recopilación de elementos no utilizados mientras que una aplicación ejecuta una región crítica del código.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento de liberar memoria adicional.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> bytes (it attempts to allocate <ph id="ph2">`totalSize`</ph> bytes for the small object heap and <ph id="ph3">`totalSize`</ph> bytes for the large object heap).</source>
          <target state="translated">El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar la cantidad necesaria de memoria, lo que en este caso es realmente 2 * <ph id="ph1">`totalSize`</ph> bytes (intenta asignar <ph id="ph2">`totalSize`</ph> bytes para el montón de objetos pequeños y <ph id="ph3">`totalSize`</ph> bytes para el montón de objetos grandes).</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">Esto incluye las asignaciones de la aplicación, así como las asignaciones que hace que el tiempo de ejecución en nombre de la aplicación.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">No se pueden anidar las llamadas a la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> método y se debería llamar a la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En otras palabras, no debe llamar <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> sea correcta sólo porque la primera llamada a <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">No salir del modo de latencia región de GC mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> supera el tamaño del segmento efímero.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">El proceso ya está en modo de no latencia de región de GC.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">Debe ser menor o igual que el tamaño de un segmento efímero.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo <bpt id="p1">[</bpt>Fundamentos de la recolección de elementos no utilizados<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> bytes; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para omitir una recolección de elementos no utilizados de bloqueo completa si el recolector de elementos no utilizados no puede asignar inicialmente <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> bytes; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad especificada de memoria está disponible y controla si el recolector de elementos no usados realiza una recolección de elementos no usados de bloqueo completa si no hay suficiente memoria disponible inicialmente.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph> método intenta colocar el recolector de elementos no utilizados en ningún modo de latencia de región de GC, que no permite la recopilación de elementos no utilizados mientras que una aplicación ejecuta una región crítica del código.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si el tiempo de ejecución es no se puede asignar inicialmente la cantidad de memoria solicitada y la <ph id="ph1">`disallowFullBlockingGC`</ph> argumento es <ph id="ph2">`false`</ph>, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento de liberar memoria adicional; en caso contrario, se produce un error en la asignación y el método devuelve <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> (it attempts to allocate <ph id="ph2">`totalSize`</ph> for the small object heap and <ph id="ph3">`totalSize`</ph> for the large object heap).</source>
          <target state="translated">El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar la cantidad necesaria de memoria, lo que en este caso es realmente 2 * <ph id="ph1">`totalSize`</ph> (intenta asignar <ph id="ph2">`totalSize`</ph> para el montón de objetos pequeños y <ph id="ph3">`totalSize`</ph> para el montón de objetos grandes).</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">Esto incluye las asignaciones de la aplicación, así como las asignaciones que hace que el tiempo de ejecución en nombre de la aplicación.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Establecer <ph id="ph1">`disallowFullBlockingGC`</ph> a <ph id="ph2">`true`</ph> para evitar un elementos no utilizados bloqueo completa colección si no hay suficiente memoria disponible inicialmente resulta muy útil en escenarios de equilibrio de carga: un sistema puede llamar a este método y se presenta como listo para aceptar las solicitudes si devuelve <ph id="ph3">`true`</ph>, y permitir que el equilibrador de carga se redirija las solicitudes a otros sistemas si devuelve <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">A continuación, puede realizar una recolección de elementos no utilizados de bloqueo completa cuando no está controlando las solicitudes mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">No se pueden anidar las llamadas a la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> método y se debería llamar a la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En otras palabras, no debe llamar <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> sea correcta sólo porque la primera llamada a <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">No salir del modo de latencia región de GC mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> supera el tamaño del segmento efímero.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">El proceso ya está en modo de no latencia de región de GC.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> – <bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> debe ser menor o igual que el tamaño de un segmento efímero.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo <bpt id="p1">[</bpt>Fundamentos de la recolección de elementos no utilizados<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated">El número de bytes de <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> que se usarán para las asignaciones de montones de objetos grandes (LOH).</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</source>
          <target state="translated">Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad específica de memoria está disponible para los montones de objetos pequeños y grandes.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph> método intenta colocar el recolector de elementos no utilizados en ningún modo de latencia de región de GC, que no permite la recopilación de elementos no utilizados mientras que una aplicación ejecuta una región crítica del código.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento de liberar memoria adicional.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar <ph id="ph1">`lohSize`</ph> para el montón de objeto grande y <ph id="ph2">`totalSize`</ph> : <ph id="ph3">`lohSize`</ph> para el montón de objetos pequeños (SOH).</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el montón de objeto grande, y <ph id="ph2">`totalSize`</ph> : <ph id="ph3">`lohSize`</ph> debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el SOH.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">Esto incluye las asignaciones de la aplicación, así como las asignaciones que hace que el tiempo de ejecución en nombre de la aplicación.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">No se pueden anidar las llamadas a la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> método y se debería llamar a la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En otras palabras, no debe llamar <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> sea correcta sólo porque la primera llamada a <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">No salir del modo de latencia región de GC mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> supera el tamaño del segmento efímero.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">El proceso ya está en modo de no latencia de región de GC.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> – <bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> debe ser menor o igual que el tamaño de un segmento efímero.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo <bpt id="p1">[</bpt>Fundamentos de la recolección de elementos no utilizados<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated">El número de bytes de <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> que se usarán para las asignaciones de montones de objetos grandes (LOH).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para omitir una recolección de elementos no utilizados si el recolector de elementos no utilizados no puede asignar inicialmente la memoria especificada al montón de objetos pequeños (SOH) y LOH; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad especificada de memoria está disponible para los montones de objetos grandes y pequeños, y controla si el recolector de elementos no usados realiza una recolección de elementos no usados de bloqueo completa si no hay suficiente memoria disponible inicialmente.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph> método intenta colocar el recolector de elementos no utilizados en ningún modo de latencia de región de GC, que no permite la recopilación de elementos no utilizados mientras que una aplicación ejecuta una región crítica del código.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si el tiempo de ejecución es no se puede asignar inicialmente la cantidad de memoria solicitada y la <ph id="ph1">`disallowFullBlockingGC`</ph> argumento es <ph id="ph2">`false`</ph>, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento de liberar memoria adicional; en caso contrario, se produce un error en la asignación y el método devuelve <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar <ph id="ph1">`lohSize`</ph> para el montón de objeto grande y <ph id="ph2">`totalSize`</ph> : <ph id="ph3">`lohSize`</ph> para el montón de objetos pequeños (SOH).</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el montón de objeto grande, y <ph id="ph2">`totalSize`</ph> : <ph id="ph3">`lohSize`</ph> debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el SOH.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">Esto incluye las asignaciones de la aplicación, así como las asignaciones que hace que el tiempo de ejecución en nombre de la aplicación.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Establecer <ph id="ph1">`disallowFullBlockingGC`</ph> a <ph id="ph2">`true`</ph> para evitar un elementos no utilizados bloqueo completa colección si no hay suficiente memoria disponible inicialmente resulta muy útil en escenarios de equilibrio de carga: un sistema puede llamar a este método y se presenta como listo para aceptar las solicitudes si devuelve <ph id="ph3">`true`</ph>, y permitir que el equilibrador de carga se redirija las solicitudes a otros sistemas si devuelve <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">A continuación, puede realizar una recolección de elementos no utilizados de bloqueo completa cuando no está controlando las solicitudes mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">No se pueden anidar las llamadas a la <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> método y se debería llamar a la <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">En otras palabras, no debe llamar <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> sea correcta sólo porque la primera llamada a <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">No salir del modo de latencia región de GC mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> supera el tamaño del segmento efímero.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">El proceso ya está en modo de no latencia de región de GC.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">Devuelve el estado de una notificación registrada para determinar si es inminente una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">Devuelve el estado de una notificación registrada para determinar si es inminente una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">El estado de la notificación registrada de recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeración devuelto por este método para determinar el estado de la notificación actual de colección de elementos no utilizados que se registró mediante el <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">También puede usar el <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> método para determinar si se ha completado la recolección de elementos no utilizados completa.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">Cuando se devuelve la enumeración <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, puede realizar tareas como evitar que objetos adicionales que se va a asignar e induce una colección con el <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">Tenga en cuenta que la notificación no garantiza que una colección de elementos no utilizados completa se produzca, solo que las condiciones han alcanzado el umbral que son favorables para una colección de elementos no utilizados completa que se produzca.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">Este método espera indefinidamente una notificación de recolección va a obtener.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Si desea especificar un período de tiempo de espera para el método devolver si no se puede obtener la notificación, utilice el <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">Si se llama a este método sin especificar un tiempo de espera, puede llamar a la <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> método si se esperan más preferido.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">Debe seguir este método con una llamada a la <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> método para asegurarse de que haya tenido una colección de elementos no utilizados completa.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">Si solo llama a este método, pueden producirse resultados indeterminados.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar este método para determinar si una recolección completa de bloqueo elementos no utilizados se está agotando.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCApproachNotify`</ph> is called to perform actions in response to the approaching collection.</source>
          <target state="translated">Cada vez que el estado de la notificación es <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, el método de usuario <ph id="ph2">`OnFullGCApproachNotify`</ph> se llama para realizar acciones en respuesta a la recolección próxima.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo más extenso de <bpt id="p1">[</bpt>notificaciones de la colección de elementos no utilizados<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> tema.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">De plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Un código de confianza parcial no puede utilizar este miembro.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">Cantidad de tiempo que hay que esperar para obtener un estado de notificación.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">Especifique -1 para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">Devuelve el estado de una notificación registrada, en un tiempo de espera especificado, para determinar si una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime es inminente.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">El estado de la notificación registrada de recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeración devuelto por este método para determinar el estado de la notificación actual de colección de elementos no utilizados que se registró mediante el <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">También puede usar el <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> método para determinar si se ha completado la recolección de elementos no utilizados completa.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">Tenga en cuenta que este método devuelve un valor inmediatamente siempre que se obtiene un estado de notificación de la recolección de elementos no utilizados, independientemente del valor especificado por <ph id="ph1">`millisecondsTimeout`</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">Si no se obtiene un estado de notificación de la recolección de elementos no utilizados antes de <ph id="ph1">`millisecondsTimeout`</ph> horas, este método devuelve <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">Cuando se devuelve la enumeración <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, puede realizar tareas como evitar que objetos adicionales que se va a asignar e induce una colección con el <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">Tenga en cuenta que la notificación no garantiza que una colección de elementos no utilizados completa se produzca, solo que las condiciones han alcanzado el umbral que son favorables para una colección de elementos no utilizados completa que se produzca.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">Puede llamar a la <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> método cuando no puede esperar a que transcurra el período de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">Debe seguir este método con una llamada a la <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> método para asegurarse de que haya tenido una colección de elementos no utilizados completa.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">Si solo llama a este método, pueden producirse resultados indeterminados.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> debe ser un valor no negativo, un valor menor o igual a <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> o -1.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">De plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Un código de confianza parcial no puede utilizar este miembro.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">Devuelve el estado de una notificación registrada para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">Devuelve el estado de una notificación registrada para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">El estado de la notificación registrada de recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeración devuelto por este método para determinar el estado de la notificación actual de colección de elementos no utilizados que se registró mediante el <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">También puede usar el <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> método para determinar si es inminente una recolección completa.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">Cuando se devuelve la enumeración <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, puede realizar tareas como reanudar el trabajo y obtener un recuento de la colección con el <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">Este método espera indefinidamente una notificación de recolección va a obtener.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Si desea especificar un período de tiempo de espera para el método devolver si no se puede obtener la notificación, utilice el <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">Si se llama a este método sin especificar un tiempo de espera, puede llamar a la <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> método si se esperan más preferido.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">Esta llamada al método debe ir precedida por una llamada a la <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> método para asegurarse de que haya tenido una colección de elementos no utilizados completa.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">Si solo llama a este método, puede producirse resultados indeterminados.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>The following example shows how to use this method to determine whether a full garbage collection has completed.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar este método para determinar si se ha completado una recolección completa.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCCompletedNotify`</ph> is called to perform actions in response to the completed collection.</source>
          <target state="translated">Cada vez que el estado de la notificación es <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, el método de usuario <ph id="ph2">`OnFullGCCompletedNotify`</ph> se llama para realizar acciones en respuesta a la colección completa.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo más extenso de <bpt id="p1">[</bpt>notificaciones de la colección de elementos no utilizados<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> tema.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">De plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Un código de confianza parcial no puede utilizar este miembro.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">Cantidad de tiempo que hay que esperar para obtener un estado de notificación.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">Especifique -1 para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</source>
          <target state="translated">Devuelve el estado de una notificación registrada, en un tiempo de espera especificado, para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">El estado de la notificación registrada de recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeración devuelto por este método para determinar el estado de la notificación actual de colección de elementos no utilizados que se registró mediante el <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">También puede usar el <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> método para determinar si es inminente una recolección completa.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">Tenga en cuenta que este método devuelve un valor inmediatamente siempre que se obtiene un estado de notificación de la recolección de elementos no utilizados, independientemente del valor especificado por <ph id="ph1">`millisecondsTimeout`</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">Si no se obtiene un estado de notificación de la recolección de elementos no utilizados antes de <ph id="ph1">`millisecondsTimeout`</ph> horas, este método devuelve <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">Cuando se devuelve la enumeración <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, puede realizar tareas como reanudar el trabajo y obtener un recuento de la colección con el <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">Puede llamar a la <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> método cuando no puede esperar a que transcurra el período de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">Esta llamada al método debe ir precedida por una llamada a la <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> método para asegurarse de que haya tenido una colección de elementos no utilizados completa.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">Si solo llama a este método, puede producirse resultados indeterminados.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> debe ser un valor no negativo, un valor menor o igual a <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> o -1.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">De plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">Un código de confianza parcial no puede utilizar este miembro.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForPendingFinalizers">
          <source>Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</source>
          <target state="translated">Suspende el subproceso actual hasta que el subproceso que está procesando la cola de finalizadores vacíe dicha cola.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</source>
          <target state="translated">Cuando el recolector de elementos no utilizados encuentra objetos que se pueden reclamar, comprueba cada objeto para determinar los requisitos de la finalización del objeto.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>If an object implements a finalizer and has not disabled finalization by calling <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>, the object is placed in a list of objects that are marked as ready for finalization.</source>
          <target state="translated">Si un objeto implementa un finalizador y no se ha deshabilitado la finalización mediante una llamada a <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>, el objeto se coloca en una lista de objetos que están marcados como listos para la finalización.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The garbage collector calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods for the objects in this list and removes the entries from the list.</source>
          <target state="translated">El recolector de elementos no utilizados llame el <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> métodos para los objetos de esta lista y quita las entradas de la lista.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>This method blocks until all finalizers have run to completion.</source>
          <target state="translated">Este método se bloquea hasta que todos los finalizadores se ejecuta hasta completarse.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</source>
          <target state="translated">El subproceso en el que se ejecutan los finalizadores no está especificado, así que no hay ninguna garantía de que este método se cerrará.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>However, this thread can be interrupted by another thread while the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method is in progress.</source>
          <target state="translated">Sin embargo, este subproceso puede ser interrumpido por otro subproceso mientras el <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> método está en curso.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</source>
          <target state="translated">Por ejemplo, puede iniciar otro subproceso que espera durante un período de tiempo y, a continuación, interrumpa el primer subproceso si sigue suspendido.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method to suspend the current thread until finalization of all the collected objects is complete.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> método para suspender el subproceso actual hasta que se complete la finalización de todos los objetos recopilados.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>