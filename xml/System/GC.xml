<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a1c461238411ccdddc7c07cf92774d06a76bc8dd" /><Meta Name="ms.sourcegitcommit" Value="e3904cb57bb8e1854a7de1615afac7a569a2064b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/14/2019" /><Meta Name="ms.locfileid" Value="54252702" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Controla el recolector de elementos no utilizados del sistema, un servicio que recupera de forma automática la memoria que no se utiliza.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El recolector de elementos no utilizados es un componente de common language runtime que controla la asignación y liberación de memoria administrada. Influir en los métodos de esta clase cuando se realiza la recolección de elementos en un objeto y, cuando se liberan los recursos asignados por un objeto. Propiedades de esta clase proporcionan información acerca de la cantidad total de memoria disponible en el sistema y la categoría de edad o la generación de memoria asignada a un objeto.  
  
 El recolector de elementos no utilizados realiza un seguimiento y reclama los objetos asignados en memoria administrada. Periódicamente, el recolector de elementos no utilizados realiza la recolección para liberar memoria asignada a objetos para los que no hay ninguna referencia válida. Colección de elementos no utilizados se produce automáticamente cuando no se puede satisfacer una solicitud de memoria utilizando la memoria libre disponible. O bien, una aplicación puede forzar la colección de elementos no utilizados mediante la <xref:System.GC.Collect%2A> método.  
  
 Recolección de elementos consta de los pasos siguientes:  
  
1.  El recolector de elementos no utilizados busca los objetos administrados que se hace referencia en código administrado.  
  
2.  El recolector de elementos no utilizados intenta finalizar los objetos que no se hace referencia.  
  
3.  El recolector de elementos no utilizados libera los objetos que no se hace referencia y reclama su memoria.  
  
 En este tema, se incluyen las siguientes secciones:  
  
 [El recolector de elementos no utilizados y los recursos no administrados](#unmanaged)   
 [Generaciones y caducidad de objetos](#generations)   
 [Impedir la recolección de elementos](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>El recolector de elementos no utilizados y los recursos no administrados  
 Durante una recolección, el recolector de elementos no utilizados no liberar un objeto si encuentra una o varias referencias al objeto en el código administrado. Sin embargo, el recolector de elementos no utilizados no reconoce las referencias a un objeto desde código no administrado y puede liberar objetos que se utilizan exclusivamente en código no administrado, a menos que explícitamente no hacerlo. El <xref:System.GC.KeepAlive%2A> método proporciona un mecanismo que impide que el recolector de elementos de recopilación de objetos que están en uso en código no administrado.  
  
 Aparte de las asignaciones de memoria administrada, las implementaciones del recolector de elementos no utilizados no mantienen información acerca de los recursos mantenidos por un objeto, como identificadores de archivos o las conexiones de base de datos. Cuando un tipo utiliza recursos no administrados que deben liberarse antes de que se recuperan instancias del tipo, el tipo puede implementar un finalizador.  
  
 En la mayoría de los casos, los finalizadores se implementan mediante la invalidación de la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método; sin embargo, los tipos escritos en C# o C++ implementan destructores, que los compiladores se convierten en un reemplazo de <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. En la mayoría de los casos, si un objeto tiene un finalizador, el recolector de elementos no utilizados lo llama antes de liberar el objeto. Sin embargo, el recolector de elementos no utilizados no es necesario para llamar a los finalizadores en todas las situaciones; Por ejemplo, el <xref:System.GC.SuppressFinalize%2A> método explícitamente impide que un finalizador del objeto que se llama. Además, el recolector de elementos no utilizados no tiene que usar un subproceso específico para finalizar los objetos o garantiza el orden en el que se llama a los finalizadores para objetos que hacen referencia entre sí, pero están disponibles para la recolección.  
  
 En escenarios donde se deben liberar los recursos en un momento determinado, las clases pueden implementar la <xref:System.IDisposable> interfaz, que contiene el <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método que realiza las tareas de administración y limpieza de recursos. Las clases que implementan <xref:System.IDisposable.Dispose%2A> especifique, como parte de su contrato de clase, cuando los consumidores de la clase llama al método para limpiar el objeto. El recolector de elementos no utilizados no, de forma predeterminada, llama a la <xref:System.IDisposable.Dispose%2A> método; sin embargo, las implementaciones de la <xref:System.IDisposable.Dispose%2A> método puede llamar a métodos el <xref:System.GC> clase para personalizar el comportamiento de finalización del recolector de elementos no utilizados.  
  
 Para obtener más información sobre la finalización del objeto y el patrón de dispose, vea [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Generaciones y caducidad de objetos  
 El recolector de elementos no utilizados de common language runtime admite la edad de los objetos mediante las generaciones. Una generación es una unidad de medida de la antigüedad relativa de los objetos en memoria. El número de generación o la edad de un objeto indica la generación a la que pertenece un objeto. Los objetos creados más recientemente forman parte de las generaciones más recientes y tienen los números más bajos de generación de ciclo de los objetos creados anteriormente en la vida de la aplicación. Son objetos de la generación más reciente en la generación 0. Esta implementación del recolector de elementos no utilizados admite tres generaciones de objetos, las generaciones 0, 1 y 2. Puede recuperar el valor de la <xref:System.GC.MaxGeneration%2A> propiedad para determinar el número de generación máximo admitido por el sistema.  
  
 Caducidad de objetos permite que las aplicaciones dirijan la recolección en un conjunto específico de generaciones en lugar de requerir el recolector de elementos no utilizados evaluar todas las generaciones. Las sobrecargas de los <xref:System.GC.Collect%2A> método que incluyen un `generation` parámetro le permiten especificar la generación más antigua se recolecte.  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Impedir la recolección de elementos  
 A partir de la [!INCLUDE[net_v46](~/includes/net-v46-md.md)], el recolector de elementos no utilizados es compatible con un GC región modo de no latencia que se puede usar durante la ejecución de las rutas críticas en qué elementos no utilizados colección puede afectar al rendimiento de una aplicación. El modo de latencia ninguna región de GC requiere que especifique una cantidad de memoria que se puede asignar sin interferencias del recolector de elementos no utilizados. Si el tiempo de ejecución puede asignar memoria, el tiempo de ejecución no realizará una colección de elementos no utilizados mientras se está ejecutando código en la ruta crítica.  
  
 Definir el principio de la ruta crítica de la región de GC no mediante una llamada a una de las sobrecargas de los <xref:System.GC.TryStartNoGCRegion%2A>. Especifique el final de su ruta de acceso crítica mediante una llamada a la <xref:System.GC.EndNoGCRegion%2A> método.  
  
 No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
   
  
## Examples  
 El ejemplo siguiente usa varios métodos de GC para obtener información de memoria sobre un bloque de objetos no utilizados y la generación e imprimirlo en la consola. Los objetos no utilizados, a continuación, se recopilan y se muestran los totales de memoria resultantes.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">recolección de elementos no utilizados</related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Fundamentos de la recolección de elementos no utilizados</related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Cantidad incremental de memoria no administrada que se ha asignado.</param>
        <summary>Informa al tiempo de ejecución de una asignación grande de memoria no administrada que se debe tener en cuenta al programar la recolección de elementos no utilizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar cuándo se debe programar la recopilación de elementos no utilizados, el tiempo de ejecución tiene en cuenta la cantidad de memoria administrada está asignada. Si un objeto administrado pequeño asigna una gran cantidad de memoria no administrada, el tiempo de ejecución tiene en cuenta que sólo la memoria administrada y, por tanto, subestima la urgencia de programar la recolección. El <xref:System.GC.AddMemoryPressure%2A> método informa el tiempo de ejecución de esta necesidad adicional de memoria del sistema.  
  
 En el patrón de uso más simple, un objeto administrado asigna memoria no administrada en el constructor y lo libera en la `Dispose` o `Finalize` método. Llame a la <xref:System.GC.AddMemoryPressure%2A> método después de asignar la memoria no administrada y llamar a la <xref:System.GC.RemoveMemoryPressure%2A> método después de liberarla.  
  
 En escenarios más complicados, donde la asignación de memoria no administrada cambia considerablemente durante la vigencia del objeto administrado, puede llamar a la <xref:System.GC.AddMemoryPressure%2A> y <xref:System.GC.RemoveMemoryPressure%2A> métodos de comunicación de estos cambios incrementales en el tiempo de ejecución.  
  
> [!CAUTION]
>  Debe asegurarse de que quita exactamente la cantidad de presión que agrega. Si no lo puede afectar negativamente el rendimiento del sistema en las aplicaciones que se ejecutan durante largos períodos de tiempo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" /> es menor o igual que 0.  
  
O bien 
En un equipo de 32 bits, <paramref name="bytesAllocated" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al manipular la prioridad de la colección de elementos no utilizados. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela el registro de una notificación de recolección de elementos no utilizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método cancela una notificación de recolección que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. No es necesario llamar a este método antes de ajustar los valores de parámetro de umbral en llamadas posteriores a la <xref:System.GC.RegisterForFullGCNotification%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente cancela un registro de la colección de elementos no utilizados. Este ejemplo forma parte de un ejemplo más extenso proporcionado para el [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Este miembro no está disponible cuando la recolección de elementos no utilizados simultánea está habilitada. Vea la configuración en tiempo de ejecución [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) para obtener información sobre cómo deshabilitar la recolección de elementos no utilizados simultánea.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notificaciones de recolección de elementos no utilizados</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fuerza a que se lleve a cabo la recolección de elementos no utilizados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fuerza a que se lleve a cabo una recolección de elementos no utilizados de todas las generaciones.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para intentar reclamar toda la memoria que no es accesible. Realiza una recolección de elementos no utilizados de bloqueo de todas las generaciones.  
  
 Todos los objetos, independientemente de cuánto tiempo llevan en memoria, se consideran para la colección; Sin embargo, no se recopilan los objetos que se hace referencia en código administrado. Utilice este método para forzar al sistema para intentar reclamar la cantidad máxima de memoria disponible.  
  
 A partir de la [!INCLUDE[net_v451](~/includes/net-v451-md.md)], puede compactar el montón de objetos grandes (LOH) estableciendo el <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> antes de llamar a la <xref:System.GC.Collect%2A> método, como en el ejemplo siguiente se muestra.  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.Collect%2A> método para realizar una recolección en todas las generaciones de memoria. El código genera un número de objetos no utilizados y, a continuación, llama a la <xref:System.GC.Collect%2A> método para limpiarlos de la memoria.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Colecciones inducidas</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">El número de la generación más antigua de elementos no usados para recolectar.</param>
        <summary>Fuerza a que se lleve a cabo inmediatamente la recolección de elementos no utilizados desde la generación 0 hasta la generación especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para intentar reclamar la memoria que no es accesible. Sin embargo, con este método no garantiza que se reclame toda la memoria accesible en la generación especificada.  
  
 Si se implementa la edad de los objetos, el recolector de elementos no utilizados no recopila los objetos con un número de generación que es mayor que la generación especificada. Si no se implementa la edad de los objetos, el recolector de elementos no utilizados considera que todos los objetos durante la recolección.  
  
 Use la <xref:System.GC.MaxGeneration%2A> propiedad para determinar el máximo valor válido de la `generation` parámetro.  
  
 Para que el recolector de elementos no utilizados que considere la posibilidad de todos los objetos independientemente de su generación, utilice la versión de este método que no toma ningún parámetro. Para que el recolector de elementos reclamar objetos en función de un <xref:System.GCCollectionMode> establecer, use el <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> sobrecarga del método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.Collect%2A> método para realizar una recolección en capas individuales de memoria. El código genera un número de objetos no utilizados y, a continuación, llama a la <xref:System.GC.Collect%2A> método para limpiarlos de la memoria.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> no es válido.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Colecciones inducidas</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">El número de la generación más antigua de elementos no usados para recolectar.</param>
        <param name="mode">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o si será optimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Fuerza una recolección de elementos no utilizados desde la generación 0 hasta la generación especificada, en el momento especificado por el valor <see cref="T:System.GCCollectionMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `mode` parámetro para especificar si la colección de elementos no utilizados debería producirse inmediatamente o solo si el tiempo es adecuado para reclamar objetos. Con este método no garantiza que se reclame toda la memoria accesible en la generación especificada.  
  
 Para ajustar la tendencia a la intrusión de elementos no utilizados durante los períodos críticos en la aplicación, establezca el <xref:System.Runtime.GCSettings.LatencyMode%2A> propiedad.  
  
 El recolector de elementos no utilizados no recopila los objetos con un número de generación superior al especificado por el `generation` parámetro. Use la <xref:System.GC.MaxGeneration%2A> propiedad para determinar el máximo valor válido de `generation`.  
  
 Para que el recolector de elementos no utilizados que considere la posibilidad de todos los objetos independientemente de su generación, utilice la versión de este método que no toma ningún parámetro.  
  
 Para que el recolector de elementos no utilizados recupera los objetos hasta una generación especificada de objetos, use el <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método. Al especificar la generación máxima, se recopilan todos los objetos.  
  
   
  
## Examples  
 En el ejemplo siguiente se fuerza una recolección de elementos para los objetos de generación 2 con la <xref:System.GCCollectionMode.Optimized> configuración.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> no es válido.  
  
O bien 
 <paramref name="mode" /> no es uno de los valores de <see cref="T:System.GCCollectionMode" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Colecciones inducidas</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">El número de la generación más antigua de elementos no usados para recolectar.</param>
        <param name="mode">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o si será optimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking"><see langword="true" /> para realizar una recolección de elementos no utilizados de bloqueo; <see langword="false" /> para realizar una recolección de elementos no utilizados en segundo plano cuando sea posible.</param>
        <summary>Fuerza una recolección de elementos no utilizados de generación 0 en una generación especificada, en un momento especificado por un valor de <see cref="T:System.GCCollectionMode" />, con un valor que especifica si la recolección debe ser de bloqueo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se resume la interacción de la `mode` y `blocking` parámetros:  
  
|`mode`|`blocking` es `true`|`blocking` es `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> o <xref:System.GCCollectionMode.Default>|Se realiza una recolección de bloqueo lo antes posible. Si una recolección en segundo plano está en curso y `generation` es 0 o 1, el <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> método inmediatamente desencadena una recolección de bloqueo y vuelve cuando finaliza la colección. Si una recolección en segundo plano está en curso y `generation` es 2, el método espera hasta que finalice la recolección en segundo plano, desencadena una recolección de generación 2 de bloqueo y, a continuación, se devuelve.|Se realiza una recolección lo antes posible. El método <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> solicita una colección en segundo plano, pero esto no se garantiza; puede que aún se realice una colección de bloqueo, dependiendo de las circunstancias. Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.|  
|<xref:System.GCCollectionMode.Optimized>|Se puede realizar una recolección de bloqueo, dependiendo del estado del recolector de elementos no utilizados y del parámetro `generation`. El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo.|Se puede realizar una recolección, según el estado del recolector de elementos no utilizados. El método <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> solicita una colección en segundo plano, pero esto no se garantiza; puede que aún se realice una colección de bloqueo, dependiendo de las circunstancias. El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo. Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.|  
  
 Si una llamada a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> método realiza una recolección de elementos no utilizados de bloqueo completa, también puede compactar el montón de objeto grande estableciendo la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> antes de llamar a la <xref:System.GC.Collect%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> no es válido.  
  
O bien 
 <paramref name="mode" /> no es uno de los valores de <see cref="T:System.GCCollectionMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">El número de la generación más antigua de elementos no usados para recolectar.</param>
        <param name="mode">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o si será optimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking"><see langword="true" /> para realizar una recolección de elementos no utilizados de bloqueo; <see langword="false" /> para realizar una recolección de elementos no utilizados en segundo plano cuando sea posible.</param>
        <param name="compacting"><see langword="true" /> para compactar el montón de objetos pequeños; <see langword="false" /> solo para limpiar.</param>
        <summary>Fuerza una recolección de elementos no utilizados de generación 0 en una generación especificada, en un momento especificado por un valor de <see cref="T:System.GCCollectionMode" />, con valores que especifican si la recolección debe ser de bloqueo y compactante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `blocking` es `false`, el GC decide si debe realizar una recolección de elementos no utilizados de bloqueo o de un fondo. Si `compacting` es `true`, realiza una recolección de elementos no utilizados de bloqueo.  
  
 Si `compacting` es `true`, el tiempo de ejecución compacta el montón de objetos pequeños (SOH). No se compacta el montón de objetos grandes (LOH) a menos que el <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad está establecida en <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>. Tenga en cuenta que esto incluye todos los elementos no utilizados colecciones de bloqueo, no solo de forma completa las colecciones de elementos no utilizados de bloqueo.  
  
 Puede llamar a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método para reducir el montón administrado para el menor tamaño posible, como se muestra en el siguiente fragmento de código.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Especificar `true` para el `compacting` argumento garantiza una recolección de elementos no utilizados de bloqueo completa, con compactación. Establecer el <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> garantiza que el montón de objeto grande y el SOH se compactan.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">La generación de objetos para la que se va a determinar el número de recolecciones de elementos no utilizados.</param>
        <summary>Devuelve el número de veces que se ha producido la recolección de elementos no utilizados para la generación de objetos especificada.</summary>
        <returns>El número de veces que se ha realizado la recolección de elementos no utilizados para la generación especificada desde que se inició el proceso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si implementa su propia administración de recursos, es posible que deba forzar la recolección periódicamente mediante una llamada a la <xref:System.GC.Collect%2A> método. Se trata de una operación costosa, puede mejorar el rendimiento omitiendo la llamada cuando se ha producido recientemente a una colección de elementos no utilizados. Guarde el valor devuelto por <xref:System.GC.CollectionCount%2A> inmediatamente después de llamar a <xref:System.GC.Collect%2A>. La próxima vez que se debe llamar a <xref:System.GC.Collect%2A>, compare el valor actual devuelto por <xref:System.GC.CollectionCount%2A> en el valor guardado. Si los dos valores son iguales, no se ha producido ninguna recolección provisional y resulta razonable llamar a <xref:System.GC.Collect%2A> nuevo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> es menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Finaliza el modo de no latencia en la región GC.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.EndNoGCRegion%2A> método produce una <xref:System.InvalidOperationException> si el recolector de elementos no utilizados no está en modo de no latencia de la región de GC. Esto se produce en cualquiera de las condiciones siguientes:  
  
-   El <xref:System.GC.TryStartNoGCRegion%2A> no llamó al método anteriormente.  
  
-   La llamada a la <xref:System.GC.TryStartNoGCRegion%2A> devuelto del método `false`.  
  
-   La llamada a la <xref:System.GC.TryStartNoGCRegion%2A> método producía una excepción.  
  
 Puede evitar una excepción para cualquiera de estos motivos mediante código como el siguiente:  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El recolector de elementos no utilizados no está en modo de no latencia en la región GC.  
  
O bien 
El modo de no latencia en la región GC se terminó prematuramente porque se indujo una recolección de elementos no utilizados.  
  
O bien 
Una asignación de memoria superó la cantidad especificada en la llamada al método <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modos de latencia</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número total de bytes asignados al subproceso actual desde el principio de su duración.</summary>
        <returns>Número total de bytes asignados al subproceso actual desde el principio de su duración.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

El `GetAllocatedBytesForCurrentThread` método devuelve el número total de bytes asignados en el montón administrado durante la vigencia de un subproceso, no el número total de bytes que han sobrevivido a la recolección de elementos. El valor devuelto no incluye también las asignaciones nativas.

Este método es muy útil en escenarios para medir la diferencia en la asignación de memoria entre intervalos de tiempo o los eventos de supervisión.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el número de generación actual de un objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">El objeto cuya información sobre generación se recupera.</param>
        <summary>Devuelve el número de generación actual del objeto especificado.</summary>
        <returns>El número de generación actual de <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para determinar la edad de un objeto y, a continuación, usar esa información con el <xref:System.GC.Collect%2A> método para obligar al recolector de elementos no utilizados para recopilar objetos de la misma generación. Por ejemplo, puede usar este método cuando tenga un conjunto de objetos que se crean como un grupo y que dejan de estar accesibles al mismo tiempo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.GetGeneration%2A> método para determinar la edad de un objeto. El ejemplo, a continuación, realiza recolecciones de elementos para limpiar la memoria y comparar el pre y post colección totales de memoria en la consola de.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">Un <see cref="T:System.WeakReference" /> que hace referencia al objeto de destino cuyo número de generación debe determinarse.</param>
        <summary>Devuelve el número de generación actual del destino de una referencia débil especificada.</summary>
        <returns>El número de generación actual del destino de <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.GC.GetGeneration%2A> método para determinar la edad de un objeto de referencia débil.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ya se ha realizado la recolección de elementos no utilizados en <paramref name="wo" />.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection"><see langword="true" /> para indicar que este método puede esperar a que se produzca la recolección de elementos no utilizados antes de regresar; en caso contrario, <see langword="false" />.</param>
        <summary>Recupera el número de bytes que se considera que están asignados en la actualidad. Un parámetro indica si este método puede esperar un breve intervalo de tiempo antes de regresar, para permitir que el sistema recoja los elementos no utilizados y finalice los objetos.</summary>
        <returns>Número que representa la aproximación más exacta disponible del número de bytes actualmente asignados en la memoria administrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `forceFullCollection` parámetro es `true`, este método espera un breve intervalo antes de devolver mientras el sistema recopila elementos no utilizados y finaliza los objetos. La duración del intervalo es un límite especificado internamente determinado por el número de ciclos de colección de elementos no utilizados completa y el cambio en la cantidad de memoria recuperada entre los ciclos. El recolector de elementos no utilizados no garantiza que se recopila toda la memoria accesible.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.GetTotalMemory%2A> método para obtener y mostrar el número de bytes actualmente asignados en memoria administrada.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">El objeto al que se va a hacer referencia.</param>
        <summary>Hace referencia al objeto especificado, convirtiéndolo en un objeto no válido para la recolección de elementos no utilizados desde el principio de la rutina actual hasta el momento en que se llamó a este método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El propósito de la <xref:System.GC.KeepAlive%2A> método consiste en garantizar la existencia de una referencia a un objeto que está en riesgo de ser reclamado prematuramente por el recolector de elementos no utilizados. Un escenario común donde esto puede ocurrir es cuando no hay ninguna referencia al objeto en código administrado o datos, pero el objeto todavía está en uso en código no administrado, como las API de Win32, archivos DLL no administrados, o métodos que utilizan COM.  
  
 Este método hace referencia a la `obj` parámetro, convirtiéndolo ese objeto no válido para la recolección de elementos desde el principio de la rutina hasta el punto en el orden de ejecución, donde se llama a este método. Este método al final, no al principio del intervalo de instrucciones de código donde `obj` deben estar disponibles.  
  
 El <xref:System.GC.KeepAlive%2A> método no realiza ninguna operación y no produce efectos aparte de ampliar la duración del objeto pasado como un parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un objeto al principio de su `Main` método y no hace referencia al objeto nuevamente hasta el final, cuando el <xref:System.GC.KeepAlive%2A> se llama al método. El objeto se mantiene durante 30 segundos de la `Main` método, a pesar de las llamadas a la <xref:System.GC.Collect%2A> y <xref:System.GC.WaitForPendingFinalizers%2A> métodos.  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número máximo de generaciones que el sistema admite en la actualidad.</summary>
        <value>Un valor comprendido entre cero y el número máximo de generaciones admitidas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de generación o la edad de un objeto es una medida relativa de la duración de un objeto definido por la implementación. Son los objetos creados más recientemente en la generación 0 y los objetos más antiguos están en una generación menor o igual a la generación devuelta por la <xref:System.GC.MaxGeneration%2A> propiedad.  
  
 El recolector de elementos no utilizados se da por supuesto que la memoria más reciente es más probable que sea apto para la recolección de memoria anterior. Por lo tanto, el recolector de elementos no utilizados mejora su rendimiento ajustando los números de generación cada vez que reclama memoria, y el <xref:System.GC.MaxGeneration%2A> puede alcanzar el valor de propiedad con el tiempo.  
  
 Si se implementa la edad de los objetos, el <xref:System.GC.MaxGeneration%2A> propiedad devuelve el número de generación máximo utilizado por el sistema; en caso contrario, esta propiedad devuelve cero.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar la propiedad MaxGeneration para mostrar el mayor número de generación actualmente en uso.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Para esta implementación, el valor devuelto por la <see cref="P:System.GC.MaxGeneration" /> se garantiza que la propiedad permanece constante para la duración de una aplicación en ejecución.  
  
Use la <see cref="P:System.GC.MaxGeneration" /> propiedad para determinar el valor máximo que puede especificar cuando se llama a la <see cref="M:System.GC.Collect(System.Int32)" /> método que toma un parámetro de generación.</para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Número comprendido entre 1 y 99 que especifica cuándo debe emitirse la notificación basándose en los objetos asignados en la generación 2.</param>
        <param name="largeObjectHeapThreshold">Un número comprendido entre 1 y 99 que especifica cuándo debe emitirse la notificación basándose en los objetos asignados en el montón de objetos grandes.</param>
        <summary>Especifica que debe emitirse una notificación de recolección de elementos no utilizados cuando las condiciones favorecen la recolección completa de elementos no utilizados y cuando se ha completado la recolección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por cada generación, el recolector de elementos no utilizados establece un umbral para las asignaciones en dicha generación. Cuando el tamaño de las asignaciones supera este umbral, se desencadena una recolección en dicha generación. De ejemplo, si el umbral de generación 2 es 20MB (lo que significa que 20MB sobrevive a las recolecciones de generación 1 y se promueven a la generación 2) y más de 20MB sobrevivió a la generación 1 y se pide a la generación 2, se volverá a intentar la siguiente recolección de elementos no utilizados como una recolección de generación 2. De forma similar, si el montón de objetos grandes (LOH) Value de umbral es de 20MB y la aplicación ha asignado más de 20MB de objetos grandes, la siguiente recolección de elementos no utilizados también se volverá a intentar como una recolección de generación 2 (ya que el montón de objeto grande solo se recopila en las colecciones de elementos no utilizados de gen2).  
  
 El `maxGenerationThreshold` y `largeObjectHeapThreshold` umbrales controlan cuánto de antemano se le notificará antes de que se produce una colección de elementos no utilizados completa. Cuanto mayor sea el umbral, las asignaciones más que pueden producirse entre la notificación y la siguiente recolección de elementos no utilizados completa.  
  
 Si dispone de las situaciones en que una colección de elementos no utilizados completa por common language runtime negativamente afectaría al rendimiento de la aplicación, puede pedir que se le notifique cuando el tiempo de ejecución se va a realizar una recolección de elementos no utilizados completa y eludir esa recolección por inducción de una colección por su cuenta (mediante el <xref:System.GC.Collect%2A> método) cuando las condiciones son todavía favorables. Además de cambiar la programación de la colección de elementos no utilizados, notificación de GC completo es útil en los escenarios siguientes:  
  
-   Supervisión de la estrategia de una colección de elementos no utilizados completa y, cuando se le notifique que uno se aproxima, reducir el tamaño de los datos en directo (por ejemplo, al liberar algunas entradas de caché). Como resultado, cuando se produce la recolección de elementos, es capaz de liberar más memoria.  
  
-   Supervisar la finalización de una colección de elementos no utilizados completa para que pueda recopilar algunas estadísticas.  Por ejemplo, es posible que desee medir el tamaño del montón al finalizar el GC para que sepa el tamaño de los datos en directo. (Después de un GC completo, el montón es con su tamaño más pequeño).  
  
 Para obtener más información sobre lo que representa una colección de elementos no utilizados completa, consulte [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md).  
  
 Cuando se registra para una notificación de recolección, puede recibir notificaciones cuando una recolección de elementos no utilizados completa está próxima y cuando se complete. Este patrón es similar a cómo se supervisa el sistema operativo para las notificaciones de memoria baja.  
  
 Utilice las instrucciones siguientes para especificar el `maxGenerationThreshold` y `largeObjectHeapThreshold` parámetros:  
  
-   Cuanto mayor sea el valor de umbral, se producen la más asignaciones entre la notificación y la colección de elementos no utilizados completa.  
  
     Un valor de umbral mayor proporciona más oportunidades para el tiempo de ejecución comprobar si una recolección próxima. Esto aumenta la probabilidad de que se le notificará. Sin embargo, no debe establecer el umbral demasiado alto, ya da lugar a una más asignaciones antes de que el tiempo de ejecución induce la recolección siguiente.  
  
     Cuando se induce una recolección tras la notificación con un valor de umbral alto, menos objetos se reclaman que reclamarían colección siguiente del tiempo de ejecución.  
  
-   Cuanto menor sea el valor de umbral, menos las asignaciones entre la notificación y la colección de elementos no utilizados completa.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo registrar una notificación de recolección e iniciar un subproceso para supervisar el estado de la notificación de recolección. Este ejemplo de código forma parte de un ejemplo más extenso de [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxGenerationThreshold" /> o <paramref name="largeObjectHeapThreshold" /> no está entre 1 y 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notificaciones de recolección de elementos no utilizados</related>
        <exception cref="T:System.InvalidOperationException">Este miembro no está disponible cuando la recolección de elementos no utilizados simultánea está habilitada. Vea la configuración en tiempo de ejecución &lt;gcConcurrent&gt; para obtener información sobre cómo deshabilitar la recolección de elementos no utilizados simultánea.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Cantidad de memoria no administrada que se ha liberado.</param>
        <summary>Informa al tiempo de ejecución de que se ha liberado la memoria no administrada y ya no se necesita tener en cuenta al programar la recolección de elementos no utilizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar cuándo se debe programar la recopilación de elementos no utilizados, el tiempo de ejecución tiene en cuenta la cantidad de memoria administrada está asignada. Si un objeto administrado pequeño asigna una gran cantidad de memoria no administrada, el tiempo de ejecución tiene en cuenta que sólo la memoria administrada y, por tanto, subestima la urgencia de programar la recolección. El <xref:System.GC.AddMemoryPressure%2A> método informa el tiempo de ejecución de esta necesidad adicional de memoria del sistema y el <xref:System.GC.RemoveMemoryPressure%2A> método informa al tiempo de ejecución que se ha liberado la presión adicional.  
  
 En el patrón de uso más simple, un objeto administrado asigna memoria no administrada en el constructor y lo libera en la `Dispose` o `Finalize` método. Llame a la <xref:System.GC.AddMemoryPressure%2A> método después de asignar la memoria no administrada y llamar a la <xref:System.GC.RemoveMemoryPressure%2A> método después de liberarla.  
  
 En escenarios más complicados, donde la asignación de memoria no administrada cambia considerablemente durante la vigencia del objeto administrado, puede llamar a la <xref:System.GC.AddMemoryPressure%2A> y <xref:System.GC.RemoveMemoryPressure%2A> métodos de comunicación de estos cambios incrementales en el tiempo de ejecución.  
  
> [!CAUTION]
>  Debe asegurarse de que quita exactamente la cantidad de presión que agrega. Si no lo puede afectar negativamente el rendimiento del sistema en las aplicaciones que se ejecutan durante largos períodos de tiempo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" /> es menor o igual que 0.  
  
O bien 
En un equipo de 32 bits, <paramref name="bytesAllocated" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al manipular la prioridad de la colección de elementos no utilizados. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">El objeto cuyo finalizador debe llamarse.</param>
        <summary>Solicita que el sistema llame al finalizador del objeto especificado, para el que previamente se ha llamado a <see cref="M:System.GC.SuppressFinalize(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.ReRegisterForFinalize%2A> método agrega el `obj` parámetro a la lista de objetos que solicitan una finalización antes de que el recolector de elementos no utilizados libere el objeto. El `obj` parámetro debe ser el llamador de este método.  
  
 Una llamada a la <xref:System.GC.ReRegisterForFinalize%2A> método no garantiza que el recolector de elementos no utilizados llame al finalizador de un objeto.  
  
 De forma predeterminada, todos los objetos que implementan los finalizadores se agregan a la lista de objetos que requieren la finalización; Sin embargo, es posible que ya ha finalizado o es posible que haya deshabilitado la finalización mediante una llamada a un objeto el <xref:System.GC.SuppressFinalize%2A> método.  
  
 Un finalizador puede usar este método a resucitar a sí mismo o a un objeto que hace referencia.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el método ReRegisterForFinalize para finalizar un objeto una segunda vez después de la recolección de elementos.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">El objeto cuyo finalizador no debe ejecutarse.</param>
        <summary>Solicita que Common Language Runtime no llame al finalizador del objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método establece un bit en el encabezado del objeto de `obj`, lo que el tiempo de ejecución comprueba cuando se llama a los finalizadores. Un finalizador, que viene representado por la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método, se usa para liberar recursos no administrados antes de que un objeto se recopila de elementos no utilizados. Si `obj` no tiene un finalizador, la llamada a la <xref:System.GC.SuppressFinalize%2A> método no tiene ningún efecto.  
  
 Los objetos que implementan la <xref:System.IDisposable> interfaz puede llamar a este método desde el objeto <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación para evitar que el recolector de elementos no utilizados que realiza la llamada <xref:System.Object.Finalize%2A?displayProperty=nameWithType> en un objeto que no la necesita. Normalmente, esto se hace para evitar que el finalizador de liberar recursos no administrados que ya se han liberado por el <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.SuppressFinalize%2A> método en una clase de recurso para evitar que una recolección redundantes desde que se llama. El ejemplo se usa el [dispose](~/docs/standard/garbage-collection/implementing-dispose.md) patrón para liberar tanto recursos administrados (es decir, los objetos que implementan <xref:System.IDisposable>) y los recursos no administrados.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">Patrón de Dispose</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta suspender la recolección de elementos durante la ejecución de una ruta crítica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección. Debe ser menor o igual que el tamaño de un segmento efímero. Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <summary>Intenta suspender la recolección de elementos durante la ejecución de una ruta crítica si una cantidad específica de memoria está disponible.</summary>
        <returns><see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> método intenta poner el recolector de elementos no utilizados en ningún modo de latencia de región de GC, lo que impide la recolección de elementos mientras una región crítica del código ejecuta una aplicación.  Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento para liberar memoria adicional. El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar la cantidad necesaria de memoria, lo que en este caso es realmente 2 * `totalSize` bytes (intenta asignar `totalSize` bytes para el montón de objetos pequeños y `totalSize` bytes para el montón de objetos grandes).  
  
 `totalSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica. Esto incluye las asignaciones por la aplicación, así como las asignaciones que el tiempo de ejecución se realiza en nombre de la aplicación.  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 No salir del modo de latencia región de GC llamando el <xref:System.GC.EndNoGCRegion%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> supera el tamaño del segmento efímero.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya está en modo de no latencia de región de GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Fundamentos de la recolección de elementos no utilizados</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modos de latencia</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección. Debe ser menor o igual que el tamaño de un segmento efímero. Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="disallowFullBlockingGC"><see langword="true" /> para omitir una recolección de elementos no utilizados de bloqueo completa si el recolector de elementos no utilizados no puede asignar inicialmente <paramref name="totalSize" /> bytes; en caso contrario, <see langword="false" />.</param>
        <summary>Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad especificada de memoria está disponible y controla si el recolector de elementos no usados realiza una recolección de elementos no usados de bloqueo completa si no hay suficiente memoria disponible inicialmente.</summary>
        <returns><see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> método intenta poner el recolector de elementos no utilizados en ningún modo de latencia de región de GC, lo que impide la recolección de elementos mientras una región crítica del código ejecuta una aplicación.  Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada y la `disallowFullBlockingGC` argumento es `false`, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento para liberar memoria adicional; de lo contrario, la asignación se produce un error y el método devuelve `false`. El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar la cantidad necesaria de memoria, lo que en este caso es realmente 2 * `totalSize` (intenta asignar `totalSize` para el montón de objetos pequeños y `totalSize` para el objeto grande montón).  
  
 `totalSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica. Esto incluye las asignaciones por la aplicación, así como las asignaciones que el tiempo de ejecución se realiza en nombre de la aplicación.  
  
 Establecer `disallowFullBlockingGC` a `true` para evitar un elementos no utilizados bloqueo completa colección si no hay suficiente memoria disponible inicialmente es muy útil en escenarios de equilibrio de carga: puede llamar a este método y se presenta como listo para aceptar las solicitudes si devuelve un sistema `true`, y tiene el equilibrador de carga redirigir las solicitudes a otros sistemas si devuelve `false`. A continuación, hacer una recolección de elementos no utilizados de bloqueo completa cuando no está controlando las solicitudes mediante una llamada a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método.  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 No salir del modo de latencia región de GC llamando el <xref:System.GC.EndNoGCRegion%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> supera el tamaño del segmento efímero.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya está en modo de no latencia de región de GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Fundamentos de la recolección de elementos no utilizados</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modos de latencia</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección. <paramref name="totalSize" /> -<paramref name="lohSize" /> debe ser menor o igual que el tamaño de un segmento efímero. Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">El número de bytes de <paramref name="totalSize" /> que se utilizarán para las asignaciones de montones de objetos grandes (LOH).</param>
        <summary>Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad específica de memoria está disponible para los montones de objetos pequeños y grandes.</summary>
        <returns><see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> método intenta poner el recolector de elementos no utilizados en ningún modo de latencia de región de GC, lo que impide la recolección de elementos mientras una región crítica del código ejecuta una aplicación.  Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento para liberar memoria adicional. El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar `lohSize` para el montón de objeto grande y `totalSize`  -  `lohSize` para el montón de objetos pequeños (SOH).  
  
 `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el montón de objeto grande y `totalSize`  -  `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el informe de mantenimiento. Esto incluye las asignaciones por la aplicación, así como las asignaciones que el tiempo de ejecución se realiza en nombre de la aplicación.  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 No salir del modo de latencia región de GC llamando el <xref:System.GC.EndNoGCRegion%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" /> supera el tamaño del segmento efímero.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya está en modo de no latencia de región de GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Fundamentos de la recolección de elementos no utilizados</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modos de latencia</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección. <paramref name="totalSize" /> -<paramref name="lohSize" /> debe ser menor o igual que el tamaño de un segmento efímero. Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">El número de bytes de <paramref name="totalSize" /> que se utilizarán para las asignaciones de montones de objetos grandes (LOH).</param>
        <param name="disallowFullBlockingGC"><see langword="true" /> para omitir una recolección de elementos no utilizados si el recolector de elementos no utilizados no puede asignar inicialmente la memoria especificada al montón de objetos pequeños (SOH) y LOH; en caso contrario, <see langword="false" />.</param>
        <summary>Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad especificada de memoria está disponible para los montones de objetos grandes y pequeños, y controla si el recolector de elementos no usados realiza una recolección de elementos no usados de bloqueo completa si no hay suficiente memoria disponible inicialmente.</summary>
        <returns><see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> método intenta poner el recolector de elementos no utilizados en ningún modo de latencia de región de GC, lo que impide la recolección de elementos mientras una región crítica del código ejecuta una aplicación.  Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada y la `disallowFullBlockingGC` argumento es `false`, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento para liberar memoria adicional; de lo contrario, la asignación se produce un error y el método devuelve `false`. El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar `lohSize` para el montón de objeto grande y `totalSize`  -  `lohSize` para el montón de objetos pequeños (SOH).  
  
 `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el montón de objeto grande y `totalSize`  -  `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el informe de mantenimiento. Esto incluye las asignaciones por la aplicación, así como las asignaciones que el tiempo de ejecución se realiza en nombre de la aplicación.  
  
 Establecer `disallowFullBlockingGC` a `true` para evitar un elementos no utilizados bloqueo completa colección si no hay suficiente memoria disponible inicialmente es muy útil en escenarios de equilibrio de carga: puede llamar a este método y se presenta como listo para aceptar las solicitudes si devuelve un sistema `true`, y tiene el equilibrador de carga redirigir las solicitudes a otros sistemas si devuelve `false`. A continuación, hacer una recolección de elementos no utilizados de bloqueo completa cuando no está controlando las solicitudes mediante una llamada a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método.  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 No salir del modo de latencia región de GC llamando el <xref:System.GC.EndNoGCRegion%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" /> supera el tamaño del segmento efímero.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya está en modo de no latencia de región de GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Fundamentos de la recolección de elementos no utilizados</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Modos de latencia</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el estado de una notificación registrada para determinar si es inminente una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el estado de una notificación registrada para determinar si es inminente una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
        <returns>El estado de la notificación registrada de recolección de elementos no utilizados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.GCNotificationStatus> enumeración devuelta por este método para determinar el estado de la notificación de recolección actual que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. También puede usar el <xref:System.GC.WaitForFullGCComplete%2A> método para determinar si se ha completado la colección de elementos no utilizados completa.  
  
 Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede hacer tareas como impide que los objetos adicionales que se asigna y provocar una colección con el <xref:System.GC.Collect%2A> método. Tenga en cuenta que la notificación no garantiza que una colección de elementos no utilizados completa se produzca, sólo que condiciones han alcanzado el umbral de favorable para una colección de elementos no utilizados completa que se produzca.  
  
 Este método espera indefinidamente para que obtener una notificación de recolección. Si desea especificar un período de tiempo de espera para el método devolver si no se puede obtener la notificación, utilice el <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método. Si se llama a este método sin especificar un tiempo de espera, puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método si se esperan más de preferido.  
  
 Debe seguir este método con una llamada a la <xref:System.GC.WaitForFullGCComplete%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa. Si solo llama a este método, pueden producirse resultados indeterminados.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar este método para determinar si se está agotando un completo, la recolección de elementos no utilizados de bloqueo. Cada vez que el estado de la notificación es <xref:System.GCNotificationStatus.Succeeded>, el método de usuario `OnFullGCApproachNotify` se llama para realizar acciones en respuesta a la colección de proximidad. Este ejemplo de código forma parte de un ejemplo más extenso de [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notificaciones de recolección de elementos no utilizados</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Cantidad de tiempo que hay que esperar para obtener un estado de notificación. Especifique -1 para esperar indefinidamente.</param>
        <summary>Devuelve el estado de una notificación registrada, en un tiempo de espera especificado, para determinar si una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime es inminente.</summary>
        <returns>El estado de la notificación registrada de recolección de elementos no utilizados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.GCNotificationStatus> enumeración devuelta por este método para determinar el estado de la notificación de recolección actual que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. También puede usar el <xref:System.GC.WaitForFullGCComplete%2A> método para determinar si se ha completado la colección de elementos no utilizados completa.  
  
 Tenga en cuenta que este método devuelve un valor inmediatamente cada vez que se obtiene un estado de notificación de la colección de elementos no utilizados, independientemente del valor especificado por `millisecondsTimeout`. Si no se consigue un estado de notificación de la colección de elementos no utilizados antes de `millisecondsTimeout` veces, este método devuelve <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede hacer tareas como impide que los objetos adicionales que se asigna y provocar una colección con el <xref:System.GC.Collect%2A> método. Tenga en cuenta que la notificación no garantiza que una colección de elementos no utilizados completa se produzca, sólo que condiciones han alcanzado el umbral de favorable para una colección de elementos no utilizados completa que se produzca.  
  
 Puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método cuando no puede esperar a que transcurra el tiempo de espera.  
  
 Debe seguir este método con una llamada a la <xref:System.GC.WaitForFullGCComplete%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa. Si solo llama a este método, pueden producirse resultados indeterminados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> debe ser no negativo, o bien menor o igual que <see cref="F:System.Int32.MaxValue" /> o -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notificaciones de recolección de elementos no utilizados</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el estado de una notificación registrada para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el estado de una notificación registrada para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
        <returns>El estado de la notificación registrada de recolección de elementos no utilizados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.GCNotificationStatus> enumeración devuelta por este método para determinar el estado de la notificación de recolección actual que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. También puede usar el <xref:System.GC.WaitForFullGCApproach%2A> método para determinar si es inminente una recolección completa.  
  
 Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede hacer tareas como reanudar el trabajo y obtener un recuento de la colección con el <xref:System.GC.CollectionCount%2A> propiedad.  
  
 Este método espera indefinidamente para que obtener una notificación de recolección. Si desea especificar un período de tiempo de espera para el método devolver si no se puede obtener la notificación, utilice el <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método. Si se llama a este método sin especificar un tiempo de espera, puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método si se esperan más de preferido.  
  
 Esta llamada al método debe ir precedida por una llamada a la <xref:System.GC.WaitForFullGCApproach%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa. Llamar a este método solo puede producir resultados indeterminados.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar este método para determinar si se ha completado una recolección completa. Cada vez que el estado de la notificación es <xref:System.GCNotificationStatus.Succeeded>, el método de usuario `OnFullGCCompletedNotify` se llama para realizar acciones en respuesta a la colección completa. Este ejemplo de código forma parte de un ejemplo más extenso de [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notificaciones de recolección de elementos no utilizados</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Cantidad de tiempo que hay que esperar para obtener un estado de notificación. Especifique -1 para esperar indefinidamente.</param>
        <summary>Devuelve el estado de una notificación registrada, en un tiempo de espera especificado, para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
        <returns>El estado de la notificación registrada de recolección de elementos no utilizados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.GCNotificationStatus> enumeración devuelta por este método para determinar el estado de la notificación de recolección actual que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. También puede usar el <xref:System.GC.WaitForFullGCApproach%2A> método para determinar si es inminente una recolección completa.  
  
 Tenga en cuenta que este método devuelve un valor inmediatamente cada vez que se obtiene un estado de notificación de la colección de elementos no utilizados, independientemente del valor especificado por `millisecondsTimeout`. Si no se consigue un estado de notificación de la colección de elementos no utilizados antes de `millisecondsTimeout` veces, este método devuelve <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede hacer tareas como reanudar el trabajo y obtener un recuento de la colección con el <xref:System.GC.CollectionCount%2A> propiedad.  
  
 Puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método cuando no puede esperar a que transcurra el tiempo de espera.  
  
 Esta llamada al método debe ir precedida por una llamada a la <xref:System.GC.WaitForFullGCApproach%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa. Llamar a este método solo puede producir resultados indeterminados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="millisecondsTimeout" /> debe ser no negativo, o bien menor o igual que <see cref="F:System.Int32.MaxValue" /> o -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Notificaciones de recolección de elementos no utilizados</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspende el subproceso actual hasta que el subproceso que está procesando la cola de finalizadores vacíe dicha cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el recolector de elementos no utilizados detecta los objetos que se pueden reclamar, comprueba cada objeto para determinar los requisitos de finalización del objeto. Si un objeto implementa un finalizador y no se ha deshabilitado la finalización mediante una llamada a <xref:System.GC.SuppressFinalize%2A>, el objeto se coloca en una lista de objetos que se marcan como listos para la finalización. El recolector de elementos no utilizados llame al <xref:System.Object.Finalize%2A> métodos para los objetos de esta lista y quita las entradas de la lista. Este método se bloquea hasta que todos los finalizadores se ha ejecutado hasta su finalización.  
  
 El subproceso en el que se ejecutan los finalizadores no se especifica, por lo que no hay ninguna garantía de que este método se cerrará. Sin embargo, este subproceso puede ser interrumpido por otro subproceso mientras el <xref:System.GC.WaitForPendingFinalizers%2A> método está en curso. Por ejemplo, puede iniciar otro subproceso que espera durante un período de tiempo y, a continuación, interrumpe este subproceso si sigue suspendido este subproceso.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.WaitForPendingFinalizers%2A> método para suspender el subproceso actual hasta que se complete la finalización de todos los objetos recopilados.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>