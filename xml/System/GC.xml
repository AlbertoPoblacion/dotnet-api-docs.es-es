<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="11996d97bef6121bce982a8368bef5e8197c8a44" />
    <Meta Name="ms.sourcegitcommit" Value="1465f1a9bce3970cd9e95769eaa641b92a0a22d5" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/18/2018" />
    <Meta Name="ms.locfileid" Value="31469404" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Controla el recolector de elementos no utilizados del sistema, un servicio que recupera de forma automática la memoria que no se utiliza.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El recolector de elementos no utilizados es un componente de common language runtime que controla la asignación y liberación de memoria administrada. Influir en los métodos de esta clase cuando se realiza la recolección de elementos no utilizados en un objeto y, cuando se liberan los recursos asignados por un objeto. Propiedades de esta clase proporcionan información acerca de la cantidad total de memoria disponible en el sistema y la categoría de edad o la generación de memoria asignada a un objeto.  
  
 El recolector de elementos no utilizados realiza un seguimiento y recupera los objetos asignados en la memoria administrada. El recolector de elementos no utilizados realiza periódicamente, colección de elementos no utilizados para reclamar la memoria asignada a objetos para los que no hay ninguna referencia válida. Colección de elementos no utilizados se produce automáticamente cuando no se puede satisfacer una solicitud de memoria utilizando la memoria libre disponible. O bien, una aplicación puede forzar la colección de elementos no utilizados mediante la <xref:System.GC.Collect%2A> método.  
  
 Colección de elementos no utilizados consta de los siguientes pasos:  
  
1.  El recolector de elementos no utilizados busca objetos administrados a los que se hace referencia en código administrado.  
  
2.  El recolector de elementos no utilizados intenta finalizar los objetos que no se hace referencia.  
  
3.  El recolector de elementos no utilizados libera los objetos que no se hace referencia y recupera su memoria.  
  
 En este tema, se incluyen las siguientes secciones:  
  
 [El recolector de elementos no utilizados y los recursos no administrados](#unmanaged)   
 [Generaciones y edad de los objetos](#generations)   
 [Impedir la recolección de elementos](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>El recolector de elementos no utilizados y los recursos no administrados  
 Durante una recolección, el recolector de elementos no utilizados no liberar un objeto si encuentra una o varias referencias al objeto en el código administrado. Sin embargo, el recolector de elementos no utilizados no reconoce las referencias a un objeto de código no administrado y puede liberar objetos que se utilizan exclusivamente en código no administrado, a menos que se impide explícitamente hacerlo. El <xref:System.GC.KeepAlive%2A> método proporciona un mecanismo que impide que el recolector de elementos no utilizados recoja objetos que aún estén en uso en código no administrado.  
  
 Además de las asignaciones de memoria administrada, las implementaciones del recolector de elementos no utilizados no mantienen información acerca de los recursos mantenidos por un objeto, como los identificadores de archivo o las conexiones de base de datos. Cuando un tipo utiliza recursos no administrados que deben liberarse antes de que se reclaman instancias del tipo, el tipo puede implementar un finalizador.  
  
 En la mayoría de los casos, los finalizadores se implementan reemplazando el <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método; sin embargo, los tipos escritos en C# o C++ implementan destructores, que los compiladores convierten en un reemplazo del <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. En la mayoría de los casos, si un objeto tiene un finalizador, el recolector de elementos no utilizados lo llama antes de liberar el objeto. Sin embargo, el recolector de elementos no utilizados no es necesario llamar a los finalizadores en todas las situaciones; Por ejemplo, el <xref:System.GC.SuppressFinalize%2A> método explícitamente impide que un finalizador del objeto que se va a llamar. Además, el recolector de elementos no utilizados no tiene que utilizar un subproceso concreto para finalizar los objetos o garantiza el orden en el que se llama a los finalizadores para los objetos que hacen referencia entre sí, pero están disponibles para la recolección.  
  
 En escenarios donde se deben liberar los recursos en un momento determinado, las clases pueden implementar la <xref:System.IDisposable> interfaz, que contiene el <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método que realiza tareas de administración y limpieza de recursos. Las clases que implementan <xref:System.IDisposable.Dispose%2A> especifique, como parte de su contrato de clase, si y cuando los consumidores de la clase llama al método para limpiar el objeto. El recolector de elementos no utilizados no es así, de forma predeterminada, llame a la <xref:System.IDisposable.Dispose%2A> método; sin embargo, las implementaciones de la <xref:System.IDisposable.Dispose%2A> método puede llamar a métodos la <xref:System.GC> clase para personalizar el comportamiento de finalización del recolector de elementos no utilizados.  
  
 Para obtener más información sobre la finalización del objeto y el patrón de dispose, vea [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Generaciones y edad de los objetos  
 El recolector de elementos no utilizados de common language runtime admite la edad de los objetos mediante las generaciones. Una generación es una unidad de medida de la antigüedad relativa de los objetos en la memoria. El número de generación o la edad de un objeto indica la generación a la que pertenece un objeto. Objetos creados más recientemente forman parte de las generaciones más recientes y tienen los números más bajos de generación de ciclo de objetos creados anteriormente en la vida de las aplicaciones. Objetos de la generación más reciente están en la generación 0. Esta implementación del recolector de elementos no utilizados admite tres generaciones de objetos, las generaciones 0, 1 y 2. Puede recuperar el valor de la <xref:System.GC.MaxGeneration%2A> propiedad para determinar el número de generación máximo admitido por el sistema.  
  
 Caducidad de objetos permite a las aplicaciones dirijan la recolección en un conjunto específico de generaciones en lugar de requerir el recolector de elementos no utilizados evaluar todas las generaciones. Sobrecargas de la <xref:System.GC.Collect%2A> método que incluyen un `generation` parámetro le permiten especificar la generación más antigua se recolecte.  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Impedir la recolección de elementos  
 A partir de la [!INCLUDE[net_v46](~/includes/net-v46-md.md)], el recolector de elementos no utilizados no admite un GC región modo de latencia que se puede usar durante la ejecución de las rutas de acceso críticas en los elementos no utilizados colección puede afectar negativamente el rendimiento de una aplicación. El modo de latencia ninguna región de GC requiere que especifique una cantidad de memoria que puede asignar sin interferencias del recolector de elementos no utilizados. Si el tiempo de ejecución puede asignar esa memoria, el runtime no realizará una colección de elementos no utilizados mientras se está ejecutando código en la ruta crítica.  
  
 Definir el principio de la ruta crítica de la región de GC no mediante una llamada a una de las sobrecargas de los <xref:System.GC.TryStartNoGCRegion%2A>. Especifique el final de su ruta de acceso crítica mediante una llamada a la <xref:System.GC.EndNoGCRegion%2A> método.  
  
 No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> método y se debería llamar a la <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debe llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa varios métodos de GC para obtener información de memoria sobre un bloque de objetos no utilizados y la generación e imprimirlo en la consola. Los objetos no utilizados, a continuación, se recopilan y se muestran los totales de memoria resultantes.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Cantidad incremental de memoria no administrada que se ha asignado.</param>
        <summary>Informa al tiempo de ejecución de una asignación grande de memoria no administrada que se debe tener en cuenta al programar la recolección de elementos no utilizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar cuándo se debe programar la recopilación de elementos no utilizados, el tiempo de ejecución tiene en cuenta la cantidad de memoria administrada se asigna. Si un objeto administrado pequeño asigna una gran cantidad de memoria no administrada, el tiempo de ejecución tiene en cuenta sólo la memoria administrada y, por tanto, subestima la urgencia de programar la recolección. El <xref:System.GC.AddMemoryPressure%2A> método informa el tiempo de ejecución de esta necesidad adicional de memoria del sistema.  
  
 En el patrón de uso más simple, un objeto administrado asigna la memoria no administrada en el constructor y lo libera de la `Dispose` o `Finalize` método. Llame a la <xref:System.GC.AddMemoryPressure%2A> método después de asignar la memoria no administrada y llamar a la <xref:System.GC.RemoveMemoryPressure%2A> método después de liberarla.  
  
 En escenarios más complicados, donde la asignación de memoria no administrada cambia substancialmente durante la duración del objeto administrado, puede llamar a la <xref:System.GC.AddMemoryPressure%2A> y <xref:System.GC.RemoveMemoryPressure%2A> métodos para comunicar estos cambios incrementales en el tiempo de ejecución.  
  
> [!CAUTION]
>  Debe asegurarse de que quita exactamente la cantidad de memoria que agrega. Si no lo puede afectar negativamente el rendimiento del sistema en las aplicaciones que se ejecutan durante largos períodos de tiempo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> es menor o igual que 0.  
  
 O bien  
  
 En un equipo de 32 bits, <paramref name="bytesAllocated" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al manipular la prioridad de la colección de elementos no utilizados. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela el registro de una notificación de recolección de elementos no utilizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método cancela una notificación de la colección de elementos no utilizados que se registró mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. No es necesario llamar a este método antes de ajustar los valores de parámetro de umbral en llamadas posteriores a la <xref:System.GC.RegisterForFullGCNotification%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se cancela un registro de la colección de elementos no utilizados. Este ejemplo forma parte de un ejemplo mayor proporcionado para el [notificaciones de la colección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Este miembro no está disponible cuando la recolección de elementos no utilizados simultánea está habilitada. Vea la configuración en tiempo de ejecución [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) para obtener información sobre cómo deshabilitar la recolección de elementos no utilizados simultánea.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fuerza a que se lleve a cabo la recolección de elementos no utilizados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fuerza a que se lleve a cabo una recolección de elementos no utilizados de todas las generaciones.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para intentar reclamar toda la memoria que no es accesible. Realiza una recolección de elementos no utilizados de bloqueo de todas las generaciones.  
  
 Todos los objetos, independientemente de cuánto tiempo llevan en memoria, se consideran para la colección; Sin embargo, no se recopilan los objetos que se hace referencia en código administrado. Utilice este método para forzar el sistema para intentar obtener la máxima cantidad de memoria disponible.  
  
 A partir de la [!INCLUDE[net_v451](~/includes/net-v451-md.md)], también puede compactar el montón de objetos grandes (LOH) estableciendo el <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad a <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> antes de llamar a la <xref:System.GC.Collect%2A> método, como en el ejemplo siguiente se muestra.  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.GC.Collect%2A> método para realizar una recolección en todas las generaciones de memoria. El código genera un número de objetos no utilizados y, a continuación, llama a la <xref:System.GC.Collect%2A> método para limpiarlos de la memoria.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">El número de la generación más antigua de elementos no usados para recolectar.</param>
        <summary>Fuerza a que se lleve a cabo inmediatamente la recolección de elementos no utilizados desde la generación 0 hasta la generación especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para intentar reclamar la memoria que no es accesible. Sin embargo, con este método no garantiza que se reclame toda la memoria puede tener acceso en la generación especificada.  
  
 Si se implementa la edad de los objetos, el recolector de elementos no utilizados no recoge objetos con un número de generación que es mayor que la generación especificada. Si no se implementa la edad de los objetos, el recolector de elementos no utilizados considera que todos los objetos durante la recolección.  
  
 Use la <xref:System.GC.MaxGeneration%2A> propiedad para determinar el máximo valor válido de la `generation` parámetro.  
  
 Para que el recolector de elementos no utilizados tenga en cuenta todos los objetos independientemente de su generación, utilice la versión de este método que no toma ningún parámetro. Para que el recolector de elementos no utilizados recupera los objetos en función de un <xref:System.GCCollectionMode> configuración, use la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> sobrecarga del método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.GC.Collect%2A> método para realizar una recolección en capas individuales de memoria. El código genera un número de objetos no utilizados y, a continuación, llama a la <xref:System.GC.Collect%2A> método para limpiarlos de la memoria.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">El número de la generación más antigua de elementos no usados para recolectar.</param>
        <param name="mode">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o si será optimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Fuerza una recolección de elementos no utilizados desde la generación 0 hasta la generación especificada, en el momento especificado por el valor <see cref="T:System.GCCollectionMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `mode` para especificar si la colección de elementos no utilizados debería producirse inmediatamente o solo si la hora es adecuada para reclamar objetos. Con este método no garantiza que se reclame toda la memoria puede tener acceso en la generación especificada.  
  
 Para ajustar la tendencia a la intrusión de la recolección durante los períodos críticos en la aplicación, establezca el <xref:System.Runtime.GCSettings.LatencyMode%2A> propiedad.  
  
 El recolector de elementos no utilizados no recoge objetos con un número de generación superior al especificado en el `generation` parámetro. Use la <xref:System.GC.MaxGeneration%2A> propiedad para determinar el máximo valor válido de `generation`.  
  
 Para que el recolector de elementos no utilizados tenga en cuenta todos los objetos independientemente de su generación, utilice la versión de este método que no toma ningún parámetro.  
  
 Para que el recolector de elementos no utilizados recupera los objetos hasta una generación especificada de objetos, siga el <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método. Al especificar la generación máxima, se recopilan todos los objetos.  
  
   
  
## Examples  
 En el ejemplo siguiente se fuerza una recolección de elementos no utilizados para los objetos de generación 2 con el <xref:System.GCCollectionMode.Optimized> configuración.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> no es válido.  
  
 O bien  
  
 <paramref name="mode" /> no es uno de los valores de <see cref="T:System.GCCollectionMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">El número de la generación más antigua de elementos no usados para recolectar.</param>
        <param name="mode">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o si será optimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> para realizar una recolección de elementos no utilizados de bloqueo; <see langword="false" /> para realizar una recolección de elementos no utilizados en segundo plano cuando sea posible.</param>
        <summary>Fuerza una recolección de elementos no utilizados de generación 0 en una generación especificada, en un momento especificado por un valor de <see cref="T:System.GCCollectionMode" />, con un valor que especifica si la recolección debe ser de bloqueo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se resume la interacción de la `mode` y `blocking` parámetros:  
  
|`mode`|`blocking` es `true`|`blocking` es `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> o <xref:System.GCCollectionMode.Default>|Se realiza una recolección de bloqueo lo antes posible. Si una recolección en segundo plano está en curso y `generation` es 0 o 1, el <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> método desencadena una recolección de bloqueo inmediatamente y vuelve cuando finaliza la colección. Si una recolección en segundo plano está en curso y `generation` es 2, el método espera hasta que la recolección en segundo plano finalice, desencadena una recolección de generación 2 de bloqueo y, a continuación, se devuelve.|Se realiza una recolección lo antes posible. El método <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> solicita una colección en segundo plano, pero esto no se garantiza; puede que aún se realice una colección de bloqueo, dependiendo de las circunstancias. Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.|  
|<xref:System.GCCollectionMode.Optimized>|Se puede realizar una recolección de bloqueo, dependiendo del estado del recolector de elementos no utilizados y del parámetro `generation`. El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo.|Se puede realizar una recolección, según el estado del recolector de elementos no utilizados. El método <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> solicita una colección en segundo plano, pero esto no se garantiza; puede que aún se realice una colección de bloqueo, dependiendo de las circunstancias. El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo. Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.|  
  
 Si una llamada a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> método realiza una recolección de elementos no utilizados de bloqueo completa, también puede compactar el montón de objetos grandes si establece la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> antes de llamar a la <xref:System.GC.Collect%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> no es válido.  
  
 O bien  
  
 <paramref name="mode" /> no es uno de los valores de <see cref="T:System.GCCollectionMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">El número de la generación más antigua de elementos no usados para recolectar.</param>
        <param name="mode">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o si será optimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> para realizar una recolección de elementos no utilizados de bloqueo; <see langword="false" /> para realizar una recolección de elementos no utilizados en segundo plano cuando sea posible.</param>
        <param name="compacting">
          <see langword="true" /> para compactar el montón de objetos pequeños; <see langword="false" /> solo para limpiar.</param>
        <summary>Fuerza una recolección de elementos no utilizados de generación 0 en una generación especificada, en un momento especificado por un valor de <see cref="T:System.GCCollectionMode" />, con valores que especifican si la recolección debe ser de bloqueo y compactante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `blocking` es `false`, el catálogo global decide si se debe realizar una recolección de elementos no utilizados de bloqueo o de un fondo. Si `compacting` es `true`, que realiza una recolección de elementos no utilizados de bloqueo.  
  
 Si `compacting` es `true`, el tiempo de ejecución compacta el montón de objetos pequeños (SOH). No se compacta el montón de objetos grandes (LOH) a menos que la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad está establecida en <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>. Tenga en cuenta que esto incluye todos los elementos no utilizados colecciones de bloqueo, no solo completas colecciones de elementos no utilizados de bloqueo.  
  
 Puede llamar a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método para reducir el montón administrado a las posibles de tamaño más pequeña, como se muestra en el siguiente fragmento de código.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Especificar `true` para el `compacting` argumento garantiza una recolección de elementos no utilizados de bloqueo compactación, completa. Establecer el <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> garantiza que se compactan el montón de objeto grande y el SOH.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">La generación de objetos para la que se va a determinar el número de recolecciones de elementos no utilizados.</param>
        <summary>Devuelve el número de veces que se ha producido la recolección de elementos no utilizados para la generación de objetos especificada.</summary>
        <returns>El número de veces que se ha realizado la recolección de elementos no utilizados para la generación especificada desde que se inició el proceso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si implementa su propia administración de recursos, deberá forzar la recolección periódicamente mediante una llamada a la <xref:System.GC.Collect%2A> método. Dado que se trata de una operación costosa, puede mejorar el rendimiento evitando la llamada cuando se ha producido recientemente a una colección de elementos no utilizados. Guarde el valor devuelto por <xref:System.GC.CollectionCount%2A> inmediatamente después de llamar a <xref:System.GC.Collect%2A>. La próxima vez que se debe llamar a <xref:System.GC.Collect%2A>, compare el valor actual devuelto por <xref:System.GC.CollectionCount%2A> en el valor guardado. Si los dos valores son iguales, no se ha producido ninguna colección en la versión preliminar y es razonable llamar a <xref:System.GC.Collect%2A> nuevo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> es menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Finaliza el modo de no latencia en la región GC.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.EndNoGCRegion%2A> método produce una <xref:System.InvalidOperationException> si el recolector de elementos no utilizados no está en modo de no latencia de la región de GC. Esto se produce en cualquiera de las condiciones siguientes:  
  
-   El <xref:System.GC.TryStartNoGCRegion%2A> método no se llamó anteriormente.  
  
-   La llamada a la <xref:System.GC.TryStartNoGCRegion%2A> el método devolvió `false`.  
  
-   La llamada a la <xref:System.GC.TryStartNoGCRegion%2A> método produjo una excepción.  
  
 Puede evitar una excepción por alguno de estos motivos mediante código como el siguiente:  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El recolector de elementos no utilizados no está en modo de no latencia en la región GC.  
  
 O bien  
  
 El modo de no latencia en la región GC se terminó prematuramente porque se indujo una recolección de elementos no utilizados.  
  
 O bien  
  
 Una asignación de memoria superó la cantidad especificada en la llamada al método <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el número de generación actual de un objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">El objeto cuya información sobre generación se recupera.</param>
        <summary>Devuelve el número de generación actual del objeto especificado.</summary>
        <returns>El número de generación actual de <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para determinar la edad de un objeto y, a continuación, utilizar esa información con el <xref:System.GC.Collect%2A> método para forzar que el recolector de elementos no utilizados para recopilar los objetos de la misma generación. Por ejemplo, use este método cuando tiene un conjunto de objetos que se crean como un grupo y que dejan de estar accesibles al mismo tiempo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.GC.GetGeneration%2A> método para determinar la antigüedad de un objeto. En el ejemplo, a continuación, realiza recolecciones de elementos no utilizados para limpiar la memoria y comparar el anterior y registrar los totales de memoria de colección en la consola.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">Un <see cref="T:System.WeakReference" /> que hace referencia al objeto de destino cuyo número de generación debe determinarse.</param>
        <summary>Devuelve el número de generación actual del destino de una referencia débil especificada.</summary>
        <returns>El número de generación actual del destino de <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.GC.GetGeneration%2A> método para determinar la antigüedad de un objeto de referencia débil.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ya se ha realizado la recolección de elementos no utilizados en <paramref name="wo" />.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <see langword="true" /> para indicar que este método puede esperar a que se produzca la recolección de elementos no utilizados antes de regresar; en caso contrario, <see langword="false" />.</param>
        <summary>Recupera el número de bytes que se considera que están asignados en la actualidad. Un parámetro indica si este método puede esperar un breve intervalo de tiempo antes de regresar, para permitir que el sistema recoja los elementos no utilizados y finalice los objetos.</summary>
        <returns>Número que representa la aproximación más exacta disponible del número de bytes actualmente asignados en la memoria administrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `forceFullCollection` parámetro es `true`, este método espera un breve intervalo antes de devolver mientras el sistema recopila elementos no utilizados y finaliza los objetos. La duración del intervalo es un límite especificado internamente determinado por el número de ciclos de la colección de elementos no utilizados completa y el cambio en la cantidad de memoria recuperada entre los ciclos. El recolector de elementos no utilizados no garantiza que se recopila toda la memoria inaccesible.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.GC.GetTotalMemory%2A> método para obtener y mostrar el número de bytes actualmente asignados en la memoria administrada.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">El objeto al que se va a hacer referencia.</param>
        <summary>Hace referencia al objeto especificado, convirtiéndolo en un objeto no válido para la recolección de elementos no utilizados desde el principio de la rutina actual hasta el momento en que se llamó a este método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El propósito de la <xref:System.GC.KeepAlive%2A> método consiste en asegurarse de la existencia de una referencia a un objeto que tenga probabilidades de ser reclamado prematuramente por el recolector de elementos no utilizados. Un escenario común donde esto puede ocurrir es cuando no hay ninguna referencia al objeto en código administrado o datos, pero el objeto aún está en uso en código no administrado, como las API de Win32, archivos DLL no administrados, o métodos que utilizan COM.  
  
 Este método hace referencia el `obj` parámetro, convirtiéndolo ese objeto elegible para la recolección de elementos desde el principio de la rutina hasta el punto, en orden de ejecución, que se llama a este método. Este método al final, y no al principio del intervalo de instrucciones de código donde `obj` deben estar disponibles.  
  
 El <xref:System.GC.KeepAlive%2A> método no realiza ninguna operación ni no produce ningún efecto secundario aparte de ampliar la duración del objeto pasado como un parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un objeto al principio de su `Main` método y no hace referencia al objeto nuevo hasta el final, cuando el <xref:System.GC.KeepAlive%2A> se llama al método. El objeto persiste durante 30 segundos de la `Main` método, a pesar de las llamadas a la <xref:System.GC.Collect%2A> y <xref:System.GC.WaitForPendingFinalizers%2A> métodos.  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número máximo de generaciones que el sistema admite en la actualidad.</summary>
        <value>Un valor comprendido entre cero y el número máximo de generaciones admitidas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de generación o la edad de un objeto es una medida relativa de tiempo de vida de un objeto definido por la implementación. Son los objetos creados más recientemente en la generación 0 y los objetos más antiguos pertenecen a una generación menor o igual a la generación devuelta por la <xref:System.GC.MaxGeneration%2A> propiedad.  
  
 El recolector de elementos no utilizados se da por supuesto que es más probable que sea apto para la recolección de elementos no utilizados de memoria anterior memoria más reciente. Por lo tanto, el recolector de elementos no utilizados mejora su rendimiento ajustando los números de generación cada vez que recupera de la memoria, y el <xref:System.GC.MaxGeneration%2A> puede alcanzar el valor de la propiedad con el tiempo.  
  
 Si se implementa la edad de los objetos, la <xref:System.GC.MaxGeneration%2A> propiedad devuelve el número de generación máximo utilizado por el sistema; en caso contrario, esta propiedad devuelve cero.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar la propiedad MaxGeneration para mostrar el mayor número de generación que está actualmente en uso.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Para esta implementación, el valor devuelto por el <see cref="P:System.GC.MaxGeneration" /> se garantiza que la propiedad permanece constante para la duración de una aplicación en ejecución.  
  
 Use la <see cref="P:System.GC.MaxGeneration" /> propiedad para determinar el valor máximo que puede especificar cuando se llama a la <see cref="M:System.GC.Collect(System.Int32)" /> método que toma un parámetro de generación.</para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Número comprendido entre 1 y 99 que especifica cuándo debe emitirse la notificación basándose en los objetos asignados en la generación 2.</param>
        <param name="largeObjectHeapThreshold">Un número comprendido entre 1 y 99 que especifica cuándo debe emitirse la notificación basándose en los objetos asignados en el montón de objetos grandes.</param>
        <summary>Especifica que debe emitirse una notificación de recolección de elementos no utilizados cuando las condiciones favorecen la recolección completa de elementos no utilizados y cuando se ha completado la recolección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por cada generación, el recolector de elementos no utilizados establece un umbral para las asignaciones en esa generación. Cuando el tamaño de las asignaciones de supera este umbral, se desencadena una recolección en esa generación. De ejemplo, si el umbral de generación 2 es 20MB (lo que significa que 20MB sobrevive a las recolecciones de generación 1 y se promueven a la generación 2) y más de 20MB ha sobrevivido a la generación 1 y se solicita a la generación 2, la siguiente recolección se tratará como una recolección de generación 2. De forma similar, si el montón de objetos grandes (LOH) Value de umbral es de 20MB y la aplicación ha asignado más de 20MB de objetos grandes, la siguiente recolección también se tratará como una recolección de generación 2 (ya que solo se recopila el montón de objeto grande en colecciones de elementos no utilizados de gen2).  
  
 El `maxGenerationThreshold` y `largeObjectHeapThreshold` umbrales de controlan la cantidad de antemano se le notifique antes de que se produce una recolección completa. Cuanto mayor sea el umbral, las asignaciones más que se pueden producir entre la notificación y la recolección de elementos no utilizados completa siguiente.  
  
 Si tiene situaciones en que una colección de elementos no utilizados completa por common language runtime negativamente afectaría al rendimiento de la aplicación, puede pedir que se le notifique cuando el tiempo de ejecución está a punto de realizar una recolección completa y eludir esa recolección mediante la inducción de una colección usted mismo (mediante el <xref:System.GC.Collect%2A> método) cuando las condiciones todavía sean favorables. Además de cambiar la programación de la colección de elementos no utilizados, notificación de GC completo es útil en los escenarios siguientes:  
  
-   Supervisar para el enfoque de una colección de elementos no utilizados completa y, cuando se le notifique que se acerca uno, reducir el tamaño de los datos en directo (por ejemplo, al liberar algunas entradas de caché). Como resultado, cuando la recolección de elementos no utilizados se produce, es capaz de recuperar más memoria.  
  
-   Supervisar la finalización de una colección de elementos no utilizados completa para que pueda recopilar estadísticas.  Por ejemplo, puede medir el tamaño del montón al término de catálogo global para que sepa el tamaño de los datos en directo. (Después de un GC completo, el montón tiene en su tamaño más pequeño).  
  
 Para obtener más información sobre lo que representa una colección de elementos no utilizados completa, consulte [notificaciones de la colección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md).  
  
 Al registrarse para una notificación de recolección, puede recibir una notificación cuando una recolección de elementos no utilizados completa está próxima y cuando se completan. Este patrón es similar a cómo se supervisa el sistema operativo para notificaciones de memoria insuficiente.  
  
 Utilice las instrucciones siguientes para especificar el `maxGenerationThreshold` y `largeObjectHeapThreshold` parámetros:  
  
-   Cuanto mayor sea el valor de umbral, se producen más asignaciones entre la notificación y la colección de elementos no utilizados completa.  
  
     Un valor de umbral mayor proporciona más oportunidades para el tiempo de ejecución comprobar si una recolección próxima. Esto aumenta la probabilidad de que se le notificará. Sin embargo, no debería establecer el umbral demasiado alto, ya tiene como resultado en una asignaciones más antes de que el tiempo de ejecución induce la recolección siguiente.  
  
     Cuando induce la recolección usted mismo tras la notificación mediante un valor de umbral alta, menos objetos se reclaman que podría ser reclamado por la recolección siguiente del runtime.  
  
-   Cuanto menor sea el valor de umbral, menos las asignaciones entre la notificación y la colección de elementos no utilizados completa.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo registrar una notificación de recolección e iniciar un subproceso para supervisar el estado de la notificación de la colección de elementos no utilizados. Este ejemplo de código forma parte de un ejemplo más extenso de [notificaciones de la colección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxGenerationThreshold" /> o <paramref name="largeObjectHeapThreshold" /> no está entre 1 y 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Cantidad de memoria no administrada que se ha liberado.</param>
        <summary>Informa al tiempo de ejecución de que se ha liberado la memoria no administrada y ya no se necesita tener en cuenta al programar la recolección de elementos no utilizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar cuándo se debe programar la recopilación de elementos no utilizados, el tiempo de ejecución tiene en cuenta la cantidad de memoria administrada se asigna. Si un objeto administrado pequeño asigna una gran cantidad de memoria no administrada, el tiempo de ejecución tiene en cuenta sólo la memoria administrada y, por tanto, subestima la urgencia de programar la recolección. El <xref:System.GC.AddMemoryPressure%2A> método informa el tiempo de ejecución de esta necesidad adicional de memoria del sistema y el <xref:System.GC.RemoveMemoryPressure%2A> método informa que el tiempo de ejecución que se ha liberado la presión adicional.  
  
 En el patrón de uso más simple, un objeto administrado asigna la memoria no administrada en el constructor y lo libera de la `Dispose` o `Finalize` método. Llame a la <xref:System.GC.AddMemoryPressure%2A> método después de asignar la memoria no administrada y llamar a la <xref:System.GC.RemoveMemoryPressure%2A> método después de liberarla.  
  
 En escenarios más complicados, donde la asignación de memoria no administrada cambia substancialmente durante la duración del objeto administrado, puede llamar a la <xref:System.GC.AddMemoryPressure%2A> y <xref:System.GC.RemoveMemoryPressure%2A> métodos para comunicar estos cambios incrementales en el tiempo de ejecución.  
  
> [!CAUTION]
>  Debe asegurarse de que quita exactamente la cantidad de memoria que agrega. Si no lo puede afectar negativamente el rendimiento del sistema en las aplicaciones que se ejecutan durante largos períodos de tiempo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> es menor o igual que 0.  
  
 O bien  
  
 En un equipo de 32 bits, <paramref name="bytesAllocated" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al manipular la prioridad de la colección de elementos no utilizados. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">El objeto cuyo finalizador debe llamarse.</param>
        <summary>Solicita que el sistema llame al finalizador del objeto especificado, para el que previamente se ha llamado a <see cref="M:System.GC.SuppressFinalize(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.ReRegisterForFinalize%2A> método agrega la `obj` parámetro a la lista de objetos que solicitan una finalización antes de que el recolector de elementos no utilizados libera el objeto. El `obj` parámetro debe ser el llamador de este método.  
  
 Llamar a la <xref:System.GC.ReRegisterForFinalize%2A> método no garantiza que el recolector de elementos no utilizados llame al finalizador de un objeto.  
  
 De forma predeterminada, todos los objetos que implementan los finalizadores se agregan a la lista de objetos que requieren finalización; Sin embargo, un objeto podría ya ha finalizado o que haya deshabilitado la finalización mediante una llamada a la <xref:System.GC.SuppressFinalize%2A> método.  
  
 Un finalizador puede utilizar este método para restablecerse consigo mismo ni con un objeto que hace referencia.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el método ReRegisterForFinalize para finalizar un objeto una segunda vez después de la recolección de elementos.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">El objeto cuyo finalizador no debe ejecutarse.</param>
        <summary>Solicita que Common Language Runtime no llame al finalizador del objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método establece un bit en el encabezado del objeto de `obj`, lo que el tiempo de ejecución comprueba cuando se llama a los finalizadores. Un finalizador, que se representa mediante el <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método, se utiliza para liberar recursos no administrados antes de que un objeto se recopilan de elementos no utilizados. Si `obj` no tiene un finalizador, la llamada a la <xref:System.GC.SuppressFinalize%2A> método no tiene ningún efecto.  
  
 Objetos que implementan la <xref:System.IDisposable> interfaz puede llamar a este método desde el objeto <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación para evitar que el recolector de elementos no utilizados que realiza la llamada <xref:System.Object.Finalize%2A?displayProperty=nameWithType> en un objeto que no la necesita. Normalmente, esto se hace para evitar que el finalizador de liberar recursos no administrados que ya se ha liberado mediante el <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.GC.SuppressFinalize%2A> método en una clase de recurso para evitar una redundancia de recolección de elementos que se la llame. El ejemplo se utiliza la [patrón de dispose](~/docs/standard/design-guidelines/dispose-pattern.md) liberar tanto recursos administrados (es decir, los objetos que implementan <xref:System.IDisposable>) y los recursos no administrados.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta suspender la recolección de elementos durante la ejecución de una ruta crítica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> método y se debería llamar a la <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debe llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección. Debe ser menor o igual que el tamaño de un segmento efímero. Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <summary>Intenta suspender la recolección de elementos durante la ejecución de una ruta crítica si una cantidad específica de memoria está disponible.</summary>
        <returns>
          <see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> método intenta colocar el recolector de elementos no utilizados en ningún modo de latencia de región de GC, que no permite la recopilación de elementos no utilizados mientras que una aplicación ejecuta una región crítica del código.  Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento de liberar memoria adicional. El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar la cantidad necesaria de memoria, lo que en este caso es realmente 2 * `totalSize` bytes (intenta asignar `totalSize` bytes para el montón de objetos pequeños y `totalSize` bytes para el montón de objetos grandes).  
  
 `totalSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica. Esto incluye las asignaciones de la aplicación, así como las asignaciones que hace que el tiempo de ejecución en nombre de la aplicación.  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> método y se debería llamar a la <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debe llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 No salir del modo de latencia región de GC mediante una llamada a la <xref:System.GC.EndNoGCRegion%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> supera el tamaño del segmento efímero.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya está en modo de no latencia de región de GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección. Debe ser menor o igual que el tamaño de un segmento efímero. Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> para omitir una recolección de elementos no utilizados de bloqueo completa si el recolector de elementos no utilizados no puede asignar inicialmente <c>totalSize</c> bytes; en caso contrario, <see langword="false" />.</param>
        <summary>Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad especificada de memoria está disponible y controla si el recolector de elementos no usados realiza una recolección de elementos no usados de bloqueo completa si no hay suficiente memoria disponible inicialmente.</summary>
        <returns>
          <see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> método intenta colocar el recolector de elementos no utilizados en ningún modo de latencia de región de GC, que no permite la recopilación de elementos no utilizados mientras que una aplicación ejecuta una región crítica del código.  Si el tiempo de ejecución es no se puede asignar inicialmente la cantidad de memoria solicitada y la `disallowFullBlockingGC` argumento es `false`, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento de liberar memoria adicional; en caso contrario, se produce un error en la asignación y el método devuelve `false`. El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar la cantidad necesaria de memoria, lo que en este caso es realmente 2 * `totalSize` (intenta asignar `totalSize` para el montón de objetos pequeños y `totalSize` para el montón de objetos grandes).  
  
 `totalSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica. Esto incluye las asignaciones de la aplicación, así como las asignaciones que hace que el tiempo de ejecución en nombre de la aplicación.  
  
 Establecer `disallowFullBlockingGC` a `true` para evitar un elementos no utilizados bloqueo completa colección si no hay suficiente memoria disponible inicialmente resulta muy útil en escenarios de equilibrio de carga: un sistema puede llamar a este método y se presenta como listo para aceptar las solicitudes si devuelve `true`, y permitir que el equilibrador de carga se redirija las solicitudes a otros sistemas si devuelve `false`. A continuación, puede realizar una recolección de elementos no utilizados de bloqueo completa cuando no está controlando las solicitudes mediante una llamada a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método.  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> método y se debería llamar a la <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debe llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 No salir del modo de latencia región de GC mediante una llamada a la <xref:System.GC.EndNoGCRegion%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> supera el tamaño del segmento efímero.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya está en modo de no latencia de región de GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección. <c>totalSize</c> – <c>lohSize</c> debe ser menor o igual que el tamaño de un segmento efímero. Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">El número de bytes de <c>totalSize</c> que se usarán para las asignaciones de montones de objetos grandes (LOH).</param>
        <summary>Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad específica de memoria está disponible para los montones de objetos pequeños y grandes.</summary>
        <returns>
          <see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> método intenta colocar el recolector de elementos no utilizados en ningún modo de latencia de región de GC, que no permite la recopilación de elementos no utilizados mientras que una aplicación ejecuta una región crítica del código.  Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento de liberar memoria adicional. El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar `lohSize` para el montón de objeto grande y `totalSize` : `lohSize` para el montón de objetos pequeños (SOH).  
  
 `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el montón de objeto grande, y `totalSize` : `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el SOH. Esto incluye las asignaciones de la aplicación, así como las asignaciones que hace que el tiempo de ejecución en nombre de la aplicación.  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> método y se debería llamar a la <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debe llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 No salir del modo de latencia región de GC mediante una llamada a la <xref:System.GC.EndNoGCRegion%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> – <paramref name="lohSize" /> supera el tamaño del segmento efímero.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya está en modo de no latencia de región de GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección. <c>totalSize</c> – <c>lohSize</c> debe ser menor o igual que el tamaño de un segmento efímero. Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">El número de bytes de <c>totalSize</c> que se usarán para las asignaciones de montones de objetos grandes (LOH).</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> para omitir una recolección de elementos no utilizados si el recolector de elementos no utilizados no puede asignar inicialmente la memoria especificada al montón de objetos pequeños (SOH) y LOH; en caso contrario, <see langword="false" />.</param>
        <summary>Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad especificada de memoria está disponible para los montones de objetos grandes y pequeños, y controla si el recolector de elementos no usados realiza una recolección de elementos no usados de bloqueo completa si no hay suficiente memoria disponible inicialmente.</summary>
        <returns>
          <see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> método intenta colocar el recolector de elementos no utilizados en ningún modo de latencia de región de GC, que no permite la recopilación de elementos no utilizados mientras que una aplicación ejecuta una región crítica del código.  Si el tiempo de ejecución es no se puede asignar inicialmente la cantidad de memoria solicitada y la `disallowFullBlockingGC` argumento es `false`, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento de liberar memoria adicional; en caso contrario, se produce un error en la asignación y el método devuelve `false`. El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar `lohSize` para el montón de objeto grande y `totalSize` : `lohSize` para el montón de objetos pequeños (SOH).  
  
 `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el montón de objeto grande, y `totalSize` : `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el SOH. Esto incluye las asignaciones de la aplicación, así como las asignaciones que hace que el tiempo de ejecución en nombre de la aplicación.  
  
 Establecer `disallowFullBlockingGC` a `true` para evitar un elementos no utilizados bloqueo completa colección si no hay suficiente memoria disponible inicialmente resulta muy útil en escenarios de equilibrio de carga: un sistema puede llamar a este método y se presenta como listo para aceptar las solicitudes si devuelve `true`, y permitir que el equilibrador de carga se redirija las solicitudes a otros sistemas si devuelve `false`. A continuación, puede realizar una recolección de elementos no utilizados de bloqueo completa cuando no está controlando las solicitudes mediante una llamada a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método.  
  
> [!IMPORTANT]
>  No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> método y se debería llamar a la <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC. En otras palabras, no debe llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no deben esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.  
  
 No salir del modo de latencia región de GC mediante una llamada a la <xref:System.GC.EndNoGCRegion%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> – <paramref name="lohSize" /> supera el tamaño del segmento efímero.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya está en modo de no latencia de región de GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el estado de una notificación registrada para determinar si es inminente una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el estado de una notificación registrada para determinar si es inminente una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
        <returns>El estado de la notificación registrada de recolección de elementos no utilizados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.GCNotificationStatus> enumeración devuelto por este método para determinar el estado de la notificación actual de colección de elementos no utilizados que se registró mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. También puede usar el <xref:System.GC.WaitForFullGCComplete%2A> método para determinar si se ha completado la recolección de elementos no utilizados completa.  
  
 Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede realizar tareas como evitar que objetos adicionales que se va a asignar e induce una colección con el <xref:System.GC.Collect%2A> método. Tenga en cuenta que la notificación no garantiza que una colección de elementos no utilizados completa se produzca, solo que las condiciones han alcanzado el umbral que son favorables para una colección de elementos no utilizados completa que se produzca.  
  
 Este método espera indefinidamente una notificación de recolección va a obtener. Si desea especificar un período de tiempo de espera para el método devolver si no se puede obtener la notificación, utilice el <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método. Si se llama a este método sin especificar un tiempo de espera, puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método si se esperan más preferido.  
  
 Debe seguir este método con una llamada a la <xref:System.GC.WaitForFullGCComplete%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa. Si solo llama a este método, pueden producirse resultados indeterminados.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar este método para determinar si una recolección completa de bloqueo elementos no utilizados se está agotando. Cada vez que el estado de la notificación es <xref:System.GCNotificationStatus.Succeeded>, el método de usuario `OnFullGCApproachNotify` se llama para realizar acciones en respuesta a la recolección próxima. Este ejemplo de código forma parte de un ejemplo más extenso de [notificaciones de la colección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Cantidad de tiempo que hay que esperar para obtener un estado de notificación. Especifique -1 para esperar indefinidamente.</param>
        <summary>Devuelve el estado de una notificación registrada, en un tiempo de espera especificado, para determinar si una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime es inminente.</summary>
        <returns>El estado de la notificación registrada de recolección de elementos no utilizados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.GCNotificationStatus> enumeración devuelto por este método para determinar el estado de la notificación actual de colección de elementos no utilizados que se registró mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. También puede usar el <xref:System.GC.WaitForFullGCComplete%2A> método para determinar si se ha completado la recolección de elementos no utilizados completa.  
  
 Tenga en cuenta que este método devuelve un valor inmediatamente siempre que se obtiene un estado de notificación de la recolección de elementos no utilizados, independientemente del valor especificado por `millisecondsTimeout`. Si no se obtiene un estado de notificación de la recolección de elementos no utilizados antes de `millisecondsTimeout` horas, este método devuelve <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede realizar tareas como evitar que objetos adicionales que se va a asignar e induce una colección con el <xref:System.GC.Collect%2A> método. Tenga en cuenta que la notificación no garantiza que una colección de elementos no utilizados completa se produzca, solo que las condiciones han alcanzado el umbral que son favorables para una colección de elementos no utilizados completa que se produzca.  
  
 Puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método cuando no puede esperar a que transcurra el período de tiempo de espera.  
  
 Debe seguir este método con una llamada a la <xref:System.GC.WaitForFullGCComplete%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa. Si solo llama a este método, pueden producirse resultados indeterminados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> debe ser un valor no negativo, un valor menor o igual a <see cref="F:System.Int32.MaxValue" /> o -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el estado de una notificación registrada para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el estado de una notificación registrada para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
        <returns>El estado de la notificación registrada de recolección de elementos no utilizados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.GCNotificationStatus> enumeración devuelto por este método para determinar el estado de la notificación actual de colección de elementos no utilizados que se registró mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. También puede usar el <xref:System.GC.WaitForFullGCApproach%2A> método para determinar si es inminente una recolección completa.  
  
 Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede realizar tareas como reanudar el trabajo y obtener un recuento de la colección con el <xref:System.GC.CollectionCount%2A> propiedad.  
  
 Este método espera indefinidamente una notificación de recolección va a obtener. Si desea especificar un período de tiempo de espera para el método devolver si no se puede obtener la notificación, utilice el <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método. Si se llama a este método sin especificar un tiempo de espera, puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método si se esperan más preferido.  
  
 Esta llamada al método debe ir precedida por una llamada a la <xref:System.GC.WaitForFullGCApproach%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa. Si solo llama a este método, puede producirse resultados indeterminados.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar este método para determinar si se ha completado una recolección completa. Cada vez que el estado de la notificación es <xref:System.GCNotificationStatus.Succeeded>, el método de usuario `OnFullGCCompletedNotify` se llama para realizar acciones en respuesta a la colección completa. Este ejemplo de código forma parte de un ejemplo más extenso de [notificaciones de la colección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Cantidad de tiempo que hay que esperar para obtener un estado de notificación. Especifique -1 para esperar indefinidamente.</param>
        <summary>Devuelve el estado de una notificación registrada, en un tiempo de espera especificado, para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</summary>
        <returns>El estado de la notificación registrada de recolección de elementos no utilizados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.GCNotificationStatus> enumeración devuelto por este método para determinar el estado de la notificación actual de colección de elementos no utilizados que se registró mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método. También puede usar el <xref:System.GC.WaitForFullGCApproach%2A> método para determinar si es inminente una recolección completa.  
  
 Tenga en cuenta que este método devuelve un valor inmediatamente siempre que se obtiene un estado de notificación de la recolección de elementos no utilizados, independientemente del valor especificado por `millisecondsTimeout`. Si no se obtiene un estado de notificación de la recolección de elementos no utilizados antes de `millisecondsTimeout` horas, este método devuelve <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede realizar tareas como reanudar el trabajo y obtener un recuento de la colección con el <xref:System.GC.CollectionCount%2A> propiedad.  
  
 Puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método cuando no puede esperar a que transcurra el período de tiempo de espera.  
  
 Esta llamada al método debe ir precedida por una llamada a la <xref:System.GC.WaitForFullGCApproach%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa. Si solo llama a este método, puede producirse resultados indeterminados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="millisecondsTimeout" /> debe ser un valor no negativo, un valor menor o igual a <see cref="F:System.Int32.MaxValue" /> o -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspende el subproceso actual hasta que el subproceso que está procesando la cola de finalizadores vacíe dicha cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el recolector de elementos no utilizados encuentra objetos que se pueden reclamar, comprueba cada objeto para determinar los requisitos de la finalización del objeto. Si un objeto implementa un finalizador y no se ha deshabilitado la finalización mediante una llamada a <xref:System.GC.SuppressFinalize%2A>, el objeto se coloca en una lista de objetos que están marcados como listos para la finalización. El recolector de elementos no utilizados llame el <xref:System.Object.Finalize%2A> métodos para los objetos de esta lista y quita las entradas de la lista. Este método se bloquea hasta que todos los finalizadores se ejecuta hasta completarse.  
  
 El subproceso en el que se ejecutan los finalizadores no está especificado, así que no hay ninguna garantía de que este método se cerrará. Sin embargo, este subproceso puede ser interrumpido por otro subproceso mientras el <xref:System.GC.WaitForPendingFinalizers%2A> método está en curso. Por ejemplo, puede iniciar otro subproceso que espera durante un período de tiempo y, a continuación, interrumpa el primer subproceso si sigue suspendido.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.GC.WaitForPendingFinalizers%2A> método para suspender el subproceso actual hasta que se complete la finalización de todos los objetos recopilados.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>