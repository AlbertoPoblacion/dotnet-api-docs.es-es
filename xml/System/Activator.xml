<Type Name="Activator" FullName="System.Activator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="33496946a13ba8e7a29674ceaab89361b3bde664" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30730899" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Contiene métodos para crear tipos de objetos de forma local o remota, o para obtener referencias a objetos remotos existentes. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Activator.CreateInstance%2A> método crea una instancia de un tipo definido en un ensamblado llamando al constructor que mejor coincide con los argumentos especificados. Si no se especifica ningún argumento, se invoca el constructor que no toma ningún parámetro, es decir, el constructor predeterminado.  
  
 Debe tener permisos suficientes para buscar y llamar a un constructor; en caso contrario, se produce una excepción. De forma predeterminada, sólo los constructores públicos se consideran durante la búsqueda de un constructor. Si no se encuentra ningún constructor o un constructor predeterminado, se produce una excepción.  
  
 Un parámetro enlazador especifica un objeto que busca un ensamblado para un constructor adecuado. Puede especificar sus propios criterios de búsqueda y el enlazador. Si no se especifica ningún enlazador, se utiliza un enlazador predeterminado. Para obtener más información, vea las clases <xref:System.Reflection.Binder?displayProperty=nameWithType> y <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un parámetro de evidencia afecta a la directiva de seguridad y permisos para el constructor. Para obtener más información, vea la clase <xref:System.Security.Policy.Evidence?displayProperty=nameWithType>.  
  
 Una instancia de un tipo se puede crear en un sitio local o remoto. Si el tipo se crea de forma remota, un parámetro de atributo de activación especifica el URI del sitio remoto. La llamada para crear la instancia puede pasar a través de sitios intermedios antes de llegar al sitio remoto. Otros atributos de activación pueden modificar el entorno o contexto, en el que se ejecuta la llamada en los sitios intermedios y remotos.  
  
 Si la instancia se crea localmente, se devuelve una referencia a ese objeto. Si la instancia se crea de forma remota, se devuelve una referencia a un servidor proxy. El objeto remoto se manipula a través del proxy como si fuera un objeto local.  
  
 El <xref:System.Activator.GetObject%2A> método crea un proxy para un objeto remoto en ejecución, el objeto conocido activado en el servidor o el servicio Web XML. Puede especificar el medio de conexión, es decir, el canal. Para obtener más información, vea la clase <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType>.  
  
 Los ensamblados contienen definiciones de tipo. El <xref:System.Activator.CreateInstance%2A> método crea una instancia de un tipo de un ensamblado que se está ejecutando. El <xref:System.Activator.CreateInstanceFrom%2A> método crea una instancia de un archivo que contiene un ensamblado. El <xref:System.Activator.CreateComInstanceFrom%2A> método crea una instancia de un objeto COM desde un archivo que contiene un ensamblado.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar la <xref:System.Activator> clase para construir objetos dinámicamente en tiempo de ejecución.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una instancia del objeto COM cuyo nombre se especifica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <c>typeName</c>.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <summary>Crea una instancia del objeto COM cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo con un valor de `true` deben aplicarse explícitamente o de forma predeterminada para el tipo COM por lo que la <xref:System.Activator.CreateComInstanceFrom%2A> método puede crear una instancia de ese tipo; de lo contrario, <xref:System.TypeLoadException> se produce.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para crear tipos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="typeName" /> o <paramref name="assemblyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">No se puede crear una instancia mediante COM.  
  
 O bien  
  
 <paramref name="assemblyName" /> no se encuentra en <paramref name="typename" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encuentra <paramref name="assemblyName" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstract.  
  
 O bien  
  
 Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede proporcionar atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> es la cadena vacía ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <c>typeName</c>.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="hashValue">Valor del código hash calculado.</param>
        <param name="hashAlgorithm">Algoritmo hash que se aplica a los archivos para generar el nombre seguro.</param>
        <summary>Crea una instancia del objeto COM cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo con un valor de `true` deben aplicarse explícitamente o de forma predeterminada para el tipo COM por lo que la <xref:System.Activator.CreateComInstanceFrom%2A> método puede crear una instancia de ese tipo; de lo contrario, <xref:System.TypeLoadException> se produce.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para crear tipos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="typeName" /> o <paramref name="assemblyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> es la cadena vacía ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes o el nombre del ensamblado tiene más de MAX_PATH caracteres.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encuentra <paramref name="assemblyName" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</exception>
        <exception cref="T:System.IO.FileLoadException">
          Se ha encontrado <paramref name="assemblyName" />, pero no se puede cargar.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.</exception>
        <exception cref="T:System.Security.SecurityException">Se especificó un código base que no comienza con "file://" sin el valor de <see langword="WebPermission" /> necesario.</exception>
        <exception cref="T:System.TypeLoadException">No se puede crear una instancia mediante COM.  
  
 O bien  
  
 <paramref name="assemblyName" /> no se encuentra en <paramref name="typename" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstract.  
  
 O bien  
  
 Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer un identificador URI que comienza con "file://". Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienza con "file://".</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Objeto de contexto de activación que especifica el objeto que se va a crear.</param>
        <summary>Crea una instancia del tipo designado por el objeto <see cref="T:System.ActivationContext" /> especificado.</summary>
        <returns>Identificador que debe desajustarse para obtener acceso al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 El contexto de activación se utiliza durante la activación basada en manifiestos para configurar la directiva de dominio y proporcionar un modelo de seguridad basado en la aplicación. El <xref:System.ActivationContext> clase contiene un <xref:System.ApplicationIdentity> objeto que proporciona acceso al manifiesto de aplicación. Para obtener más información, vea la clase <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor predeterminado de ese tipo.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor que se debe invocar debe ser accesible.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a tipos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Activator.CreateInstance%28System.Type%29> método. Se crean instancias de varios tipos distintos y se muestran sus valores predeterminados.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
 O bien  
  
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 O bien  
  
 No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
 No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase usado para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos no públicos, independientemente de sus conjuntos de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">Objeto de contexto de activación que especifica el objeto que se va a crear.</param>
        <param name="activationCustomData">Matriz de cadenas Unicode que contienen los datos de activación personalizados.</param>
        <summary>Crea una instancia del tipo designado por el objeto <see cref="T:System.ActivationContext" /> especificado y activada con los datos de activación personalizados especificados.</summary>
        <returns>Identificador que debe desajustarse para obtener acceso al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 El contexto de activación se utiliza durante la activación basada en manifiestos para configurar la directiva de dominio y proporcionar un modelo de seguridad basado en la aplicación. El <xref:System.ActivationContext> clase contiene un <xref:System.ApplicationIdentity> objeto que proporciona acceso al manifiesto de aplicación. Para obtener más información, vea la clase <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <c>typeName</c>. Si <c>assemblyName</c> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
 `assemblyName` puede ser cualquiera de las siguientes acciones:  
  
-   El nombre sencillo de un ensamblado sin la extensión de archivo o ruta de acceso. Por ejemplo, podría especificar `TypeExtensions` para un ensamblado cuyo nombre y ruta de acceso es.\bin\TypeExtensions.dll.  
  
-   El nombre completo de un ensamblado firmado, que consta de su nombre simple, la versión, la referencia cultural y el token de clave pública; Por ejemplo, "TypeExtensions, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 181869f2f7435b51".  
  
 Para obtener más información sobre cómo common language runtime identifica y carga los ensamblados, vea [cómo el tiempo de ejecución ubica ensamblados](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Para obtener información sobre cómo utilizar el archivo de configuración de aplicación para definir ubicaciones de ensamblados, vea [especificar la ubicación de un ensamblado](~/docs/framework/configure-apps/specify-assembly-location.md). Si `assemblyName` se encuentra, se carga en el contexto predeterminado.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para crear tipos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una clase denominada `Person` en un ensamblado denominado `PersonInfo`. Tenga en cuenta que la `Person` clase tiene dos constructores, uno de los cuales no tiene parámetros.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 El ejemplo siguiente se llama el <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> método para crear una instancia de la `Person` clase. Requiere una referencia a PersonInfo.dll va a agregar al proyecto. Dado que la <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> llamadas al método el `Person` constructor de clase predeterminado, en el ejemplo se asigna un valor a su `Name` propiedad.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 Sin embargo, <xref:System.Activator.CreateInstance%2A> se llama con frecuencia para crear una instancia de un tipo que cruza los límites del equipo o que no se conoce en tiempo de diseño. En este caso, no se puede incluir una referencia al ensamblado en el proyecto y no se pueden realizar llamadas enlazadas tempranamente a los miembros del tipo. Para solucionar esta limitación, en el ejemplo siguiente se usa el <xref:System.Activator.CreateInstance%2A> método junto con la reflexión para asignar un valor a la `Person` del objeto `Name` propiedad y mostrar su valor.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución. </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
 O bien  
  
 El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="nonPublic">
          <see langword="true" /> si puede haber coincidencias de constructores predeterminados públicos o no públicos; <see langword="false" /> si solo puede haber coincidencias de constructores predeterminados públicos.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor predeterminado de ese tipo.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a tipos y miembros si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos y miembros se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
 O bien  
  
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 O bien  
  
 No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase usado para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor que se va a invocar debe ser accesible y debe proporcionar a la coincidencia más específica con la lista de argumentos especificados.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a tipos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> método para crear un <xref:System.String> objeto. Lo llama el <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructor para crear instancias de una cadena que contiene diez elementos de una matriz de caracteres a partir de la posición decimocuarta.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 En el ejemplo siguiente se crea una matriz escalonada cuyos elementos son los argumentos que se pasan a un <xref:System.String> constructor. En el ejemplo, a continuación, pasa cada matriz a la <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> método que se invoca el constructor de la cadena adecuada.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
 O bien  
  
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 O bien  
  
 No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
 O bien  
  
 El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
 No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase usado para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto en el que se crea el tipo denominado <c>typeName</c>.</param>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <c>typeName</c>. Si <c>assemblyName</c> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice <xref:System.Activator.CreateInstance%2A> cuando un host necesite ejecutar código en un dominio de aplicación que tiene permisos de seguridad restringidos.  
  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para requerir el llamador inmediato tiene plena confianza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="typeName" /> o <paramref name="domain" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de un tipo abstracto.  
  
 O bien  
  
 Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
 O bien  
  
 El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <c>typeName</c>. Si <c>assemblyName</c> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para crear tipos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los tipos no públicos se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
 O bien  
  
 <paramref name="activationAttributes" /> no es una matriz <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />  
  
 .</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
 O bien  
  
 El nombre o la base de código del ensamblado no son válidos.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se produjo un error al intentar la activación remota en un destino especificado en <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor que se va a invocar debe ser accesible y debe proporcionar a la coincidencia más específica con la lista de argumentos especificados.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a tipos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
 O bien  
  
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 O bien  
  
 No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
 O bien  
  
 El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
 O bien  
  
 El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase usado para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <c>type</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>type</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>type</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor que se va a invocar debe proporcionar a la coincidencia más específica con la lista de argumentos especificados, bajo las restricciones del enlazador especificado y atributos de enlace.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a tipos y miembros si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos y miembros se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
 O bien  
  
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 O bien  
  
 No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
 O bien  
  
 El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase que se usa para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <c>type</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>type</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>type</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor que se va a invocar debe proporcionar a la coincidencia más específica con la lista de argumentos especificados, bajo las restricciones del enlazador especificado y atributos de enlace.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a tipos y miembros si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los tipos no públicos y miembros se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
 O bien  
  
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 O bien  
  
 No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
 O bien  
  
 El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
 O bien  
  
 El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase que se usa para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <c>typeName</c>. Si <c>assemblyName</c> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <c>typeName</c> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor <c>typeName</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>typeName</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>typeName</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para crear tipos y miembros si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos y miembros se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)42d9dc2a 8fcc 4ff3 b002 4ff260ef3dc5.)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
 O bien  
  
 El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
 O bien  
  
 El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio en el que se crea el tipo denominado <c>typeName</c>.</param>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <c>typeName</c>. Si <c>assemblyName</c> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <c>typeName</c> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor <c>typeName</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>typeName</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>typeName</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el ensamblado con nombre y el constructor que se adapta mejor a los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice <xref:System.Activator.CreateInstance%2A> cuando un host necesite ejecutar código en un dominio de aplicación que tiene permisos de seguridad restringidos.  
  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para requerir el llamador inmediato tiene plena confianza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
 O bien  
  
 El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
 O bien  
  
 El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <c>typeName</c>. Si <c>assemblyName</c> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <c>typeName</c> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor <c>typeName</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>typeName</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>typeName</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityInfo">Información usada para tomar decisiones sobre la directiva de seguridad y conceder permisos de código.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para crear tipos y miembros si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos concedidos del ensamblado que contiene los tipos no públicos y miembros se restringe al conjunto de permisos concedidos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
 O bien  
  
 El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
 O bien  
  
 El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio en el que se crea el tipo denominado <c>typeName</c>.</param>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <c>typeName</c>. Si <c>assemblyName</c> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <c>typeName</c> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor <c>typeName</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>typeName</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>typeName</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un solo objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. El atributo <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> especifica la dirección URL necesaria para activar un objeto remoto.</param>
        <param name="securityAttributes">Información usada para tomar decisiones sobre la directiva de seguridad y conceder permisos de código.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el ensamblado con nombre y el constructor que se adapta mejor a los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice <xref:System.Activator.CreateInstance%2A> cuando un host necesite ejecutar código en un dominio de aplicación que tiene permisos de seguridad restringidos.  
  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para requerir el llamador inmediato tiene plena confianza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
 O bien  
  
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
 O bien  
  
 El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
 O bien  
  
 El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo que se va a crear.</typeparam>
        <summary>Crea una instancia del tipo designado por el parámetro de tipo genérico especificado, usando el constructor sin parámetros.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Activator.CreateInstance%60%601> método genérico se utiliza por los compiladores para implementar la creación de instancias de tipos especificados por los parámetros de tipo. Por ejemplo, en el siguiente método genérico, la implementación de `new T()` (`gcnew T()` en C++) utiliza el <xref:System.Activator.CreateInstance%60%601> método genérico.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 En general, no hay ningún uso para la <xref:System.Activator.CreateInstance%60%601> código de método genérico en la aplicación, ya que debe conocer el tipo en tiempo de compilación. Si se conoce el tipo en tiempo de compilación, pueden usarse la sintaxis de creación de instancias normal (`new` operador de C#, `New` en Visual Basic, `gcnew` en C++). Si no se conoce el tipo en tiempo de compilación, puede llamar a una sobrecarga no genérica de <xref:System.Activator.CreateInstance%2A>.  
  
 Existen dos sobrecargas de la <xref:System.Activator.CreateInstance%60%601> método genérico que toman listas de argumentos, como sobrecarga no genérica de <xref:System.Activator.CreateInstance%2A> ya proporcionan la resolución de constructor en tiempo de ejecución.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
 El tipo que se especifica para <paramref name="T" /> no tiene un constructor sin parámetros.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <c>typeName</c>.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Activator.CreateInstanceFrom%2A> método. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Activator> clase.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto en el que se crea el tipo denominado <c>typeName</c>.</param>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <c>typeName</c>.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice <xref:System.Activator.CreateInstanceFrom%2A> cuando un host necesite ejecutar código en un dominio de aplicación que tiene permisos de seguridad restringidos.  
  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para requerir el llamador inmediato tiene plena confianza.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <c>typeName</c>.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <c>typeName</c>.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <c>typeName</c> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor <c>typeName</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>typeName</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>typeName</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto en el que se crea el tipo denominado <c>typeName</c>.</param>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <c>typeName</c>.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <c>typeName</c> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor <c>typeName</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>typeName</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>typeName</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el archivo del ensamblado con nombre y el constructor que se adapta mejor a los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice <xref:System.Activator.CreateInstanceFrom%2A> cuando un host necesite ejecutar código en un dominio de aplicación que tiene permisos de seguridad restringidos.  
  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, consulte las secciones de las excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
 O bien  
  
 <paramref name="assemblyName" /> se compiló para una versión de Common Language Runtime que es posterior a la versión que se está ejecutando actualmente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <c>typeName</c>.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <c>typeName</c> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor <c>typeName</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>typeName</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>typeName</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityInfo">Información usada para tomar decisiones sobre la directiva de seguridad y conceder permisos de código.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto en el que se crea el tipo denominado <c>typeName</c>.</param>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <c>typeName</c>.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <c>typeName</c> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor <c>typeName</c>. Si <c>bindingAttr</c> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <c>bindingAttr</c> y <c>args</c> para buscar e identificar el constructor <c>typeName</c>. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <c>args</c> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <c>args</c> en los tipos formales declarados para el constructor <c>typeName</c>. Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
 Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityAttributes">Información usada para tomar decisiones sobre la directiva de seguridad y conceder permisos de código.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el archivo del ensamblado con nombre y el constructor que se adapta mejor a los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice <xref:System.Activator.CreateInstanceFrom%2A> cuando un host necesite ejecutar código en un dominio de aplicación que tiene permisos de seguridad restringidos.  
  
 Use la <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para requerir el llamador inmediato tiene plena confianza.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">
          No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
 O bien  
  
 Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para tener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un proxy para un objeto o servicio Web XML conocido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del objeto conocido con el que se desea establecer conexión.</param>
        <param name="url">URL del objeto conocido.</param>
        <summary>Crea un proxy para el objeto conocido indicado por el tipo y dirección URL especificados.</summary>
        <returns>Proxy que apunta a un punto de conexión atendido por el objeto conocido solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame al proxy para enviar mensajes al objeto remoto. No se envían a través de la red hasta que se llama a un método en el servidor proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="type" /> o <paramref name="url" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> no calcula las referencias por referencia y no es una interfaz.</exception>
        <exception cref="T:System.MemberAccessException">Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del objeto conocido con el que se desea establecer conexión.</param>
        <param name="url">URL del objeto conocido.</param>
        <param name="state">Datos específicos del canal o <see langword="null" />.</param>
        <summary>Crea un proxy para el objeto conocido indicado por el tipo, dirección URL y datos de canal especificados.</summary>
        <returns>Proxy que apunta a un punto de conexión atendido por el objeto conocido solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame al proxy para enviar mensajes al objeto remoto. No se envían a través de la red hasta que se llama a un método en el servidor proxy.  
  
 El `state` parámetro comunica información al canal y se pasa a la <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="type" /> o <paramref name="url" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> no calcula las referencias por referencia y no es una interfaz.</exception>
        <exception cref="T:System.MemberAccessException">Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="rgszNames">Matriz pasada de nombres que se van a asignar.</param>
        <param name="cNames">Número de nombres que se van a asignar.</param>
        <param name="lcid">Contexto de configuración regional en el que se van a interpretar los nombres.</param>
        <param name="rgDispId">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</param>
        <summary>Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para tener acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Información de tipos que se va a devolver.</param>
        <param name="lcid">Identificador de la configuración regional de la información de tipo.</param>
        <param name="ppTInfo">Objeto que recibe un puntero al objeto de información de tipo solicitado.</param>
        <summary>Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para tener acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">El resultado que devuelve este método, contiene un puntero a una ubicación que recibe el número de interfaces de información de tipo proporcionada por el objeto. Este parámetro se pasa sin inicializar.</param>
        <summary>Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para tener acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identificador de envío que identifica el miembro.</param>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="lcid">Contexto de la configuración regional en que se interpretan los argumentos.</param>
        <param name="wFlags">Marcas que describen el contexto de la llamada.</param>
        <param name="pDispParams">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</param>
        <param name="pVarResult">Puntero a la ubicación donde se va a almacenar el resultado.</param>
        <param name="pExcepInfo">Puntero a una estructura que contiene información de excepciones.</param>
        <param name="puArgErr">Índice del primer argumento que tiene un error.</param>
        <summary>Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para tener acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
  </Members>
</Type>