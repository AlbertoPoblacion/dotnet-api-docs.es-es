<Type Name="Activator" FullName="System.Activator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a912c36148a235cad7f0213e4ea2fe09d1b2b8fa" />
    <Meta Name="ms.sourcegitcommit" Value="6ee2e6b2c5d7c5bd66feeb362d29e65fdf858836" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/15/2018" />
    <Meta Name="ms.locfileid" Value="51691565" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <TypeSignature Language="F#" Value="type Activator = class&#xA;    interface _Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Contiene métodos para crear tipos de objetos de forma local o remota, o para obtener referencias a objetos remotos existentes. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Activator.CreateInstance%2A> método crea una instancia de un tipo definido en un ensamblado mediante la invocación del constructor que mejor coincide con los argumentos especificados. Si no se especifica ningún argumento, el constructor que no toma ningún parámetro, es decir, el constructor predeterminado, se invoca.  
  
 Debe tener permisos suficientes para buscar y llamar a un constructor; en caso contrario, se produce una excepción. De forma predeterminada, sólo los constructores públicos se consideran durante la búsqueda de un constructor. Si no se encuentra ningún constructor o un constructor predeterminado, se produce una excepción.  
  
 Un parámetro enlazador especifica un objeto que busca un ensamblado para un constructor adecuado. Puede especificar sus propios criterios de búsqueda y el enlazador. Si no se especifica, se utiliza un enlazador predeterminado. Para obtener más información, vea las clases <xref:System.Reflection.Binder?displayProperty=nameWithType> y <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un parámetro de evidencia afecta a la directiva de seguridad y permisos para el constructor. Para obtener más información, vea la clase <xref:System.Security.Policy.Evidence?displayProperty=nameWithType>.  
  
 Una instancia de un tipo puede crearse en un sitio local o remoto. Si el tipo se crea de forma remota, un parámetro de atributo de activación especifica el URI del sitio remoto. La llamada para crear la instancia podría pasar a través de los sitios intermedios antes de que llegue el sitio remoto. Otros atributos de activación pueden modificar el contexto, en el que se ejecuta la llamada en los sitios remotos e intermediarios o entorno.  
  
 Si la instancia se crea localmente, se devuelve una referencia a ese objeto. Si la instancia se crea de forma remota, se devuelve una referencia a un servidor proxy. El objeto remoto se manipula a través del proxy como si fuese un objeto local.  
  
 El <xref:System.Activator.GetObject%2A> método crea un proxy a un objeto remoto en ejecución, el objeto conocido activado en el servidor o el servicio Web XML. Puede especificar el medio de conexión, es decir, el canal. Para obtener más información, vea la clase <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType>.  
  
 Los ensamblados contienen definiciones de tipo. El <xref:System.Activator.CreateInstance%2A> método crea una instancia de un tipo de un ensamblado que se está ejecutando. El <xref:System.Activator.CreateInstanceFrom%2A> método crea una instancia de un archivo que contiene un ensamblado. El <xref:System.Activator.CreateComInstanceFrom%2A> método crea una instancia de un objeto COM desde un archivo que contiene un ensamblado.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Activator> clase para construir objetos dinámicamente en tiempo de ejecución.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una instancia del objeto COM cuyo nombre se especifica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <paramref name="typeName" />.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <summary>Crea una instancia del objeto COM cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo con un valor de `true` deben aplicarse explícitamente o de forma predeterminada al tipo COM para que el <xref:System.Activator.CreateComInstanceFrom%2A> método puede crear una instancia de ese tipo; de lo contrario, <xref:System.TypeLoadException> se produce.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede usarse para crear tipos no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos del ensamblado que contiene los tipos no públicos se restringe a la concesión del llamador Establezca o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> o <paramref name="assemblyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">No se puede crear una instancia mediante COM.  
  
O bien 
 <paramref name="assemblyName" /> no se encuentra en <paramref name="typename" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra <paramref name="assemblyName" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstract.  
  
O bien 
Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede proporcionar atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> es la cadena vacía ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <paramref name="typeName" />.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="hashValue">Valor del código hash calculado.</param>
        <param name="hashAlgorithm">Algoritmo hash que se aplica a los archivos para generar el nombre seguro.</param>
        <summary>Crea una instancia del objeto COM cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo con un valor de `true` deben aplicarse explícitamente o de forma predeterminada al tipo COM para que el <xref:System.Activator.CreateComInstanceFrom%2A> método puede crear una instancia de ese tipo; de lo contrario, <xref:System.TypeLoadException> se produce.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede usarse para crear tipos no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos del ensamblado que contiene los tipos no públicos se restringe a la concesión del llamador Establezca o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> o <paramref name="assemblyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> es la cadena vacía ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.
        
O bien 
 <paramref name="assemblyName" /> es mayor que la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra <paramref name="assemblyName" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</exception>
        <exception cref="T:System.IO.FileLoadException">Se ha encontrado <paramref name="assemblyName" />, pero no se puede cargar.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.</exception>
        <exception cref="T:System.Security.SecurityException">Se especificó un código base que no comienza con "file://" sin el valor de <see langword="WebPermission" /> necesario.</exception>
        <exception cref="T:System.TypeLoadException">No se puede crear una instancia mediante COM.  
  
O bien 
 <paramref name="assemblyName" /> no se encuentra en <paramref name="typename" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstract.  
  
O bien 
Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer un URI que comienza con "file://". Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienzan con "file://".</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance activationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Objeto de contexto de activación que especifica el objeto que se va a crear.</param>
        <summary>Crea una instancia del tipo designado por el objeto <see cref="T:System.ActivationContext" /> especificado.</summary>
        <returns>Identificador que debe desajustarse para obtener acceso al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 El contexto de activación se utiliza durante la activación basada en manifiestos para configurar la directiva de dominio y para proporcionar un modelo de seguridad basado en aplicación. El <xref:System.ActivationContext> clase contiene un <xref:System.ApplicationIdentity> objeto que proporciona acceso al manifiesto de aplicación. Para obtener más información, vea la clase <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type -&gt; obj" Usage="System.Activator.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor predeterminado de ese tipo.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La invocación del constructor debe ser accesible.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a tipos no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos del ensamblado que contiene los tipos no públicos se restringe a la concesión del llamador Establezca o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Activator.CreateInstance%28System.Type%29> método. Se crean instancias de varios tipos diferentes y se muestran los valores predeterminados.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
O bien 
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
O bien 
No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
 No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase usado para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos no públicos, independientemente de sus conjuntos de concesión. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext * string[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (activationContext, activationCustomData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">Objeto de contexto de activación que especifica el objeto que se va a crear.</param>
        <param name="activationCustomData">Matriz de cadenas Unicode que contienen los datos de activación personalizados.</param>
        <summary>Crea una instancia del tipo designado por el objeto <see cref="T:System.ActivationContext" /> especificado y activada con los datos de activación personalizados especificados.</summary>
        <returns>Identificador que debe desajustarse para obtener acceso al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 El contexto de activación se utiliza durante la activación basada en manifiestos para configurar la directiva de dominio y para proporcionar un modelo de seguridad basado en aplicación. El <xref:System.ActivationContext> clase contiene un <xref:System.ApplicationIdentity> objeto que proporciona acceso al manifiesto de aplicación. Para obtener más información, vea la clase <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <paramref name="typeName" />. Si <paramref name="assemblyName" /> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
 `assemblyName` puede ser cualquiera de las siguientes acciones:  
  
-   El nombre sencillo de un ensamblado sin la extensión de archivo o ruta de acceso. Por ejemplo, especificaría `TypeExtensions` para un ensamblado cuyo nombre y ruta de acceso es.\bin\TypeExtensions.dll.  
  
-   El nombre completo de un ensamblado firmado, que consta de su nombre simple, versión, referencia cultural y token de clave pública; Por ejemplo, "TypeExtensions, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 181869f2f7435b51".  
  
 Para obtener más información sobre cómo common language runtime identifica y carga los ensamblados, vea [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Para obtener información acerca de cómo utilizar el archivo de configuración para definir ubicaciones de ensamblados, vea [especificar la ubicación del ensamblado](~/docs/framework/configure-apps/specify-assembly-location.md). Si `assemblyName` se encuentra, se carga en el contexto predeterminado.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede usarse para crear tipos no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos del ensamblado que contiene los tipos no públicos se restringe a la concesión del llamador Establezca o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una clase denominada `Person` en un ensamblado denominado `PersonInfo`. Tenga en cuenta que el `Person` clase tiene dos constructores, uno de los cuales no tiene parámetros.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 El ejemplo siguiente se llama el <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> método para crear una instancia de la `Person` clase. Requiere una referencia a PersonInfo.dll agregarse al proyecto. Dado que el <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> llamadas al método el `Person` constructor de clase de forma predeterminada, el ejemplo asigna un valor a su `Name` propiedad.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 Sin embargo, <xref:System.Activator.CreateInstance%2A> se llama con frecuencia para crear una instancia de un tipo que cruza los límites del equipo o que no se conoce en tiempo de diseño. En este caso, no puede incluir una referencia al ensamblado en el proyecto y no puede realizar las llamadas enlazadas a los miembros del tipo. Para solucionar esta limitación, el ejemplo siguiente utiliza el <xref:System.Activator.CreateInstance%2A> método junto con la reflexión para asignar un valor a la `Person` del objeto `Name` propiedad y mostrar su valor.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución. </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
O bien 
El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * bool -&gt; obj" Usage="System.Activator.CreateInstance (type, nonPublic)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="nonPublic">
          <see langword="true" /> si puede haber coincidencias de constructores predeterminados públicos o no públicos; <see langword="false" /> si solo puede haber coincidencias de constructores predeterminados públicos.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor predeterminado de ese tipo.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a tipos y miembros, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si se restringe el conjunto de permisos del ensamblado que contiene los tipos no públicos y miembros para el llamador conceder establecido o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
O bien 
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
O bien 
No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase usado para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La invocación del constructor debe ser accesible y debe proporcionar a la coincidencia más específica con la lista de argumentos especificada.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a tipos no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos del ensamblado que contiene los tipos no públicos se restringe a la concesión del llamador Establezca o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> método para crear un <xref:System.String> objeto. Lo llama el <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructor para crear instancias de una cadena que contiene diez elementos de una matriz de caracteres a partir de la posición del decimocuarta.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 En el ejemplo siguiente se crea una matriz escalonada cuyos elementos son los argumentos que se pasarán a un <xref:System.String> constructor. En el ejemplo, a continuación, pasa cada matriz a la <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> método para invocar el constructor de cadena apropiado.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
O bien 
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
O bien 
No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
O bien 
El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
 No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase usado para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto en el que se crea el tipo denominado <paramref name="typeName" />.</param>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <paramref name="typeName" />. Si <paramref name="assemblyName" /> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstance%2A> cuando un host necesite ejecutar código en un dominio de aplicación que se ha restringido los permisos de seguridad.  
  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir al llamador inmediato que tiene plena confianza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> o <paramref name="domain" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de un tipo abstracto.  
  
O bien 
Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
O bien 
El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <paramref name="typeName" />. Si <paramref name="assemblyName" /> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede usarse para crear tipos no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los tipos no públicos se restringe al conjunto de permisos del llamador o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
O bien 
 <paramref name="activationAttributes" /> no es una matriz <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />  
  
.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
O bien 
El nombre o la base de código del ensamblado no son válidos.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se produjo un error al intentar la activación remota en un destino especificado en <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La invocación del constructor debe ser accesible y debe proporcionar a la coincidencia más específica con la lista de argumentos especificada.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a tipos no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos del ensamblado que contiene los tipos no públicos se restringe a la concesión del llamador Establezca o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
O bien 
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
O bien 
No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
O bien 
El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
O bien 
El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase usado para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="type" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="type" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="type" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La invocación del constructor debe proporcionar a la coincidencia más específica con la lista de argumentos especificados, bajo las restricciones del enlazador especificado y atributos de enlace.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a tipos y miembros, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si se restringe el conjunto de permisos del ensamblado que contiene los tipos no públicos y miembros para el llamador conceder establecido o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
O bien 
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
O bien 
No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
O bien 
El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase que se usa para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de objeto que se va a crear.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="type" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="type" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="type" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo especificado usando el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La invocación del constructor debe proporcionar a la coincidencia más específica con la lista de argumentos especificados, bajo las restricciones del enlazador especificado y atributos de enlace.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a tipos y miembros, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los tipos no públicos y miembros está restringido al llamador concesión el conjunto o para un subconjunto de ellos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no es un <see langword="RuntimeType" />.  
  
O bien 
 <paramref name="type" /> es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> no puede ser un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
O bien 
No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
O bien 
El ensamblado que contiene <paramref name="type" /> es un ensamblado dinámico que se creó con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
O bien 
El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor al que se llama genera una excepción.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> es un objeto COM, pero el identificador de clase que se usa para obtener el tipo no es válido o la clase identificada no está registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> no es un tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <paramref name="typeName" />. Si <paramref name="assemblyName" /> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <paramref name="typeName" /> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="typeName" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede usarse para crear tipos y miembros, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si se restringe el conjunto de permisos del ensamblado que contiene los tipos no públicos y miembros para el llamador conceder establecido o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
O bien 
El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
O bien 
El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio en el que se crea el tipo denominado <paramref name="typeName" />.</param>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <paramref name="typeName" />. Si <paramref name="assemblyName" /> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <paramref name="typeName" /> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="typeName" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el ensamblado con nombre y el constructor que se adapta mejor a los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstance%2A> cuando un host necesite ejecutar código en un dominio de aplicación que se ha restringido los permisos de seguridad.  
  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir al llamador inmediato que tiene plena confianza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
O bien 
El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
O bien 
El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <paramref name="typeName" />. Si <paramref name="assemblyName" /> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <paramref name="typeName" /> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="typeName" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityInfo">Información usada para tomar decisiones sobre la directiva de seguridad y conceder permisos de código.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede usarse para crear tipos y miembros, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si se restringe el conjunto de permisos del ensamblado que contiene los tipos no públicos y miembros para el llamador conceder establecido o a un subconjunto de los mismos. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
O bien 
El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
O bien 
El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio en el que se crea el tipo denominado <paramref name="typeName" />.</param>
        <param name="assemblyName">Nombre del ensamblado en el que se busca el tipo denominado <paramref name="typeName" />. Si <paramref name="assemblyName" /> es <see langword="null" />, se busca en el ensamblado que se está ejecutando.</param>
        <param name="typeName">Nombre completo del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <paramref name="typeName" /> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="typeName" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un solo objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. El atributo <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> especifica la dirección URL necesaria para activar un objeto remoto.</param>
        <param name="securityAttributes">Información usada para tomar decisiones sobre la directiva de seguridad y conceder permisos de código.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el ensamblado con nombre y el constructor que se adapta mejor a los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstance%2A> cuando un host necesite ejecutar código en un dominio de aplicación que se ha restringido los permisos de seguridad.  
  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir al llamador inmediato que tiene plena confianza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">El tipo COM no se obtuvo a través de <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite la creación de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> y <see cref="T:System.RuntimeArgumentHandle" />, ni de matrices de estos tipos.  
  
O bien 
 <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.  
  
O bien 
El constructor que más se aproxima a <paramref name="args" /> tiene argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.  
  
O bien 
El nombre o la base de código del ensamblado no son válidos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberSignature Language="F#" Value="static member CreateInstance : unit -&gt; 'T" Usage="System.Activator.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo que se va a crear.</typeparam>
        <summary>Crea una instancia del tipo designado por el parámetro de tipo genérico especificado, usando el constructor sin parámetros.</summary>
        <returns>Referencia al objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Activator.CreateInstance%60%601> método genérico se usa por los compiladores para implementar la creación de instancias de tipos especificados por los parámetros de tipo. Por ejemplo, en el siguiente método genérico, la implementación de `new T()` (`gcnew T()` en C++) utiliza el <xref:System.Activator.CreateInstance%60%601> método genérico.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 En general, no hay ningún uso para el <xref:System.Activator.CreateInstance%60%601> código del método genérico en la aplicación, porque el tipo debe conocerse en tiempo de compilación. Si el tipo se conoce en tiempo de compilación, pueden usarse la sintaxis normal de la creación de instancias (`new` operador en C#, `New` en Visual Basic, `gcnew` en C++). Si no se conoce el tipo en tiempo de compilación, puede llamar a una sobrecarga no genérica de <xref:System.Activator.CreateInstance%2A>.  
  
 Existen dos sobrecargas de los <xref:System.Activator.CreateInstance%60%601> método genérico que toman listas de argumentos, como sobrecarga no genérica de <xref:System.Activator.CreateInstance%2A> ya proporcionan la resolución de constructor en tiempo de ejecución.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
 El tipo especificado para <paramref name="T" /> no tiene un constructor sin parámetros.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <paramref name="typeName" />.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Activator.CreateInstanceFrom%2A> método. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Activator> clase.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto en el que se crea el tipo denominado <paramref name="typeName" />.</param>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <paramref name="typeName" />.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstanceFrom%2A> cuando un host necesite ejecutar código en un dominio de aplicación que se ha restringido los permisos de seguridad.  
  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir al llamador inmediato que tiene plena confianza.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <paramref name="typeName" />.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor predeterminado.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos no públicos, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <paramref name="typeName" />.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <paramref name="typeName" /> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="typeName" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto en el que se crea el tipo denominado <paramref name="typeName" />.</param>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <paramref name="typeName" />.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <paramref name="typeName" /> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="typeName" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el archivo del ensamblado con nombre y el constructor que se adapta mejor a los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstanceFrom%2A> cuando un host necesite ejecutar código en un dominio de aplicación que se ha restringido los permisos de seguridad.  
  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea las secciones de las excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
 <paramref name="assemblyName" /> se compiló para una versión de Common Language Runtime que es posterior a la versión que se está ejecutando actualmente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <paramref name="typeName" />.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <paramref name="typeName" /> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="typeName" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityInfo">Información usada para tomar decisiones sobre la directiva de seguridad y conceder permisos de código.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica, usando el archivo de ensamblado con nombre y el constructor que mejor coincida con los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto en el que se crea el tipo denominado <paramref name="typeName" />.</param>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado donde se busca el tipo denominado <paramref name="typeName" />.</param>
        <param name="typeName">Nombre del tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que en la búsqueda de <paramref name="typeName" /> no se distingue entre mayúsculas y minúsculas; <see langword="false" /> para especificar que en la búsqueda se tenga en cuenta el uso de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que usa <paramref name="bindingAttr" /> y <paramref name="args" /> para buscar e identificar el constructor de <paramref name="typeName" />. Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</param>
        <param name="args">Matriz de argumentos que coinciden en número, orden y tipo con los parámetros del constructor al que se llama. Si <paramref name="args" /> es una matriz vacía o <see langword="null" />, se llama al constructor que no toma parámetros (constructor predeterminado).</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, se trata de una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityAttributes">Información usada para tomar decisiones sobre la directiva de seguridad y conceder permisos de código.</param>
        <summary>Crea una instancia del tipo cuyo nombre se especifica en el dominio remoto indicado, usando el archivo del ensamblado con nombre y el constructor que se adapta mejor a los parámetros especificados.</summary>
        <returns>Identificador que debe desempaquetarse para obtener acceso a la instancia recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstanceFrom%2A> cuando un host necesite ejecutar código en un dominio de aplicación que se ha restringido los permisos de seguridad.  
  
 Use el <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> método para desempaquetar el valor devuelto.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir al llamador inmediato que tiene plena confianza.  
  
 Para obtener información acerca de otras excepciones que se pueden producir al invocar métodos, vea la sección excepciones de la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> y <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="domain" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MemberAccessException">No se puede crear una instancia de una clase abstracta o este miembro se invocó mediante un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El constructor, que se invocó mediante reflexión, inició una excepción.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso <see cref="T:System.Security.Permissions.FileIOPermission" /> requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> no es una matriz vacía y el tipo que se está creando no se deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
Common Language Runtime (CLR) 2.0 o una versión posterior está cargado actualmente y <paramref name="assemblyName" /> se compiló para una versión de CLR posterior a la versión cargada actualmente. Tenga en cuenta que las versiones 2.0, 3.0 y 3.5 de .NET Framework usan CLR versión 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder buscar rutas de acceso de directorio y leer su contenido. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a tipos y miembros, independientemente de su conjunto de permisos. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un proxy para un objeto o servicio Web XML conocido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string -&gt; obj" Usage="System.Activator.GetObject (type, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del objeto conocido con el que se desea establecer conexión.</param>
        <param name="url">URL del objeto conocido.</param>
        <summary>Crea un proxy para el objeto conocido indicado por el tipo y dirección URL especificados.</summary>
        <returns>Proxy que apunta a un punto de conexión atendido por el objeto conocido solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame al proxy para enviar mensajes al objeto remoto. No se envían mensajes a través de la red hasta que se llama a un método en el servidor proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="url" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> no calcula las referencias por referencia y no es una interfaz.</exception>
        <exception cref="T:System.MemberAccessException">Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string * obj -&gt; obj" Usage="System.Activator.GetObject (type, url, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del objeto conocido con el que se desea establecer conexión.</param>
        <param name="url">URL del objeto conocido.</param>
        <param name="state">Datos específicos del canal o <see langword="null" />.</param>
        <summary>Crea un proxy para el objeto conocido indicado por el tipo, dirección URL y datos de canal especificados.</summary>
        <returns>Proxy que apunta a un punto de conexión atendido por el objeto conocido solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame al proxy para enviar mensajes al objeto remoto. No se envían mensajes a través de la red hasta que se llama a un método en el servidor proxy.  
  
 El `state` parámetro comunica información al canal y se pasa a la <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="url" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> no calcula las referencias por referencia y no es una interfaz.</exception>
        <exception cref="T:System.MemberAccessException">Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="rgszNames">Matriz pasada de nombres que se van a asignar.</param>
        <param name="cNames">Número de nombres que se van a asignar.</param>
        <param name="lcid">Contexto de configuración regional en el que se van a interpretar los nombres.</param>
        <param name="rgDispId">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</param>
        <summary>Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para tener acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Información de tipos que se va a devolver.</param>
        <param name="lcid">Identificador de la configuración regional de la información de tipo.</param>
        <param name="ppTInfo">Objeto que recibe un puntero al objeto de información de tipo solicitado.</param>
        <summary>Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para tener acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">El resultado que devuelve este método, contiene un puntero a una ubicación que recibe el número de interfaces de información de tipo proporcionada por el objeto. Este parámetro se pasa sin inicializar.</param>
        <summary>Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para tener acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identificador de envío que identifica el miembro.</param>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="lcid">Contexto de la configuración regional en que se interpretan los argumentos.</param>
        <param name="wFlags">Marcas que describen el contexto de la llamada.</param>
        <param name="pDispParams">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</param>
        <param name="pVarResult">Puntero a la ubicación donde se va a almacenar el resultado.</param>
        <param name="pExcepInfo">Puntero a una estructura que contiene información de excepciones.</param>
        <param name="puArgErr">Índice del primer argumento que tiene un error.</param>
        <summary>Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para tener acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
  </Members>
</Type>