<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e75fac17db76d96759e0d5c583680b029b3a0963" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39928524" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa declaraciones de tipos: tipos de clase, tipos de interfaz, tipos de matriz, tipos de valor, tipos de enumeración, parámetros de tipo, definiciones de tipo genérico y tipos genéricos construidos abiertos o cerrados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` es la raíz de la <xref:System.Reflection> funcionalidad y es la manera principal para acceder a metadatos. Utilice los miembros de <xref:System.Type> para obtener información sobre una declaración de tipos, acerca de los miembros de un tipo (por ejemplo, los constructores, métodos, campos, propiedades y eventos de una clase), así como el módulo y el ensamblado en el que se implementa la clase.  
  
 No se requieren permisos para usar la reflexión para obtener información sobre los tipos y sus miembros, independientemente de sus niveles de acceso de código. No se requieren permisos para el código usar la reflexión para tener acceso a los miembros públicos o a otros miembros cuyos niveles de acceso deben que estén visibles durante la compilación normal. Sin embargo, para el código para usar la reflexión para obtener acceso a miembros que normalmente serían inaccesibles, como métodos privados o internos o campos protegidos de un tipo no hereda la clase, el código debe tener <xref:System.Security.Permissions.ReflectionPermission>. Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` es una clase base abstracta que permite varias implementaciones. El sistema siempre proporcionará la clase derivada `RuntimeType`. En la reflexión, todas las clases que comiencen por la palabra en tiempo de ejecución se crean una sola vez por cada objeto en el sistema y compatibilidad con las operaciones de comparación.  
  
> [!NOTE]
>  En escenarios de multithreading, no bloquee <xref:System.Type> con el fin de sincronizar el acceso a los objetos `static` datos. Otro código, en el que no tiene ningún control, también puede bloquear el tipo de clase. Esto puede dar lugar a un interbloqueo. En su lugar, sincronizar el acceso a los datos estáticos bloqueando una privada `static` objeto.  
  
> [!NOTE]
>  Una clase derivada puede tener acceso a miembros protegidos de clases base del código que realiza la llamada. Además, se permite el acceso a los miembros del ensamblado del ensamblado del código de llamada. Como norma, si se permite el acceso en tiempo de compilación código, a continuación, se también pueden acceder en el código en tiempo de ejecución.  
  
> [!NOTE]
>  Las interfaces que extienden otras interfaces no heredan los métodos definidos en las interfaces extendidas.  
  
 En esta sección:  
  
 [¿Qué tipos de representa un objeto de tipo?](#WhatTypes)   
 [Recuperar un objeto de tipo](#Retrieve)   
 [Comparar objetos de tipo de igualdad](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>¿Qué tipos de representa un objeto de tipo?  
 Esta clase es seguro para subprocesos; varios subprocesos pueden leer simultáneamente desde una instancia de este tipo. Una instancia de la <xref:System.Type> clase puede representar cualquiera de los siguientes tipos:  
  
-   Clases  
  
-   Tipos de valor  
  
-   Matrices  
  
-   Interfaces  
  
-   Enumeraciones  
  
-   Delegados  
  
-   Tipos genéricos construidos y definiciones de tipo genérico  
  
-   Argumentos de tipo y parámetros de tipos genéricos construidos, definiciones de tipo genérico y definiciones de método genérico de tipo  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Recuperar un objeto de tipo  
 El <xref:System.Type> se puede obtener el objeto asociado a un tipo determinado de las maneras siguientes:  
  
-   La instancia <xref:System.Object.GetType%2A?displayProperty=nameWithType> método devuelve un <xref:System.Type> objeto que representa el tipo de una instancia. Dado que todos los tipos administrados se derivan de <xref:System.Object>, el <xref:System.Object.GetType%2A> método puede llamarse en una instancia de cualquier tipo.  
  
     El ejemplo siguiente se llama el <xref:System.Object.GetType%2A?displayProperty=nameWithType> método para determinar el tipo en tiempo de ejecución de cada objeto en una matriz de objetos.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Estático <xref:System.Type.GetType%2A?displayProperty=nameWithType> métodos devuelven un <xref:System.Type> objeto que representa un tipo especificado por su nombre completo.  
  
-   El <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, y <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> métodos devuelven `Type` objetos que representan los tipos definidos en un módulo. El primer método se puede usar para obtener una matriz de <xref:System.Type> objetos para todos los tipos públicos y privados definidos en un módulo. (Puede obtener una instancia de `Module` a través de la <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> método, o a través del <xref:System.Type.Module%2A?displayProperty=nameWithType> propiedad.)  
  
-   El <xref:System.Reflection.Assembly?displayProperty=nameWithType> objeto contiene una serie de métodos para recuperar las clases definidas en un ensamblado, incluyendo <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, y <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   El <xref:System.Type.FindInterfaces%2A> método devuelve una lista filtrada de los tipos de interfaz compatible con un tipo.  
  
-   El <xref:System.Type.GetElementType%2A> método devuelve un `Type` objeto que representa el elemento.  
  
-   El <xref:System.Type.GetInterfaces%2A> y <xref:System.Type.GetInterface%2A> métodos devuelven <xref:System.Type> objetos que representan los tipos de interfaz compatibles con un tipo.  
  
-   El <xref:System.Type.GetTypeArray%2A> método devuelve una matriz de <xref:System.Type> objetos que representan los tipos especificados por un conjunto arbitrario de objetos. Los objetos se especifican con una matriz de tipo <xref:System.Object>.  
  
-   El <xref:System.Type.GetTypeFromProgID%2A> y <xref:System.Type.GetTypeFromCLSID%2A> se proporcionan métodos para la interoperabilidad COM. Devuelven un <xref:System.Type> objeto que representa el tipo especificado por un `ProgID` o `CLSID`.  
  
-   El <xref:System.Type.GetTypeFromHandle%2A> se proporciona el método de interoperabilidad. Devuelve un `Type` objeto que representa el tipo especificado por un identificador de clase.  
  
-   C# `typeof` operador, C++ `typeid` operador y el de Visual Basic `GetType` operador obtener el `Type` un tipo de objeto.  
  
-   El <xref:System.Type.MakeGenericType%2A> método devuelve un <xref:System.Type> objeto que representa un tipo genérico construido, que es un tipo construido abierto si su <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `true`, y un tipo construido cerrado en caso contrario. Puede crearse un tipo genérico solo si está cerrado.  
  
-   El <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, y <xref:System.Type.MakeByRefType%2A> métodos devuelven <xref:System.Type> objetos que representan, respectivamente, una matriz de un tipo especificado, un puntero a un tipo especificado y el tipo de un parámetro de referencia (`ref` en C#, `ByRef`en Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Comparar objetos de tipo de igualdad  
 Un <xref:System.Type> objeto que representa un tipo es único; es decir, dos <xref:System.Type> las referencias de objeto hacen referencia al mismo objeto solo si representan el mismo tipo. Esto permite la comparación de <xref:System.Type> objetos mediante la igualdad de referencia. En el ejemplo siguiente se comparan los <xref:System.Type> objetos que representan un número de valores enteros para determinar si son del mismo tipo.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 El ejemplo siguiente muestra algunas características representativas de <xref:System.Type>. C# `typeof` operador (`GetType` operador en Visual Basic, `typeid` operador en Visual C++) se utiliza para obtener un <xref:System.Type> que representa el objeto <xref:System.String>. Desde este <xref:System.Type> objeto, el <xref:System.Type.GetMethod%2A> método se utiliza para obtener un <xref:System.Reflection.MethodInfo> que representa el <xref:System.String.Substring%2A> sobrecarga que toma una posición inicial y una longitud.  
  
 Para identificar la signatura de sobrecarga, el ejemplo de código crea una matriz temporal que contiene dos <xref:System.Type> objetos que representan `int` (`Integer` en Visual Basic).  
  
> [!NOTE]
>  Para ser exactos, la matriz contiene dos referencias a la instancia de <xref:System.Type> que representa `int` en el dominio de aplicación actual. Para cualquier tipo, hay solo una instancia de <xref:System.Type> por dominio de aplicación.  
  
 El ejemplo de código se usa el <xref:System.Reflection.MethodInfo> para invocar el <xref:System.String.Substring%2A> método en la cadena "Hello, World!" y muestra el resultado.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <block subset="none" type="overrides">
      <para>Al heredar de <see langword="Type" />, debe reemplazar los miembros siguientes:- <see cref="P:System.Type.Assembly" />   
  
-    <see cref="P:System.Type.AssemblyQualifiedName" />   
  
-    <see cref="P:System.Type.BaseType" />   
  
-    <see cref="P:System.Type.FullName" />   
  
-    <see cref="M:System.Type.GetAttributeFlagsImpl" />   
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  -   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Type" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas, se invoca este constructor durante la construcción de objetos de tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la propiedad <see cref="T:System.Reflection.Assembly" /> en la que está declarado el tipo. Para los tipos genéricos, obtiene la propiedad <see cref="T:System.Reflection.Assembly" /> en la que está definido el tipo genérico.</summary>
        <value>Instancia de <see cref="T:System.Reflection.Assembly" /> que describe el ensamblado que contiene el tipo actual. Para los tipos genéricos, la instancia describe el ensamblado que contiene la definición de tipo genérico, no el ensamblado que crea y usa un tipo construido en particular.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> objeto representa un tipo genérico construido, esta propiedad devuelve el ensamblado que contiene la definición de tipo genérico. Por ejemplo, suponga que crea un ensamblado denominado MyGenerics.dll que contiene la definición de tipo genérico `MyGenericStack<T>` (`MyGenericStack(Of T)` en Visual Basic, `generic<T> ref class MyGenericStack` en C++). Si crea una instancia de `MyGenericStack<int>` (`MyGenericStack(Of Integer)` en Visual Basic) en otro ensamblado, el <xref:System.Type.Assembly%2A> propiedad para el tipo construido devuelve un <xref:System.Reflection.Assembly> objeto que representa MyGenerics.dll.  
  
 De forma similar, si el actual <xref:System.Type> objeto representa un parámetro genérico sin asignar `T`, esta propiedad devuelve el ensamblado que contiene el tipo genérico que define `T`.  
  
 Si el <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propiedad no está disponible en una implementación concreta. NET, como .NET Core o la plataforma Universal de Windows, use el <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> propiedad en su lugar.      
  
 Esta propiedad es de sólo lectura.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el nombre del ensamblado asociado a la clase y el nombre completo del tipo.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre calificado con el ensamblado del tipo, que incluye el nombre del ensamblado a partir del cual se ha cargado el objeto <see cref="T:System.Type" />.</summary>
        <value>Nombre calificado con el ensamblado de <see cref="T:System.Type" />, que incluye el nombre del ensamblado a partir del cual se ha cargado <see cref="T:System.Type" />, o <see langword="null" /> si la instancia actual representa un parámetro de tipo genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre completo de ensamblado de un tipo consta del nombre de tipo, incluido su espacio de nombres, seguido por una coma, seguida por el nombre para mostrar del ensamblado. El nombre para mostrar de un ensamblado se obtiene mediante la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propiedad.  
  
> [!NOTE]
>  En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado. Por ejemplo, "ProcessorArchitecture = msil". Sin embargo, no se incluye en la cadena devuelta por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, por motivos de compatibilidad. Vea <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 El nombre sencillo de una clase anidada de la emisión de todos los compiladores compatibles con common language runtime y reflexión construye un nombre con sufijo cuando se consulta, con arreglo a las siguientes convenciones.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra diagonal inversa (\\)|Carácter de escape.|  
|Coma (,)|Precede al nombre de ensamblado.|  
|Signo más (+)|Precede a una clase anidada.|  
|Punto (.)|Denota los identificadores de espacio de nombres.|  
|Corchetes ([])|Después de un nombre de tipo, indica una matriz de ese tipo.<br /><br /> O bien<br /><br /> Para un tipo genérico, incluye la lista de argumentos de tipo genérico.<br /><br /> O bien<br /><br /> Dentro de una lista de argumentos de tipo incluye un tipo calificado con el ensamblado.|  
  
 Por ejemplo, el nombre completo de ensamblado para una clase podría ser similar al siguiente:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Si el espacio de nombres contiene un signo más, por ejemplo EspacioNombresPrincipal. Sub+EspacioNombres, entonces el signo más (+) debería ir precedido de un carácter de escape (\\) para evitar que se va a interpretar como un separador de anidamiento. La reflexión emitiría esta cadena como sigue:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 Un "++" se convierte en "\\+\\+" y un "\\"se convierte en"\\\\".  
  
 Este nombre completo puede conservarse y usa más adelante para cargar el <xref:System.Type>. Para buscar y cargar un <xref:System.Type>, utilice <xref:System.Type.GetType%2A> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado. <xref:System.Type.GetType%2A> con el tipo de nombre sólo buscará los <xref:System.Type> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema. <xref:System.Type.GetType%2A> con el ensamblado de nombre de tipo calificado buscará el <xref:System.Type> en cualquier ensamblado.  
  
 Los nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz. Para recuperar el nombre del tipo sin estos caracteres finales, use `t.GetElementType().ToString()`, donde `t` es el tipo.  
  
 Espacios son relevantes en todos los componentes de nombre de tipo, excepto el nombre del ensamblado. En el nombre del ensamblado, espacios antes del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.  
  
 Argumentos genéricos de tipos genéricos propios están calificados por el nombre del ensamblado. Por ejemplo, en el nombre de tipo calificado con el ensamblado `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic), `int` se expande para el nombre de tipo calificado con el ensamblado <xref:System.Int32>.  
  
 Si el actual <xref:System.Type> objeto representa un parámetro genérico, esta propiedad devuelve `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el nombre del ensamblado asociado a la clase y el nombre completo del tipo.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 En el ejemplo siguiente se comparan las cadenas devueltas por la <xref:System.Type.ToString%2A> método y el `Name`, <xref:System.Type.FullName%2A>, y <xref:System.Type.AssemblyQualifiedName%2A> propiedades.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los atributos asociados al objeto <see cref="T:System.Type" />.</summary>
        <value>Objeto <see cref="T:System.Reflection.TypeAttributes" /> que representa el conjunto de atributos del objeto <see cref="T:System.Type" />, a menos que el objeto <see cref="T:System.Type" /> represente un parámetro de tipo genérico, en cuyo caso el valor no se especifica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos miembros de la <xref:System.Reflection.TypeAttributes> enumeración son máscaras que representan un grupo de valores. Cada grupo incluye a un miembro cuyo valor subyacente es cero. Por ejemplo, el valor subyacente de la <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> miembro en el <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> grupo es cero, como es el <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> miembro en el <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> grupo. Por este motivo, debe usar la máscara antes de realizar pruebas para esos valores. En este ejemplo se ilustra.  
  
> [!TIP]
>  Para la mayoría de los casos, al igual que las propiedades <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, y <xref:System.Type.IsSpecialName%2A> son más fáciles de usar que los atributos de tipo.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad devuelve los atributos de la definición de tipo genérico. Por ejemplo, los atributos devueltos para `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic) son los atributos de `MyGenericClass<T>` (`MyGenericClass(Of T)` en Visual Basic).  
  
 Si actual <xref:System.Type> representa un parámetro de tipo genérico, es decir, si la <xref:System.Type.IsGenericParameter%2A> propiedad devuelve `true` : el <xref:System.Reflection.TypeAttributes> valor devuelto por esta propiedad no está especificado.  
  
   
  
## Examples  
 El siguiente utiliza ejemplo <xref:System.Type.Attributes%2A> propiedad.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo del que hereda directamente el objeto <see cref="T:System.Type" /> actual.</summary>
        <value>
          <see cref="T:System.Type" /> desde el cual el objeto <see cref="T:System.Type" /> actual hereda directamente, o <see langword="null" /> si el objeto <see langword="Type" /> actual representa la clase <see cref="T:System.Object" /> o una interfaz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo base es el tipo del que hereda directamente el tipo actual. <xref:System.Object> es el único tipo que no tiene un tipo base, por lo tanto, `null` se devuelve como el tipo base del <xref:System.Object>.  
  
 Las interfaces heredar de cero o más interfaces base; por lo tanto, esta propiedad devuelve `null` si la `Type` objeto representa una interfaz. Las interfaces base se pueden determinar con <xref:System.Type.GetInterfaces%2A> o <xref:System.Type.FindInterfaces%2A>.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, el tipo base refleja los argumentos genéricos. Por ejemplo, consideremos las siguientes declaraciones:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Para el tipo construido `C<int>` (`C(Of Integer)` en Visual Basic), el <xref:System.Type.BaseType%2A> propiedad devuelve `B<int>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo de una definición de tipo genérico, <xref:System.Type.BaseType%2A> devuelve la restricción de clase, es decir, la clase debe heredar el parámetro de tipo. Si no hay ninguna restricción de clase, <xref:System.Type.BaseType%2A> devuelve <xref:System.Object?displayProperty=nameWithType>.  
  
 Esta propiedad es de sólo lectura.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo utilizar el <xref:System.Type.BaseType%2A> propiedad.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 El ejemplo siguiente usa la recursividad se muestra la jerarquía de herencia completa de cada clase que se encuentra en un ensamblado. El ejemplo define una clase denominada `C` que se deriva una clase denominada `B`, que, a su vez, deriva una clase denominada `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual tiene parámetros de tipo que no han sido reemplazados por tipos específicos.</summary>
        <value>
          <see langword="true" /> si el objeto <see cref="T:System.Type" /> es un parámetro de tipo genérico o tiene parámetros de tipo para los que no se han proporcionado tipos específicos; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para crear una instancia de un tipo, no debe haber ninguna definición de tipo genérico o tipos construidos abiertos en los argumentos de tipo del tipo en Sí, en los tipos genéricos envolventes, o en todos los elementos del tipo. Otra forma de expresarlo es que, cuando examina de forma recursiva, el tipo no debe contener ningún parámetro de tipo genérico.  
  
 Puesto que los tipos pueden ser arbitrariamente complejos, es difícil tomar esta decisión. Por comodidad y para reducir la posibilidad de error, el <xref:System.Type.ContainsGenericParameters%2A> propiedad proporciona una manera estándar para distinguir entre tipos construidos cerrados, que se pueden crear instancias, y construido abierto tipos, que no se pueden. Si el <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `true`, no pueden crearse instancias del tipo.  
  
 El <xref:System.Type.ContainsGenericParameters%2A> propiedad busca los parámetros de tipo de forma recursiva. Por ejemplo, devuelve `true` para una matriz cuyos elementos son de tipo `A<T>` (`A(Of T)` en Visual Basic), aunque la matriz no es genérico en sí mismo. Compare esto con el comportamiento de la <xref:System.Type.IsGenericType%2A> propiedad, que devuelve `false` para las matrices.  
  
 Para un conjunto de clases de ejemplo y una tabla que muestra los valores de la <xref:System.Type.ContainsGenericParameters%2A> propiedad, vea <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente define una clase genérica con dos parámetros de tipo y, a continuación, define una segunda clase genérica que se deriva de la primera clase. Clase base de la clase derivada tiene dos argumentos de tipo: el primero es <xref:System.Int32> y el segundo es un parámetro de tipo del tipo derivado. En el ejemplo se muestra información acerca de estas clases genéricas, incluidas las posiciones notifican por el <xref:System.Type.GenericParameterPosition%2A> propiedad.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Reflection.MethodBase" /> que representa el método declarativo si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo de un método genérico.</summary>
        <value>Si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo de un método genérico, <see cref="T:System.Reflection.MethodBase" /> que representa el método de declaración; de lo contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método declarativo es una definición de método genérico. Es decir, si <xref:System.Type.DeclaringMethod%2A> no devuelve `null`, a continuación, `DeclaringMethod.IsGenericMethodDefinition` devuelve `true`.  
  
 El <xref:System.Type.DeclaringType%2A> y <xref:System.Type.DeclaringMethod%2A> propiedades identifican la definición de tipo genérico o una definición de método genérico en el que se definió originalmente el parámetro de tipo genérico:  
  
-   Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve un <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa una definición de método genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de esa definición de método genérico.  
  
-   Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve `null`, el <xref:System.Type.DeclaringType%2A> propiedad siempre devuelve un <xref:System.Type> objeto que representa una definición de tipo genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de ese tipo genérico definición.  
  
-   Obteniendo el <xref:System.Type.DeclaringMethod%2A> propiedad en un tipo cuyo <xref:System.Type.IsGenericParameter%2A> propiedad es `false` produce una <xref:System.InvalidOperationException>.  
  
 El <xref:System.Reflection.MethodBase> devuelta por la <xref:System.Type.DeclaringMethod%2A> propiedad sea un <xref:System.Reflection.MethodInfo> en el caso de un método genérico, o un <xref:System.Reflection.ConstructorInfo> en el caso de un constructor genérico.  
  
> [!NOTE]
>  En la versión 2.0 de .NET Framework, no se admiten constructores genéricos.  
  
 Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente define una clase que tiene un método genérico, asigna un argumento de tipo para el método e invoca el método genérico construido resultante. También muestra información acerca de la definición de método genérico y el método construido. Al mostrar información acerca de los parámetros de tipo de la definición de método genérico, en el `DisplayGenericMethodInfo` método, el código de ejemplo muestra el valor de la <xref:System.Type.DeclaringMethod%2A> propiedad para el parámetro de tipo genérico del método.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que declara el tipo anidado actual o el parámetro de tipo genérico.</summary>
        <value>Un objeto <see cref="T:System.Type" /> que representa el tipo envolvente, si el tipo actual es un tipo anidado; o la definición de tipo genérico, si el tipo actual es un parámetro de tipo de un tipo genérico; o el tipo que declara el método genérico, si el tipo actual es un parámetro de tipo de un método genérico; en caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> objeto representa un parámetro de tipo de un tipo genérico, esta propiedad devuelve la definición de tipo genérico.  
  
 Si el actual <xref:System.Type> objeto representa un parámetro de tipo de un método genérico, esta propiedad devuelve el tipo que contiene la definición de método genérico. Si el tipo es genérico, se devuelve la definición de tipo genérico. Es decir, el código siguiente devuelve la definición de tipo genérico de la <xref:System.Collections.Generic.List%601> clase genérica, que contiene el <xref:System.Collections.Generic.List%601.ConvertAll%2A> método genérico:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, la <xref:System.Type.DeclaringType%2A> y <xref:System.Type.DeclaringMethod%2A> propiedades identifican la definición de tipo genérico o la definición de método genérico donde el parámetro de tipo genérico se definió originalmente:  
  
-   Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve un <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa una definición de método genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de esa definición de método genérico.  
  
-   Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve `null`, el <xref:System.Type.DeclaringType%2A> propiedad siempre devuelve un <xref:System.Type> objeto que representa una definición de tipo genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de ese tipo genérico definición.  
  
-   Obteniendo el <xref:System.Type.DeclaringType%2A> propiedad en un tipo cuyo <xref:System.Type.IsGenericParameter%2A> propiedad es `false` produce una <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 En este ejemplo se muestra el tipo declarativo de un método en una clase derivada.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia al enlazador predeterminado, que implementa varias reglas internas para seleccionar los miembros adecuados a los que llamará el método <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Referencia al enlazador predeterminado que el sistema usa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El enlazador predeterminado suministrado con common language runtime es aplicable en todas las circunstancias más especializadas. Si necesita un cuaderno que sigue las reglas que difieren de las del enlazador predeterminado proporcionado, definen un tipo derivado de la <xref:System.Reflection.Binder> clase y pasar una instancia de ese tipo mediante el `binder` parámetro de uno de los <xref:System.Type.InvokeMember%2A> sobrecargas.  
  
 Las reglas de accesibilidad de common type system de los modelos de reflexión. Por ejemplo, si el llamador está en el mismo ensamblado, el llamador no necesita permisos especiales para los miembros internos. En caso contrario, el llamador necesita <xref:System.Security.Permissions.ReflectionPermission>. Esto es coherente con la búsqueda de miembros que están protegidas, privadas y así sucesivamente.  
  
 El principio general es que <xref:System.Reflection.Binder.ChangeType%2A> debe realizar sólo conversiones de ampliación, que nunca se pierden datos. Un ejemplo de una conversión de ampliación es convertir un valor que es un entero de 32 bits con signo en un valor que es un entero con signo de 64 bits. Esto se diferencia de una conversión de restricción, que se puede perder datos. Un ejemplo de una conversión de restricción es convertir a un entero de 64 bits con signo en un entero de 32 bits con signo.  
  
 En la tabla siguiente se enumera las conversiones compatibles con el enlazador predeterminado.  
  
|Tipo de origen|Tipo de destino|  
|-----------------|-----------------|  
|Cualquier tipo|Su tipo base.|  
|Cualquier tipo|La interfaz que implementa.|  
|Char|Unt16, Int32, UInt32, UInt64, Int64, Single o Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single o Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Doble|  
|Sin referencia|Por referencia.|  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el enlazador predeterminado desde el `DefaultBinder` propiedad y se invoca a un miembro de MyClass pasando el `DefaultBinder` valor como un parámetro a <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Separa los nombres en el espacio de nombres de <see cref="T:System.Type" />. Este campo es de solo lectura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa una matriz vacía de tipo <see cref="T:System.Type" />. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código muestra la `EmptyTypes` campo utilizado en uno de los `GetConstructor` métodos para obtener un constructor que no toma ningún parámetro.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si el tipo del sistema subyacente del objeto <see cref="T:System.Type" /> actual coincide con el tipo del sistema subyacente del objeto <see cref="T:System.Object" /> o <see cref="T:System.Type" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Objeto cuyo tipo de sistema subyacente se va a comparar con el tipo de sistema subyacente del objeto <see cref="T:System.Type" /> actual. Para que la comparación se realice correctamente, <c>o</c> debe poder convertirse en un objeto de tipo <see cref="T:System.Type" />.</param>
        <summary>Determina si el tipo del sistema subyacente del objeto <see cref="T:System.Type" /> actual es el mismo que el tipo del sistema subyacente del objeto <see cref="T:System.Object" /> especificado.</summary>
        <returns>Es <see langword="true" /> si el tipo del sistema subyacente de <paramref name="o" /> coincide con el tipo del sistema subyacente del objeto <see cref="T:System.Type" /> actual; de lo contrario, es <see langword="false" />. Este método también devuelve <see langword="false" /> si:  
  El valor de 
-   <paramref name="o" /> es <see langword="null" />.  
  
-   <paramref name="o" /> no se puede convertir en un objeto <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Proyecta `o` a un objeto de tipo <xref:System.Type> y llama a la <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Type.Equals%28System.Object%29> para comparar varios <xref:System.Type> instancias con distintos de un objeto <xref:System.Object> instancias.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Dos cosas son especialmente que vale la pena tener en cuenta sobre el ejemplo:  
  
-   La comparación de un <xref:System.Type> objeto que representa un entero con un <xref:System.Reflection.TypeInfo> objeto que representa un valor devuelto entero `true` porque <xref:System.Reflection.TypeInfo> se deriva de <xref:System.Type>.  
  
-   La comparación de un <xref:System.Type> objeto que representa un <xref:System.Collections.Generic.IList%601> objeto (un tipo genérico abierto) con un `List(Of String)` devuelve el objeto (un tipo genérico cerrado) `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Objeto cuyo tipo de sistema subyacente se va a comparar con el tipo de sistema subyacente del objeto <see cref="T:System.Type" /> actual.</param>
        <summary>Determina si el tipo de sistema subyacente del objeto <see cref="T:System.Type" /> actual es igual que el tipo de sistema subyacente del objeto <see cref="T:System.Type" /> especificado.</summary>
        <returns>Es <see langword="true" /> si el tipo del sistema subyacente de <paramref name="o" /> coincide con el tipo del sistema subyacente del objeto <see cref="T:System.Type" /> actual; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se usa `Equals` para comparar dos tipos.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el filtro de miembros que se usa para los atributos. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo contiene una referencia al delegado usado por el <xref:System.Type.FindMembers%2A> método. El método encapsulado por este delegado toma dos parámetros: el primero es un <xref:System.Reflection.MemberInfo> objeto y el segundo es un `Object`. El método determina si el `MemberInfo` objeto coincide con los criterios especificados por el `Object`. El `Object` puede tener asignado el valor de uno de los campos en las clases <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, o <xref:System.Reflection.MethodImplAttributes>.  
  
 Por ejemplo, el `Object` se puede asignar el valor de un campo de `FieldAttributes` como Public. En ese caso, cuando el `FilterAttribute` delegado se invoca, devolverá `true` sólo si el método representado por la `MemberInfo` objeto está decorado con el atributo de campo público en los metadatos.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el `FilterAttribute` delegado, lo pasa como un parámetro a la <xref:System.Type.FindMembers%2A> método y muestra los miembros especificados y sus atributos.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el filtro de miembros que distingue mayúsculas de minúsculas y que se aplica a los nombres. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo contiene una referencia al delegado usado por el <xref:System.Type.FindMembers%2A> método. El método encapsulado por este delegado toma dos parámetros: el primero es un <xref:System.Reflection.MemberInfo> objeto y el segundo es un `Object`. El método determina si el `MemberInfo` objeto coincide con los criterios especificados por el `Object`. El `Object` se asigna un valor de cadena, que puede incluir un carácter "*" carácter comodín. Coincidencia de cadenas de final de carácter comodín solo se admite.  
  
 Por ejemplo, el `Object` puede tener asignado el valor "Byte *". En ese caso, cuando el `FilterName` delegado se invoca, devolverá `true` sólo si el método representado por la `MemberInfo` objeto tiene un nombre que comienza con "Bytes".  
  
   
  
## Examples  
 El ejemplo de código siguiente obtiene los métodos asociados con el definido por el usuario `Application` tipo.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el filtro de miembros que no distingue mayúsculas de minúsculas y que se aplica a los nombres. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo contiene una referencia al delegado usado por el <xref:System.Type.FindMembers%2A> método. El método encapsulado por este delegado toma dos parámetros: el primero es un <xref:System.Reflection.MemberInfo> objeto y el segundo es un `Object`. El método determina si el `MemberInfo` objeto coincide con los criterios especificados por el `Object`. El `Object` se asigna un valor de cadena, que puede incluir un carácter "*" carácter comodín. Coincidencia de cadenas de final de carácter comodín solo se admite.  
  
 Por ejemplo, el `Object` puede tener asignado el valor "ByTe *". En ese caso, cuando el `FilterName` delegado se invoca, devolverá true solo si el método representado por la `MemberInfo` objeto tiene un nombre que comienza con "bytes", mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el `MemberFilter` delegado, lo pasa como un parámetro a la <xref:System.Type.FindMembers%2A> método y muestra los métodos y los atributos de la `String` clase que comienzan por la letra "c", omitiendo el caso.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">Delegado que compara las interfaces con <c>filterCriteria</c>.</param>
        <param name="filterCriteria">Criterios de búsqueda que determinan si una interfaz se debe incluir en la matriz devuelta.</param>
        <summary>Devuelve una matriz de objetos <see cref="T:System.Type" /> que representa una lista filtrada de interfaces implementadas o heredadas por el objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Type" /> que representa una lista filtrada de las interfaces implementadas o heredadas por el <see cref="T:System.Type" /> actual, o una matriz vacía de tipo <see cref="T:System.Type" /> si no hay ninguna interfaz que coincida con el filtro y que haya sido implementada o heredada por el <see cref="T:System.Type" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada.  
  
 El <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> y <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegados proporcionados por el <xref:System.Reflection.Module?displayProperty=nameWithType> clase también puede utilizarse, en lugar de la <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegar.  
  
 Todas las interfaces implementadas por esta clase se consideran durante la búsqueda, si declara una clase base o esta misma clase.  
  
 Este método busca en la jerarquía de clases base, devolver interfaces cada una de las interfaces coincidentes de cada clase implementa, así como la coincidencia de cada uno de esos implementa interfaces (es decir, se devuelve el cierre transitivo de las interfaces coincidentes). No hay ninguna interfaz duplicada se devuelve.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, <xref:System.Type.FindInterfaces%2A> busca todas las interfaces declaradas en las restricciones del parámetro de tipo, y todas las interfaces heredadas a través de interfaces declarado en las restricciones. Si el actual <xref:System.Type> representa un argumento de tipo de un tipo genérico, <xref:System.Type.FindInterfaces%2A> busca todas las interfaces implementadas por el tipo, si no coinciden con las restricciones.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> puede devolver interfaces genéricas, incluso en los tipos que no son genéricas. Por ejemplo, podría implementar un tipo no genérico `IEnumerable<int>` (`IEnumerable(Of Integer)` en Visual Basic).  
  
   
  
## Examples  
 En el ejemplo siguiente se busca la interfaz especificada implementada o heredada por el tipo especificado y, a continuación, muestra los nombres de interfaz.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador estático y produce una excepción.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">Objeto que indica el tipo de miembro que se va a buscar.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <param name="filter">Delegado que realiza las comparaciones y que devuelve <see langword="true" /> si el miembro inspeccionado coincide con <c>filterCriteria</c> y <see langword="false" /> en caso contrario. Es posible usar los delegados <see langword="FilterAttribute" />, <see langword="FilterName" /> y <see langword="FilterNameIgnoreCase" /> que esta clase proporciona. El primero usa los campos de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> y <see langword="MethodImplAttributes" /> como criterios de búsqueda, y los otros dos usan objetos <see langword="String" /> como criterios de búsqueda.</param>
        <param name="filterCriteria">Criterios de búsqueda que determinan si se devuelve un miembro en la matriz de objetos <see langword="MemberInfo" />.  
  
Los campos de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> y <see langword="MethodImplAttributes" /> se pueden usar junto con el delegado <see langword="FilterAttribute" /> que esta clase proporciona.</param>
        <summary>Devuelve una matriz filtrada de objetos <see cref="T:System.Reflection.MemberInfo" /> del tipo del miembro especificado.</summary>
        <returns>Matriz filtrada de objetos <see cref="T:System.Reflection.MemberInfo" /> del tipo del miembro especificado.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.MemberInfo" /> en caso de que el objeto <see cref="T:System.Type" /> actual no tenga miembros del tipo <paramref name="memberType" /> que coincidan con los criterios del filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada.  
  
 Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Instance` para incluir los miembros de instancia en la búsqueda.  
  
-   Especificar `BindingFlags.Static` para incluir los miembros estáticos en la búsqueda.  
  
-   Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Los valores válidos para <xref:System.Type.MemberType%2A> se definen en <xref:System.Reflection.MemberInfo>. Si dichos miembros no se encuentran, se devuelve una matriz vacía.  
  
 Para obtener el inicializador de clase (.cctor) con este método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico o un método genérico, <xref:System.Type.FindMembers%2A> procesa los miembros declarados por la restricción de clase y las restricciones del parámetro de tipo de interfaz.  
  
   
  
## Examples  
 El ejemplo siguiente busca a todos los miembros de una clase que coinciden con los criterios de búsqueda especificado y, a continuación, muestra a los miembros coincidentes.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre completo del tipo, incluido su espacio de nombres, pero no su ensamblado.</summary>
        <value>Nombre completo del tipo, con espacio de nombres y sin ensamblado; o bien, <see langword="null" /> si la instancia actual representa un parámetro de tipo genérico, un tipo de matriz, un tipo de puntero o un tipo <see langword="byref" /> basado en un parámetro de tipo, o un tipo genérico que no sea una definición de tipo genérico, pero que contenga parámetros de tipo sin resolver.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por ejemplo, el nombre completo de la <xref:System.String> es de tipo `System.String`. Compare esto con el nombre completo del ensamblado devuelto por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, compuesto por el nombre completo más el nombre completo del ensamblado.  
  
 Si el tipo actual representa un tipo genérico cerrado, los argumentos de tipo en la cadena devuelven por la <xref:System.Type.FullName%2A> propiedad se califican por su nombre completo del ensamblado, aunque la representación de cadena del tipo genérico en sí no está calificada con su completo nombre del ensamblado. El ejemplo siguiente muestra la diferencia en la propiedad FullName para un tipo que representa la definición de tipo genérico y otro que representa un tipo genérico cerrado.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Esta propiedad devuelve `null` si:  
  
-   Actual <xref:System.Type> objeto representa un parámetro de tipo de un tipo genérico.  
  
     En el ejemplo siguiente se recupera el parámetro de tipo de la <xref:System.Nullable%601> tipo e intenta mostrar su <xref:System.Type.FullName%2A> propiedad.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Actual <xref:System.Type> objeto representa un tipo de matriz, un tipo de puntero, o un `byref` tipo que se basa en un parámetro de tipo genérico.  
  
     En el ejemplo siguiente se define un tipo genérico, `Generictype1<T>`, con tres métodos: `Display(T[])`, que se pasa una matriz de tipo T; `HandleT(T)`, que se pasa un objeto T; y `ChangeValue(ref T)`, un objeto T que se pasa por referencia. Dado que C# y Visual Basic no nos permiten definir T como un puntero en el `HandleT` método, se debe llamar a la <xref:System.Type.MakePointerType%2A> método en el <xref:System.Type> objeto que representa el tipo de parámetro del método para crear un puntero a un tipo genérico. El resultado del ejemplo muestra en los tres casos, el <xref:System.Type.FullName%2A> propiedad es `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   El tipo actual contiene parámetros de tipo genérico que no han sido reemplazados por tipos específicos (es decir, el <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `true`), pero el tipo no es una definición de tipo genérico (es decir, el <xref:System.Type.IsGenericTypeDefinition%2A> devuelve de la propiedad `false`  
  
     En el ejemplo siguiente, `Derived<T>` hereda de `Base<T>`. El <xref:System.Type.BaseType%2A> propiedad obtiene el <xref:System.Type> objeto que representa el tipo base del `Derived<T>`y su <xref:System.Type.FullName%2A> propiedad devuelve `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Para obtener un <xref:System.Type.FullName%2A> que no es `null`, puede usar el <xref:System.Type.GetGenericTypeDefinition%2A> método para obtener la definición de tipo genérico, como se muestra en el ejemplo siguiente.  
  
 Esta propiedad es de sólo lectura.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el nombre completo del tipo especificado.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 En el ejemplo siguiente se comparan las cadenas devueltas por la <xref:System.Type.ToString%2A> método y el `Name`, <xref:System.Type.FullName%2A>, y <xref:System.Type.AssemblyQualifiedName%2A> propiedades.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una combinación de marcas <see cref="T:System.Reflection.GenericParameterAttributes" /> que describen la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</summary>
        <value>Combinación bit a bit de valores de <see cref="T:System.Reflection.GenericParameterAttributes" /> que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta propiedad contiene las marcas que describen si el parámetro de tipo genérico actual es covariante y las marcas que describen las restricciones especiales. Utilice la <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> valor para seleccionar los indicadores de covarianza y usar el <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> valor para seleccionar los indicadores de restricción.  
  
 Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente define un tipo genérico `Test` con dos parámetros de tipo que tienen distintas restricciones. Cuando se ejecuta el programa, se examinan las restricciones mediante la <xref:System.Type.GenericParameterAttributes%2A> propiedad y el <xref:System.Type.GetGenericParameterConstraints%2A> método.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Type" /> actual no es un parámetro de tipo genérico. Es decir, la propiedad <see cref="P:System.Type.IsGenericParameter" /> devuelve <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la posición del parámetro de tipo en la lista de parámetros de tipo del tipo o método genérico que declaró el parámetro, siempre que el objeto <see cref="T:System.Type" /> represente un parámetro de tipo de un tipo genérico o de un método genérico.</summary>
        <value>Posición de un parámetro de tipo en la lista de parámetros de tipo del método o tipo genérico que define el parámetro. Los números de posición comienzan en 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GenericParameterPosition%2A> propiedad devuelve la posición de un parámetro de tipo en la lista de parámetros de la definición de tipo genérico o una definición de método genérico donde se definió originalmente el parámetro de tipo. El <xref:System.Type.DeclaringType%2A> y <xref:System.Type.DeclaringMethod%2A> propiedades identifican la definición de tipo o método genérico:  
  
-   Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve un <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa una definición de método genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de esa definición de método genérico.  
  
-   Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve `null`, el <xref:System.Type.DeclaringType%2A> propiedad siempre devuelve un <xref:System.Type> objeto que representa una definición de tipo genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de ese tipo genérico definición.  
  
 Para proporcionar el contexto correcto para el valor de la <xref:System.Type.GenericParameterPosition%2A> propiedad, es necesario identificar el tipo o método genérico al que pertenece un parámetro de tipo. Por ejemplo, considere el valor devuelto del método genérico `GetSomething` en el código siguiente:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 El tipo devuelto por `GetSomething` depende de los argumentos de tipo proporcionados a la clase `A` y `GetSomething` propio. Puede obtener un <xref:System.Reflection.MethodInfo> para `GetSomething`, y desde el que se puede obtener el tipo de valor devuelto. Al examinar los parámetros de tipo del tipo de valor devuelto, <xref:System.Type.GenericParameterPosition%2A> devuelve 0 para ambos. La posición de `V` es 0 porque `V` es el primer parámetro de tipo en la lista de parámetros de tipo para la clase `A`. La posición de `X` es 0 porque `X` es el primer parámetro de tipo en la lista de parámetros de tipo `GetSomething`.  
  
> [!NOTE]
>  Una llamada a la <xref:System.Type.GenericParameterPosition%2A> propiedad produce una excepción si el actual <xref:System.Type> no representa un parámetro de tipo. Al examinar los argumentos de tipo de un tipo construido abierto, use el <xref:System.Type.IsGenericParameter%2A> propiedad para indicar que son parámetros de tipo y cuáles son los tipos. El <xref:System.Type.IsGenericParameter%2A> propiedad devuelve `true` para un parámetro de tipo; a continuación, puede usar el <xref:System.Type.GenericParameterPosition%2A> método obtener su posición y utilizar el <xref:System.Type.DeclaringMethod%2A> y <xref:System.Type.DeclaringType%2A> propiedades para determinar el método genérico o que lo define la definición de tipo .  
  
   
  
## Examples  
 El ejemplo siguiente define una clase genérica con dos parámetros de tipo y define una segunda clase genérica que se deriva de la primera clase. Clase base de la clase derivada tiene dos argumentos de tipo: el primero es <xref:System.Int32>, y el segundo es un parámetro de tipo del tipo derivado. En el ejemplo se muestra información acerca de estas clases genéricas, incluidas las posiciones notifican por el <xref:System.Type.GenericParameterPosition%2A> propiedad.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo actual no representa un parámetro de tipo. Es decir, <see cref="P:System.Type.IsGenericParameter" /> devuelve <see langword="false" />.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una matriz de los argumentos de tipo genérico para este tipo.</summary>
        <value>Una matriz de argumentos de tipo genérico para este tipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad obtiene solo los argumentos de tipo genérico; es decir, los tipos que se han especificado para los parámetros de tipo genérico del tipo actual. Si el tipo actual es una definición de tipo genérico, esta propiedad devuelve una matriz vacía.  
  
> [!NOTE]
>  Si se usa un tipo genérico en un método genérico o en otro tipo genérico, algunos de sus argumentos de tipo genérico podrían ser parámetros de tipo genérico del método o tipo envolvente.  
  
 Para obtener los parámetros de tipo genérico de un tipo que representa una definición de tipo genérico, use el <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> propiedad. Para obtener un <xref:System.Reflection.TypeInfo> objeto actual <xref:System.Type> de objeto, utilice el <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> método de extensión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número de dimensiones de una matriz.</summary>
        <returns>Entero que contiene el número de dimensiones del tipo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el número de dimensiones en una matriz.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La funcionalidad de este método no se admite en la clase base y debe implementarse en una clase derivada.</exception>
        <exception cref="T:System.ArgumentException">El tipo actual no es una matriz.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.Attributes" /> y obtiene una máscara de bits que indica los atributos asociados a <see cref="T:System.Type" />.</summary>
        <returns>Objeto <see cref="T:System.Reflection.TypeAttributes" /> que representa el conjunto de atributos de <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un constructor específico del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de los parámetros del constructor deseado.  
  
O bien 
Matriz vacía de objetos <see cref="T:System.Type" />, para obtener un constructor que no requiera parámetros. El campo <see langword="static" /><see cref="F:System.Type.EmptyTypes" /> proporciona dicha matriz vacía.</param>
        <summary>Busca un constructor de instancia público cuyos parámetros coincidan con los tipos de la matriz especificada.</summary>
        <returns>Objeto que representa el constructor de instancia público cuyos parámetros coinciden con los tipos de la matriz de tipos de parámetro, si se encuentra; de lo contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del método busca constructores de instancia públicos y no se puede usar para obtener a un inicializador de clase (.cctor). Para obtener un inicializador de clase, use una sobrecarga que toma <xref:System.Reflection.BindingFlags>y especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 Si el constructor solicitado no es público, este método devuelve `null`.  
  
> [!NOTE]
>  No se puede omitir los parámetros al buscar los constructores y métodos. Solo puede omitir los parámetros al invocar.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado. Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método siempre devuelve `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el tipo de `MyClass`, obtiene el <xref:System.Reflection.ConstructorInfo> de objetos y muestra la firma del constructor.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> es <see langword="null" />.  
  
O bien 
Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el constructor debe obtener.  
  
O bien 
Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener un constructor que no requiera parámetros.  
  
O bien 
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz de tipo de parámetro. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Busca un constructor cuyos parámetros coincidan con los tipos y modificadores de argumento especificados, mediante las restricciones de enlace también especificadas.</summary>
        <returns>Objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no existe una coincidencia exacta, la `binder` intentará convertir los tipos de parámetro especificados en la `types` matriz para seleccionar una coincidencia. Si el `binder` no puede seleccionar una coincidencia, a continuación, `null` se devuelve.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los constructores que deben incluirse en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir los constructores públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
> [!NOTE]
>  No se puede omitir los parámetros al buscar los constructores y métodos. Solo puede omitir los parámetros al invocar.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado. Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método siempre devuelve `null`.  
  
   
  
## Examples  
 El programa siguiente obtiene el tipo de `MyClass1` clase, obtiene el <xref:System.Reflection.ConstructorInfo> coincidencia de las marcas de enlace especificado de objetos y muestra la firma del constructor.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> es <see langword="null" />.  
  
O bien 
Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.  
  
O bien 
 <paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Objeto que especifica el conjunto de reglas que se va a usar en cuanto al orden y al diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y la pila que se limpia.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el constructor debe obtener.  
  
O bien 
Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener un constructor que no requiera parámetros.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>types</c>. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Busca un constructor cuyos parámetros coincidan con los modificadores y tipos de argumento especificados, mediante las restricciones de enlace indicadas y la convención de llamadas también especificada.</summary>
        <returns>Objeto que representa el constructor que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 Si no existe una coincidencia exacta, la `binder` intentará convertir los tipos de parámetro especificados en la `types` matriz para seleccionar una coincidencia. Si el `binder` no puede seleccionar una coincidencia, a continuación, `null` se devuelve.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los constructores que deben incluirse en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir los constructores públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Para obtener el inicializador de clase (.cctor) con este método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
> [!NOTE]
>  No se puede omitir los parámetros al buscar los constructores y métodos. Solo puede omitir los parámetros al invocar.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado. Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método siempre devuelve `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el tipo de `MyClass1`, obtiene el <xref:System.Reflection.ConstructorInfo> objeto que coincide con las marcas de enlace especificadas y muestra la firma del constructor.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> es <see langword="null" />.  
  
O bien 
Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.  
  
O bien 
 <paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Objeto que especifica el conjunto de reglas que se va a usar en cuanto al orden y al diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y la pila que se limpia.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el constructor debe obtener.  
  
O bien 
Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener un constructor que no requiera parámetros.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>types</c>. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Cuando se invalida en una clase derivada, busca un constructor cuyos parámetros coincidan con los tipos y modificadores de argumento especificados, y aplica las restricciones de enlace especificadas y la convención de llamadas especificada.</summary>
        <returns>Objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 Si no existe una coincidencia exacta, la `binder` intentará convertir los tipos de parámetro especificados en la `types` matriz para seleccionar una coincidencia. Si el `binder` no puede seleccionar una coincidencia, a continuación, `null` se devuelve.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los constructores que deben incluirse en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir los constructores públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Este método implementa <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> es <see langword="null" />.  
  
O bien 
Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.  
  
O bien 
 <paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</exception>
        <exception cref="T:System.NotSupportedException">El tipo actual es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene los constructores del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve todos los constructores públicos definidos para el objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representan todos los constructores de instancias públicos definidos para el objeto <see cref="T:System.Type" /> actual, pero sin incluir el inicializador de tipo (constructor estático). Si no se han definido constructores de instancia públicos para el objeto <see cref="T:System.Type" /> actual o si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo en la definición de un tipo genérico o de un método genérico, se devuelve una matriz vacía de tipo <see cref="T:System.Reflection.ConstructorInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetConstructors%2A> método no devuelve los constructores en un orden determinado, por ejemplo, el orden de declaración. El código no debe depender del orden en que se devuelven los constructores, porque ese orden varía.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Esta sobrecarga del método llama a la <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarga del método, con <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> en Visual Basic). No encontrará a inicializadores de clase (.cctor). Para buscar los inicializadores de clase, use una sobrecarga que toma <xref:System.Reflection.BindingFlags>y especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado. Por ejemplo, si clase `C<T>` tiene un constructor `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), que realiza la llamada <xref:System.Type.GetConstructors%2A> en `C<int>` devuelve un <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` en C# (`Sub New(ByVal t1 As Integer)` en Visual Basic).  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo genérico, la <xref:System.Type.GetConstructors%2A> método devuelve una matriz vacía.  
  
   
  
## Examples  
 En este ejemplo se muestra la salida de la <xref:System.Type.GetConstructors%2A> sobrecarga de una clase que tiene dos constructores de instancia y un constructor estático.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 El resultado de este código es:  
  
 2  
  
 False  
  
 False  
  
 Dado que el <xref:System.Type.GetConstructors> sobrecarga se utiliza solo <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> y <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, el constructor estático no se calcula mediante la `for` expresión ni se evalúa con `IsStatic`.  
  
 Para buscar los constructores estáticos, utilice el <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarga y pase la combinación (lógico `OR`) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, tal y como se muestra en el ejemplo de código siguiente:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Ahora, el resultado es:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, busca los constructores definidos para el objeto <see cref="T:System.Type" /> actual, con las enumeraciones <see langword="BindingFlags" /> especificadas.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representa todos los constructores definidos para el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas, incluido el inicializador de tipo si está definido. Devuelve una matriz vacía de tipo <see cref="T:System.Reflection.ConstructorInfo" /> si no se definen constructores para el objeto <see cref="T:System.Type" /> actual, si ninguno de los constructores definidos cumple las restricciones de enlace o si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo en la definición de un tipo genérico o de un método genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetConstructors%2A> método no devuelve los constructores en un orden determinado, por ejemplo, el orden de declaración. El código no debe depender del orden en que se devuelven los constructores, porque ese orden varía.  
  
 `bindingAttr` puede usarse para especificar si se deben devolver sólo los constructores públicos o constructores públicos y no públicos.  
  
 Si no existe una coincidencia exacta, la `binder` intentará convertir los tipos de parámetro especificados en la `types` matriz para seleccionar una coincidencia. Si el `binder` no puede seleccionar una coincidencia, a continuación, `null` se devuelve.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los constructores que deben incluirse en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir los constructores públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda. No se devuelven los constructores de clases bases.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado. Por ejemplo, si clase `C<T>` tiene un constructor `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), que realiza la llamada <xref:System.Type.GetConstructors%2A> en `C<int>` devuelve un <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` en C# (`Sub New(ByVal t1 As Integer)` en Visual Basic).  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo genérico, la <xref:System.Type.GetConstructors%2A> método devuelve una matriz vacía.  
  
   
  
## Examples  
 En este ejemplo se muestra la salida de la <xref:System.Type.GetConstructors> sobrecarga de una clase que tiene dos constructores de instancia y un constructor estático.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 El resultado de este código es:  
  
 2  
  
 False  
  
 False  
  
 Dado que el <xref:System.Type.GetConstructors%2A> sobrecarga se utiliza solo <xref:System.Reflection.BindingFlags.Public> y <xref:System.Reflection.BindingFlags.Instance>, el constructor estático no se calcula mediante la `for` expresión ni se evalúa con `IsStatic`.  
  
 Para buscar los constructores estáticos, utilice el <xref:System.Type.GetConstructors%2A> sobrecarga y pásele la combinación (OR lógico) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, tal y como se muestra en el ejemplo de código siguiente:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Ahora, el resultado es:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Busca los miembros definidos para el objeto <see cref="T:System.Type" /> actual cuya clase <see cref="T:System.Reflection.DefaultMemberAttribute" /> esté establecida.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos los miembros predeterminados del objeto <see cref="T:System.Type" /> actual.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.MemberInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene miembros predeterminados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetDefaultMembers%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración. El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.  
  
 Este método puede reemplazarse por una clase derivada.  
  
 Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado. Por ejemplo, si clase `C<T>` tiene una propiedad `P` que devuelve `T`, al llamar a <xref:System.Type.GetDefaultMembers%2A> en `C<int>` devuelve `int P` en C# (`Property P As Integer` en Visual Basic).  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene la información del miembro predeterminado de `MyClass` y muestra los miembros predeterminados.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, devuelve la clase <see cref="T:System.Type" /> del objeto englobado o al que hace referencia la matriz, el puntero o el tipo de referencia actual.</summary>
        <returns>
          <see cref="T:System.Type" /> del objeto englobado o al que hace referencia la matriz, puntero o tipo de referencia actual; o bien, <see langword="null" /> si el objeto <see cref="T:System.Type" /> actual no es una matriz o un puntero, o si no se pasa por referencia, o si representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o de un método genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve `null` para el <xref:System.Array> clase.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo utilizar el `GetElementType` método.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valor cuyo nombre se va a recuperar.</param>
        <summary>Devuelve el nombre de la constante que tiene el valor especificado para el tipo de enumeración actual.</summary>
        <returns>Nombre del miembro del tipo de enumeración actual que tiene el valor especificado o <see langword="null" /> si no se encuentra tal constante.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El tipo actual no es una enumeración.  
  
O bien 
 <paramref name="value" /> no es ni de tipo actual ni tiene el mismo tipo subyacente que el tipo actual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve los nombres de los miembros del tipo de enumeración actual.</summary>
        <returns>Una matriz que contiene los nombres de los miembros de la enumeración.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos de la matriz de valores devueltos se ordenan por los valores binarios (es decir, los valores sin signo) de las constantes enumeradas. Si la matriz contiene constantes enumeradas con el mismo valor, se especifica el orden de los nombres correspondientes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tipo actual no es una enumeración.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el tipo subyacente del tipo de enumeración actual.</summary>
        <returns>Tipo subyacente de la enumeración actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, el tipo subyacente de una enumeración en C# y Visual Basic es <xref:System.Int32>. Se pueden especificar otros tipos de enteros.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tipo actual no es una enumeración.  
  
O bien 
El tipo de enumeración no es válido, ya que contiene más de un campo de instancia.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz con los valores de las constantes en el tipo de enumeración actual.</summary>
        <returns>Matriz que contiene los valores. Los elementos de la matriz se ordenan en función de los valores binarios (es decir, los valores sin firmar) de las constantes de enumeración.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El tipo actual no es una enumeración.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un evento específico declarado o heredado por el objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de un evento que la clase <see cref="T:System.Type" /> actual declaró o heredó.</param>
        <summary>Devuelve el objeto <see cref="T:System.Reflection.EventInfo" /> que representa el evento público especificado.</summary>
        <returns>Objeto que representa el evento público especificado que declara o hereda el <see cref="T:System.Type" /> actual, si se encuentra; de lo contrario es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un evento se considera público para la reflexión si tiene al menos un método o un descriptor de acceso público. En caso contrario, el evento se considera privado, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye los eventos de instancia pública de static y public.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.EventInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los eventos de la restricción de clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Reflection.EventInfo> de objetos y obtiene el evento de una clase de botón para el evento especificado.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de un evento que la clase <see cref="T:System.Type" /> actual declara o hereda.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, devuelve el objeto <see cref="T:System.Reflection.EventInfo" /> que representa el evento especificado y aplica las restricciones de enlace especificadas.</summary>
        <returns>Objeto que representa el evento especificado que declara o hereda el <see cref="T:System.Type" /> actual, si se encuentra; de lo contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los eventos que se va a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir eventos públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir eventos no públicos (es decir, los eventos protegidos, internos y privados) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo los eventos declarados en el <xref:System.Type>, no los eventos que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Un evento se considera público para la reflexión si tiene al menos un método o un descriptor de acceso público. En caso contrario, el evento se considera privado, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.EventInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los eventos de la restricción de clase.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> para buscar un tipo para un evento público o no público denominado "Click" que no sea `static` (`Shared` en Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene los eventos declarados o heredados por el objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve todos los eventos públicos declarados o heredados por el objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa todos los eventos públicos declarados o heredados por el objeto <see cref="T:System.Type" /> actual.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.EventInfo" /> si el objeto actual <see cref="T:System.Type" /> no tiene eventos públicos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un evento se considera público para la reflexión si tiene al menos un método o un descriptor de acceso público. En caso contrario, el evento se considera privado, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 El <xref:System.Type.GetEvents%2A> método no devuelve eventos en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven los eventos, porque ese orden varía.  
  
 Este método puede reemplazarse por una clase derivada.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.EventInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los eventos de la restricción de clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene una matriz de <xref:System.Reflection.EventInfo> los objetos, obtiene todos los eventos de un `Button` clase y muestra los nombres de evento. Para compilar el ejemplo de Visual Basic, use la siguiente línea de comandos:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, busca los eventos declarados o heredados por el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa todos los eventos declarados o heredados por el objeto <see cref="T:System.Type" /> actual que cumplen las restricciones de enlace especificadas.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.EventInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene eventos o si ninguno de los eventos coincide con las restricciones de enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetEvents%2A> método no devuelve eventos en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven los eventos, porque ese orden varía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los eventos que se va a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir eventos públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir eventos no públicos (es decir, los eventos protegidos, internos y privados) en la búsqueda. Solo se devuelven eventos internos de las clases base; y protegidos no se devuelven los eventos privados de clases base.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo los eventos declarados en el <xref:System.Type>, no los eventos que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Un evento se considera público para la reflexión si tiene al menos un método o un descriptor de acceso público. En caso contrario, el evento se considera privado, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.EventInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los eventos de la restricción de clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene una matriz de <xref:System.Reflection.EventInfo> objetos que coinciden con las marcas de enlace especificadas, obtiene todos los eventos de un `Button` clase y muestra los nombres de evento. Para compilar el ejemplo de Visual Basic, use la siguiente línea de comandos:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un campo específico del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del campo de datos que se va a obtener.</param>
        <summary>Busca el campo público con el nombre especificado.</summary>
        <returns>Objeto que representa el campo público con el nombre especificado, si se encuentra; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye los campos de instancia públicos y estáticos públicos.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.FieldInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los campos de la restricción de clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el `Type` de objeto para la clase especificada, se obtiene el <xref:System.Reflection.FieldInfo> objeto para el campo y muestra el valor del campo.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Este objeto <see cref="T:System.Type" /> es <see cref="T:System.Reflection.Emit.TypeBuilder" /> a cuyo método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> aún no se ha llamado.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del campo de datos que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Busca el campo especificado mediante las restricciones de enlace especificadas.</summary>
        <returns>Objeto que representa el campo que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir qué campos desea incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir campos públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir campos no públicos (es decir, campos privados, internos y protegidos) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar solo los campos declarados en el <xref:System.Type>, no los campos que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.FieldInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los campos de la restricción de clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el `Type` de objeto para la clase especificada, se obtiene el <xref:System.Reflection.FieldInfo> objeto para el campo que coincide con las marcas de enlace especificadas y muestra el valor del campo.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene los campos del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve todos los campos públicos del objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa todos los campos públicos definidos para el objeto <see cref="T:System.Type" /> actual.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.FieldInfo" /> si no hay campos públicos definidos para el objeto <see cref="T:System.Type" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetFields%2A> método no devuelve los campos en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven los campos, porque ese orden varía.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.FieldInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los campos públicos de la restricción de clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de la `GetFields()` método.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, busca los campos definidos para el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa todos los campos definidos para el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.FieldInfo" /> si no se han definido campos para el objeto <see cref="T:System.Type" /> actual o si ninguno de los campos definidos coincide con las restricciones de enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetFields%2A> método no devuelve los campos en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven los campos, porque ese orden varía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir qué campos desea incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir campos públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir campos no públicos (es decir, campos privados, internos y protegidos) en la búsqueda. Solo protegido y se devuelven los campos internos en las clases base; no se devuelven los campos privados de las clases base.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.DeclaredOnly` para buscar solo los campos declarados en el <xref:System.Type>, no los campos que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.FieldInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los campos públicos de la restricción de clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de la `GetFields(BindingFlags)` método.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</summary>
        <returns>Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un tipo genérico. Devuelve una matriz vacía si el tipo actual no es un tipo genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos de matriz se devuelven en el orden en que aparecen en la lista de argumentos de tipo para el tipo genérico.  
  
-   Si el tipo actual es un tipo construido cerrado (es decir, el <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `false`), la matriz devuelta por la <xref:System.Type.GetGenericArguments%2A> método contiene los tipos que se han asignado a los parámetros de tipo genérico de la definición de tipo genérico .  
  
-   Si el tipo actual es una definición de tipo genérico, la matriz contiene los parámetros de tipo.  
  
-   Si el tipo actual es un tipo construido abierto (es decir, el <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `true`) en los tipos específicos no se asignaron a todos los parámetros de tipo y parámetros de tipo envolvente métodos ni tipos genéricos, contiene la matriz tipos y parámetros de tipo. Use el <xref:System.Type.IsGenericParameter%2A> propiedad para distinguirlos. Para ver una demostración de este escenario, vea el ejemplo de código para el <xref:System.Type.ContainsGenericParameters%2A> propiedad.  
  
 Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Type.GetGenericArguments%2A> método para mostrar los argumentos de tipo de un tipo construido y los parámetros de tipo de su definición de tipo genérico.  
  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Type.IsGenericTypeDefinition%2A> propiedad. Vea el ejemplo más extenso de salida de ejemplo.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base. Las clases derivadas deben proporcionar una implementación.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan las restricciones en el parámetro de tipo genérico actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Type" /> que representan las restricciones en el parámetro de tipo genérico actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada restricción en un parámetro de tipo genérico se expresa como un <xref:System.Type> objeto. Use la <xref:System.Type.IsClass%2A> propiedad para determinar si una restricción es la restricción de clase base; si la propiedad devuelve `false`, la restricción es una restricción de interfaz. Si un parámetro de tipo tiene ninguna restricción de clase y no hay restricciones de interfaz, se devuelve una matriz vacía.  
  
 Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente define un tipo genérico `Test` con dos parámetros de tipo que tienen distintas restricciones. Cuando se ejecuta el programa, se examinan las restricciones mediante la <xref:System.Type.GenericParameterAttributes%2A> propiedad y el <xref:System.Type.GetGenericParameterConstraints%2A> método.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Type" /> actual no es un parámetro de tipo genérico. Es decir, la propiedad <see cref="P:System.Type.IsGenericParameter" /> devuelve <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede construir el tipo genérico actual.</summary>
        <returns>Objeto <see cref="T:System.Type" /> que representa un tipo genérico a partir del cual se puede construir el tipo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una definición de tipo genérico es una plantilla desde el que se pueden construir otros tipos. Por ejemplo, desde la definición de tipo genérico `G<T>` (expresada en sintaxis de C#; `G(Of T)` en Visual Basic o `generic <typename T> ref class G` en C++) puede construir y crear instancias del tipo `G<int>` (`G(Of Integer)` en Visual Basic). Dado un <xref:System.Type> construido de objeto que representa este tipo, el <xref:System.Type.GetGenericTypeDefinition%2A> método devuelve la definición de tipo genérico.  
  
 Si se crean dos tipos construidos desde la misma definición de tipo genérico, con los mismos argumentos de tipo, el <xref:System.Type.GetGenericTypeDefinition%2A> que devuelve el mismo método <xref:System.Type> objeto para ambos tipos.  
  
 Si se llama a la <xref:System.Type.GetGenericTypeDefinition%2A> método en un <xref:System.Type> objeto que ya representa una definición de tipo genérico, devuelve el valor actual <xref:System.Type>.  
  
> [!IMPORTANT]
>  Una matriz de tipos genéricos no es genérico en sí mismo. En el código de C# `A<int>[] v;` o el código de Visual Basic `Dim v() As A(Of Integer)`, el tipo de variable `v` no es genérico. Use <xref:System.Type.IsGenericType%2A> para determinar si un tipo es genérico antes de llamar a <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una instancia de un tipo construido mediante la creación de la instancia normal y, a continuación, usa el <xref:System.Type.GetType%2A> y <xref:System.Type.GetGenericTypeDefinition%2A> métodos para recuperar el tipo construido y la definición de tipo genérico. Este ejemplo usa el modelo genérico <xref:System.Collections.Generic.Dictionary%602> tipo; el tipo construido representa un <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos con claves de cadena.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo actual no es un tipo genérico.  Es decir, <see cref="P:System.Type.IsGenericType" /> devuelve <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base. Las clases derivadas deben proporcionar una implementación.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de esta instancia.</summary>
        <returns>Código hash de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el código hash de la `System.Windows.Forms.Button` clase.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene una interfaz específica implementada o heredada por el objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la interfaz que se va a obtener. Para las interfaces genéricas, este es el nombre con sufijo.</param>
        <summary>Busca la interfaz con el nombre especificado.</summary>
        <returns>Objeto que representa la interfaz con el nombre especificado, implementada o heredada por el objeto <see cref="T:System.Type" /> actual, si se encuentra; de lo contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda de `name` distingue mayúsculas de minúsculas.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Type> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en las restricciones de interfaz y las interfaces heredadas de restricciones de clase o interfaz.  
  
> [!NOTE]
>  Para las interfaces genéricas, el `name` parámetro es el nombre alterado y termina con un acento grave (\`) y el número de parámetros de tipo. Esto es cierto para las definiciones de interfaz genérica e interfaces genéricas construidas. Por ejemplo, para buscar `IExample<T>` (`IExample(Of T)` en Visual Basic) o `IExample<string>` (`IExample(Of String)` en Visual Basic), busque ``"IExample`1"``.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Type.GetInterface%28System.String%29> para buscar el <xref:System.Collections.Hashtable> de clases para el <xref:System.Runtime.Serialization.IDeserializationCallback> interfaz y se enumeran los métodos de la interfaz.  
  
 El ejemplo de código también muestra el <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> sobrecarga del método y el <xref:System.Type.GetInterfaceMap%2A> método.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">El objeto <see cref="T:System.Type" /> actual representa un tipo que implementa la misma interfaz genérica con argumentos de tipo distintos.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la interfaz que se va a obtener. Para las interfaces genéricas, este es el nombre con sufijo.</param>
        <param name="ignoreCase">
          <see langword="true" /> para omitir la grafía de la parte de <c>name</c> que especifica el nombre de interfaz simple (se debe respetar la grafía de la parte que especifica el espacio de nombres).  
  
O bien 
 <see langword="false" /> para realizar una búsqueda de todas las partes de <c>name</c> que distinga mayúsculas de minúsculas.</param>
        <summary>Cuando se invalida en una clase derivada, busca la interfaz especificada e indica si la búsqueda no debe distinguir entre mayúsculas y minúsculas para el nombre de la interfaz.</summary>
        <returns>Objeto que representa la interfaz con el nombre especificado, implementada o heredada por el objeto <see cref="T:System.Type" /> actual, si se encuentra; de lo contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ignoreCase` parámetro solo se aplica a lo nombre de interfaz simple, no al espacio de nombres. La parte de `name` que especifica el espacio de nombres debe tener el formato correcto o no se encuentra la interfaz. Por ejemplo, la cadena "System.icomparable" busca la <xref:System.IComparable> interfaz, pero la cadena "system.icomparable" no es así.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Type> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en las restricciones de interfaz y las interfaces heredadas de restricciones de clase o interfaz.  
  
> [!NOTE]
>  Para las interfaces genéricas, el `name` parámetro es el nombre alterado y termina con un acento grave (\`) y el número de parámetros de tipo. Esto es cierto para las definiciones de interfaz genérica e interfaces genéricas construidas. Por ejemplo, para buscar `IExample<T>` (`IExample(Of T)` en Visual Basic) o `IExample<string>` (`IExample(Of String)` en Visual Basic), busque `"IExample`1"'.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> método para realizar una búsqueda de mayúsculas y minúsculas de la <xref:System.Collections.Hashtable> de clases para el <xref:System.Collections.IEnumerable> interfaz.  
  
 El ejemplo de código también muestra el <xref:System.Type.GetInterface%28System.String%29> sobrecarga del método y el <xref:System.Type.GetInterfaceMap%2A> método.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">El objeto <see cref="T:System.Type" /> actual representa un tipo que implementa la misma interfaz genérica con argumentos de tipo distintos.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Tipo de interfaz para el que recuperar una asignación.</param>
        <summary>Devuelve una asignación de interfaz para el tipo de interfaz especificado.</summary>
        <returns>Objeto que representa la asignación de interfaz para <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El mapa de interfaz indica cómo se asigna una interfaz a los miembros reales en una clase que implementa esa interfaz.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, tipo de parámetros se sustituyen por los argumentos de tipo adecuado de los elementos de la <xref:System.Reflection.InterfaceMapping> devuelto por este método.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Type.GetInterfaceMap%2A> método para determinar cómo el <xref:System.IFormatProvider> interfaz se asigna a <xref:System.Globalization.CultureInfo> métodos y cómo el <xref:System.IAppDomainSetup> interfaz se asigna a <xref:System.AppDomainSetup> propiedades. Tenga en cuenta que, dado el <xref:System.IAppDomainSetup> interfaz define un conjunto de propiedades, el valor devuelto <xref:System.Reflection.InterfaceMapping> objeto incluye independiente <xref:System.Reflection.MethodInfo> objetos para get de una propiedad y descriptores de acceso set.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> no está implementado por el tipo actual.  
  
O bien 
El parámetro <paramref name="interfaceType" /> no hace referencia a una interfaz.  
  
O bien 
 <paramref name="interfaceType" /> es una interfaz genérica y el tipo actual es un tipo de matriz.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo genérico; es decir, <see cref="P:System.Type.IsGenericParameter" /> es <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base. Las clases derivadas deben proporcionar una implementación.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene todas las interfaces implementadas o heredadas por el objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Type" /> que representa todas las interfaces implementadas o heredadas por el objeto <see cref="T:System.Type" /> actual.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Type" /> en caso de que el objeto <see cref="T:System.Type" /> actual no implemente ni herede ninguna interfaz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetInterfaces%2A> método no devuelve las interfaces en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven interfaces, porque ese orden varía.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Type> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en las restricciones de interfaz y las interfaces heredadas de restricciones de clase o interfaz.  
  
   
  
## Examples  
 El ejemplo siguiente obtiene el tipo de la clase especificada y muestra todas las interfaces que implementa el tipo o que hereda. Para compilar el ejemplo de Visual Basic, use los siguientes comandos del compilador:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador estático y produce una excepción.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene los miembros especificados del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de los miembros públicos que se van a obtener.</param>
        <summary>Busca los miembros públicos con el nombre especificado.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos con el nombre especificado, si se encuentran; de lo contrario, una matriz vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye a los miembros de instancia pública de static y public.  
  
 Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.  
  
 El <xref:System.Type.GetMember%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración. El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.  
  
 Esta sobrecarga del método no encontrará a inicializadores de clase (.cctor). Para buscar los inicializadores de clase, use una sobrecarga que toma <xref:System.Reflection.BindingFlags>y especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.  
  
> [!NOTE]
>  Para métodos genéricos, no incluya los argumentos de tipo en `name`. Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los miembros de la `String` clase que empiezan por la letra C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de los miembros que se van a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para que se devuelva una matriz vacía.</param>
        <summary>Busca los miembros especificados mediante las restricciones de enlace especificadas.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos con el nombre especificado, si se encuentran; de lo contrario, una matriz vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada.  
  
 Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.  
  
 El <xref:System.Type.GetMember%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración. El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, debe especificar ".cctor" para `name`, y <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic) para `bindingAttr`. También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.  
  
> [!NOTE]
>  Para métodos genéricos, no incluya los argumentos de tipo en `name`. Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los miembros estáticos públicos de la `myString` clase que empiezan por la letra C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de los miembros que se van a obtener.</param>
        <param name="type">Valor que se va a buscar.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para que se devuelva una matriz vacía.</param>
        <summary>Busca los miembros especificados que sean del tipo de miembro especificado mediante las restricciones de enlace especificadas.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos con el nombre especificado, si se encuentran; de lo contrario, una matriz vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.  
  
 El <xref:System.Type.GetMember%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración. El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, debe especificar ".cctor" para `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> para `type`, y <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic) para `bindingAttr`. También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.  
  
> [!NOTE]
>  Para métodos genéricos, no incluya los argumentos de tipo en `name`. Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los métodos de la `myString` clase que empiezan por la letra C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La clase derivada debe proporcionar una implementación.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene los miembros (propiedades, métodos, campos, eventos, etc.) del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve todos los miembros públicos del objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos los miembros públicos del objeto <see cref="T:System.Type" /> actual.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.MemberInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene miembros públicos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.  
  
 El <xref:System.Type.GetMembers%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración. El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.  
  
 Esta sobrecarga del método llama a la <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga del método, con <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> en Visual Basic). No encontrará a inicializadores de clase (.cctor). Para buscar los inicializadores de clase, use una sobrecarga que toma <xref:System.Reflection.BindingFlags>y especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Type.GetMembers> sobrecarga del método para recopilar información sobre todos los miembros públicos de una clase especificada.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero (<see cref="F:System.Reflection.BindingFlags.Default" />), para que se devuelva una matriz vacía.</param>
        <summary>Cuando se invalida en una clase derivada, busca los miembros definidos para el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos los miembros definidos para el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.MemberInfo" /> si no se han definido miembros para el objeto <see cref="T:System.Type" /> actual o si ninguno de los miembros definidos coincide con las restricciones de enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.  
  
 El <xref:System.Type.GetMembers%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración. El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda. Solo se devuelven miembros internos de las clases base; y protegidos no se devuelven los miembros privados de clases base.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.  
  
 Llamar a este método solamente con el `Public` marca o solo el `NonPublic` marca devolverá los miembros especificados y no requiere otros indicadores.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.  
  
 Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga del método para recopilar información sobre todos los miembros de instancia pública de una clase especificada.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un método específico del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del método público que se va a obtener.</param>
        <summary>Busca el método público con el nombre especificado.</summary>
        <returns>Objeto que representa al método público con el nombre especificado, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye métodos de instancia públicos y estáticos públicos.  
  
 Si un método está sobrecargado y tiene más de un método público, el <xref:System.Type.GetMethod%28System.String%29> método produce una <xref:System.Reflection.AmbiguousMatchException> excepción. En el ejemplo siguiente, se produce una excepción porque no hay más de una sobrecarga pública de la <xref:System.Int32.ToString%2A?displayProperty=nameWithType> método.  Por otro lado, dado que el `Person.ToString` reemplazos de método <xref:System.Object.ToString%2A?displayProperty=nameWithType> y, por tanto, no está sobrecargado, el <xref:System.Type.GetMethod%28System.String%29> método es capaz de recuperar el <xref:System.Reflection.MethodInfo> objeto.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Puede hacer lo siguiente para recuperar un método específico:  
  
-   Llame a la <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> método y especifique un `bindingAttr` argumento que identifica el método. Por ejemplo, si se produce la excepción porque un tipo tiene una estática y una sobrecarga de la instancia, puede especificar un `bindingAttr` argumento de <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Llamar a una sobrecarga de la <xref:System.Type.GetMethod%2A> método que incluye un `types` parámetro que define los tipos de los parámetros del método.  
  
-   Llame a la <xref:System.Type.GetMethods> método para recuperar una matriz que contiene todos los métodos públicos que pertenecen a un tipo. A continuación, puede iterar para identificar los duplicados métodos denominados `name`.  
  
 Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.  
  
> [!NOTE]
>  Para métodos genéricos, no incluya los argumentos de tipo en `name`. Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene un método denominado `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de un método con el nombre especificado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del método que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Busca el método especificado mediante las restricciones de enlace especificadas.</summary>
        <returns>Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:  
  
-   Debe especificar <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> con el fin de obtener un valor devuelto.  
  
-   Especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir métodos públicos en la búsqueda.  
  
-   Especificar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.  
  
-   Especificar <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> para omitir la grafía de `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Si un método está sobrecargado y más de una sobrecarga cumple las restricciones especificadas por el `bindingAttr` argumento, el método produce una <xref:System.Reflection.AmbiguousMatchException> excepción. En el ejemplo siguiente, se produce una excepción porque:  
  
-   El `TestClass` tipo tiene dos sobrecargas de instancia pública de la `DisplayValue` método `DisplayValue(String)` y `DisplayValue(String, Object[])`.  
  
-   El `TestClass` tipo tiene dos sobrecargas de instancia pública de la `Equals` método, uno de los cuales se hereda de <xref:System.Object>: `Equals(TestClass)` y `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Puede hacer lo siguiente para recuperar un método específico:  
  
-   Cambiar las restricciones de enlace. En el ejemplo anterior, intenta recuperar una instancia pública `Equals` recupera el método que se declara el tipo y no hereda correctamente `Equals(TestClass)`.  
  
-   Llamar a una sobrecarga de la <xref:System.Type.GetMethod%2A> método que incluye un `types` parámetro que define los tipos de los parámetros del método.  
  
-   Llame a la <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> método para recuperar una matriz que contiene todos los métodos que pertenecen a un tipo que tienen los atributos de enlace especificadas. A continuación, puede iterar para identificar los duplicados métodos denominados `name`. Este enfoque se ilustra en el controlador del ejemplo anterior para el <xref:System.Reflection.AmbiguousMatchException> excepción.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.  
  
> [!NOTE]
>  Para métodos genéricos, no incluya los argumentos de tipo en `name`. Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.  
  
   
  
## Examples  
 El ejemplo siguiente obtiene el método que coincide con las marcas de enlace especificadas.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del método público que se va a obtener.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.  
  
O bien 
Una matriz vacía de objetos <see cref="T:System.Type" /> (proporcionados por el campo <see cref="F:System.Type.EmptyTypes" />) para obtener un método que no requiera parámetros.</param>
        <summary>Busca el método público especificado cuyos parámetros coincidan con los tipos de argumentos especificados.</summary>
        <returns>Objeto que representa el método público cuyos parámetros coinciden con los tipos de argumentos especificados, si se encuentra; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye métodos de instancia públicos y estáticos públicos.  
  
> [!NOTE]
>  No se puede omitir los parámetros al buscar los constructores y métodos. Solo puede omitir los parámetros al invocar.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.  
  
> [!NOTE]
>  El `name` parámetro no puede incluir argumentos de tipo. Por ejemplo, el código de C# `GetMethod("MyGenericMethod<int>")` busca un método con el nombre de texto "`MyGenericMethod<int>`", en lugar de para un método denominado `MyGenericMethod` que tiene un argumento genérico de tipo `int`. En su lugar, use `GetMethod("MyGenericMethod")` con el parámetro correspondiente en el `types` matriz.  
  
   
  
## Examples  
 El ejemplo siguiente busca sobrecargas concretas de `MethodA`, especificar una serie de tipos de argumento.  
  
> [!NOTE]
>  El [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] ejemplo requiere la `/unsafe` opción del compilador.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 En el ejemplo siguiente se recuperan <xref:System.Reflection.MethodInfo> objetos que representan el `Add` métodos de un tipo no genérico (la <xref:System.Collections.ArrayList> clase), un tipo genérico abierto (el <xref:System.Collections.Generic.List%601> clase) y un tipo genérico cerrado (el `List(Of String)` tipo.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 El ejemplo define un `GetAddMethod` método que recupera adecuado <xref:System.Reflection.MethodInfo> objeto. Para proporcionar la `types` argumento para un tipo genérico abierto, llama a la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método. Para proporcionar la `types` argumento para un tipo genérico cerrado, se recupera el valor de la <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encuentra más de un método con el nombre y los parámetros especificados.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="types" /> es <see langword="null" />.  
  
O bien 
Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del método público que se va a obtener.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.  
  
O bien 
Una matriz vacía de objetos <see cref="T:System.Type" /> (proporcionados por el campo <see cref="F:System.Type.EmptyTypes" />) para obtener un método que no requiera parámetros.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>types</c>. Solo se ha de usar cuando se llama mediante la interoperabilidad COM y solo se controlan parámetros que se pasan por referencia. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Busca el método público especificado cuyos parámetros coincidan con los tipos y modificadores de argumento especificados.</summary>
        <returns>Objeto que representa el método público que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye métodos de instancia públicos y estáticos públicos.  
  
> [!NOTE]
>  No se puede omitir los parámetros al buscar los constructores y métodos. Solo puede omitir los parámetros al invocar.  
  
 Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.  
  
> [!NOTE]
>  Para métodos genéricos, no incluya los argumentos de tipo en `name`. Por ejemplo, el código de C# `GetMethod("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`. En su lugar, use `GetMethod("MyMethod")` con el parámetro correspondiente en el `types` matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encuentra más de un método con el nombre y los parámetros especificados.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="types" /> es <see langword="null" />.  
  
O bien 
Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del método que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.  
  
O bien 
Una matriz vacía de objetos <see cref="T:System.Type" /> (proporcionados por el campo <see cref="F:System.Type.EmptyTypes" />) para obtener un método que no requiera parámetros.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>types</c>. Solo se ha de usar cuando se llama mediante la interoperabilidad COM y solo se controlan parámetros que se pasan por referencia. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Busca el método especificado cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, mediante las restricciones de enlace indicadas.</summary>
        <returns>Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir métodos públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
> [!NOTE]
>  No se puede omitir los parámetros al buscar los constructores y métodos. Solo puede omitir los parámetros al invocar.  
  
 Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.  
  
> [!NOTE]
>  Para métodos genéricos, no incluya los argumentos de tipo en `name`. Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.  
  
   
  
## Examples  
 El ejemplo siguiente busca sobrecargas concretas de `MethodA`, especificar restricciones de enlace y una variedad de tipos de argumento.  
  
> [!NOTE]
>  El [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] ejemplo requiere la `/unsafe` opción del compilador.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="types" /> es <see langword="null" />.  
  
O bien 
Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del método que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Objeto que especifica el conjunto de reglas que van a usarse en cuanto al orden y diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y la forma en que se limpia la pila.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.  
  
O bien 
Una matriz vacía de objetos <see cref="T:System.Type" /> (proporcionados por el campo <see cref="F:System.Type.EmptyTypes" />) para obtener un método que no requiera parámetros.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>types</c>. Solo se ha de usar cuando se llama mediante la interoperabilidad COM y solo se controlan parámetros que se pasan por referencia. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Busca el método especificado cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, usando las restricciones de enlace indicadas y la convención de llamada especificada.</summary>
        <returns>Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `GetXXX` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir métodos públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
> [!NOTE]
>  No se puede omitir los parámetros al buscar los constructores y métodos. Solo puede omitir los parámetros al invocar.  
  
 Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.  
  
> [!NOTE]
>  Para métodos genéricos, no incluya los argumentos de tipo en `name`. Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.  
  
   
  
## Examples  
 El ejemplo siguiente busca sobrecargas concretas de `MethodA`, especificar restricciones de enlace, convenciones de llamada y una variedad de tipos de argumento.  
  
> [!NOTE]
>  El [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] ejemplo requiere la `/unsafe` opción del compilador.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="types" /> es <see langword="null" />.  
  
O bien 
Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del método que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Objeto que especifica el conjunto de reglas que se va a usar en cuanto al orden y diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y el proceso encargado de limpiar la pila.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.  
  
O bien 
Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener un método que no requiera parámetros.  
  
O bien 
 <see langword="null" />. Si <c>types</c> es <see langword="null" />, no habrá coincidencias con los argumentos.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>types</c>. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Cuando se invalida en una clase derivada, busca el método especificado cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados y aplica las restricciones de enlace especificadas y la convención de llamada especificada.</summary>
        <returns>Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 Si `types` es `null`, no habrá coincidencias con los argumentos.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir métodos públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.  
  
O bien 
 <paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</exception>
        <exception cref="T:System.NotSupportedException">El tipo actual es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene los métodos del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve todos los métodos públicos del objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representa todos los métodos públicos definidos para el objeto <see cref="T:System.Type" /> actual.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.MethodInfo" /> si no hay métodos públicos definidos para el objeto <see cref="T:System.Type" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetMethods%2A> método no devuelve los métodos en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven los métodos, porque ese orden varía.  
  
 Los constructores no se incluyen en la matriz de los métodos devueltos por esta llamada. Realizar una llamada independiente a `GetConstructors()` para obtener los métodos de constructor.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
> [!NOTE]
>  No se puede omitir los parámetros al buscar los constructores y métodos. Solo puede omitir los parámetros al invocar.  
  
 Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, busca los métodos definidos para el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representa todos los métodos definidos para el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.MethodInfo" /> si no se han definido métodos para el objeto <see cref="T:System.Type" /> actual o si ninguno de los métodos definidos coincide con las restricciones de enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetMethods%2A> método no devuelve los métodos en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven los métodos, porque ese orden varía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir métodos públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda. Solo protegido y se devuelven los métodos internos de las clases base; no se devuelven los métodos privados de las clases base.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
> [!NOTE]
>  No se puede omitir los parámetros al buscar los constructores y métodos. Solo puede omitir los parámetros al invocar.  
  
 Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.  
  
   
  
## Examples  
 El ejemplo siguiente se crea una clase con dos métodos públicos y un método protegido, se crea un `Type` correspondiente objeto `MyTypeClass`, obtiene todos los métodos públicos y no públicos y se muestran sus nombres.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un tipo específico anidado dentro del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del tipo anidado que se va a obtener.</param>
        <summary>Busca el tipo anidado público con el nombre especificado.</summary>
        <returns>Objeto que representa el tipo anidado público con el nombre especificado, si se encuentra; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda de `name` distingue mayúsculas de minúsculas.  
  
 Utilice el nombre sencillo de la clase anidada para `name`. No califique con el nombre de la clase externa. Para una clase anidada genérica, utilice el nombre alterado, es decir, agregue un acento grave y el número de argumentos genéricos. Por ejemplo, use la cadena "interna\`1" obtener el tipo genérico de clase anidada `Inner<T>` (`Inner(Of T)` en Visual Basic). No incluya la sintaxis específica del lenguaje para los parámetros de tipo.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca los tipos anidados de la restricción de clase.  
  
 Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico. Esto es cierto incluso si el tipo genérico envolvente es un tipo construido cerrado.  
  
> [!NOTE]
>  Si el actual <xref:System.Type> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son todos genéricos incluso si tienen que no hay parámetros genéricos de sus propios. Esto no es necesariamente cierto de tipos anidados definidos en ensamblados dinámicos o compilados con la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obtener información sobre los tipos genéricos anidados y sobre cómo crear tipos genéricos anidados de sus definiciones de tipo genérico, vea <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del tipo anidado que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, busca el tipo anidado especificado y aplica las restricciones de enlace especificadas.</summary>
        <returns>Objeto que representa el tipo anidado que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice el nombre sencillo de la clase anidada para `name`. No califique con el nombre de la clase externa. Para una clase anidada genérica, utilice el nombre alterado, es decir, agregue un acento grave y el número de parámetros genéricos. Por ejemplo, use la cadena "interna\`1" obtener el tipo genérico de clase anidada `Inner<T>` (`Inner(Of T)` en Visual Basic). No incluya la sintaxis específica del lenguaje para los parámetros de tipo.  
  
 La siguiente <xref:System.Reflection.BindingFlags> filtro indicadores pueden utilizarse para definir que anidar tipos debe para incluir en la búsqueda:  
  
-   Debe especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para obtener un valor devuelto.  
  
-   Especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir los tipos anidados públicos en la búsqueda.  
  
-   Especificar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir los tipos anidados no públicos (es decir, privados, internos y protegidos tipos anidados) en la búsqueda.  
  
 Este método devuelve sólo los tipos anidados del tipo actual. No se busca las clases base del tipo actual. Para buscar tipos que están anidados en clases base, debe recorrer la jerarquía de herencia, una llamada a <xref:System.Type.GetNestedType%2A> en cada nivel.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> y <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> se omiten.  
  
 Llamar a este método solamente con el <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> marca o solo el <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> marca devolverá los tipos anidados especificados y no requieren otros indicadores.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca los tipos anidados de la restricción de clase.  
  
 Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico. Esto es cierto incluso si el tipo genérico envolvente es un tipo construido cerrado.  
  
> [!NOTE]
>  Si el actual <xref:System.Type> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son todos genéricos incluso si tienen que no hay parámetros genéricos de sus propios. Esto no es necesariamente cierto de tipos anidados definidos en ensamblados dinámicos o compilados con la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obtener información sobre los tipos genéricos anidados y sobre cómo crear tipos genéricos anidados de sus definiciones de tipo genérico, vea <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene los tipos anidados dentro del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve los tipos públicos anidados en el objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Una matriz de objetos <see cref="T:System.Type" /> que representan los tipos públicos anidados en el objeto <see cref="T:System.Type" /> actual (la búsqueda no es recursiva), o una matriz vacía de tipo <see cref="T:System.Type" /> si no hay tipos públicos anidados en el objeto <see cref="T:System.Type" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetNestedTypes%2A> método no devuelve tipos en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven los tipos, porque ese orden varía.  
  
 Se devuelven los tipos públicos anidados inmediatamente en el tipo actual; la búsqueda no es recursiva.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca los tipos anidados de la restricción de clase.  
  
 Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico. Esto es cierto incluso si el tipo genérico envolvente es un tipo construido cerrado.  
  
> [!NOTE]
>  Si el actual <xref:System.Type> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son todos genéricos incluso si tienen que no hay parámetros genéricos de sus propios. Esto no es necesariamente cierto de tipos anidados definidos en ensamblados dinámicos o compilados con la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obtener información sobre los tipos genéricos anidados y sobre cómo crear tipos genéricos anidados de sus definiciones de tipo genérico, vea <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una clase anidada y un `struct` en `MyClass`y, a continuación, obtiene los objetos de los tipos anidados utilizando el tipo de `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, busca los tipos anidados en el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</summary>
        <returns>Una matriz de objetos <see cref="T:System.Type" /> que representan todos los tipos anidados en el objeto <see cref="T:System.Type" /> actual que cumplen las restricciones de enlace especificadas (la búsqueda no es recursiva), o una matriz vacía de tipo <see cref="T:System.Type" />, si no se encuentran tipos anidados que cumplan las restricciones de enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda para los tipos anidados no es recursiva.  
  
 El <xref:System.Type.GetNestedTypes%2A> método no devuelve tipos en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven los tipos, porque ese orden varía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> filtro indicadores pueden utilizarse para definir que anidar tipos debe para incluir en la búsqueda:  
  
-   Debe especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para obtener un valor devuelto.  
  
-   Especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir los tipos anidados públicos en la búsqueda.  
  
-   Especificar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir los tipos anidados no públicos (es decir, privados, internos y protegidos tipos anidados) en la búsqueda.  
  
 Este método devuelve sólo los tipos anidados del tipo actual. No se busca las clases base del tipo actual. Para buscar tipos que están anidados en clases base, debe recorrer la jerarquía de herencia, una llamada a <xref:System.Type.GetNestedTypes%2A> en cada nivel.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> y <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> se omiten.  
  
 Llamar a este método solamente con el <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> marca o solo el <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> marca devolverá los tipos anidados especificados y no requieren otros indicadores.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca los tipos anidados de la restricción de clase.  
  
 Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico. Esto es cierto incluso si el tipo genérico envolvente es un tipo construido cerrado.  
  
> [!NOTE]
>  Si el actual <xref:System.Type> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son todos genéricos incluso si tienen que no hay parámetros genéricos de sus propios. Esto no es necesariamente cierto de tipos anidados definidos en ensamblados dinámicos o compilados con la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obtener información sobre los tipos genéricos anidados y sobre cómo crear tipos genéricos anidados de sus definiciones de tipo genérico, vea <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente crea dos clases públicas anidadas y dos clases protegidas anidadas y muestra información para las clases que coinciden con las restricciones de enlace especificadas.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene las propiedades del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve todas las propiedades públicas del objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representa todas las propiedades públicas del objeto <see cref="T:System.Type" /> actual.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.PropertyInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene propiedades públicas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a esta sobrecarga es equivalente a llamar a la <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> sobrecarga con un `bindingAttr` igual al argumento `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` en C# y `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` en Visual Basic. Devuelve todas las instancias públicos y propiedades estáticas, tanto los definidos por el tipo representado por el actual <xref:System.Type> objeto, así como las que se hereden de sus tipos base.  
  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 El <xref:System.Type.GetProperties%2A> método no devuelve las propiedades en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven las propiedades, porque ese orden varía.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra el uso del método `GetProperties`.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, busca las propiedades del objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representa a todas las propiedades del objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.  
  
O bien 
Matriz vacía de tipo <see cref="T:System.Reflection.PropertyInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene propiedades o si ninguna de las propiedades coincide con las restricciones de enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 El <xref:System.Type.GetProperties%2A> método no devuelve las propiedades en un orden concreto, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven las propiedades, porque ese orden varía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> filtro indicadores pueden utilizarse para definir que anidar tipos debe para incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir propiedades públicas en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir propiedades no públicas (es decir, las propiedades privadas, internas y protegidas) en la búsqueda. Solo se devuelven propiedades internas de las clases base; y protegidos no se devuelven las propiedades privadas de las clases base.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo las propiedades declaradas en el <xref:System.Type>, no las propiedades que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una clase denominada `PropertyClass` que incluye seis propiedades: dos son públicos, uno es privado, uno está protegida, uno es interno (`Friend` en Visual Basic), y uno es protected internal (`Protected Friend` en Visual Basic). A continuación, muestra información básica de propiedad (el nombre de propiedad y el tipo, si es lectura/escritura y la visibilidad de su `get` y `set` descriptores de acceso) para las propiedades que coinciden con las restricciones de enlace especificadas.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene una propiedad específica del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</param>
        <summary>Busca la propiedad pública con el nombre especificado.</summary>
        <returns>Objeto que representa la propiedad pública con el nombre especificado, si se encuentra; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye las propiedades de instancia pública de static y public.  
  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.  
  
 Situaciones en las que <xref:System.Reflection.AmbiguousMatchException> se produce incluyen lo siguiente:  
  
-   Un tipo contiene dos propiedades indizadas que tienen el mismo nombre pero distintos números de parámetros. Para resolver la ambigüedad, use una sobrecarga de la <xref:System.Type.GetProperty%2A> método que especifica los tipos de parámetro.  
  
-   Un tipo derivado declara una propiedad que oculta una propiedad heredada con el mismo nombre, mediante el uso de la `new` modificador (`Shadows` en Visual Basic). Para resolver la ambigüedad, use el <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> sobrecarga de método y agregue el <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> marca para restringir la búsqueda a los miembros que no se heredan.  
  
## <a name="indexers-and-default-properties"></a>Los indizadores y propiedades predeterminadas  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo. Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3. Puede sobrecargar la propiedad.  
  
 En C#, esta característica se llama a un indizador y no se refiere por su nombre. De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item". Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos. Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>. Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.  
  
 Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo. Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera el `Type` objeto de una clase definida por el usuario, recupera una propiedad de esa clase y muestra el nombre de propiedad.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Internamente, esta propiedad se conoce en los metadatos con el nombre "Item". Cualquier intento de obtener `PropertyInfo` mediante reflexión, debe especificar este nombre interno para devolver correctamente la `PropertyInfo` propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de una propiedad con el nombre especificado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la propiedad que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <summary>Busca la propiedad especificada, mediante las restricciones de enlace especificadas.</summary>
        <returns>Objeto que representa la propiedad que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir las propiedades que se va a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir propiedades públicas en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir propiedades no públicas (es decir, las propiedades privadas, internas y protegidas) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo las propiedades declaradas en el <xref:System.Type>, no las propiedades que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.  
  
 Situaciones en las que <xref:System.Reflection.AmbiguousMatchException> se produce incluyen lo siguiente:  
  
-   Un tipo contiene dos propiedades indizadas que tienen el mismo nombre pero distintos números de parámetros. Para resolver la ambigüedad, use una sobrecarga de la <xref:System.Type.GetProperty%2A> método que especifica los tipos de parámetro.  
  
-   Un tipo derivado declara una propiedad que oculta una propiedad heredada con el mismo nombre, mediante el `new` modificador (`Shadows` en Visual Basic). Para resolver la ambigüedad, incluya <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> para restringir la búsqueda a los miembros que no se heredan.  
  
## <a name="indexers-and-default-properties"></a>Los indizadores y propiedades predeterminadas  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo. Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3. Puede sobrecargar la propiedad.  
  
 En C#, esta característica se llama a un indizador y no se refiere por su nombre. De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item". Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos. Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>. Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.  
  
 Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo. Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.  
  
   
  
## Examples  
 El ejemplo siguiente recupera el tipo de una clase definida por el usuario, recupera una propiedad de esa clase y muestra el nombre de propiedad de acuerdo con las restricciones de enlace especificadas.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de una propiedad con el nombre especificado y que coincide con las restricciones de enlace especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</param>
        <param name="returnType">Tipo de valor devuelto de la propiedad.</param>
        <summary>Busca la propiedad pública con el nombre especificado y el tipo de valor devuelto.</summary>
        <returns>Objeto que representa la propiedad pública con el nombre especificado, si se encuentra; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye las propiedades de instancia pública de static y public.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.  
  
## <a name="indexers-and-default-properties"></a>Los indizadores y propiedades predeterminadas  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo. Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3. Puede sobrecargar la propiedad.  
  
 En C#, esta característica se llama a un indizador y no se refiere por su nombre. De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item". Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos. Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>. Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.  
  
 Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo. Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.  
  
   
  
## Examples  
 El ejemplo siguiente define una clase con una propiedad y recupera el nombre y tipo de la propiedad.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de una propiedad con el nombre especificado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />, o bien, <paramref name="returnType" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.  
  
O bien 
Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</param>
        <summary>Busca la propiedad pública especificada cuyos parámetros coincidan con los tipos de argumentos especificados.</summary>
        <returns>Objeto que representa la propiedad pública cuyos parámetros coinciden con los tipos de argumentos especificados, si se encuentra; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye las propiedades de instancia pública de static y public.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.  
  
## <a name="indexers-and-default-properties"></a>Los indizadores y propiedades predeterminadas  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo. Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3. Puede sobrecargar la propiedad.  
  
 En C#, esta característica se llama a un indizador y no se refiere por su nombre. De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item". Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos. Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>. Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.  
  
 Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo. Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera el `Type` objeto de una clase definida por el usuario, recupera la propiedad de esa clase y muestra el nombre de propiedad y el tipo de la propiedad según lo especificado por los argumentos pasados a `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de una propiedad con el nombre especificado y que coincide con los tipos de argumento especificados.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.</exception>
        <exception cref="T:System.NullReferenceException">Un elemento de <paramref name="types" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</param>
        <param name="returnType">Tipo de valor devuelto de la propiedad.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.  
  
O bien 
Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</param>
        <summary>Busca la propiedad pública especificada cuyos parámetros coincidan con los tipos de argumentos especificados.</summary>
        <returns>Objeto que representa la propiedad pública cuyos parámetros coinciden con los tipos de argumentos especificados, si se encuentra; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye las propiedades de instancia pública de static y public.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.  
  
## <a name="indexers-and-default-properties"></a>Los indizadores y propiedades predeterminadas  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo. Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3. Puede sobrecargar la propiedad.  
  
 En C#, esta característica se llama a un indizador y no se refiere por su nombre. De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item". Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos. Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>. Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.  
  
 Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo. Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de una propiedad con el nombre especificado y que coincide con los tipos de argumento especificados.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.</exception>
        <exception cref="T:System.NullReferenceException">Un elemento de <paramref name="types" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</param>
        <param name="returnType">Tipo de valor devuelto de la propiedad.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.  
  
O bien 
Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>types</c>. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Busca la propiedad pública especificada cuyos parámetros coincidan con los tipos y modificadores de los argumentos especificados.</summary>
        <returns>Objeto que representa la propiedad pública que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 La búsqueda de `name` distingue mayúsculas de minúsculas. La búsqueda incluye las propiedades de instancia pública de static y public.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.  
  
## <a name="indexers-and-default-properties"></a>Los indizadores y propiedades predeterminadas  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo. Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3. Puede sobrecargar la propiedad.  
  
 En C#, esta característica se llama a un indizador y no se refiere por su nombre. De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item". Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos. Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>. Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.  
  
 Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo. Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene un `Type` objeto correspondiente a `MyPropertyClass`, y la propiedad indizada de esta clase se recupera mediante los argumentos pasados a la `GetProperty` método.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Existe más de una propiedad con el nombre especificado que coincide con los modificadores y tipos de argumentos especificados.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.  
  
O bien 
 <paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</exception>
        <exception cref="T:System.NullReferenceException">Un elemento de <paramref name="types" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la propiedad que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Tipo de valor devuelto de la propiedad.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.  
  
O bien 
Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>types</c>. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Busca la propiedad especificada cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, mediante las restricciones de enlace indicadas.</summary>
        <returns>Objeto que representa la propiedad que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público. En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.  
  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir las propiedades que se va a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir propiedades públicas en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir propiedades no públicas (es decir, las propiedades privadas, internas y protegidas) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo las propiedades declaradas en el <xref:System.Type>, no las propiedades que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.  
  
## <a name="indexers-and-default-properties"></a>Los indizadores y propiedades predeterminadas  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo. Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3. Puede sobrecargar la propiedad.  
  
 En C#, esta característica se llama a un indizador y no se refiere por su nombre. De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item". Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos. Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>. Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.  
  
 Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo. Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de una propiedad con el nombre especificado y que coincide con las restricciones de enlace especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.  
  
O bien 
 <paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</exception>
        <exception cref="T:System.NullReferenceException">Un elemento de <paramref name="types" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre de la propiedad que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
O bien 
Cero, para devolver <see langword="null" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace que pueden implicar la selección de un miembro sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Tipo de valor devuelto de la propiedad.</param>
        <param name="types">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.  
  
O bien 
Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>types</c>. El enlazador predeterminado no procesa este parámetro.</param>
        <summary>Cuando se invalida en una clase derivada, busca la propiedad especificada cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, usando las restricciones de enlace especificadas.</summary>
        <returns>Objeto que representa la propiedad que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir las propiedades que se va a incluir en la búsqueda:  
  
-   Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.  
  
-   Especificar `BindingFlags.Public` para incluir propiedades públicas en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir propiedades no públicas (es decir, las propiedades privadas, internas y protegidas) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar sólo las propiedades declaradas en el <xref:System.Type>, no las propiedades que simplemente se han heredado.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Se encontró más de una propiedad con el nombre especificado y que coincide con las restricciones de enlace especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="types" /> es <see langword="null" />.  
  
O bien 
Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> es multidimensional.  
  
O bien 
 <paramref name="modifiers" /> es multidimensional.  
  
O bien 
 <paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</exception>
        <exception cref="T:System.NotSupportedException">El tipo actual es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Type" /> que representa el tipo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene la estructura <see cref="T:System.Type" /> actual.</summary>
        <returns>Objeto <see cref="T:System.Type" /> actual.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre calificado con el ensamblado del tipo que se va a obtener. Vea <see cref="P:System.Type.AssemblyQualifiedName" />. Si el tipo está en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, es suficiente para proporcionar el nombre completo del tipo por su espacio de nombres.</param>
        <summary>Obtiene el objeto <see cref="T:System.Type" /> con el nombre especificado, mediante una búsqueda en la que se distingue entre mayúsculas y minúsculas.</summary>
        <returns>Tipo con el nombre especificado, si se encuentra; de lo contrario <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Type.GetType%2A> método para obtener un <xref:System.Type> si sabe su nombre completo de ensamblado que puede obtenerse a partir de objetos para un tipo en otro ensamblado, <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> hace que la carga del ensamblado especificado en `typeName`. También puede cargar un ensamblado mediante la <xref:System.Reflection.Assembly.Load%2A> método y, a continuación, utilice el <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> métodos de la <xref:System.Reflection.Assembly> clase para obtener <xref:System.Type> objetos. Si un tipo está en un ensamblado que se sabe que el programa en tiempo de compilación, es más eficaz utilizar en C#, <xref:System.Type.GetType%2A> en Visual Basic o C++.  
  
> [!NOTE]
>  Si `typeName` no se encuentra, la llamada a la <xref:System.Type.GetType%28System.String%29> devuelve del método `null`. No se produce una excepción. Para controlar si se produce una excepción, llamar a una sobrecarga de la <xref:System.Type.GetType%2A> método que tiene un `throwOnError` parámetro.  
  
 <xref:System.Type.GetType%2A> solo funciona en los ensamblados cargados desde el disco. Si se llama a <xref:System.Type.GetType%2A> para buscar un tipo definido en un ensamblado dinámico definido mediante el <xref:System.Reflection.Emit> servicios, podría obtener un comportamiento incoherente. El comportamiento depende de si el ensamblado dinámico es persistente, es decir, se crea mediante la `RunAndSave` o `Save` modos de acceso a la <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeración. Si el ensamblado dinámico es persistente y se ha escrito en el disco antes de `GetType` es llamado, el cargador busca el ensamblado guardado en disco, carga ese ensamblado y recupera el tipo del ensamblado. Si el ensamblado no se ha guardado en el disco cuando `GetType` se llama, el método devuelve `null`. `GetType` no entiende los ensamblados dinámicos transitorios; por lo tanto, una llamada a `GetType` para recuperar un tipo en transitorio devuelve el ensamblado dinámico `null`.  
  
 Para usar `GetType` en un módulo dinámico, suscribirse a la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos y llamadas `GetType` antes de guardar. De lo contrario, obtendrá dos copias del ensamblado en la memoria.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Las matrices o los tipos COM no se buscan, a menos que ya se han cargado en la tabla de clases disponibles.  
  
 `typeName` puede ser el nombre de tipo calificado por su espacio de nombres o un nombre completo de ensamblado que incluya una especificación de nombre de ensamblado. Vea <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Si `typeName` incluye el espacio de nombres pero no el nombre del ensamblado, este método busca solo ensamblado del objeto que realiza la llamada y Mscorlib.dll, en ese orden. Si typeName es un nombre completo con el nombre de ensamblado parcial o completo, este método busca en el ensamblado especificado. Si el ensamblado tiene un nombre seguro, se requiere un nombre de ensamblado completo.  
  
 El <xref:System.Type.AssemblyQualifiedName%2A> propiedad devuelve un nombre de tipo completo incluido tipos anidados, el nombre del ensamblado y los argumentos de tipo genérico. Todos los compiladores compatibles con common language runtime emitirá el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando se consulta, con arreglo a las siguientes convenciones.  
  
> [!NOTE]
>  En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado. Por ejemplo, "ProcessorArchitecture = msil". Sin embargo, no se incluye en la cadena devuelta por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, por motivos de compatibilidad. También puede cargar tipos mediante la creación de un <xref:System.Reflection.AssemblyName> objeto y pasarlo a una sobrecarga adecuada de la <xref:System.Reflection.Assembly.Load%2A> método. A continuación, puede usar el <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método para cargar tipos desde el ensamblado. Vea también <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra diagonal inversa (\\)|Carácter de escape.|  
|Acento grave (')|Precede a uno o más dígitos que representa el número de parámetros de tipo, situado al final del nombre de un tipo genérico.|  
|Corchetes ([])|Incluya una lista de argumentos de tipo genérico, para un tipo genérico construido; dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.|  
|Coma (,)|Precede al nombre de ensamblado.|  
|Punto (.)|Denota los identificadores de espacio de nombres.|  
|Signo más (+)|Precede a una clase anidada.|  
  
 Por ejemplo, el nombre completo para una clase podría ser similar al siguiente:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Si el espacio de nombres fuera EspacioNombresPrincipal. Sub+EspacioNombres, la cadena tendría que ir delante del signo más (+) con un carácter de escape (\\) para evitar que se va a interpretar como un separador de anidamiento. La reflexión emite esta cadena como sigue:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Un "++" se convierte en "\\+\\+" y un "\\"se convierte en"\\\\".  
  
 Este nombre completo puede conservarse y usa más adelante para cargar el <xref:System.Type>. Para buscar y cargar un <xref:System.Type>, utilice <xref:System.Type.GetType%2A> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado. <xref:System.Type.GetType%2A> con el tipo de nombre sólo buscará los <xref:System.Type> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema. <xref:System.Type.GetType%2A> con el ensamblado de nombre de tipo calificado buscará el <xref:System.Type> en cualquier ensamblado.  
  
 Los nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz. Para recuperar el nombre del tipo sin estos caracteres finales, use `t.GetElementType().ToString()`, donde `t` es el tipo.  
  
 Espacios son relevantes en todos los componentes de nombre de tipo, excepto el nombre del ensamblado. En el nombre del ensamblado, espacios antes del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.  
  
 El nombre de un tipo genérico finaliza con un acento grave (\`) seguido de dígitos que representa el número de argumentos de tipo genérico. El propósito de este nombre con sufijo es permitir que los compiladores admitir tipos genéricos con el mismo nombre pero con distintos números de parámetros de tipo, que se producen en el mismo ámbito. Por ejemplo, la reflexión devuelve los nombres alterados `Tuple`1` and `tupla`2` desde los métodos genéricos `Tuple(Of T)` y `Tuple(Of T0, T1)` en Visual Basic, o `Tuple<T>` y tupla`\<T0, T1>` en Visual C#.  
  
 Para los tipos genéricos, la lista de argumentos de tipo se encierra entre corchetes y los argumentos de tipo están separados por comas. Por ejemplo, un tipo genérico <xref:System.Collections.Generic.Dictionary%602> tiene dos parámetros de tipo. Un <xref:System.Collections.Generic.Dictionary%602> de `MyType` con claves de tipo <xref:System.String> puede representarse como sigue:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Para especificar un tipo calificado con el ensamblado en una lista de argumentos de tipo, incluya el tipo de ensamblado completo entre corchetes. En caso contrario, las comas que separan las partes del nombre completo de ensamblado se interpretan como delimitar los argumentos de tipo adicionales. Por ejemplo, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` fromMyAssembly.dll, con claves de tipo <xref:System.String>, puede especificar como sigue:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un tipo calificado con el ensamblado puede escribirse entre corchetes solo cuando aparece dentro de una lista de parámetros de tipo. Las reglas para buscar los ensamblados de tipos completos e incompletos en listas de parámetros de tipo son las mismas que las reglas para tipos no genéricos completos e incompletos.  
  
 Tipos que aceptan valores NULL son un caso especial de tipos genéricos. Por ejemplo, una que acepta valores NULL <xref:System.Int32> representado por la cadena "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  En C#, C++ y Visual Basic también puede obtener los tipos que aceptan valores NULL mediante operadores de tipo. Por ejemplo, el que acepta valores NULL <xref:System.Boolean> tipo devuelto por `typeof(Nullable<bool>)` en C#, por `Nullable<Boolean>::typeid` en C++ y por `GetType(Nullable(Of Boolean))` en Visual Basic.  
  
 En la tabla siguiente se muestra la sintaxis que usa con `GetType` para varios tipos.  
  
|Para obtener|Usar|  
|------------|---------|  
|Acepta valores null <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")'|  
|Un puntero no administrado para `MyType`|`Type.GetType("MyType*")`|  
|Un puntero no administrado a un puntero a `MyType`|`Type.GetType("MyType**")`|  
|Un puntero administrado o una referencia a `MyType`|`Type.GetType("MyType&")`. Tenga en cuenta que, a diferencia de los punteros, las referencias están limitadas a un nivel.|  
|Una clase primaria y una clase anidada|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Una matriz unidimensional con un límite inferior de 0|`Type.GetType("MyType[]")`|  
|Una matriz unidimensional con un límite inferior desconocido|`Type.GetType("MyType[*]")`|  
|Una matriz de n dimensiones|Una coma (,) dentro de los corchetes un total de n-1 veces. Por ejemplo, `System.Object[,,]` representa tridimensional `Object` matriz.|  
|Una matriz de matrices unidimensionales|`Type.GetType("MyType[][]")`|  
|Una matriz bidimensional rectangular con límites inferiores desconocidos|`Type.GetType("MyType[,]")`|  
|Un tipo genérico con un argumento de tipo|`Type.GetType("MyGenericType`1[MyType]")'|  
|Un tipo genérico con dos argumentos de tipo|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|Un tipo genérico con dos argumentos de tipo calificado con el ensamblado|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|Un tipo genérico con un argumento de tipo calificado de ensamblado completo de ensamblado|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|Un tipo genérico cuyo argumento de tipo es un tipo genérico con dos argumentos de tipo|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 El ejemplo siguiente recupera el tipo de `System.Int32` y usa ese objeto de tipo para mostrar el <xref:System.Type.FullName%2A> propiedad de `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> En las [aplicaciones .NET para la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.IO.IOException" />. </para>
          </block>  
  
Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado o alguna de sus dependencias no son válidos.  
  
O bien 
Actualmente, está cargada la versión 2.0 u otra posterior de Common Language Runtime pero el ensamblado se compiló con una versión posterior.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre calificado con el ensamblado del tipo que se va a obtener. Vea <see cref="P:System.Type.AssemblyQualifiedName" />. Si el tipo está en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, es suficiente para proporcionar el nombre completo del tipo por su espacio de nombres.</param>
        <param name="throwOnError">Es <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; es <see langword="false" /> para devolver <see langword="null" />. Si se especifica <see langword="false" /> se suprimen otras condiciones de excepción, pero no todas. Vea la sección Excepciones.</param>
        <summary>Obtiene el objeto <see cref="T:System.Type" /> con el nombre especificado, que realiza una búsqueda donde se distingue entre mayúsculas y minúsculas y especifica si se va a producir o no una excepción si no se encuentra el tipo.</summary>
        <returns>Tipo con el nombre especificado. Si el tipo no se encuentra, el parámetro <paramref name="throwOnError" /> especifica si se devuelve <see langword="null" /> o se produce una excepción. En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwOnError" />. Vea la sección Excepciones.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Type.GetType%2A> método para obtener un <xref:System.Type> si sabe su nombre completo de ensamblado que puede obtenerse a partir de objetos para un tipo en otro ensamblado, <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> hace que la carga del ensamblado especificado en `typeName`. También puede cargar un ensamblado mediante la <xref:System.Reflection.Assembly.Load%2A> método y, a continuación, utilice el <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> métodos de la <xref:System.Reflection.Assembly> clase para obtener <xref:System.Type> objetos. Si un tipo está en un ensamblado que se sabe que el programa en tiempo de compilación, es más eficaz utilizar `typeof` en C#, <xref:System.Type.GetType%2A> en Visual Basic, o `typeid` en C++.  
  
 `GetType` solo funciona en los ensamblados cargados desde el disco. Si se llama a `GetType` para buscar un tipo definido en un ensamblado dinámico definido mediante el <xref:System.Reflection.Emit> servicios, podría obtener un comportamiento incoherente. El comportamiento depende de si el ensamblado dinámico es persistente, es decir, se crea mediante la `RunAndSave` o `Save` modos de acceso a la <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeración. Si el ensamblado dinámico es persistente y se ha escrito en el disco antes de `GetType` es llamado, el cargador busca el ensamblado guardado en disco, carga ese ensamblado y recupera el tipo del ensamblado. Si el ensamblado no se ha guardado en el disco cuando `GetType` se llama, el método devuelve `null`. `GetType` no entiende los ensamblados dinámicos transitorios; por lo tanto, una llamada a `GetType` para recuperar un tipo en transitorio devuelve el ensamblado dinámico `null`.  
  
 Para usar `GetType` en un módulo dinámico, suscribirse a la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos y llamadas `GetType` antes de guardar. De lo contrario, obtendrá dos copias del ensamblado en la memoria.  
  
 El `throwOnError` parámetro especifica lo que sucede cuando no se encuentra el tipo y también suprime algunas condiciones de excepción, como se describe en la sección excepciones. Algunas excepciones se producen independientemente del valor de `throwOnError`. Por ejemplo, si se encuentra el tipo, pero no se puede cargar, un <xref:System.TypeLoadException> se produce incluso si `throwOnError` es `false`.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Las matrices o los tipos COM no se buscan, a menos que ya se han cargado en la tabla de clases disponibles.  
  
 `typeName` puede ser el nombre de tipo calificado por su espacio de nombres o un nombre completo de ensamblado que incluya una especificación de nombre de ensamblado. Vea <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Si `typeName` incluye el espacio de nombres pero no el nombre del ensamblado, este método busca solo ensamblado del objeto que realiza la llamada y Mscorlib.dll, en ese orden. Si typeName es un nombre completo con el nombre de ensamblado parcial o completo, este método busca en el ensamblado especificado. Si el ensamblado tiene un nombre seguro, se requiere un nombre de ensamblado completo.  
  
 El <xref:System.Type.AssemblyQualifiedName%2A> propiedad devuelve un nombre de tipo completo incluido tipos anidados, el nombre del ensamblado y los argumentos genéricos. Todos los compiladores compatibles con common language runtime emitirá el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando se consulta, con arreglo a las siguientes convenciones.  
  
> [!NOTE]
>  En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado. Por ejemplo, "ProcessorArchitecture = msil". Sin embargo, no se incluye en la cadena devuelta por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, por motivos de compatibilidad. También puede cargar tipos mediante la creación de un <xref:System.Reflection.AssemblyName> objeto y pasarlo a una sobrecarga adecuada de la <xref:System.Reflection.Assembly.Load%2A> método. A continuación, puede usar el <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método para cargar tipos desde el ensamblado. Vea también <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra diagonal inversa (\\)|Carácter de escape.|  
|Acento grave (')|Precede a uno o más dígitos que representa el número de parámetros de tipo, situado al final del nombre de un tipo genérico.|  
|Corchetes ([])|Incluya una lista de argumentos de tipo genérico, para un tipo genérico construido; dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.|  
|Coma (,)|Precede al nombre de ensamblado.|  
|Punto (.)|Denota los identificadores de espacio de nombres.|  
|Signo más (+)|Precede a una clase anidada.|  
  
 Por ejemplo, el nombre completo para una clase podría ser similar al siguiente:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Si el espacio de nombres fuera EspacioNombresPrincipal. Sub+EspacioNombres, la cadena tendría que ir delante del signo más (+) con un carácter de escape (\\) para evitar que se va a interpretar como un separador de anidamiento. La reflexión emite esta cadena como sigue:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Un "++" se convierte en "\\+\\+" y un "\\"se convierte en"\\\\".  
  
 Este nombre completo puede conservarse y usa más adelante para cargar el <xref:System.Type>. Para buscar y cargar un <xref:System.Type>, utilice <xref:System.Type.GetType%2A> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado. <xref:System.Type.GetType%2A> con el tipo de nombre sólo buscará los <xref:System.Type> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema. <xref:System.Type.GetType%2A> con el ensamblado de nombre de tipo calificado buscará el <xref:System.Type> en cualquier ensamblado.  
  
 Los nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz. Para recuperar el nombre del tipo sin estos caracteres finales, use `t.GetElementType().ToString()`, donde `t` es el tipo.  
  
 Espacios son relevantes en todos los componentes de nombre de tipo, excepto el nombre del ensamblado. En el nombre del ensamblado, espacios antes del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.  
  
 El nombre de un tipo genérico finaliza con un acento grave (\`) seguido de dígitos que representa el número de argumentos de tipo genérico. El propósito de este nombre con sufijo es permitir que los compiladores admitir tipos genéricos con el mismo nombre pero con distintos números de parámetros de tipo, que se producen en el mismo ámbito. Por ejemplo, la reflexión devuelve los nombres alterados `Tuple`1` and `tupla`2` desde los métodos genéricos `Tuple(Of T)` y `Tuple(Of T0, T1)` en Visual Basic, o `Tuple<T>` y tupla`\<T0, T1>` en Visual C#.  
  
 Para los tipos genéricos, la lista de argumentos de tipo se encierra entre corchetes y los argumentos de tipo están separados por comas. Por ejemplo, un tipo genérico <xref:System.Collections.Generic.Dictionary%602> tiene dos parámetros de tipo. Un <xref:System.Collections.Generic.Dictionary%602> de `MyType` con claves de tipo <xref:System.String> puede representarse como sigue:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Para especificar un tipo calificado con el ensamblado en una lista de argumentos de tipo, incluya el tipo de ensamblado completo entre corchetes. En caso contrario, las comas que separan las partes del nombre completo de ensamblado se interpretan como delimitar los argumentos de tipo adicionales. Por ejemplo, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` en MyAssembly.dll, con claves de tipo <xref:System.String>, puede especificar como sigue:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un tipo calificado con el ensamblado puede escribirse entre corchetes solo cuando aparece dentro de una lista de parámetros de tipo. Las reglas para buscar los ensamblados de tipos completos e incompletos en listas de parámetros de tipo son las mismas que las reglas para tipos no genéricos completos e incompletos.  
  
 Tipos que aceptan valores NULL son un caso especial de tipos genéricos. Por ejemplo, una que acepta valores NULL <xref:System.Int32> representado por la cadena "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  En C#, C++ y Visual Basic también puede obtener los tipos que aceptan valores NULL mediante operadores de tipo. Por ejemplo, el que acepta valores NULL <xref:System.Boolean> tipo devuelto por `typeof(Nullable<bool>)` en C#, por `Nullable<Boolean>::typeid` en C++ y por `GetType(Nullable(Of Boolean))` en Visual Basic.  
  
 En la tabla siguiente se muestra la sintaxis que usa con `GetType` para varios tipos.  
  
|Para obtener|Usar|  
|------------|---------|  
|Acepta valores null <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")'|  
|Un puntero no administrado para `MyType`|`Type.GetType("MyType*")`|  
|Un puntero no administrado a un puntero a `MyType`|`Type.GetType("MyType**")`|  
|Un puntero administrado o una referencia a `MyType`|`Type.GetType("MyType&")`. Tenga en cuenta que, a diferencia de los punteros, las referencias están limitadas a un nivel.|  
|Una clase primaria y una clase anidada|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Una matriz unidimensional con un límite inferior de 0|`Type.GetType("MyArray[]")`|  
|Una matriz unidimensional con un límite inferior desconocido|`Type.GetType("MyArray[*]")`|  
|Una matriz de n dimensiones|Una coma (,) dentro de los corchetes un total de n-1 veces. Por ejemplo, `System.Object[,,]` representa tridimensional `Object` matriz.|  
|La matriz de una matriz bidimensional|`Type.GetType("MyArray[][]")`|  
|Una matriz bidimensional rectangular con límites inferiores desconocidos|`Type.GetType("MyArray[,]")`|  
|Un tipo genérico con un argumento de tipo|`Type.GetType("MyGenericType`1[MyType]")'|  
|Un tipo genérico con dos argumentos de tipo|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|Un tipo genérico con dos argumentos de tipo calificado con el ensamblado|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|Un tipo genérico con un argumento de tipo calificado de ensamblado completo de ensamblado|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|Un tipo genérico cuyo argumento de tipo es un tipo genérico con dos argumentos de tipo|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 El ejemplo siguiente recupera el tipo de `System.Int32` y usa ese objeto de tipo para mostrar el <xref:System.Type.FullName%2A> propiedad de `System.Int32`. Si un objeto de tipo hace referencia a un ensamblado que no existe, este ejemplo produce una excepción.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo.  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada. 
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.  
  
O bien 
 <paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene sintaxis no válida. Por ejemplo: "MyType[,*,]".  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> En las [aplicaciones .NET para la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.IO.IOException" />. </para>
          </block>  
  
Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado o alguna de sus dependencias no son válidos.  
  
O bien 
Actualmente, está cargada la versión 2.0 u otra posterior de Common Language Runtime pero el ensamblado se compiló con una versión posterior.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre calificado con el ensamblado del tipo que se va a obtener. Vea <see cref="P:System.Type.AssemblyQualifiedName" />. Si el tipo está en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, es suficiente para proporcionar el nombre completo del tipo por su espacio de nombres.</param>
        <param name="throwOnError">
          <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; <see langword="false" /> para devolver <see langword="null" />. Especificar <see langword="false" /> también suprime algunas otras condiciones de excepción, pero no todas ellas. Vea la sección Excepciones.</param>
        <param name="ignoreCase">
          <see langword="true" /> para realizar una búsqueda de <c>typeName</c> que no distinga entre mayúsculas y minúsculas; <see langword="false" /> para realizar una búsqueda de <c>typeName</c> que distinga entre mayúsculas y minúsculas.</param>
        <summary>Obtiene el <see cref="T:System.Type" /> con el nombre indicado, que especifica si se genera una excepción en caso de que no se encuentre el tipo y si se va a realizar una búsqueda donde se distingue entre mayúsculas y minúsculas.</summary>
        <returns>Tipo con el nombre especificado. Si el tipo no se encuentra, el parámetro <paramref name="throwOnError" /> especifica si se devuelve <see langword="null" /> o se produce una excepción. En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwOnError" />. Vea la sección Excepciones.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Type.GetType%2A> método para obtener un <xref:System.Type> si sabe su nombre completo de ensamblado que puede obtenerse a partir de objetos para un tipo en otro ensamblado, <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> hace que la carga del ensamblado especificado en `typeName`. También puede cargar un ensamblado mediante la <xref:System.Reflection.Assembly.Load%2A> método y, a continuación, utilice el <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> métodos de la <xref:System.Reflection.Assembly> clase para obtener <xref:System.Type> objetos. Si un tipo está en un ensamblado que se sabe que el programa en tiempo de compilación, es más eficaz utilizar `typeof` en C#, <xref:System.Type.GetType%2A> en Visual Basic, o `typeid` en C++.  
  
 `GetType` solo funciona en los ensamblados cargados desde el disco. Si se llama a `GetType` para buscar un tipo definido en un ensamblado dinámico definido mediante el <xref:System.Reflection.Emit> servicios, podría obtener un comportamiento incoherente. El comportamiento depende de si el ensamblado dinámico es persistente, es decir, se crea mediante la `RunAndSave` o `Save` modos de acceso a la <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeración. Si el ensamblado dinámico es persistente y se ha escrito en el disco antes de `GetType` es llamado, el cargador busca el ensamblado guardado en disco, carga ese ensamblado y recupera el tipo del ensamblado. Si el ensamblado no se ha guardado en el disco cuando `GetType` se llama, el método devuelve `null`. `GetType` no entiende los ensamblados dinámicos transitorios; por lo tanto, una llamada a `GetType` para recuperar un tipo en transitorio devuelve el ensamblado dinámico `null`.  
  
 Para usar `GetType` en un módulo dinámico, suscribirse a la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos y llamadas `GetType` antes de guardar. De lo contrario, obtendrá dos copias del ensamblado en la memoria.  
  
 El `throwOnError` parámetro especifica lo que sucede cuando no se encuentra el tipo y también suprime algunas condiciones de excepción, como se describe en la sección excepciones. Algunas excepciones se producen independientemente del valor de `throwOnError`. Por ejemplo, si se encuentra el tipo, pero no se puede cargar, un <xref:System.TypeLoadException> se produce incluso si `throwOnError` es `false`.  
  
 La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.  
  
|Tipo de miembro|Estático|No estático|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Campo|No|Sí. Un campo siempre es ocultar por nombre y firma.|  
|evento|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
|Método|No|Sí. Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).|  
|Tipo anidado|No|No|  
|Propiedad.|No es aplicable|La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad. Reflexión trata las propiedades como ocultar por nombre y firma. Véase la nota 2.|  
  
1.  Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas. Se trata de una comparación binaria.  
  
2.  Para la reflexión, propiedades y eventos son ocultar por nombre y firma. Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.  
  
3.  Los atributos personalizados no forman parte de common type system.  
  
 Las matrices o los tipos COM no se buscan, a menos que ya se han cargado en la tabla de clases disponibles.  
  
 `typeName` puede ser el nombre de tipo calificado por su espacio de nombres o un nombre completo de ensamblado que incluya una especificación de nombre de ensamblado. Vea <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Si `typeName` incluye el espacio de nombres pero no el nombre del ensamblado, este método busca solo ensamblado del objeto que realiza la llamada y Mscorlib.dll, en ese orden. Si typeName es un nombre completo con el nombre de ensamblado parcial o completo, este método busca en el ensamblado especificado. Si el ensamblado tiene un nombre seguro, se requiere un nombre de ensamblado completo.  
  
 El <xref:System.Type.AssemblyQualifiedName%2A> propiedad devuelve un nombre de tipo completo incluido tipos anidados, el nombre del ensamblado y los argumentos de tipo. Todos los compiladores compatibles con common language runtime emitirá el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando se consulta, con arreglo a las siguientes convenciones.  
  
> [!NOTE]
>  En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado. Por ejemplo, "ProcessorArchitecture = msil". Sin embargo, no se incluye en la cadena devuelta por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, por motivos de compatibilidad. También puede cargar tipos mediante la creación de un <xref:System.Reflection.AssemblyName> objeto y pasarlo a una sobrecarga adecuada de la <xref:System.Reflection.Assembly.Load%2A> método. A continuación, puede usar el <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método para cargar tipos desde el ensamblado. Vea también <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra diagonal inversa (\\)|Carácter de escape.|  
|Acento grave (')|Precede a uno o más dígitos que representa el número de parámetros de tipo, situado al final del nombre de un tipo genérico.|  
|Corchetes ([])|Incluya una lista de argumentos de tipo genérico, para un tipo genérico construido; dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.|  
|Coma (,)|Precede al nombre de ensamblado.|  
|Punto (.)|Denota los identificadores de espacio de nombres.|  
|Signo más (+)|Precede a una clase anidada.|  
  
 Por ejemplo, el nombre completo para una clase podría ser similar al siguiente:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Si el espacio de nombres fuera EspacioNombresPrincipal. Sub+EspacioNombres, la cadena tendría que ir delante del signo más (+) con un carácter de escape (\\) para evitar que se va a interpretar como un separador de anidamiento. La reflexión emite esta cadena como sigue:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Un "++" se convierte en "\\+\\+" y un "\\"se convierte en"\\\\".  
  
 Este nombre completo puede conservarse y usa más adelante para cargar el <xref:System.Type>. Para buscar y cargar un <xref:System.Type>, utilice <xref:System.Type.GetType%2A> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado. <xref:System.Type.GetType%2A> con el tipo de nombre sólo buscará los <xref:System.Type> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema. <xref:System.Type.GetType%2A> con el ensamblado de nombre de tipo calificado buscará el <xref:System.Type> en cualquier ensamblado.  
  
 Los nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz. Para recuperar el nombre del tipo sin estos caracteres finales, use `t.GetElementType().ToString()`, donde `t` es el tipo.  
  
 Espacios son relevantes en todos los componentes de nombre de tipo, excepto el nombre del ensamblado. En el nombre del ensamblado, espacios antes del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.  
  
 El nombre de un tipo genérico finaliza con un acento grave (\`) seguido de dígitos que representa el número de argumentos de tipo genérico. El propósito de este nombre con sufijo es permitir que los compiladores admitir tipos genéricos con el mismo nombre pero con distintos números de parámetros de tipo, que se producen en el mismo ámbito. Por ejemplo, la reflexión devuelve los nombres alterados `Tuple`1` and `tupla`2` desde los métodos genéricos `Tuple(Of T)` y `Tuple(Of T0, T1)` en Visual Basic, o `Tuple<T>` y tupla`\<T0, T1>` en Visual C#.  
  
 Para los tipos genéricos, la lista de argumentos de tipo se encierra entre corchetes y los argumentos de tipo están separados por comas. Por ejemplo, un tipo genérico <xref:System.Collections.Generic.Dictionary%602> tiene dos parámetros de tipo. Un <xref:System.Collections.Generic.Dictionary%602> de `MyType` con claves de tipo <xref:System.String> puede representarse como sigue:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Para especificar un tipo calificado con el ensamblado en una lista de argumentos de tipo, incluya el tipo de ensamblado completo entre corchetes. En caso contrario, las comas que separan las partes del nombre completo de ensamblado se interpretan como delimitar los argumentos de tipo adicionales. Por ejemplo, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` en MyAssembly.dll, con claves de tipo <xref:System.String>, puede especificar como sigue:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un tipo calificado con el ensamblado puede escribirse entre corchetes solo cuando aparece dentro de una lista de parámetros de tipo. Las reglas para buscar los ensamblados de tipos completos e incompletos en listas de parámetros de tipo son las mismas que las reglas para tipos no genéricos completos e incompletos.  
  
 Tipos que aceptan valores NULL son un caso especial de tipos genéricos. Por ejemplo, una que acepta valores NULL <xref:System.Int32> representado por la cadena "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  En C#, C++ y Visual Basic también puede obtener los tipos que aceptan valores NULL mediante operadores de tipo. Por ejemplo, el que acepta valores NULL <xref:System.Boolean> tipo devuelto por `typeof(Nullable<bool>)` en C#, por `Nullable<Boolean>::typeid` en C++ y por `GetType(Nullable(Of Boolean))` en Visual Basic.  
  
 En la tabla siguiente se muestra la sintaxis que usa con `GetType` para varios tipos.  
  
|Para obtener|Usar|  
|------------|---------|  
|Acepta valores null <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")'|  
|Un puntero no administrado para `MyType`|`Type.GetType("MyType*")`|  
|Un puntero no administrado a un puntero a `MyType`|`Type.GetType("MyType**")`|  
|Un puntero administrado o una referencia a `MyType`|`Type.GetType("MyType&")`. Tenga en cuenta que, a diferencia de los punteros, las referencias están limitadas a un nivel.|  
|Una clase primaria y una clase anidada|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Una matriz unidimensional con un límite inferior de 0|`Type.GetType("MyArray[]")`|  
|Una matriz unidimensional con un límite inferior desconocido|`Type.GetType("MyArray[*]")`|  
|Una matriz de n dimensiones|Una coma (,) dentro de los corchetes un total de n-1 veces. Por ejemplo, `System.Object[,,]` representa tridimensional `Object` matriz.|  
|La matriz de una matriz bidimensional|`Type.GetType("MyArray[][]")`|  
|Una matriz bidimensional rectangular con límites inferiores desconocidos|`Type.GetType("MyArray[,]")`|  
|Un tipo genérico con un argumento de tipo|`Type.GetType("MyGenericType`1[MyType]")'|  
|Un tipo genérico con dos argumentos de tipo|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|Un tipo genérico con dos argumentos de tipo calificado con el ensamblado|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|Un tipo genérico con un argumento de tipo calificado de ensamblado completo de ensamblado|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|Un tipo genérico cuyo argumento de tipo es un tipo genérico con dos argumentos de tipo|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo.  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada. 
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.  
  
O bien 
 <paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene sintaxis no válida. Por ejemplo: "MyType[,*,]".  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.</exception>
        <exception cref="T:System.IO.FileLoadException">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado o alguna de sus dependencias no son válidos.  
  
O bien 
Actualmente, está cargada la versión 2.0 u otra posterior de Common Language Runtime pero el ensamblado se compiló con una versión posterior.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre del tipo que se va a obtener. Si se proporciona el parámetro <c>typeResolver</c>, el nombre del tipo puede ser cualquier cadena que <c>typeResolver</c> pueda resolver. Si se proporciona el parámetro <c>assemblyResolver</c> o se usa la resolución de tipos estándar, <c>typeName</c> debe ser un nombre calificado con el ensamblado (vea <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que el tipo esté en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, en cuyo caso basta con aplicar el nombre de tipo calificado con su espacio de nombres.</param>
        <param name="assemblyResolver">Método que busca y devuelve el ensamblado especificado en <c>typeName</c>. El nombre del ensamblado se pasa a <c>assemblyResolver</c> como un objeto <see cref="T:System.Reflection.AssemblyName" />. Si <c>typeName</c> no contiene el nombre de un ensamblado, no se llama a <c>assemblyResolver</c>. Si no se proporciona <c>assemblyResolver</c>, se realiza la resolución de ensamblados estándar.  
  
Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza. Hacerlo podría tener como resultado la elevación de privilegios para el código malintencionado. Use solo los métodos que proporciona o con los que está familiarizado.</param>
        <param name="typeResolver">Método que busca y devuelve el tipo especificado por <c>typeName</c> del ensamblado devuelto por <c>assemblyResolver</c> o mediante la resolución de ensamblados estándar. Si no se proporciona ningún ensamblado, el método <c>typeResolver</c> podrá proporcionar uno. El método también toma un parámetro que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas; se pasa <see langword="false" /> a ese parámetro.  
  
Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</param>
        <summary>Obtiene el tipo con el nombre especificado, que, de manera opcional, puede proporcionar métodos personalizados para resolver el ensamblado y el tipo.</summary>
        <returns>Tipo con el nombre especificado, o <see langword="null" /> si no se encuentra el tipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Escenarios de uso para este método y los detalles sobre la `assemblyResolver` y `typeResolver` parámetros pueden encontrarse en el <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método.  
  
> [!NOTE]
>  Si `typeName` no se encuentra, la llamada a la <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> devuelve del método `null`. No se produce una excepción. Para controlar si se produce una excepción, llamar a una sobrecarga de la <xref:System.Type.GetType%2A> método que tiene un `throwOnError` parámetro.  
  
 Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método y especificando `false` para el `throwOnError` y `ignoreCase` parámetros.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
        <exception cref="T:System.ArgumentException">Se produce un error cuando <paramref name="typeName" /> se analiza en un nombre de tipo y un nombre de ensamblado (por ejemplo, cuando el nombre del tipo simple incluye un carácter especial sin escape).  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.  
  
O bien 
 <paramref name="typeName" /> contiene un nombre de ensamblado no válido.  
  
O bien 
 <paramref name="typeName" /> es un nombre de ensamblado válido sin un nombre de tipo.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado o alguna de sus dependencias no son válidos.  
  
O bien 
El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre del tipo que se va a obtener. Si se proporciona el parámetro <c>typeResolver</c>, el nombre del tipo puede ser cualquier cadena que <c>typeResolver</c> pueda resolver. Si se proporciona el parámetro <c>assemblyResolver</c> o se usa la resolución de tipos estándar, <c>typeName</c> debe ser un nombre calificado con el ensamblado (vea <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que el tipo esté en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, en cuyo caso basta con aplicar el nombre de tipo calificado con su espacio de nombres.</param>
        <param name="assemblyResolver">Método que busca y devuelve el ensamblado especificado en <c>typeName</c>. El nombre del ensamblado se pasa a <c>assemblyResolver</c> como un objeto <see cref="T:System.Reflection.AssemblyName" />. Si <c>typeName</c> no contiene el nombre de un ensamblado, no se llama a <c>assemblyResolver</c>. Si no se proporciona <c>assemblyResolver</c>, se realiza la resolución de ensamblados estándar.  
  
Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza. Hacerlo podría tener como resultado la elevación de privilegios para el código malintencionado. Use solo los métodos que proporciona o con los que está familiarizado.</param>
        <param name="typeResolver">Método que busca y devuelve el tipo especificado por <c>typeName</c> del ensamblado devuelto por <c>assemblyResolver</c> o mediante la resolución de ensamblados estándar. Si no se proporciona ningún ensamblado, el método podrá proporcionar uno. El método también toma un parámetro que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas; se pasa <see langword="false" /> a ese parámetro.  
  
Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</param>
        <param name="throwOnError">Es <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; es <see langword="false" /> para devolver <see langword="null" />. Si se especifica <see langword="false" /> se suprimen otras condiciones de excepción, pero no todas. Vea la sección Excepciones.</param>
        <summary>Obtiene el tipo con el nombre indicado, que especifica si se va a iniciar una excepción en caso de que el tipo no se encuentre y que, de manera opcional, puede proporcionar métodos personalizados para resolver el ensamblado y el tipo.</summary>
        <returns>Tipo con el nombre especificado. Si el tipo no se encuentra, el parámetro <paramref name="throwOnError" /> especifica si se devuelve <see langword="null" /> o se produce una excepción. En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwOnError" />. Vea la sección Excepciones.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Escenarios de uso para este método y los detalles sobre la `assemblyResolver` y `typeResolver` parámetros pueden encontrarse en el <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método.  
  
 Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método y especificando `false` para el `ignoreCase` parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo.  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada. 
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.  
  
O bien 
 <paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Se produce un error cuando <paramref name="typeName" /> se analiza en un nombre de tipo y un nombre de ensamblado (por ejemplo, cuando el nombre del tipo simple incluye un carácter especial sin escape).  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene la sintaxis no válida (por ejemplo, "MyType [, *,]").  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.  
  
O bien 
 <paramref name="typeName" /> contiene un nombre de ensamblado no válido.  
  
O bien 
 <paramref name="typeName" /> es un nombre de ensamblado válido sin un nombre de tipo.</exception>
        <exception cref="T:System.IO.FileLoadException">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado o alguna de sus dependencias no son válidos.  
  
O bien 
El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre del tipo que se va a obtener. Si se proporciona el parámetro <c>typeResolver</c>, el nombre del tipo puede ser cualquier cadena que <c>typeResolver</c> pueda resolver. Si se proporciona el parámetro <c>assemblyResolver</c> o se usa la resolución de tipos estándar, <c>typeName</c> debe ser un nombre calificado con el ensamblado (vea <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que el tipo esté en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, en cuyo caso basta con aplicar el nombre de tipo calificado con su espacio de nombres.</param>
        <param name="assemblyResolver">Método que busca y devuelve el ensamblado especificado en <c>typeName</c>. El nombre del ensamblado se pasa a <c>assemblyResolver</c> como un objeto <see cref="T:System.Reflection.AssemblyName" />. Si <c>typeName</c> no contiene el nombre de un ensamblado, no se llama a <c>assemblyResolver</c>. Si no se proporciona <c>assemblyResolver</c>, se realiza la resolución de ensamblados estándar.  
  
Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza. Hacerlo podría tener como resultado la elevación de privilegios para el código malintencionado. Use solo los métodos que proporciona o con los que está familiarizado.</param>
        <param name="typeResolver">Método que busca y devuelve el tipo especificado por <c>typeName</c> del ensamblado devuelto por <c>assemblyResolver</c> o mediante la resolución de ensamblados estándar. Si no se proporciona ningún ensamblado, el método podrá proporcionar uno. El método también toma un parámetro que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas; se pasa el valor de <c>ignoreCase</c> a ese parámetro.  
  
Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</param>
        <param name="throwOnError">Es <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; es <see langword="false" /> para devolver <see langword="null" />. Si se especifica <see langword="false" /> se suprimen otras condiciones de excepción, pero no todas. Vea la sección Excepciones.</param>
        <param name="ignoreCase">
          <see langword="true" /> para realizar una búsqueda de <c>typeName</c> que no distinga entre mayúsculas y minúsculas; <see langword="false" /> para realizar una búsqueda de <c>typeName</c> que distinga entre mayúsculas y minúsculas.</param>
        <summary>Obtiene el tipo con el nombre indicado, que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas y si se va a iniciar una excepción en caso de que el tipo no se encuentre y que, de manera opcional, puede proporcionar métodos personalizados para resolver el ensamblado y el tipo.</summary>
        <returns>Tipo con el nombre especificado. Si el tipo no se encuentra, el parámetro <paramref name="throwOnError" /> especifica si se devuelve <see langword="null" /> o se produce una excepción. En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwOnError" />. Vea la sección Excepciones.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método y sus sobrecargas asociadas (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> y <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) para reemplazar la implementación predeterminada de la <xref:System.Type.GetType%2A> método con las implementaciones más flexibles. Al proporcionar sus propios métodos que se resuelven los nombres de tipo y los nombres de los ensamblados que los contienen, puede hacer lo siguiente:  
  
-   Controlar qué versión de un ensamblado se carga un tipo de.  
  
-   Proporcionar otro lugar para buscar un nombre de tipo que no incluya un nombre de ensamblado.  
  
-   Cargar ensamblados con nombres de ensamblado parciales.  
  
-   Devolver las subclases de <xref:System.Type?displayProperty=nameWithType> no creados por common language runtime (CLR).  
  
 Por ejemplo, en la serialización tolerante a versiones este método le permite buscar un ensamblado de "ajuste perfecto" mediante un nombre parcial. Otras sobrecargas de los <xref:System.Type.GetType%2A> método requiere un nombre de tipo calificado con el ensamblado, que incluye el número de versión.  
  
 Implementaciones alternativas del sistema de tipos que deba devolver las subclases de <xref:System.Type?displayProperty=nameWithType> que no se crean mediante CLR; todos los tipos que son devueltos por otras sobrecargas de los <xref:System.Type.GetType%2A> método son tipos de tiempo de ejecución.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Notas de uso  
 Esta sobrecarga del método y sus sobrecargas asociadas analizar `typeName` en el nombre de un tipo y el nombre de un ensamblado y, a continuación, resolver los nombres. Resolución del nombre del ensamblado se produce antes de la resolución del nombre de tipo, porque se debe resolver un nombre de tipo en el contexto de un ensamblado.  
  
> [!NOTE]
>  Si no está familiarizado con el concepto de nombres de tipo calificado con el ensamblado, vea el <xref:System.Type.AssemblyQualifiedName%2A> propiedad.  
  
 Si `typeName` no es un nombre completo de ensamblado, se omite la resolución de ensamblado. Se pueden resolver los nombres de tipo no calificado en el contexto de Mscorlib.dll o el ensamblado actualmente en ejecución, o puede proporcionar opcionalmente un ensamblado en el `typeResolver` parámetro. Los efectos de incluir u omitir el nombre del ensamblado para diferentes tipos de resolución de nombres se muestran como una tabla en la [la resolución de nombres mixtos](#mixed_name_resolution) sección.  
  
 Notas de uso general:  
  
-   No pase métodos a `assemblyResolver` o `typeResolver` si proceden de llamadores desconocidos o que no se confía. Use solo los métodos que proporciona o con los que está familiarizado.  
  
    > [!CAUTION]
    >  Mediante métodos de llamadores desconocidos o no confiables podría provocar la elevación de privilegios para el código malintencionado.  
  
-   Si se omite el `assemblyResolver` o `typeResolver` parámetros, el valor de la `throwOnError` parámetro se pasa a los métodos que realizan la resolución predeterminada.  
  
-   Si `throwOnError` es `true`, este método produce una <xref:System.TypeLoadException> cuando `typeResolver` devuelve `null`y un <xref:System.IO.FileNotFoundException> cuando `assemblyResolver` devuelve `null`.  
  
-   Este método no detecta las excepciones producidas por `assemblyResolver` y `typeResolver`. Usted es responsable de las excepciones producidas por los métodos de resolución.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Resolver ensamblados  
 El `assemblyResolver` método recibe una <xref:System.Reflection.AssemblyName> objeto, que se produce al analizar el nombre del ensamblado de cadena que se incluye en `typeName`. Si `typeName` no contiene un nombre de ensamblado, `assemblyResolver` no se llama y `null` se pasa a `typeResolver`.  
  
 Si `assemblyResolver` no es el ensamblado proporcionado, estándar de sondeo se usa para buscar el ensamblado. Si `assemblyResolver` se proporciona, el <xref:System.Type.GetType%2A> método realiza la búsqueda estándar; en ese caso debe asegurarse de que su `assemblyResolver` puede administrar todos los ensamblados que se pasa a él.  
  
 El `assemblyResolver` método debe devolver `null` si no se puede resolver el ensamblado. Si `assemblyResolver` devuelve `null`, `typeResolver` no se llama y se produce la ningún procesamiento adicional; además, si `throwOnError` es `true`, un <xref:System.IO.FileNotFoundException> se produce.  
  
 Si el <xref:System.Reflection.AssemblyName> que se pasa a `assemblyResolver` es una parcial nombre, una o varias de sus partes son `null`. Por ejemplo, si no tiene versión, la <xref:System.Reflection.AssemblyName.Version%2A> propiedad es `null`. Si el <xref:System.Reflection.AssemblyName.Version%2A> propiedad, el <xref:System.Reflection.AssemblyName.CultureInfo%2A> propiedad y el <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> método devuelven `null`, a continuación, solo el nombre sencillo del ensamblado se ha proporcionado. El `assemblyResolver` método puede usar o ignorar todas las partes del nombre del ensamblado.  
  
 Los efectos de las opciones de resolución de ensamblado diferentes se muestran como una tabla en la [la resolución de nombres mixtos](#mixed_name_resolution) sección para nombres de tipo simple y completo de ensamblado.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Resolución de tipos  
 Si `typeName` no especifica un nombre de ensamblado, `typeResolver` siempre se llama. Si `typeName` especifica un nombre de ensamblado, `typeResolver` sólo se llama cuando el nombre de ensamblado se resuelve correctamente. Si `assemblyResolver` o ensamblado estándar sondeo devuelve `null`, `typeResolver` no se llama.  
  
 El `typeResolver` método recibe tres argumentos:  
  
-   El ensamblado para buscar o `null` si `typeName` no contiene un nombre de ensamblado.  
  
-   Nombre del tipo simple. En el caso de un tipo anidado, se trata del tipo de contenedor más externo. En el caso de un tipo genérico, esto es el nombre simple del tipo genérico.  
  
-   Un valor booleano que es `true` si el caso de nombres de tipo se va a omitir.  
  
 La implementación determina la manera en que se usan estos argumentos. El `typeResolver` método debe devolver `null` si no se puede resolver el tipo. Si `typeResolver` devuelve `null` y `throwOnError` es `true`, esta sobrecarga de <xref:System.Type.GetType%2A> produce una <xref:System.TypeLoadException>.  
  
 Se muestran los efectos de las opciones de resolución de tipo diferente como una tabla en la [la resolución de nombres mixtos](#mixed_name_resolution) sección para nombres de tipo simple y completo de ensamblado.  
  
#### <a name="resolving-nested-types"></a>Resolución de tipos anidados  
 Si `typeName` es un tipo anidado, solo el nombre del exterior que contiene el tipo se pasa a `typeResolver`. Cuando `typeResolver` devuelve este tipo, el <xref:System.Type.GetNestedType%2A> se llama al método de forma recursiva hasta que se ha resuelto el tipo anidado más interno.  
  
#### <a name="resolving-generic-types"></a>Resolución de tipos genéricos  
 El <xref:System.Type.GetType%2A> se denomina de forma recursiva para resolver tipos genéricos: en primer lugar para resolver el tipo genérico en Sí y, a continuación, para resolver sus argumentos de tipo. Si un argumento de tipo es genérico, <xref:System.Type.GetType%2A> se llama de forma recursiva para resolver sus argumentos de tipo y así sucesivamente.  
  
 La combinación de `assemblyResolver` y `typeResolver` que proporcione debe ser capaz de resolver todos los niveles de esta recursividad. Por ejemplo, suponga que proporciona un `assemblyResolver` que controla la carga de `MyAssembly`. Suponga que desea resolver el tipo genérico `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` en Visual Basic). Es posible que pase el siguiente nombre de tipo genérico:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Tenga en cuenta que `MyType` es el argumento de tipo calificado con el ensamblado solo. Los nombres de los <xref:System.Collections.Generic.Dictionary%602> y <xref:System.String> clases no son calificado del ensamblado. Su `typeResolver` debe ser capaz de identificador en un ensamblado o `null`, porque recibirá `null` para <xref:System.Collections.Generic.Dictionary%602> y <xref:System.String>. Ese caso puede controlar mediante una llamada a una sobrecarga de la <xref:System.Type.GetType%2A> método que toma una cadena, porque ambos de los nombres de tipo incompletos están en Mscorlib.dll:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 El `assemblyResolver` método no se llama para el tipo de diccionario y el tipo de cadena, porque esos nombres de tipo no están calificado con el ensamblado.  
  
 Ahora, supongamos que en lugar de `System.String`, el primer tipo de argumento genérico es `YourType`, desde `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Dado que este ensamblado es Mscorlib.dll ni ensamblado actualmente en ejecución, no puede resolver `YourType` sin un nombre completo de ensamblado. Dado que su `assemblyResolve` será llama de forma recursiva, debe ser capaz de controlar este caso. En lugar de devolver `null` para los ensamblados que no sea `MyAssembly`, ahora realiza una carga de ensamblados con el <xref:System.Reflection.AssemblyName> objeto.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Volver a [notas de uso](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Resolución de nombres de tipo con caracteres especiales  
 Ciertos caracteres tienen significados especiales en los nombres de ensamblado. Si un nombre de tipo simple contiene estos caracteres, los caracteres producen errores de análisis cuando el nombre simple es parte de un nombre completo de ensamblado. Para evitar los errores del análisis, debe realizar el escape los caracteres especiales con una barra diagonal inversa antes de pasar el nombre completo de ensamblado para el <xref:System.Type.GetType%2A> método. Por ejemplo, si un tipo se denomina `Strange]Type`, debe agregarse el carácter de escape delante del corchete como sigue: `Strange\]Type`.  
  
> [!NOTE]
>  Los nombres de los caracteres especiales no se puede crear en Visual Basic o C#, pero se pueden crear mediante el lenguaje intermedio de Microsoft (MSIL) o emitir ensamblados dinámicos.  
  
 La siguiente tabla muestra los caracteres especiales para nombres de tipo.  
  
|Carácter|Significado|  
|---------------|-------------|  
|`,` (coma)|Delimitador para los nombres de ensamblado.|  
|`[]` (los corchetes)|Como un par de sufijo, indica un tipo de matriz; como un par de delimitadores, incluye las listas de argumentos genéricos y los nombres de ensamblado.|  
|`&` (y comercial)|Como sufijo, indica que un tipo es un tipo de referencia.|  
|`*` (asterisco)|Como sufijo, indica que un tipo es un tipo de puntero.|  
|`+` (signo más)|Delimitador para los tipos anidados.|  
|`\` (barra diagonal inversa)|Carácter de escape.|  
  
 Propiedades, como <xref:System.Type.AssemblyQualifiedName%2A> devuelven correctamente cadenas de caracteres de escape. Debe pasar correctamente cadenas de escape para el <xref:System.Type.GetType%2A> método. A su vez, el <xref:System.Type.GetType%2A> método pasa los nombres de escape correctamente a `typeResolver` y a los métodos de resolución de tipo predeterminado. Si necesita comparar un nombre con un nombre sin escape en `typeResolver`, debe quitar los caracteres de escape.  
  
 Volver a [notas de uso](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Resolución de nombres mixtos  
 En la tabla siguiente se resume las interacciones entre `assemblyResolver`, `typeResolver`, resolución de nombres predeterminado, para todas las combinaciones de nombre de tipo y nombre del ensamblado y `typeName`:  
  
|Contenido del nombre de tipo|Método de resolución de ensamblado|Método de resolución de tipo|Resultado|  
|---------------------------|------------------------------|--------------------------|------------|  
|tipo de ensamblado|nulo|nulo|Equivalente a llamar a la <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga del método.|  
|tipo de ensamblado|Proporciona|nulo|`assemblyResolver` Devuelve el ensamblado o devuelve `null` si no se puede resolver el ensamblado. Si el ensamblado se ha resuelto, el <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga del método se usa para cargar el tipo del ensamblado; en caso contrario, no hay ningún intento para resolver el tipo.|  
|tipo de ensamblado|nulo|Proporciona|Equivalente a poner el nombre del ensamblado a un <xref:System.Reflection.AssemblyName> objeto y llamar a la <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> sobrecarga del método para obtener el ensamblado. Si el ensamblado se ha resuelto, se pasa a `typeResolver`; en caso contrario, `typeResolver` no se llama y no hay ningún intento adicional para resolver el tipo.|  
|tipo de ensamblado|Proporciona|Proporciona|`assemblyResolver` Devuelve el ensamblado o devuelve `null` si no se puede resolver el ensamblado. Si el ensamblado se ha resuelto, se pasa a `typeResolver`; en caso contrario, `typeResolver` no se llama y no hay ningún intento adicional para resolver el tipo.|  
|type|null, proporcionado|nulo|Equivalente a llamar a la <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga del método. Porque no se proporcionó el nombre del ensamblado, se buscan solo Mscorlib.dll y ensamblado actualmente en ejecución. Si `assemblyResolver` es siempre se omite.|  
|type|null, proporcionado|Proporciona|`typeResolver` se llama a, y `null` se pasa para el ensamblado. `typeResolver` puede proporcionar un tipo de cualquier ensamblado, incluidos los ensamblados que carga para el propósito. Si `assemblyResolver` es siempre se omite.|  
|ensamblado|null, proporcionado|null, proporcionado|Un <xref:System.IO.FileLoadException> se produce porque el nombre del ensamblado se analiza como si fuese un nombre de tipo calificado con el ensamblado. Esto da como resultado un nombre de ensamblado no válido.|  
  
 Volver a: [notas de uso](#usage_notes), [resolver ensamblados](#resolving_assemblies), [resolver tipos](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo.  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada. 
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.  
  
O bien 
 <paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Se produce un error cuando <paramref name="typeName" /> se analiza en un nombre de tipo y un nombre de ensamblado (por ejemplo, cuando el nombre del tipo simple incluye un carácter especial sin escape).  
  
O bien 
 <paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene la sintaxis no válida (por ejemplo, "MyType [, *,]").  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.</exception>
        <exception cref="T:System.IO.FileLoadException">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.  
  
O bien 
 <paramref name="typeName" /> contiene un nombre de ensamblado no válido.  
  
O bien 
 <paramref name="typeName" /> es un nombre de ensamblado válido sin un nombre de tipo.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado o alguna de sus dependencias no son válidos.  
  
O bien 
El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Matriz de objetos cuyos tipos se han de determinar.</param>
        <summary>Obtiene los tipos de los objetos de la matriz especificada.</summary>
        <returns>Matriz de objetos <see cref="T:System.Type" /> que representa todos los tipos de los elementos correspondientes de <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Type.GetTypeArray%2A> método para enumerar los tipos de los elementos de una matriz.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> es <see langword="null" />.  
  
O bien 
Uno o varios elementos de <paramref name="args" /> son <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invocan los inicializadores de clase y al menos uno genera una excepción.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo cuyo código de tipo subyacente se debe obtener.</param>
        <summary>Obtiene el código de tipo subyacente del objeto <see cref="T:System.Type" /> especificado.</summary>
        <returns>Código de tipo subyacente o <see cref="F:System.TypeCode.Empty" /> si <paramref name="type" /> es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al heredar de <xref:System.Type>, puede cambiar el comportamiento de este método invalidando el <xref:System.Type.GetTypeCodeImpl%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo el <xref:System.TypeCode> pueden usar la enumeración. En un bloque de decisiones dentro de la `WriteObjectInfo` método, el <xref:System.TypeCode> de un <xref:System.Object> parámetro se examina y se escribe un mensaje adecuado en la consola.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código de tipo subyacente de esta instancia de <see cref="T:System.Type" />.</summary>
        <returns>Código de tipo del tipo subyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método proporciona la implementación de la `static` (en C#) o `Shared` (en Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> método. Al heredar de <xref:System.Type>, puede invalidar este método para proporcionar su propia implementación de <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene el tipo asociado al identificador de clase especificado (CLSID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">Identificador CLSID del tipo que se va a obtener.</param>
        <summary>Obtiene el tipo asociado al identificador de clase especificado (CLSID).</summary>
        <returns>
          <see langword="System.__ComObject" /> independientemente de que CLSID sea válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetTypeFromCLSID%2A> método admite acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).  El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro. Puede recuperar el valor de la <xref:System.Type.IsCOMObject%2A> propiedad para determinar si el tipo devuelto por este método es un objeto COM.  
  
> [!TIP]
>  Puede llamar a la <xref:System.Type.GetTypeFromProgID%2A> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) sabe.  
  
 Crear una instancia de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:  
  
1.  Obtener un <xref:System.Type> objeto que representa el`__ComObject` que corresponde al CLSID mediante una llamada a la <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Llame a la <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para crear una instancia del objeto COM.  
  
 Vea el ejemplo para ver una ilustración.  
  
 El <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> sobrecarga pasa por alto cualquier excepción que se puede producir al crear instancias de un <xref:System.Type> objeto según el `clsid` argumento. Tenga en cuenta que si no se produce ninguna excepción `clsid` no se encuentra en el registro.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el CLSID de Microsoft Word [objeto Application](http://msdn.microsoft.com/library/office/ff838565.aspx) para recuperar un tipo COM que representa la aplicación Microsoft Word. A continuación, crea una instancia del tipo mediante una llamada a la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método y se cierra mediante una llamada a la [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) método.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework. Todos los objetos administrados, los que son visibles para COM incluidos (es decir, sus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo es <see langword="true" />) tiene un GUID que es devuelto por la <see cref="P:System.Type.GUID" /> propiedad. Aunque el método devuelve un <see cref="T:System.Type" /> objetos del objeto que se corresponde con el GUID de .NET Framework, no puede usar dicha <see cref="T:System.Type" /> objeto va a crear una instancia de tipo mediante una llamada a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como se muestra en el ejemplo siguiente.  [! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] en su lugar, el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> solo debe usarse para recuperar el GUID de un COM no administrado objeto y resultante <see cref="T:System.Type" /> objeto que se pasa a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> el método debe representar un objeto COM no administrado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Identificador CLSID del tipo que se va a obtener.</param>
        <param name="throwOnError">
          <see langword="true" /> para producir cualquier excepción que se genere.  
  
O bien 
 <see langword="false" /> para pasar por alto cualquier excepción que se produzca.</param>
        <summary>Obtiene el tipo asociado al identificador de clase (CLSID) especificado, que debe indicar si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</summary>
        <returns>
          <see langword="System.__ComObject" /> independientemente de que CLSID sea válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetTypeFromCLSID%2A> método admite acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).  El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro. Puede recuperar el valor de la <xref:System.Type.IsCOMObject%2A> propiedad para determinar si el tipo devuelto por este método es un objeto COM.  
  
> [!TIP]
>  Puede llamar a la <xref:System.Type.GetTypeFromProgID%2A> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) sabe.  
  
 Crear una instancia de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:  
  
1.  Obtener un <xref:System.Type> objeto que representa el `__ComObject` que corresponde al CLSID mediante una llamada a la <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Llame a la <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para crear una instancia del objeto COM.  
  
 Vea el ejemplo para ver una ilustración.  
  
 Las excepciones, como <xref:System.OutOfMemoryException> se producirá cuando se especifica `true` para `throwOnError`, pero no se producirá para anular el Registro CLSID.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el CLSID de Microsoft Word [objeto Application](http://msdn.microsoft.com/library/office/ff838565.aspx) para recuperar un tipo COM que representa la aplicación Microsoft Word. A continuación, crea una instancia del tipo mediante una llamada a la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método y se cierra mediante una llamada a la [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) método. Se produce una excepción si se produce un error al cargar el tipo.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework. Todos los objetos administrados, los que son visibles para COM incluidos (es decir, sus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo es <see langword="true" />) tiene un GUID que es devuelto por la <see cref="P:System.Type.GUID" /> propiedad. Aunque el método devuelve un <see cref="T:System.Type" /> objetos del objeto que se corresponde con el GUID de .NET Framework, no puede usar dicha <see cref="T:System.Type" /> objeto va a crear una instancia de tipo mediante una llamada a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como se muestra en el ejemplo siguiente.  [! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] en su lugar, el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> solo debe usarse para recuperar el GUID de un COM no administrado objeto y resultante <see cref="T:System.Type" /> objeto que se pasa a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> el método debe representar un objeto COM no administrado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Identificador CLSID del tipo que se va a obtener.</param>
        <param name="server">Servidor desde el que se va a cargar el tipo. Si el nombre de servidor es <see langword="null" />, el resultado que el método devuelve automáticamente es el equipo local.</param>
        <summary>Obtiene el tipo asociado al identificador de clase (CLSID) especificado desde el servidor especificado.</summary>
        <returns>
          <see langword="System.__ComObject" /> independientemente de que CLSID sea válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetTypeFromCLSID%2A> método admite acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).  El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro. Puede recuperar el valor de la <xref:System.Type.IsCOMObject%2A> propiedad para determinar si el tipo devuelto por este método es un objeto COM.  
  
> [!TIP]
>  Puede llamar a la <xref:System.Type.GetTypeFromProgID%2A> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) sabe.  
  
 Crear una instancia de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:  
  
1.  Obtener un <xref:System.Type> objeto que representa el `__ComObject` que corresponde al CLSID mediante una llamada a la <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Llame a la <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para crear una instancia del objeto COM.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el CLSID de Microsoft Word [objeto Application](http://msdn.microsoft.com/library/office/ff838565.aspx) para recuperar un tipo COM que representa la aplicación Microsoft Word desde un servidor llamado computer17.central.contoso.com. A continuación, crea una instancia del tipo mediante una llamada a la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método y se cierra mediante una llamada a la [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) método.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework. Todos los objetos administrados, los que son visibles para COM incluidos (es decir, sus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo es <see langword="true" />) tiene un GUID que es devuelto por la <see cref="P:System.Type.GUID" /> propiedad. Aunque el método devuelve un <see cref="T:System.Type" /> objetos del objeto que se corresponde con el GUID de .NET Framework, no puede usar dicha <see cref="T:System.Type" /> objeto va a crear una instancia de tipo mediante una llamada a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como se muestra en el ejemplo siguiente.  [! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] en su lugar, el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> solo debe usarse para recuperar el GUID de un COM no administrado objeto y resultante <see cref="T:System.Type" /> objeto que se pasa a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> el método debe representar un objeto COM no administrado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Identificador CLSID del tipo que se va a obtener.</param>
        <param name="server">Servidor desde el que se va a cargar el tipo. Si el nombre de servidor es <see langword="null" />, el resultado que el método devuelve automáticamente es el equipo local.</param>
        <param name="throwOnError">
          <see langword="true" /> para producir cualquier excepción que se genere.  
  
O bien 
 <see langword="false" /> para pasar por alto cualquier excepción que se produzca.</param>
        <summary>Obtiene el tipo asociado al identificador de clase (CLSID) indicado desde el servidor especificado y debe indicarse si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</summary>
        <returns>
          <see langword="System.__ComObject" /> independientemente de que CLSID sea válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.GetTypeFromCLSID%2A> método admite acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).  El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro. Puede recuperar el valor de la <xref:System.Type.IsCOMObject%2A> propiedad para determinar si el tipo devuelto por este método es un objeto COM.  
  
> [!TIP]
>  Puede llamar a la <xref:System.Type.GetTypeFromProgID%2A> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) sabe.  
  
 Crear una instancia de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:  
  
1.  Obtener un <xref:System.Type> objeto que representa el `__ComObject` que corresponde al CLSID mediante una llamada a la <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Llame a la <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para crear una instancia del objeto COM.  
  
 Las excepciones, como <xref:System.OutOfMemoryException> se producirá cuando se especifica `true` para `throwOnError`, pero no se producirá para anular el Registro CLSID.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el CLSID de Microsoft Word [objeto Application](http://msdn.microsoft.com/library/office/ff838565.aspx) para recuperar un tipo COM que representa la aplicación Microsoft Word desde un servidor llamado computer17.central.contoso.com. A continuación, crea una instancia del tipo mediante una llamada a la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método y se cierra mediante una llamada a la [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) método. Se produce una excepción si se produce un error al cargar el tipo.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework. Todos los objetos administrados, los que son visibles para COM incluidos (es decir, sus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo es <see langword="true" />) tiene un GUID que es devuelto por la <see cref="P:System.Type.GUID" /> propiedad. Aunque el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> método devuelve un <see cref="T:System.Type" /> objeto que se corresponde con el GUID de un objeto administrado determinado, no puede usar dicha <see cref="T:System.Type" /> objeto va a crear una instancia de tipo mediante una llamada a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como en el ejemplo siguiente se muestra.  [! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] en su lugar, el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> solo debe usarse para recuperar el GUID de no administrado Objeto COM y resultante <see cref="T:System.Type" /> objeto que se pasa a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> el método debe representar un objeto COM no administrado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Objeto que hace referencia al tipo.</param>
        <summary>Obtiene el tipo al que hace referencia el identificador de tipos especificado.</summary>
        <returns>El tipo al que hace referencia el <see cref="T:System.RuntimeTypeHandle" /> especificado o <see langword="null" /> si la propiedad <see cref="P:System.RuntimeTypeHandle.Value" /> de <paramref name="handle" /> es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Type.GetTypeFromHandle%2A> método para obtener un <xref:System.Type> objeto desde un <xref:System.RuntimeTypeHandle> proporcionada por el <xref:System.Type.GetTypeHandle%2A> método.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene el tipo asociado al identificador de programa (ProgID) especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID del tipo que se va a obtener.</param>
        <summary>Obtiene el tipo asociado al identificador de programa (ProgID) especificado y devuelve null si se produce un error al cargar <see cref="T:System.Type" />.</summary>
        <returns>Tipo asociado al ProgID especificado si <paramref name="progID" /> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para la compatibilidad con COM. ProgID no se utilizan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID del tipo que se va a obtener.</param>
        <param name="throwOnError">
          <see langword="true" /> para producir cualquier excepción que se genere.  
  
O bien 
 <see langword="false" /> para pasar por alto cualquier excepción que se produzca.</param>
        <summary>Obtiene el tipo asociado al identificador de programa (ProgID) especificado; debe indicarse si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</summary>
        <returns>Tipo asociado al identificador de programa (ProgID) especificado si <paramref name="progID" /> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para la compatibilidad con COM. Los identificadores del programa no se usan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.  
  
   
  
## Examples  
 El ejemplo siguiente recupera un tipo pasando un ProgID, especificando si se debe producir una excepción si el ProgID es válido. El ejemplo muestra a continuación, el ClassID relacionados con el ProgID, junto con cualquier mensaje de excepción aplicable.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">El ProgID especificado no está registrado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID del tipo que se va a obtener.</param>
        <param name="server">Servidor desde el que se va a cargar el tipo. Si el nombre de servidor es <see langword="null" />, el resultado que el método devuelve automáticamente es el equipo local.</param>
        <summary>Obtiene el tipo asociado al identificador de programa (ProgID) especificado desde el servidor especificado y devuelve null si se produce un error al cargar el tipo.</summary>
        <returns>Tipo asociado al identificador de programa (ProgID) especificado si <paramref name="progID" /> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para la compatibilidad con COM. Los identificadores del programa no se usan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.  
  
   
  
## Examples  
 El ejemplo siguiente recupera un tipo pasando un ProgID y nombre de servidor. En el ejemplo, a continuación, muestra el ClassID relacionado con el ProgID o produce una excepción si el ProgID o el nombre del servidor no es válido.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">Identificador de programa (ProgID) del <see cref="T:System.Type" /> que se va a obtener.</param>
        <param name="server">Servidor desde el que se va a cargar el tipo. Si el nombre de servidor es <see langword="null" />, el resultado que el método devuelve automáticamente es el equipo local.</param>
        <param name="throwOnError">
          <see langword="true" /> para producir cualquier excepción que se genere.  
  
O bien 
 <see langword="false" /> para pasar por alto cualquier excepción que se produzca.</param>
        <summary>Obtiene el tipo asociado al identificador de programa (ProgID) indicado desde el servidor especificado; debe indicarse si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</summary>
        <returns>Tipo asociado al identificador de programa (ProgID) especificado si <paramref name="progID" /> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para la compatibilidad con COM. Los identificadores del programa no se usan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.  
  
   
  
## Examples  
 El ejemplo siguiente recupera un tipo pasando un ProgID y nombre de servidor. El ejemplo muestra a continuación, el ClassID relacionados con el ProgID, especificando si se debe producir una excepción si el ProgID o el nombre del servidor no es válido.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">El ProgID especificado no está registrado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Objeto para el que se va a obtener el identificador Type.</param>
        <summary>Obtiene el identificador para la clase <see cref="T:System.Type" /> de un objeto especificado.</summary>
        <returns>Identificador para la clase <see cref="T:System.Type" /> del objeto <see cref="T:System.Object" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.  
  
   
  
## Examples  
 En el ejemplo siguiente se define la clase `MyClass1`, obtiene una instancia de él y recupera el identificador de ejecución del objeto.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el GUID asociado al objeto <see cref="T:System.Type" />.</summary>
        <value>GUID asociado al objeto <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un GUID está asociado a un tipo mediante el <xref:System.Runtime.InteropServices.GuidAttribute> atributo.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea la clase `MyClass1` con un método público, se crea un `Type` objeto correspondiente a `MyClass1`y obtiene el <xref:System.Guid> estructura mediante la `GUID` propiedad de la `Type` clase.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual engloba o hace referencia a otro tipo; es decir, si el objeto <see cref="T:System.Type" /> actual es una matriz o un puntero, o si se pasa por referencia.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> es una matriz o un puntero, o si se pasa por referencia; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por ejemplo, Type.GetType("Int32[]"). HasElementType devuelve `true`, pero Type.GetType("Int32"). HasElementType devuelve `false`. También devuelve HasElementType `true` para "Int32 *" y "Int32 &".  
  
 Si el actual <xref:System.Type> representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
   
  
## Examples  
 El ejemplo siguiente devuelve `true` o `false` dependiendo de si el objeto es una matriz, un tipo de referencia o un puntero.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.HasElementType" /> y determina si el objeto <see cref="T:System.Type" /> actual engloba a otro tipo o hace referencia a él; es decir, si el objeto <see cref="T:System.Type" /> actual es una matriz o un puntero, o se pasa por referencia.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Type" /> es una matriz o un puntero, o si se pasa por referencia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por ejemplo, Type.GetType("Int32[]"). HasElementTypeImpl devuelve `true`, pero Type.GetType("Int32"). HasElementTypeImpl devuelve `false`. También devuelve HasElementTypeImpl `true` para "Int32 *" y "Int32 &".  
  
   
  
## Examples  
 En el ejemplo siguiente se define la clase `MyTypeDelegator`, lo que invalida el `HasElementTypeImpl` método. La clase principal que se busca el `HasElementType` propiedad y muestra el elemento de tipo.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invoca a un miembro específico del objeto <see cref="T:System.Type" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del constructor, el método, la propiedad o el miembro de campo al que se va a invocar.  
  
O bien 
Cadena vacía ("") para llamar al miembro predeterminado.  
  
O bien 
Para los miembros de <see langword="IDispatch" />, cadena que representa el identificador DispID, por ejemplo "[DispID=3]".</param>
        <param name="invokeAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda. El acceso puede corresponder a uno de los marcadores <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc. No es necesario especificar el tipo de búsqueda. Si se omite el tipo de búsqueda, se usan <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />. Observe que la definición explícita de un objeto <see cref="T:System.Reflection.Binder" /> puede resultar necesaria para llamar correctamente a sobrecargas de método con argumentos variables.</param>
        <param name="target">Objeto donde debe invocarse al miembro especificado.</param>
        <param name="args">Matriz que contiene los argumentos que se van a pasar al miembro al cual se va a invocar.</param>
        <summary>Invoca al miembro especificado, aplica las restricciones de enlace igualmente especificadas y compara la lista de argumentos indicada.</summary>
        <returns>Objeto que representa el valor devuelto del miembro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  No puede usar <xref:System.Type.InvokeMember%2A> para invocar un método genérico.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:  
  
-   Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, los miembros privados y protegidos) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir miembros estáticos en la jerarquía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.  
  
 La siguiente <xref:System.Reflection.BindingFlags> indicadores de invocación pueden utilizarse para denotar la acción que realizará con el miembro:  
  
-   `CreateInstance` para invocar un constructor. `name` se omite. No es válido con otros indicadores de invocación.  
  
-   `InvokeMethod` para invocar un método, pero no un constructor o un inicializador de tipo. No es válido con `SetField` o `SetProperty`. Si `InvokeMethod` se especifica por sí mismo, `BindingFlags.Public`, `BindingFlags.Instance`, y `BindingFlags.Static` se incluyen automáticamente.  
  
-   `GetField` Para obtener el valor de un campo. No es válido con `SetField`.  
  
-   `SetField` Para establecer el valor de un campo. No es válido con `GetField`.  
  
-   `GetProperty` Para obtener una propiedad. No es válido con `SetProperty`.  
  
-   `SetProperty` Para establecer una propiedad. No es válido con `GetProperty`.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Un método se invocará si se cumplen las condiciones siguientes:  
  
-   El número de parámetros en la declaración del método es igual al número de argumentos de la `args` matriz (a menos que los argumentos predeterminados se definen en el miembro y `BindingFlags.OptionalParamBinding` se especifica).  
  
-   El tipo de cada argumento se puede convertir el enlazador para el tipo del parámetro.  
  
 El enlazador encontrará todos los métodos de coincidencia. Estos métodos se encuentran en función del tipo de enlace solicitado (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`, y así sucesivamente). El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.  
  
 Después de selecciona el método, se invoca. En ese momento se comprueba la accesibilidad. La búsqueda puede controlar qué conjunto de métodos se buscan en función del atributo de accesibilidad asociado al método. El <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método de la <xref:System.Reflection.Binder> clase es responsable de seleccionar el método que se debe invocar. El enlazador predeterminado, selecciona a la coincidencia más específica.  
  
 Se omiten las restricciones de acceso para el código de plena confianza; es decir, constructores privados, métodos, campos y propiedades pueden se puede obtener acceso y se invoca a través de <xref:System.Reflection> cada vez que el código es de plena confianza.  
  
 Puede usar `Type.InvokeMember` para establecer un campo en un valor determinado mediante la especificación de <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Por ejemplo, si desea establecer un campo de instancia público llamado F en la clase C y F es un `String`, puede usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Si F es un `String[]`, puede usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 responsable de inicializar el campo F en esta nueva matriz. También puede usar `Type.InvokeMember` para establecer una posición en una matriz proporcionando el índice del valor y, a continuación, en el siguiente valor utilizando código similar al siguiente:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Esta operación cambiará la cadena "z" en la matriz que contiene F a la cadena "b".  
  
 Cuando se invoca un `IDispatch` miembros, puede especificar el identificador DispID en lugar del nombre de miembro, con el formato de cadena "[DispID = ##]". Por ejemplo, si el identificador DispID de MyComMethod es 3, puede especificar la cadena "[DispID = 3]" en lugar de "MyComMethod". Invocar a un miembro por DispID es más rápido que buscar el miembro por su nombre. En escenarios de agregación compleja, el identificador DispID a veces es la única manera de invocar al miembro deseado.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa `InvokeMember` acceder a los miembros de un tipo.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> no contiene <see langword="CreateInstance" /> y <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> no es un atributo <see cref="T:System.Reflection.BindingFlags" /> válido.  
  
O bien 
 <paramref name="invokeAttr" /> no contiene una de las siguientes marcas de enlace:  <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> combinado con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene tanto <see langword="GetField" /> como <see langword="SetField" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene tanto <see langword="GetProperty" /> como <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> combinado con <see langword="SetField" /> o <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene <see langword="SetField" /> y <paramref name="args" /> tiene más de un elemento.  
  
O bien 
Se llama a este método en un objeto COM pero no se pasa una de las siguientes marcas de enlace: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.  
  
O bien 
Una de las matrices de parámetros con nombre contiene una cadena que es <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">El miembro especificado es un inicializador de clase.</exception>
        <exception cref="T:System.MissingFieldException">No se encuentran el campo o la propiedad.</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra ningún método que coincida con los argumentos en <paramref name="args" />.  
  
O bien 
El objeto <see cref="T:System.Type" /> actual representa un tipo que contiene parámetros de tipo abierto, es decir, <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">No se puede invocar al miembro especificado en <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método coincide con los criterios de enlace.</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework no admite actualmente este método.</exception>
        <exception cref="T:System.InvalidOperationException">El método representado por <paramref name="name" /> tiene uno o más parámetros de tipo genérico no especificados. Es decir, la propiedad <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del método devuelve <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a miembros no públicos, independientemente de su concesión establecido. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del constructor, el método, la propiedad o el miembro de campo al que se va a invocar.  
  
O bien 
Cadena vacía ("") para llamar al miembro predeterminado.  
  
O bien 
Para los miembros de <see langword="IDispatch" />, cadena que representa el identificador DispID, por ejemplo "[DispID=3]".</param>
        <param name="invokeAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda. El acceso puede corresponder a uno de los marcadores <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc. No es necesario especificar el tipo de búsqueda. Si se omite el tipo de búsqueda, se usan <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />. Observe que la definición explícita de un objeto <see cref="T:System.Reflection.Binder" /> puede resultar necesaria para llamar correctamente a sobrecargas de método con argumentos variables.</param>
        <param name="target">Objeto donde debe invocarse al miembro especificado.</param>
        <param name="args">Matriz que contiene los argumentos que se van a pasar al miembro al cual se va a invocar.</param>
        <param name="culture">Objeto que representa la configuración regional de globalización que se va a usar, que puede ser necesaria para las conversiones específicas de la configuración regional, como pasar un tipo numérico <see cref="T:System.String" /> a <see cref="T:System.Double" />.  
  
O bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar el <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <summary>Invoca al miembro especificado, aplica las restricciones de enlace especificadas y compara la lista de argumentos y la referencia cultural igualmente especificadas.</summary>
        <returns>Objeto que representa el valor devuelto del miembro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque el enlazador predeterminado no procesa <xref:System.Globalization.CultureInfo> (el `culture` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `culture`.  
  
> [!NOTE]
>  No puede usar <xref:System.Type.InvokeMember%2A> para invocar un método genérico.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:  
  
-   Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir miembros estáticos en la jerarquía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.  
  
 La siguiente <xref:System.Reflection.BindingFlags> indicadores de invocación pueden utilizarse para denotar la acción que realizará con el miembro:  
  
-   `CreateInstance` para invocar un constructor. `name` se omite. No es válido con otros indicadores de invocación.  
  
-   `InvokeMethod` para invocar un método, pero no un constructor o un inicializador de tipo. No es válido con `SetField` o `SetProperty`. Si `InvokeMethod` se especifica por sí mismo, `BindingFlags.Public`, `BindingFlags.Instance`, y `BindingFlags.Static` se incluyen automáticamente.  
  
-   `GetField` Para obtener el valor de un campo. No es válido con `SetField`.  
  
-   `SetField` Para establecer el valor de un campo. No es válido con `GetField`.  
  
-   `GetProperty` Para obtener una propiedad. No es válido con `SetProperty`.  
  
-   `SetProperty` Para establecer una propiedad. No es válido con `GetProperty`.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Un método se invocará si se cumplen las condiciones siguientes:  
  
-   El número de parámetros en la declaración del método es igual al número de argumentos de la `args` matriz (a menos que los argumentos predeterminados se definen en el miembro y `BindingFlags.OptionalParamBinding` se especifica).  
  
-   El tipo de cada argumento se puede convertir el enlazador para el tipo del parámetro.  
  
 El enlazador encontrará todos los métodos de coincidencia. Estos métodos se encuentran en función del tipo de enlace solicitado (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`, y así sucesivamente). El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.  
  
 Después de selecciona el método, se invoca. En ese momento se comprueba la accesibilidad. La búsqueda puede controlar qué conjunto de métodos se buscan en función del atributo de accesibilidad asociado al método. El <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método de la <xref:System.Reflection.Binder> clase es responsable de seleccionar el método que se debe invocar. El enlazador predeterminado, selecciona a la coincidencia más específica.  
  
 Se omiten las restricciones de acceso para el código de plena confianza; es decir, propiedades, métodos, campos y constructores privados pueden tener acceso a y se invocan mediante reflexión siempre que el código es de plena confianza.  
  
 Puede usar `Type.InvokeMember` para establecer un campo en un valor determinado mediante la especificación de <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Por ejemplo, si desea establecer un campo de instancia público llamado F en la clase C y F es un `String` puede usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Si F es un `String[]`, puede usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 responsable de inicializar el campo F en esta nueva matriz. También puede usar `Type.InvokeMember` para establecer una posición en una matriz proporcionando el índice del valor y, a continuación, en el siguiente valor utilizando código similar al siguiente:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Esta operación cambiará la cadena "z" en la matriz que contiene F a la cadena "b".  
  
 Cuando se invoca un `IDispatch` miembro puede especificar el identificador DispID en lugar del nombre de miembro, con el formato de cadena "[DispID = ##]". Por ejemplo, si el identificador DispID de MyComMethod es 3, puede especificar la cadena "[DispID = 3]" en lugar de "MyComMethod". Invocar a un miembro por DispID es más rápido que buscar el miembro por su nombre. En escenarios de agregación compleja, el identificador DispID a veces es la única manera de invocar al miembro deseado.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> no contiene <see langword="CreateInstance" /> y <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> no es un atributo <see cref="T:System.Reflection.BindingFlags" /> válido.  
  
O bien 
 <paramref name="invokeAttr" /> no contiene una de las siguientes marcas de enlace:  <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> combinado con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene tanto <see langword="GetField" /> como <see langword="SetField" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene tanto <see langword="GetProperty" /> como <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> combinado con <see langword="SetField" /> o <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene <see langword="SetField" /> y <paramref name="args" /> tiene más de un elemento.  
  
O bien 
Se llama a este método en un objeto COM pero no se pasa una de las siguientes marcas de enlace: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.  
  
O bien 
Una de las matrices de parámetros con nombre contiene una cadena que es <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">El miembro especificado es un inicializador de clase.</exception>
        <exception cref="T:System.MissingFieldException">No se encuentran el campo o la propiedad.</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra ningún método que coincida con los argumentos en <paramref name="args" />.  
  
O bien 
El objeto <see cref="T:System.Type" /> actual representa un tipo que contiene parámetros de tipo abierto, es decir, <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">No se puede invocar al miembro especificado en <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método coincide con los criterios de enlace.</exception>
        <exception cref="T:System.InvalidOperationException">El método representado por <paramref name="name" /> tiene uno o más parámetros de tipo genérico no especificados. Es decir, la propiedad <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del método devuelve <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a miembros no públicos, independientemente de su concesión establecido. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene el nombre del constructor, el método, la propiedad o el miembro de campo al que se va a invocar.  
  
O bien 
Cadena vacía ("") para llamar al miembro predeterminado.  
  
O bien 
Para los miembros de <see langword="IDispatch" />, cadena que representa el identificador DispID, por ejemplo "[DispID=3]".</param>
        <param name="invokeAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda. El acceso puede corresponder a uno de los marcadores <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc. No es necesario especificar el tipo de búsqueda. Si se omite el tipo de búsqueda, se usan <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.  
  
O bien 
Referencia nula (Nothing en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />. Observe que la definición explícita de un objeto <see cref="T:System.Reflection.Binder" /> puede resultar necesaria para llamar correctamente a sobrecargas de método con argumentos variables.</param>
        <param name="target">Objeto donde debe invocarse al miembro especificado.</param>
        <param name="args">Matriz que contiene los argumentos que se van a pasar al miembro al cual se va a invocar.</param>
        <param name="modifiers">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <c>args</c>. Los atributos asociados a un parámetro se almacenan en la firma del miembro.  
  
El enlazador predeterminado solo procesa este parámetro cuando se llama a un componente COM.</param>
        <param name="culture">Objeto <see cref="T:System.Globalization.CultureInfo" /> que representa la configuración regional de globalización que se va a usar, que puede ser necesaria para las conversiones específicas de la configuración regional, como pasar un tipo numérico String a Double.  
  
o bien 
Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar el <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="namedParameters">Matriz que contiene los nombres de los parámetros a los que se pasan los valores de la matriz <c>args</c>.</param>
        <summary>Cuando se invalida en una clase derivada, invoca al miembro especificado, aplica las restricciones de enlace igualmente especificadas y realiza una comparación con la lista de argumentos, los modificadores y la referencia cultural indicados.</summary>
        <returns>Objeto que representa el valor devuelto del miembro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` llama a un miembro de constructor o método, obtiene o establece a un miembro de propiedad, obtiene o establece a un miembro de campo de datos, u Obtiene o establece un elemento de un miembro de la matriz.  
  
> [!NOTE]
>  No puede usar <xref:System.Type.InvokeMember%2A> para invocar un método genérico.  
  
 Cuando se invoca un `IDispatch` miembro puede especificar el identificador DispID en lugar del nombre de miembro, con el formato de cadena "[DispID = ##]". Por ejemplo, si el identificador DispID de MyComMethod es 3, puede especificar la cadena "[DispID = 3]" en lugar de "MyComMethod". Invocar a un miembro por DispID es más rápido que buscar el miembro por su nombre. En escenarios de agregación compleja, el identificador DispID a veces es la única manera de invocar al miembro deseado.  
  
 Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> o <xref:System.Globalization.CultureInfo> (el `modifiers` y `culture` parámetros), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers` y `culture`. `ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.  
  
 Cada parámetro de la matriz `namedParameters` obtiene el valor en el elemento correspondiente de la matriz `args`. Si la longitud de `args` es mayor que la longitud de `namedParameters`, los valores de argumento restantes se pasan por orden.  
  
 El `namedParameters` matriz puede usarse para cambiar el orden de los argumentos en una matriz de entrada. Por ejemplo, dado el método `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` en Visual Basic) y la matriz de entrada `{ 42, "x" }`, se puede pasar sin cambios a la matriz de entrada `args` si la matriz `{ "b", "a" }` proporcionado para `namedParameters`.  
  
 La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:  
  
-   Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.  
  
-   Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.  
  
-   Especificar `BindingFlags.FlattenHierarchy` para incluir miembros estáticos en la jerarquía.  
  
 La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:  
  
-   `BindingFlags.IgnoreCase` para omitir la grafía de `name`.  
  
-   `BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.  
  
 La siguiente <xref:System.Reflection.BindingFlags> indicadores de invocación pueden utilizarse para denotar la acción que realizará con el miembro:  
  
-   `CreateInstance` para invocar un constructor. `name` se omite. No es válido con otros indicadores de invocación.  
  
-   `InvokeMethod` para invocar un método, pero no un constructor o un inicializador de tipo. No es válido con `SetField` o `SetProperty`. Si `InvokeMethod` se especifica por sí mismo, `BindingFlags.Public`, `BindingFlags.Instance`, y `BindingFlags.Static` se incluyen automáticamente.  
  
-   `GetField` Para obtener el valor de un campo. No es válido con `SetField`.  
  
-   `SetField` Para establecer el valor de un campo. No es válido con `GetField`.  
  
-   `GetProperty` Para obtener una propiedad. No es válido con `SetProperty`.  
  
-   `SetProperty` Para establecer una propiedad. No es válido con `GetProperty`.  
  
 Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.  
  
 Un método se invocará si se cumplen las condiciones siguientes:  
  
-   El número de parámetros en la declaración del método es igual al número de argumentos de la `args` matriz (a menos que los argumentos predeterminados se definen en el miembro y `BindingFlags.OptionalParamBinding` se especifica).  
  
-   El tipo de cada argumento se puede convertir el enlazador para el tipo del parámetro.  
  
 El enlazador encontrará todos los métodos de coincidencia. Estos métodos se encuentran en función del tipo de enlace solicitado (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`, y así sucesivamente). El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.  
  
 Después de selecciona el método, se invoca. En ese momento se comprueba la accesibilidad. La búsqueda puede controlar qué conjunto de métodos se buscan en función del atributo de accesibilidad asociado al método. El <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método de la <xref:System.Reflection.Binder> clase es responsable de seleccionar el método que se debe invocar. El enlazador predeterminado, selecciona a la coincidencia más específica.  
  
 `InvokeMember` puede usarse para invocar métodos con parámetros que tienen valores predeterminados. Para enlazar a estos métodos, Reflection requiere <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> especificarse. Para un parámetro que tiene un valor predeterminado, puede proporcionar un valor distinto o proporcionar <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> para usar el valor predeterminado.  
  
 Por ejemplo, considere la posibilidad de un método como MyMethod (int x, float y = 2.0). Para invocar este método solamente con el primer argumento como MyMethod (4), pasar uno de los marcadores de enlace anterior y dos argumentos, es decir, 4 para el primer argumento y `Missing.Value` para el segundo argumento. A menos que use `Missing.Value`, no se puede omitir los parámetros opcionales con la `Invoke` método. Si debe hacerlo, use `InvokeMember` en su lugar.  
  
 Se omiten las restricciones de acceso para el código de plena confianza; es decir, constructores privados, métodos, campos y propiedades pueden se puede obtener acceso y se invoca a través de <xref:System.Reflection> cada vez que el código es de plena confianza.  
  
 Puede usar `Type.InvokeMember` para establecer un campo en un valor determinado mediante la especificación de <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Por ejemplo, si desea establecer un campo de instancia público llamado F en la clase C y F es un `String`, puede usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Si F es un `String[]`, puede usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 responsable de inicializar el campo F en esta nueva matriz. También puede usar `Type.InvokeMember` para establecer una posición en una matriz proporcionando el índice del valor y, a continuación, en el siguiente valor utilizando código similar al siguiente:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Esta operación cambiará la cadena "z" en la matriz que contiene F a la cadena "b".  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> no contiene <see langword="CreateInstance" /> y <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> y <paramref name="modifiers" /> no tienen la misma longitud.  
  
O bien 
 <paramref name="invokeAttr" /> no es un atributo <see cref="T:System.Reflection.BindingFlags" /> válido.  
  
O bien 
 <paramref name="invokeAttr" /> no contiene una de las siguientes marcas de enlace:  <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> combinado con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene tanto <see langword="GetField" /> como <see langword="SetField" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene tanto <see langword="GetProperty" /> como <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> combinado con <see langword="SetField" /> o <see langword="SetProperty" />.  
  
O bien 
 <paramref name="invokeAttr" /> contiene <see langword="SetField" /> y <paramref name="args" /> tiene más de un elemento.  
  
O bien 
La matriz de parámetros con nombre es mayor que la matriz de argumentos.  
  
O bien 
Se llama a este método en un objeto COM pero no se pasa una de las siguientes marcas de enlace: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.  
  
O bien 
Una de las matrices de parámetros con nombre contiene una cadena que es <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">El miembro especificado es un inicializador de clase.</exception>
        <exception cref="T:System.MissingFieldException">No se encuentran el campo o la propiedad.</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra ningún método que coincida con los argumentos en <paramref name="args" />.  
  
O bien 
No se puede encontrar ningún miembro con los nombres de argumento proporcionados en <paramref name="namedParameters" />.  
  
O bien 
El objeto <see cref="T:System.Type" /> actual representa un tipo que contiene parámetros de tipo abierto, es decir, <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">No se puede invocar al miembro especificado en <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método coincide con los criterios de enlace.</exception>
        <exception cref="T:System.InvalidOperationException">El método representado por <paramref name="name" /> tiene uno o más parámetros de tipo genérico no especificados. Es decir, la propiedad <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del método devuelve <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para obtener acceso a miembros no públicos, independientemente de su concesión establecido. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> es abstracto y se debe invalidar.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> es abstracto; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.IsAbstract%2A> propiedad devuelve `true` en los casos siguientes:  
  
-   El tipo actual es abstracto; es decir, no pueden crearse instancias, pero sólo puede actuar como clase base para las clases derivadas. En C#, clases abstractas se marcan con el [abstracta](~/docs/csharp/language-reference/keywords/abstract.md) palabra clave; en Visual Basic, se marcan con el [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) palabra clave.  
  
-   El tipo actual es una interfaz.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una matriz de <xref:System.Type> objetos que representan los siguientes tipos: contiene los valores devueltos de tipo `true` si el objeto especificado es `abstract`; en caso contrario, devuelve `false`.  
  
-   `AbstractClass`, una clase abstracta (una clase marcada como `abstract` en C# y `MustInherit` en Visual Basic).  
  
-   `DerivedClass`, una clase que hereda de `AbstractClass`.  
  
-   `SingleClass`, una clase no heredable. Se define como `sealed` en C# y `NotInheritable` en Visual Basic.  
  
-   `ITypeInfo`, una interfaz.  
  
-   `ImplementingClass`, una clase que implementa el `ITypeInfo` interfaz.  
  
 El método devuelve `true` sólo para `AbstractClass`, la clase abstracta, y `ITypeInfo`, la interfaz.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se selecciona el atributo de formato de cadena <see langword="AnsiClass" /> para el objeto <see cref="T:System.Type" />.</summary>
        <value>Es <see langword="true" /> si se selecciona el atributo de formato de cadena <see langword="AnsiClass" /> para <see cref="T:System.Type" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.TypeAttributes.StringFormatMask> selecciona los atributos de formato de cadena. Los atributos de formato de cadena mejoran la interoperabilidad definiendo cómo se deben interpretar las cadenas.  
  
 Si el actual <xref:System.Type> representa un tipo genérico, esta propiedad pertenece a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene la información de campo y busca el `AnsiClass` atributo.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo es una matriz.</summary>
        <value>
          <see langword="true" /> si el tipo actual es una matriz; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.IsArray%2A> propiedad devuelve `false` para el <xref:System.Array> clase. También devuelve `false` si la instancia actual es un <xref:System.Type> objeto que representa un tipo de colección o una interfaz que se ha diseñado para trabajar con colecciones, como <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Para comprobar si una matriz, use código como:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Si el tipo actual representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
 Esta propiedad es de sólo lectura.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo utilizar el <xref:System.Type.IsArray%2A> propiedad.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsArray" /> y determina si <see cref="T:System.Type" /> es una matriz.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Type" /> es una matriz; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una instancia de la <xref:System.Array> debe devolver la clase `false` porque es un objeto, no es una matriz.  
  
   
  
## Examples  
 En el ejemplo siguiente se invalida el `IsArrayImpl` método en el `MyTypeDelegator` comprueba si una variable es una matriz y muestra el resultado de la clase.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Tipo que se va a comparar con el tipo actual.</param>
        <summary>Determina si una instancia del tipo especificado se puede asignar a una instancia del tipo actual.</summary>
        <returns>
          <see langword="true" /> si alguna de las condiciones siguientes es "true": 
-   <paramref name="c" /> y la instancia actual representan el mismo tipo.  
  
-   <paramref name="c" /> se deriva de forma directa o indirecta de la instancia actual. <paramref name="c" /> se deriva directamente de la instancia actual si se hereda de la instancia actual, mientras que <paramref name="c" /> se deriva indirectamente de la instancia actual si se hereda de una sucesión de una o varias clases que se heredan de la instancia actual.  
  
-   La instancia actual es una interfaz que <paramref name="c" /> implementa.  
  
-   <paramref name="c" /> es un parámetro de tipo genérico y la instancia actual representa una de las restricciones de <paramref name="c" />.  
  
En el ejemplo siguiente, la instancia actual es un objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.IO.Stream" />. <c>GenericWithConstraint</c> es un tipo genérico cuyo parámetro de tipo genérico debe ser del tipo <see cref="T:System.IO.Stream" />. La acción de pasar su parámetro de tipo genérico a <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indica que se puede asignar una instancia del parámetro de tipo genérico a un objeto <see cref="T:System.IO.Stream" />.  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> representa un tipo de valor y la instancia actual representa <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> en Visual Basic).  
  
 Es <see langword="false" /> si ninguna de estas condiciones son true o si <paramref name="c" /> es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.IsAssignableFrom%2A> método puede utilizarse para determinar si una instancia de `c` puede asignarse a una instancia del tipo actual, el método es muy útil cuando lo está manejando de objetos cuyos tipos no se conocen en tiempo de diseño y permite condicionales Muestra la asignación, como en el ejemplo siguiente.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Este método garantiza que por lo tanto, una línea de código, como los siguientes se ejecutarán en tiempo de ejecución sin producir una <xref:System.InvalidCastException> excepción o una excepción similar:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Este método puede reemplazarse por una clase derivada.  
  
> [!NOTE]
>  Una definición de tipo genérico no es asignable desde un tipo construido cerrado. Es decir, no se puede asignar el tipo construido cerrado `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) a una variable de tipo `MyGenericList<T>`.  
  
 Si el `c` parámetro es de tipo <xref:System.Reflection.Emit.TypeBuilder>, el resultado se basa en el tipo que se van a compilar. El ejemplo de código siguiente muestra esto utilizando un tipo integrado denominado `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el `IsAssignableFrom` utilizando el método definido por clases, matrices de enteros y tipos genéricos.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se selecciona el atributo de formato de cadena <see langword="AutoClass" /> para el objeto <see cref="T:System.Type" />.</summary>
        <value>Es <see langword="true" /> si se selecciona el atributo de formato de cadena <see langword="AutoClass" /> para <see cref="T:System.Type" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.TypeAttributes.StringFormatMask> selecciona los atributos de formato de cadena. Los atributos de formato de cadena mejoran la interoperabilidad definiendo cómo se deben interpretar las cadenas.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si los campos de tipo de la actual se disponen automáticamente mediante Common Language Runtime.</summary>
        <value>
          <see langword="true" /> si la propiedad <see cref="P:System.Type.Attributes" /> del tipo actual incluye <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se proporciona por comodidad. Como alternativa, puede usar el <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeración para seleccionar los atributos de diseño de tipo y la prueba si <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> está establecido. El <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, y <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeración indican la manera en que los campos del tipo se colocan en la memoria.  
  
 Para los tipos dinámicos, puede especificar <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> cuando se crea el tipo. En el código, se aplican los <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo con el <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> valor de enumeración para el tipo, para permitir que el tiempo de ejecución a determinar la forma adecuada para diseñar la clase.  
  
> [!NOTE]
>  No puede usar el <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar si el <xref:System.Runtime.InteropServices.StructLayoutAttribute> se ha aplicado a un tipo.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>.`  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
   
  
## Examples  
 El ejemplo siguiente se crea una instancia del tipo y muestra el <xref:System.Type.IsAutoLayout%2A> propiedad.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> se pasa por referencia.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> se pasa por referencia; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener el tipo real, desreferenciar el tipo que se ha pasado por referencia y, a continuación, llamar a <xref:System.Type.GetElementType%2A> en ese tipo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de la `IsByRef` propiedad para comprobar si un tipo especificado se pasa por referencia. En el ejemplo se define la clase `MyTypeDelegator`, lo que invalida el `HasElementTypeImpl` método. La clase principal que se busca el `HasElementType` propiedad y muestra el elemento de tipo.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsByRef" /> y determina si <see cref="T:System.Type" /> se pasa por referencia.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Type" /> se pasa por referencia; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> es una clase o un delegado, es decir, no es un tipo de valor ni una interfaz.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> es una clase; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve `true` para clases, así como los delegados. Devuelve `false` para tipos de valor (para las estructuras y enumeraciones) incluso si se han convertido.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `true`. Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad devuelve `true` si la definición de tipo genérico es una definición de clase; es decir, no define una interfaz o un tipo de valor.  
  
> [!NOTE]
>  Esta propiedad devuelve `true` para `Type` instancias que representan el <xref:System.Enum> y <xref:System.ValueType> clases. Estas dos clases son los tipos base para las enumeraciones y tipos de valor, respectivamente, pero no son enumeraciones o tipos de valor a sí mismos. Para obtener más información, consulte el <xref:System.Type.IsValueType%2A> y <xref:System.Type.IsEnum%2A> propiedades.  
  
 El <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valor de enumeración distingue una declaración de tipo como clase o interfaz. Sin embargo, las clases y tipos de valor se marcan con el <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> atributo. Si recupera el valor de propiedad de los atributos y el uso de un tipo el <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valor para determinar si un tipo es una clase en lugar de un tipo de valor, también se debe llamar el <xref:System.Type.IsValueType%2A> propiedad. El ejemplo de la <xref:System.Reflection.TypeAttributes> enumeración contiene información adicional, así como anexample.  
  
 Esta propiedad es de sólo lectura.  
  
   
  
## Examples  
 El ejemplo siguiente crea una instancia de un tipo y se indica si el tipo es una clase.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> es un objeto COM.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> es un objeto COM; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve `false` para interfaces COM porque no son objetos. Interfaces COM pueden ser implementadas por objetos de Microsoft .NET Framework.  
  
 También puede cargar una clase COM y obtener un `Type` objeto para esa clase mediante el uso de la [Tlbimp.exe (importador de biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) herramienta.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int`> (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsCOMObject" /> y determina si <see cref="T:System.Type" /> es un objeto COM.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Type" /> es un objeto COM; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve `false` para interfaces COM porque no son objetos. Interfaces COM pueden ser implementadas por objetos de Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto representa un tipo genérico construido. Puede crear instancias de un tipo genérico construido.</summary>
        <value>
          <see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ha producido un tipo genérico construido tipos explícitos suministrados para todos sus parámetros de tipo genérico. También se denomina un tipo genérico cerrado.  
  
 Cuando esta propiedad es `true`, puede crear instancias del tipo actual; si es `false`, no puede.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> puede estar hospedado en un contexto.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> puede estar hospedado en un contexto; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contexto intercepta las llamadas a los miembros de clase y aplica las directivas que se aplican a la clase, como la sincronización. Para obtener más información acerca de los contextos de comunicación remota, consulte <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, y <xref:System.Type.IsPrimitive%2A> propiedades de la <xref:System.Type> clase. Comprueba si el tipo especificado puede hospedarse en el contexto, si se pueden calcular las referencias por referencia, y si el tipo es un tipo de datos primitivo.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa la propiedad <see cref="P:System.Type.IsContextful" /> y determina si la clase <see cref="T:System.Type" /> puede hospedarse en un contexto.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Type" /> puede estar hospedado en un contexto; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada.  
  
 Un contexto intercepta las llamadas a los miembros de clase y aplicar directivas que se aplican a la clase, como la sincronización.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de la `IsContextfulImpl` método.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual representa una enumeración.</summary>
        <value>Es <see langword="true" /> si el objeto <see cref="T:System.Type" /> actual representa una enumeración; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve `true` para una enumeración, pero no para el <xref:System.Enum> propio tipo.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
 Esta propiedad es de sólo lectura.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el `IsEnum` propiedad.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a probar.</param>
        <summary>Devuelve un valor que indica si el valor especificado existe en el tipo de enumeración actual.</summary>
        <returns>
          <see langword="true" /> si el valor especificado es un miembro del tipo de enumeración actual; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El tipo actual no es una enumeración.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> es de un tipo que no puede ser un tipo subyacente de una enumeración.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">Tipo COM cuya equivalencia con el tipo actual se comprueba.</param>
        <summary>Determina si dos tipos COM tienen la misma identidad y se pueden usar para la equivalencia de tipos.</summary>
        <returns>
          <see langword="true" /> si los tipos COM son equivalentes; de lo contrario, <see langword="false" />. Este método también devuelve <see langword="false" /> si un tipo está en un ensamblado que se carga para la ejecución y el otro está en un ensamblado que se carga en el contexto de solo reflexión.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], common language runtime admite la incrustación de información de tipos COM directamente en los ensamblados administrados, en lugar de requerir a los ensamblados administrados obtener información de tipos COM de interoperabilidad ensamblados. Dado que la información de tipos incrustada solo incluye los tipos y miembros que realmente usa un ensamblado administrado, dos ensamblados administrados pueden tener vistas muy diferentes del mismo tipo COM. Cada ensamblado administrado tiene un objeto <xref:System.Type> diferente para representar su vista del tipo COM. Common Language Runtime admite la equivalencia de tipos entre estas distintas vistas de interfaces, estructuras, enumeraciones y delegados.  
  
 La equivalencia de tipos significa que un objeto COM que se pasa de un ensamblado administrado a otro se puede convertir al tipo administrado adecuado en el ensamblado receptor. El <xref:System.Type.IsEquivalentTo%2A> método permite a un ensamblado determinar que un objeto COM obtenido de otro ensamblado tiene la misma identidad de COM como uno de los tipos de interoperabilidad de primera insertados propios de ensamblado y, por lo tanto, se puede convertir a ese tipo.  
  
 Para obtener más información, consulte [equivalencia de tipos y tipos de interoperabilidad incrustados](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si los campos del tipo actual se disponen en los desplazamientos especificados explícitamente.</summary>
        <value>
          <see langword="true" /> si la propiedad <see cref="P:System.Type.Attributes" /> del tipo actual incluye <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se proporciona por comodidad. Como alternativa, puede usar el <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeración para seleccionar los atributos de diseño de tipo y la prueba si <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> está establecido. El <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, y <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeración indican la manera en que los campos del tipo se colocan en la memoria.  
  
 Para los tipos dinámicos, puede especificar <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> cuando se crea el tipo. En el código, se aplican los <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo con el <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> valor de enumeración para el tipo, para especificar que los desplazamientos a la que se iniciará los campos se especifican explícitamente.  
  
> [!NOTE]
>  No puede usar el <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar si el <xref:System.Runtime.InteropServices.StructLayoutAttribute> se ha aplicado a un tipo.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
   
  
## Examples  
 El ejemplo siguiente se crea una instancia de un tipo y muestra el valor de su <xref:System.Type.IsExplicitLayout%2A> propiedad. Usa el `MySystemTime` (clase), que se encuentra también en el ejemplo de código para <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo en la definición de un método o tipo genérico.</summary>
        <value>
          <see langword="true" /> si el objeto <see cref="T:System.Type" /> representa un parámetro de tipo de una definición de tipo genérico o de una definición de método genérico; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> objetos que representan los parámetros de tipo genérico se pueden obtener mediante una llamada a la <xref:System.Type.GetGenericArguments%2A> método de un <xref:System.Type> objeto que representa una definición de tipo genérico, o la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> método de un <xref:System.Reflection.MethodInfo> objeto que representa un método genérico definición.  
  
-   Para un tipo genérico o una definición de método, el <xref:System.Type.IsGenericParameter%2A> propiedad devuelve `true` para todos los elementos de la matriz resultante.  
  
-   Para un tipo construido cerrado o un método, el <xref:System.Type.IsGenericParameter%2A> propiedad devuelve `false` para todos los elementos de la matriz devuelta por la <xref:System.Type.GetGenericArguments%2A> método.  
  
-   Para un tipo construido abierto o método, algunos elementos de la matriz podrían ser tipos específicos y otros podrían ser parámetros de tipo. <xref:System.Type.IsGenericParameter%2A> Devuelve `false` para los tipos y `true` para los parámetros de tipo. El ejemplo de código para el <xref:System.Type.ContainsGenericParameters%2A> propiedad muestra una clase genérica con una mezcla de tipos y parámetros de tipo.  
  
 Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Type.IsGenericParameter%2A> propiedad va a comprobar los parámetros de tipo genérico en un tipo genérico.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo actual es genérico.</summary>
        <value>
          <see langword="true" /> Si el tipo actual es un tipo genérico; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Type.IsGenericType%2A> propiedad para determinar si un <xref:System.Type> objeto representa un tipo genérico. Use la <xref:System.Type.ContainsGenericParameters%2A> propiedad para determinar si un <xref:System.Type> objeto representa un tipo construido abierto o un tipo construido cerrado.  
  
> [!NOTE]
>  El <xref:System.Type.IsGenericType%2A> propiedad devuelve `false` si el tipo inmediato no es genérico. Por ejemplo, una matriz cuyos elementos son de tipo `A<int>` (`A(Of Integer)` en Visual Basic) no es un tipo genérico.  
  
 En la tabla siguiente se resume las condiciones invariables para los términos comunes usados en la reflexión genérica.  
  
|Término|Invariable|  
|----------|---------------|  
|definición de tipo genérico|La propiedad <xref:System.Type.IsGenericTypeDefinition%2A> es `true`.<br /><br /> Define un tipo genérico. Se crea un tipo construido mediante una llamada a la <xref:System.Type.MakeGenericType%2A> método en un <xref:System.Type> objeto que representa una definición de tipo genérico y especifica una matriz de argumentos de tipo.<br /><br /> <xref:System.Type.MakeGenericType%2A> se puede llamar solo en definiciones de tipo genérico.<br /><br /> Cualquier definición de tipo genérico es un tipo genérico (la <xref:System.Type.IsGenericType%2A> propiedad es `true`), pero la conversión no es verdadera.|  
|tipo genérico|La propiedad <xref:System.Type.IsGenericType%2A> es `true`.<br /><br /> Puede ser una definición de tipo genérico, un tipo construido abierto o un tipo construido cerrado.<br /><br /> Tenga en cuenta que un tipo de matriz cuyo tipo de elemento es genérico no es un tipo genérico. Lo mismo puede decirse de un <xref:System.Type> objeto que representa un puntero a un tipo genérico.|  
|tipo construido abierto|La propiedad <xref:System.Type.ContainsGenericParameters%2A> es `true`.<br /><br /> Algunos ejemplos son un tipo genérico que ha sin asignar parámetros de tipo, un tipo que está anidado en una definición de tipo genérico o en un tipo construido abierto o un tipo genérico que tiene un argumento de tipo para el que el <xref:System.Type.ContainsGenericParameters%2A> propiedad es `true`.<br /><br /> No es posible crear una instancia de un tipo construido abierto.<br /><br /> Tenga en cuenta que no se podrá abrir todos los tipos construidos son genéricos. Por ejemplo, una matriz cuyo tipo de elemento es una definición de tipo genérico no es genérica y un puntero a un tipo construido abierto no es genérico.|  
|tipo construido cerrado|La propiedad <xref:System.Type.ContainsGenericParameters%2A> es `false`.<br /><br /> Cuando examina de forma recursiva, el tipo no tiene ningún parámetro genérico sin asignar.|  
|parámetro de tipo genérico|La propiedad <xref:System.Type.IsGenericParameter%2A> es `true`.<br /><br /> La propiedad <xref:System.Type.ContainsGenericParameters%2A> es `true`.<br /><br /> En una definición de tipo genérico, un marcador de posición para un tipo que se asignará más tarde.|  
|argumento de tipo genérico|Puede ser cualquier tipo, incluidos un parámetro de tipo genérico.<br /><br /> Argumentos de tipo se especifican como una matriz de <xref:System.Type> objetos pasan a la <xref:System.Type.MakeGenericType%2A> método cuando se crea un tipo genérico construido. Si son instancias del tipo resultante en crearse, la <xref:System.Type.ContainsGenericParameters%2A> propiedad debe ser `false` para todos los argumentos de tipo.|  
  
 El ejemplo de código y la tabla siguiente muestran algunos de estos términos y las invariantes. La `Derived` clase es de especial interés porque su tipo base es un tipo construido que tiene una mezcla de tipos y parámetros de tipo en su lista de argumentos de tipo.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 La siguiente tabla muestra ejemplos que usan y compilación en las clases `Base`, `Derived`, y `G`. Cuando el código de C++ y C# es el mismo, se muestra una sola entrada.  
  
|Ejemplo|Invariables|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Para este tipo:<br /><br /> <xref:System.Type.IsGenericType%2A> es `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> es `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> es `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Para este tipo:<br /><br /> <xref:System.Type.IsGenericType%2A> es `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> es `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> es `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Para el tipo de variable `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> es `false` porque `d` es una matriz.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> es `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> es `false`.|  
|`T`, `U`, y `V` (en todas partes aparecen)|<xref:System.Type.IsGenericParameter%2A> es `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> es `false` porque no hay ninguna manera de restringir un parámetro de tipo para tipos genéricos.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> es `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> es `true` porque `T`, `U`, y `V` son parámetros de tipo genérico. Esto no implica nada sobre los argumentos de tipo que se asignan a ellos más adelante.|  
|El tipo de campo `F`|<xref:System.Type.IsGenericType%2A> es `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> es `false` porque se asignó un tipo para el parámetro de tipo de `G`. Tenga en cuenta que esto es equivalente a haber llamado el <xref:System.Type.MakeGenericType%2A> método.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> es `true` porque el tipo de campo `F` tiene un argumento de tipo que es un tipo construido abierto. El tipo construido es abierto porque su argumento de tipo (es decir, `Base`) es una definición de tipo genérico. Esto ilustra la naturaleza recursiva de la <xref:System.Type.IsGenericType%2A> propiedad.|  
|La clase anidada `Nested`|<xref:System.Type.IsGenericType%2A> es `true`, aunque la `Nested` clase no tiene ningún parámetro de tipo genérico propios, porque está anidada en un tipo genérico.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> es `true`. Es decir, puede llamar a la <xref:System.Type.MakeGenericType%2A> método y proporcionar el parámetro de tipo del tipo envolvente, `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> es `true` porque el tipo de la envolvente, `Derived`, tiene parámetros de tipo genérico. Esto ilustra la naturaleza recursiva de la <xref:System.Type.ContainsGenericParameters%2A> propiedad.|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de la <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, y <xref:System.Type.ContainsGenericParameters%2A> las propiedades de los tipos descritos en la sección Comentarios. Para obtener una explicación de los valores de propiedad, vea la tabla que aparece en la sección Comentarios.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual representa una definición de tipo genérico, a partir de la cual se pueden construir otros tipos genéricos.</summary>
        <value>
          <see langword="true" /> si el objeto <see cref="T:System.Type" /> representa una definición de tipo genérico; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una definición de tipo genérico es una plantilla desde el que se pueden construir otros tipos. Por ejemplo, desde la definición de tipo genérico `G<T>` (expresada en sintaxis de C#; `G(Of T)` en Visual Basic o `generic <typename T> ref class G` en C++) puede construir y crear instancias del tipo `G<int>` (`G(Of Integer)` en Visual Basic), mediante una llamada a la <xref:System.Type.MakeGenericType%2A> método con una lista de argumentos genéricos que contiene el <xref:System.Int32> tipo. Dado un <xref:System.Type> construido de objeto que representa este tipo, el <xref:System.Type.GetGenericTypeDefinition%2A> método obtiene la definición de tipo genérico vuelva a intentarlo.  
  
 Use el <xref:System.Type.IsGenericTypeDefinition%2A> propiedad para determinar si se pueden crear nuevos tipos del tipo actual. Si el <xref:System.Type.IsGenericTypeDefinition%2A> propiedad devuelve `true`, puede llamar a la <xref:System.Type.MakeGenericType%2A> método para crear nuevos tipos genéricos.  
  
 Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra información sobre un tipo, incluso si es una definición de tipo genérico o no. Se muestra información para un tipo construido, para su definición de tipo genérico y para un tipo normal.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> tiene aplicado un atributo <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />, lo que indica que se ha importado de una biblioteca de tipos COM.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Type" /> tiene un atributo <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>.`  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Objeto que se va a comparar con el tipo actual.</param>
        <summary>Determina si el objeto especificado es una instancia del objeto <see cref="T:System.Type" /> actual.</summary>
        <returns>Es <see langword="true" /> si el objeto <see langword="Type" /> actual se encuentra en la jerarquía de herencia del objeto representado por <paramref name="o" />, o si el objeto <see langword="Type" /> actual es una interfaz que implementa <paramref name="o" />. <see langword="false" /> si no se cumple ninguna de estas condiciones, o si <paramref name="o" /> es <see langword="null" />, o si el objeto <see langword="Type" /> actual es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada.  
  
> [!NOTE]
>  Un tipo construido no es una instancia de su definición de tipo genérico. Es decir, `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) no es una instancia de `MyGenericList<T>` (`MyGenericList(Of T)` en Visual Basic).  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra el uso del método `IsInstanceOfType`.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> es una interfaz, es decir, no es una clase ni un tipo de valor.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> es una interfaz; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue una declaración de tipo clase, interfaz o tipo de valor.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
 Esta propiedad es de sólo lectura.  
  
   
  
## Examples  
 El ejemplo siguiente se crea una interfaz, busca el tipo de interfaz e indica si una clase tiene el `IsInterface` conjunto de propiedades.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si los campos del tipo actual se disponen secuencialmente, en el orden que se definieron o emitieron en los metadatos.</summary>
        <value>
          <see langword="true" /> si la propiedad <see cref="P:System.Type.Attributes" /> del tipo actual incluye <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se proporciona por comodidad. Como alternativa, puede usar el <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeración para seleccionar los atributos de diseño de tipo y la prueba si <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> está establecido. El <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, y <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeración indican la manera en que los campos del tipo se colocan en la memoria.  
  
 Para los tipos dinámicos, puede especificar <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> cuando se crea el tipo. En el código, se aplican los <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo con el <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valor de enumeración para el tipo, para especificar que el diseño es secuencial.  
  
> [!NOTE]
>  No puede usar el <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar si el <xref:System.Runtime.InteropServices.StructLayoutAttribute> se ha aplicado a un tipo.  
  
 Para obtener más información, consulte la sección 9.1.2 de la especificación para la documentación de Common Language Infrastructure (CLI), "Partition II: Metadata Definition and Semantics". La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una instancia de una clase para el que el <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valor de enumeración en el <xref:System.Runtime.InteropServices.StructLayoutAttribute> (clase) se ha establecido, busca el <xref:System.Type.IsLayoutSequential%2A> propiedad y muestra el resultado.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> se calcula por referencia.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> se calcula por referencia; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra el `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, y <xref:System.Type.IsPrimitive%2A> propiedades de la <xref:System.Type> clase. Comprueba si el tipo especificado puede hospedarse en el contexto, si se pueden calcular las referencias por referencia, y si el tipo es un tipo de datos primitivo.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa la propiedad <see cref="P:System.Type.IsMarshalByRef" /> y determina si las referencias de <see cref="T:System.Type" /> se calculan por referencia.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Type" /> se calcula por referencia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada.  
  
   
  
## Examples  
 El ejemplo siguiente determina si el tipo especificado se calcula por referencia y muestra el resultado.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual representa un tipo cuya definición está anidada dentro de la definición de otro tipo.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado dentro de otro tipo; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.IsNested%2A> propiedad devuelve `true` para todos los tipos, independientemente de la visibilidad anidados. Para probar el anidamiento y visibilidad al mismo tiempo, utilice las propiedades relacionadas <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, o <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  El <xref:System.Reflection.TypeAttributes.VisibilityMask> miembro de enumeración selecciona los atributos de visibilidad para un tipo.  
  
   
  
## Examples  
 El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad. A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y solo se ve dentro de su propio ensamblado.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y solo se ve dentro de su propio ensamblado; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.  
  
   
  
## Examples  
 El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad. A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y solo está visible para las clases que pertenezcan tanto a su propia familia como a su propio ensamblado.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y solo está visible para las clases que pertenezcan a su propia familia y a su propio ensamblado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.  
  
> [!NOTE]
>  Los lenguajes C# y Visual Basic no incluyen semántica que le permite definir un tipo anidado que solo es visible para los tipos protegidos en su propio ensamblado. `protected internal` visibilidad en C# y `Protected Friend` visibilidad en Visual Basic define un tipo anidado que esté visible para los tipos protegidos y tipos en el mismo ensamblado.  
  
 Un <xref:System.Type> familia del objeto se define como todos los objetos del mismo <xref:System.Type> y de sus subtipos.  
  
   
  
## Examples  
 El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad. A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y solo se ve dentro de su propia familia.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y solo se ve dentro de su propia familia; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.  
  
 Un <xref:System.Type> familia del objeto se define como todos los objetos exactamente del mismo <xref:System.Type> y de sus subtipos.  
  
   
  
## Examples  
 El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad. A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y solo está visible para las clases que pertenezcan a su propia familia o a su propio ensamblado.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y solo está visible para las clases que pertenezcan a su propia familia o a su propio ensamblado; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la visibilidad de un tipo es `protected internal` en C# o `Protected Friend` en Visual Basic, el <xref:System.Type.IsNestedFamORAssem%2A> propiedad devuelve `true`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.  
  
 Un <xref:System.Type> familia del objeto se define como todos los objetos exactamente del mismo <xref:System.Type> y de sus subtipos.  
  
   
  
## Examples  
 El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad. A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y se ha declarado privado.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y se ha declarado privado; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.  
  
   
  
## Examples  
 El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad. A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si hay una clase anidada que se ha declarado pública.</summary>
        <value>Es <see langword="true" /> si la clase está anidada y se ha declarado pública; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.  
  
   
  
## Examples  
 El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad. A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> no se ha declarado público.</summary>
        <value>
          <see langword="true" /> si el objeto <see cref="T:System.Type" /> no se ha declarado público y no es un tipo anidado; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No use esta propiedad con los tipos anidados Utilice el <xref:System.Type.IsNestedPublic%2A> propiedad en su lugar.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad devuelve `false`.  
  
   
  
## Examples  
 Este ejemplo de utiliza `IsNotPublic` propiedad va a obtener la visibilidad del tipo.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 En el ejemplo de código siguiente se muestra por qué no se puede usar `IsPublic` y `IsNotPublic` para las clases anidadas.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Las clases anidadas, omita los resultados de `IsPublic` y `IsNotPublic` y preste atención solo a los resultados de `IsNestedPublic` y `IsNestedPrivate`. El resultado de la reflexión para este fragmento de código sería como sigue:  
  
|Clase|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> es un puntero.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> es un puntero; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
 Esta propiedad es de sólo lectura.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de la `IsPointer` propiedad.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsPointer" /> y determina si <see cref="T:System.Type" /> es un puntero.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Type" /> es un puntero; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> es uno de los tipos primitivos.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> es uno de los tipos primitivos; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los tipos primitivos son <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, y <xref:System.Single>.  
  
 Si el actual <xref:System.Type> representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, y <xref:System.Type.IsPrimitive%2A> propiedades de la <xref:System.Type> clase. Comprueba si el tipo especificado puede hospedarse en el contexto, si se pueden calcular las referencias por referencia, y si el tipo es un tipo de datos primitivo.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsPrimitive" /> y determina si <see cref="T:System.Type" /> es uno de los tipos primitivos.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Type" /> es uno de los tipos primitivos; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los tipos primitivos son <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, y <xref:System.Single>.  
  
   
  
## Examples  
 El ejemplo siguiente determina si el tipo especificado es un tipo primitivo y muestra el resultado.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> se ha declarado público.</summary>
        <value>
          <see langword="true" /> si el objeto <see cref="T:System.Type" /> se ha declarado el público y no es un tipo anidado; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No use con los tipos anidados Utilice <xref:System.Type.IsNestedPublic%2A> en su lugar.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad devuelve `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una instancia de `MyTestClass`, busca el `IsPublic` propiedad y muestra el resultado.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Las clases anidadas, omita los resultados de `IsPublic` y `IsNotPublic` y preste atención solo a los resultados de <xref:System.Type.IsNestedPublic%2A> y <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> se declaró "sealed".</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> se declara "sealed"; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una instancia de un `sealed` de clases, busca el `IsSealed` propiedad y muestra el resultado.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual y, por tanto, puede realizar operaciones críticas.</summary>
        <value>
          <see langword="true" /> si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <see langword="false" /> si es transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, y <xref:System.Type.IsSecurityTransparent%2A> notifican el nivel de transparencia del tipo en su nivel de confianza actual, determinado por common language runtime (CLR). Las combinaciones de estas propiedades se muestran en la tabla siguiente:  
  
|Nivel de seguridad|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico seguro|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.  
  
> [!IMPORTANT]
>  Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado. Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado. El ensamblado y todos sus tipos se tratan como transparentes. El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio). Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza. Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> y <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propiedades.  
  
 Para obtener más información sobre la reflexión y transparencia, consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo actual es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</summary>
        <value>
          <see langword="true" /> si el tipo actual es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <see langword="false" /> si es crítico para la seguridad o transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, y <xref:System.Type.IsSecurityTransparent%2A> notifican el nivel de transparencia del tipo en su nivel de confianza actual, determinado por common language runtime (CLR). Las combinaciones de estas propiedades se muestran en la tabla siguiente:  
  
|Nivel de seguridad|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico seguro|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.  
  
> [!IMPORTANT]
>  Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado. Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado. El ensamblado y todos sus tipos se tratan como transparentes. El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio). Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza. Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> y <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propiedades.  
  
 Para obtener más información sobre la reflexión y transparencia, consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo actual es transparente en el nivel de confianza actual y, por tanto, no puede realizar operaciones críticas.</summary>
        <value>
          <see langword="true" /> si el tipo es transparente para la seguridad en el nivel de confianza actual; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si esta propiedad devuelve `true`, <xref:System.Type.IsSecurityCritical%2A> y <xref:System.Type.IsSecuritySafeCritical%2A> devuelven propiedades `false`.  
  
 El <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, y <xref:System.Type.IsSecurityTransparent%2A> notifican el nivel de transparencia del tipo en su nivel de confianza actual, determinado por common language runtime (CLR). Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.  
  
> [!IMPORTANT]
>  Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado. Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado. El ensamblado y todos sus tipos se tratan como transparentes. El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio). Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza. Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> y <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propiedades.  
  
 Para obtener más información sobre la reflexión y transparencia, consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> es serializable.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> es serializable; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Tipos que se definen en .NET Standard no se marcan con <xref:System.SerializableAttribute>. En su lugar, cada implementación de .NET determina si un tipo es serializable. En tiempo de ejecución, puede usar el <xref:System.Type.IsSerializable%2A> propiedad para determinar si esa implementación admite la serialización de una instancia del tipo. Para obtener más información y un ejemplo, vea [cómo determinar si un objeto de .NET Standard es serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una instancia de `MyTestClass` (clase), Establece el atributo [Serializable] y comprueba el `IsSerializable` propiedad `true` o `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo tiene un nombre que requiere un tratamiento especial.</summary>
        <value>Es <see langword="true" /> si el tipo tiene un nombre que requiere un tratamiento especial; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los nombres que comienzan por o contengan un carácter de subrayado (_), los descriptores de acceso de propiedad y métodos de sobrecarga de operadores son ejemplos de tipos que pueden requerir un tratamiento especial por algunos compiladores.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Tipo que se va a comparar con el tipo actual.</param>
        <summary>Determina si el <see cref="T:System.Type" /> actual se deriva del <see cref="T:System.Type" /> especificado.</summary>
        <returns>Es <see langword="true" /> si el <see langword="Type" /> actual se quita de <paramref name="c" />; en caso contrario, es <see langword="false" />. Este método también devuelve <see langword="false" /> si <paramref name="c" /> y el <see langword="Type" /> actual son iguales.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede llamar a la <xref:System.Type.IsSubclassOf%2A> método para determinar ninguno de los siguientes:  
  
-   Si una clase se deriva de otro.  
  
-   Si un tipo se deriva de <xref:System.ValueType>. Sin embargo, el <xref:System.Type.IsValueType%2A> es una forma más eficaz para determinar si un tipo es un tipo de valor.  
  
-   Si un tipo se deriva de <xref:System.Enum>. Sin embargo, el <xref:System.Type.IsEnum%2A> método es una forma más eficaz para determinar si un tipo es una enumeración.  
  
-   Si un tipo es un delegado, es decir, si bien deriva <xref:System.Delegate> o <xref:System.MulticastDelegate>.  
  
 El <xref:System.Type.IsSubclassOf%2A> método no se puede usar para determinar si una interfaz se deriva de otra interfaz, o si una clase implementa una interfaz. Use el <xref:System.Type.IsAssignableFrom%2A> método para ese propósito, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, se deriva de su restricción de clase o de <xref:System.Object?displayProperty=nameWithType> si tiene ninguna restricción de clase.  
  
> [!NOTE]
>  Excepto cuando se usa con las interfaces, <xref:System.Type.IsSubclassOf%2A> es el elemento opuesto de <xref:System.Type.IsAssignableFrom%2A>. Es decir, si `t1.IsSubclassOf(t2)` es `true`, a continuación, `t2.IsAssignableFrom(t1)` también es `true`.  
  
 Este método puede reemplazarse por una clase derivada.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una clase denominada `Class1` y una clase derivada denominada `DerivedC1`. Lo llama el <xref:System.Type.IsSubclassOf%2A> método para mostrar que `DerivedC1` es una subclase de `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se selecciona el atributo de formato de cadena <see langword="UnicodeClass" /> para el objeto <see cref="T:System.Type" />.</summary>
        <value>Es <see langword="true" /> si se selecciona el atributo de formato de cadena <see langword="UnicodeClass" /> para <see cref="T:System.Type" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.TypeAttributes.StringFormatMask> se utiliza para seleccionar los atributos de formato de cadena. Los atributos de formato de cadena mejoran la interoperabilidad definiendo cómo se deben interpretar las cadenas.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> es un tipo de valor.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Type" /> es un tipo de valor; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos de valor son tipos que se representan como secuencias de bits; tipos de valor no son clases o interfaces. Tipos de valor se conocen como "structs" en algunos lenguajes de programación. Las enumeraciones son un caso especial de tipos de valor.  
  
 Esta propiedad devuelve `false` para el <xref:System.ValueType> clase porque <xref:System.ValueType> no es un tipo de valor. Es la clase base para todos los tipos de valor y, por lo tanto, cualquier tipo de valor puede asignarse a él. Esto no sería posible si <xref:System.ValueType> propio era un tipo de valor. Tipos de valor se aplica cuando se asignan a un campo de tipo <xref:System.ValueType>.  
  
 Esta propiedad devuelve `true` para enumeraciones, pero no para el <xref:System.Enum> propio tipo. Para obtener un ejemplo que demuestra este comportamiento, consulte <xref:System.Type.IsEnum%2A>.  
  
 Esta propiedad es de sólo lectura.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una variable de tipo `MyEnum`, busca el `IsValueType` propiedad y muestra el resultado.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa la propiedad <see cref="P:System.Type.IsValueType" /> y determina si <see cref="T:System.Type" /> es un tipo de valor; es decir, no es una clase ni una interfaz.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Type" /> es un tipo de valor; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para habilitar la implementación de sistemas de tipo alternativo. No se usa generalmente en el código de la aplicación.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se puede obtener acceso al objeto <see cref="T:System.Type" /> mediante el código fuera del ensamblado.</summary>
        <value>
          <see langword="true" /> si el objeto <see cref="T:System.Type" /> actual es un tipo público o un tipo anidado público del que todos los tipos envolventes son públicos; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para determinar si un tipo forma parte de la interfaz pública de un ensamblado de componente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se prueba dos clases, solo uno de los cuales es visible fuera del ensamblado.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</summary>
        <returns>Objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.MakeArrayType%2A> método proporciona una manera de generar tipos de matriz cuyos tipos de elemento se calculan en tiempo de ejecución.  
  
 **Tenga en cuenta** common language runtime hace una distinción entre los vectores (es decir, las matrices unidimensionales que siempre son de base cero) y las matrices multidimensionales. Un vector, que siempre tiene solo una dimensión, no es igual a una matriz multidimensional que se produce tener solo una dimensión. Esta sobrecarga del método solo puede utilizarse para crear tipos de vector y es la única forma de crear un tipo de vector. Use el <xref:System.Type.MakeArrayType%28System.Int32%29> sobrecarga del método para crear tipos de matriz multidimensional.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea la matriz, `ref` (`ByRef` en Visual Basic) y tipos de puntero para el `Test` clase.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base. Las clases derivadas deben proporcionar una implementación.</exception>
        <exception cref="T:System.TypeLoadException">El tipo actual es <see cref="T:System.TypedReference" />.  
  
O bien 
El tipo actual es un tipo <see langword="ByRef" />. Es decir, <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Número de dimensiones de la matriz. Este número debe ser menor o igual que 32.</param>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual, con el número de dimensiones especificado.</summary>
        <returns>Objeto que representa una matriz del tipo actual, con el número de dimensiones especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.MakeArrayType%2A> método proporciona una manera de generar tipos de matriz cuyos tipos de elemento se calculan en tiempo de ejecución.  
  
> [!NOTE]
>  Common language runtime hace una distinción entre los vectores (es decir, las matrices unidimensionales que siempre son de base cero) y las matrices multidimensionales. Un vector, que siempre tiene solo una dimensión, no es igual a una matriz multidimensional que se produce tener solo una dimensión. No se puede utilizar esta sobrecarga del método para crear un tipo de vector; Si `rank` es 1, esta sobrecarga del método devuelve un tipo de matriz multidimensional que se produce al tener una dimensión. Use el <xref:System.Type.MakeArrayType> sobrecarga del método para crear tipos de vector.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea la matriz, `ref` (`ByRef` en Visual Basic) y tipos de puntero para el `Test` clase.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> no es válido. Por ejemplo, 0 o negativo.</exception>
        <exception cref="T:System.NotSupportedException">No se admite el método invocado en la clase base.</exception>
        <exception cref="T:System.TypeLoadException">El tipo actual es <see cref="T:System.TypedReference" />.  
  
O bien 
El tipo actual es un tipo <see langword="ByRef" />. Es decir, <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.  
  
O bien 
 <paramref name="rank" /> es mayor que 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</summary>
        <returns>Objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.MakeByRefType%2A> método proporciona una manera de generar `ref` tipos (`ByRef` en Visual Basic) para el parámetro contiene una lista.  
  
 Mediante la sintaxis de lenguaje intermedio de Microsoft (MSIL), si el actual <xref:System.Type> objeto representa <xref:System.Int32>, este método devuelve un <xref:System.Type> que representa el objeto `Int32&`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea la matriz, `ref` (`ByRef` en Visual Basic) y tipos de puntero para el `Test` clase.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base.</exception>
        <exception cref="T:System.TypeLoadException">El tipo actual es <see cref="T:System.TypedReference" />.  
  
O bien 
El tipo actual es un tipo <see langword="ByRef" />. Es decir, <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Matriz de tipos que se va a sustituir por los parámetros del tipo genérico actual.</param>
        <summary>Sustituye los elementos de una matriz de tipos por los parámetros de tipo de la definición de tipo genérico actual y devuelve un objeto <see cref="T:System.Type" /> que representa el tipo construido resultante.</summary>
        <returns>Objeto <see cref="T:System.Type" /> que representa el tipo construido formado al sustituir los elementos de <paramref name="typeArguments" /> por los parámetros del tipo genérico actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.MakeGenericType%2A> método le permite escribir código que asigna tipos específicos a los parámetros de tipo de una definición de tipo genérico, creando así un <xref:System.Type> objeto que representa un tipo construido en particular. Puede usar esto <xref:System.Type> objeto para crear instancias de tiempo de ejecución del tipo construido.  
  
 Tipos construyen con <xref:System.Type.MakeGenericType%2A> pueden estar abiertos, es decir, algunos de sus argumentos de tipo pueden ser parámetros de tipo de métodos genéricos o tipos de inclusión. Puede usar estos tipos construidos abiertos al emitir ensamblados dinámicos. Por ejemplo, considere las clases `Base` y `Derived` en el código siguiente.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Para generar `Derived` en un ensamblado dinámico, es necesario construir su tipo base. Para ello, llame a la <xref:System.Type.MakeGenericType%2A> método en un <xref:System.Type> objeto que representa la clase `Base`, utilizando los argumentos de tipo genérico <xref:System.Int32> y el parámetro de tipo `V` desde `Derived`. Dado que los tipos y parámetros de tipo genérico se representan mediante <xref:System.Type> objetos, se puede pasar una matriz que contiene ambos a la <xref:System.Type.MakeGenericType%2A> método.  
  
> [!NOTE]
>  Un tipo construido, como `Base<int, V>` es útil cuando emitir código, pero no se puede llamar a la <xref:System.Type.MakeGenericType%2A> método en este tipo porque no es una definición de tipo genérico. Para crear un tipo construido cerrado que se puede crear instancias, primero llame a la <xref:System.Type.GetGenericTypeDefinition%2A> método para obtener un <xref:System.Type> objeto que representa la definición de tipo genérico y, a continuación, llame a <xref:System.Type.MakeGenericType%2A> con los argumentos de tipo deseado.  
  
 El <xref:System.Type> objeto devuelto por <xref:System.Type.MakeGenericType%2A> es el mismo que el <xref:System.Type> obtenido mediante una llamada a la <xref:System.Object.GetType%2A> método resultante construido tipo, o la <xref:System.Object.GetType%2A> construye de método de cualquier tipo que se creó desde la misma genérico definición de tipo con los mismos argumentos de tipo.  
  
> [!NOTE]
>  Una matriz de tipos genéricos no es un tipo genérico. No se puede llamar a <xref:System.Type.MakeGenericType%2A> en una matriz de tipo como `C<T>[]` (`Dim ac() As C(Of T)` en Visual Basic). Para construir un tipo genérico cerrado de `C<T>[]`, llame a <xref:System.Type.GetElementType%2A> para obtener la definición de tipo genérico `C<T>`; llame a <xref:System.Type.MakeGenericType%2A> en la definición de tipo genérico para crear el tipo construido; y, por último, llame a la <xref:System.Type.MakeArrayType%2A> método en el tipo construido para crear el tipo de matriz. Lo mismo puede decirse de tipos de puntero y `ref` tipos (`ByRef` en Visual Basic).  
  
 Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Tipos anidados  
 Si se define un tipo genérico con C#, C++ o Visual Basic, sus tipos anidados son todos genéricos. Esto es cierto incluso si los tipos anidados no tienen ningún parámetro de tipo de sus propios, porque los tres lenguajes incluyen los parámetros de tipo de tipos envolventes en las listas de parámetros de tipo de tipos anidados. Tenga en cuenta las siguientes clases:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 La lista de parámetros de tipo de la clase anidada `Inner` tiene dos parámetros de tipo, `T` y `U`, el primero de los cuales es el parámetro de tipo de su clase envolvente. De forma similar, la lista de parámetros de tipo de la clase anidada `Innermost1` tiene tres parámetros de tipo, `T`, `U`, y `V`, con `T` y `U` procedentes de sus clases envolventes. La clase anidada `Innermost2` tiene dos parámetros de tipo, `T` y `U`, que proceden de sus clases envolventes.  
  
 Si la lista de parámetros de tipo envolvente tiene más de un parámetro de tipo, se incluyen todos los parámetros de tipo en el orden en la lista de parámetros de tipo del tipo anidado.  
  
 Para construir un tipo genérico de la definición de tipo genérico para un tipo anidado, llame a la <xref:System.Type.MakeGenericType%2A> método con la matriz formada al concatenar las matrices de argumento de tipo de todos los tipos envolventes, que comienza con el tipo genérico exterior y terminando con el tipo de matriz de argumentos del tipo anidado en Sí, si tiene sus propios parámetros de tipo. Para crear una instancia de `Innermost1`, llame a la <xref:System.Type.MakeGenericType%2A> método con una matriz que contiene tres tipos, que se asignará a T, U y V. Para crear una instancia de `Innermost2`, llame a la <xref:System.Type.MakeGenericType%2A> método con una matriz que contiene dos tipos, que se asignará a T y U.  
  
 Los lenguajes de propagan los parámetros de tipo de tipos envolventes de esta manera, por lo que puede usar los parámetros de tipo de un tipo envolvente para definir los campos de tipos anidados. En caso contrario, los parámetros de tipo no sería en el ámbito dentro de los cuerpos de los tipos anidados. Es posible definir tipos anidados sin propagar los parámetros de tipo de tipos envolventes mediante la emisión de código en ensamblados dinámicos o mediante el uso de la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Considere el siguiente código para el ensamblador de MSIL:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 En este ejemplo, no es posible definir un campo de tipo `T` o `U` en clase `Innermost`, ya que los parámetros de tipo no están en ámbito. El siguiente código ensamblador define clases anidadas que se comportan de la manera que si estuvieran definidas en C++, Visual Basic y C#:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar las clases anidadas definidas en los lenguajes de alto nivel y observar este esquema de nomenclatura.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Type.MakeGenericType%2A> método para crear un tipo construido a partir de la definición de tipo genérico para el <xref:System.Collections.Generic.Dictionary%602> tipo. Representa el tipo construido un <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos con claves de cadena.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo actual no representa una definición de un tipo genérico. Es decir, <see cref="P:System.Type.IsGenericTypeDefinition" /> devuelve <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> es <see langword="null" />.  
  
O bien 
Cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El número de elementos de <paramref name="typeArguments" /> no coincide con el número de parámetros de tipo de la definición de tipo genérico actual.  
  
O bien 
Algún elemento de <paramref name="typeArguments" /> no satisface las restricciones especificadas para el parámetro de tipo correspondiente del tipo genérico actual.  
  
O bien 
 <paramref name="typeArguments" /> contiene un elemento que es un tipo de puntero (<see cref="P:System.Type.IsPointer" /> devuelve <see langword="true" />), un tipo por referencia (<see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />) o <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base. Las clases derivadas deben proporcionar una implementación.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa un puntero al tipo actual.</summary>
        <returns>Objeto <see cref="T:System.Type" /> que representa un puntero al tipo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type.MakePointerType%2A> método proporciona una manera de generar los tipos de puntero para listas de parámetros.  
  
 Mediante la sintaxis de lenguaje intermedio de Microsoft (MSIL), si el actual <xref:System.Type> objeto representa <xref:System.Int32>, este método devuelve un <xref:System.Type> que representa el objeto `Int32*`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea la matriz, `ref` (`ByRef` en Visual Basic) y tipos de puntero para el `Test` clase.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base.</exception>
        <exception cref="T:System.TypeLoadException">El tipo actual es <see cref="T:System.TypedReference" />.  
  
O bien 
El tipo actual es un tipo <see langword="ByRef" />. Es decir, <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor de <see cref="T:System.Reflection.MemberTypes" /> que indica que este miembro es un tipo o un tipo anidado.</summary>
        <value>Valor de <see cref="T:System.Reflection.MemberTypes" /> que indica que este miembro es un tipo o un tipo anidado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad invalida <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Por lo tanto, cuando se examina un conjunto de <xref:System.Reflection.MemberInfo> objetos — por ejemplo, la matriz devuelta por <xref:System.Type.GetMembers%2A>: el <xref:System.Reflection.MemberInfo.MemberType%2A> propiedad devuelve <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> cuando un miembro determinado es un tipo anidado.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo. Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra la `MemberType` campo como un parámetro a la `GetMember` método:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa un valor que falta en la información de <see cref="T:System.Type" />. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `Missing` campo para la invocación mediante reflexión para obtener el valor predeterminado de un parámetro. Si el `Missing` campo se pasa un valor de parámetro y no hay ningún valor predeterminado para ese parámetro, un <xref:System.ArgumentException> se produce.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la `Missing` campo para invocar un método con sus argumentos predeterminados.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Este código genera el siguiente resultado:  
  
 un = 10 b = 55.3 c = 12  
  
 un = 10 b = 1.3 c = 1  
  
 un = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el módulo (la DLL) en que se define el objeto <see cref="T:System.Type" /> actual.</summary>
        <value>Módulo en el que se define el objeto <see cref="T:System.Type" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad devuelve el módulo en el que se ha definido la definición de tipo genérico. Por ejemplo, si crea una instancia de `MyGenericStack<int>`, <xref:System.Type.Module%2A> propiedad para el tipo construido devuelve el módulo en el que `MyGenericStack<T>` está definido.  
  
 De forma similar, si el actual <xref:System.Type> representa un parámetro genérico `T`, esta propiedad devuelve el ensamblado que contiene el tipo genérico que define `T`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Type.Namespace%2A> y `Module` propiedades y el <xref:System.Type.ToString%2A> método <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el espacio de nombres de <see cref="T:System.Type" />.</summary>
        <value>Espacio de nombres de <see cref="T:System.Type" />; <see langword="null" /> si la instancia actual no tiene un espacio de nombres o representa un parámetro genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un espacio de nombres es una ventaja nomenclatura de tiempo de diseño lógica, que se usa principalmente para definir un ámbito en una aplicación y organizar clases y otros tipos en una única estructura jerárquica. Desde el punto de vista del tiempo de ejecución, no hay ningún espacio de nombres.  
  
 Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad devuelve el espacio de nombres que contiene la definición de tipo genérico. De forma similar, si el actual <xref:System.Type> representa un parámetro genérico `T`, esta propiedad devuelve el espacio de nombres que contiene la definición de tipo genérico que define `T`.  
  
 Si el actual <xref:System.Type> objeto representa un parámetro genérico, esta propiedad devuelve `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el `Namespace` y <xref:System.Type.Module%2A> propiedades y el <xref:System.Type.ToString%2A> método <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Primer objeto que se va a comparar.</param>
        <param name="right">Segundo objeto que se va a comparar.</param>
        <summary>Indica si dos objetos <see cref="T:System.Type" /> son iguales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> es igual a <paramref name="right" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Primer objeto que se va a comparar.</param>
        <param name="right">Segundo objeto que se va a comparar.</param>
        <summary>Indica si dos objetos <see cref="T:System.Type" /> no son iguales.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> no es igual a <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto de clase usado para obtener este miembro.</summary>
        <value>Objeto <see langword="Type" /> a través del cual se obtuvo este objeto <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para <xref:System.Type> objetos, el valor de esta propiedad siempre es el mismo que el valor de la <xref:System.Type.DeclaringType%2A> propiedad.  
  
   
  
## Examples  
 Este ejemplo muestra el tipo reflejado de una clase anidada.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre calificado con el ensamblado del <see cref="T:System.Type" /> que se va a obtener.</param>
        <param name="throwIfNotFound">
          <see langword="true" /> para iniciar una excepción <see cref="T:System.TypeLoadException" /> si no se puede encontrar el tipo; <see langword="false" /> para devolver <see langword="null" /> si el tipo no se puede encontrar. Si se especifica <see langword="false" /> se suprimen otras condiciones de excepción, pero no todas. Vea la sección Excepciones.</param>
        <param name="ignoreCase">
          <see langword="true" /> para realizar una búsqueda de <c>typeName</c> que no distinga mayúsculas de minúsculas; <see langword="false" /> para realizar una búsqueda de <c>typeName</c> que distinga mayúsculas de minúsculas.</param>
        <summary>Obtiene el objeto <see cref="T:System.Type" /> con el nombre indicado, que especifica si se va a realizar una búsqueda donde se distingue entre mayúsculas y minúsculas y si se va a producir una excepción en caso de que no se encuentre el tipo. Se carga el tipo solo para reflexión, no para ejecución.</summary>
        <returns>Tipo con el nombre especificado, si se encuentra; de lo contrario <see langword="null" />. Si el tipo no se encuentra, el parámetro <paramref name="throwIfNotFound" /> especifica si se devuelve <see langword="null" /> o se produce una excepción. En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwIfNotFound" />. Vea la sección Excepciones.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el ensamblado que contiene el tipo ya no se carga en el contexto de solo reflexión, usando la <xref:System.Type.ReflectionOnlyGetType%2A> método es equivalente a la primera carga el ensamblado solo para reflexión, utilizando el <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> método y, a continuación, cargar el tipo mediante una llamada a la del ensamblado <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método. Para obtener información acerca de los nombres de ensamblado, vea el <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> propiedad. Para obtener más información sobre cómo especificar los nombres de tipo, consulte el <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método.  
  
 Si el ensamblado ya está cargado para la ejecución, se carga otra copia en el contexto de solo reflexión.  
  
 El `throwIfNotFound` parámetro especifica lo que sucede cuando no se encuentra el tipo y también suprime algunas condiciones de excepción, como se describe en la sección excepciones. Algunas excepciones se producen independientemente del valor de `throwIfNotFound`. Por ejemplo, si el ensamblado no es válido, un <xref:System.BadImageFormatException> se produce incluso si `throwIfNotFound` es `false`.  
  
 Para obtener más información sobre cómo usar el contexto de solo reflexión, vea [Cómo: cargar ensamblados en el contexto de Reflection](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Se invoca un inicializador de clase y genera una excepción.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> es <see langword="true" /> y no se encuentra el tipo.  
  
O bien 
 <paramref name="throwIfNotFound" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada. 
O bien 
 <paramref name="throwIfNotFound" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.  
  
O bien 
 <paramref name="throwIfNotFound" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.  
  
O bien 
 <paramref name="typeName" /> representa una matriz de objetos <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> no incluye el nombre del ensamblado.  
  
O bien 
 <paramref name="throwIfNotFound" /> es <see langword="true" /> y <paramref name="typeName" /> contiene sintaxis no válida; por ejemplo, "MyType[,*,]".  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.  
  
O bien 
 <paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.</exception>
        <exception cref="T:System.IO.FileLoadException">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado o alguna de sus dependencias no son válidos.  
  
O bien 
El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una clase <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que describe el diseño del tipo actual.</summary>
        <value>Obtiene una clase <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que describe las características de diseño generales del tipo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> no se devuelve el <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método. En su lugar, puede usar esta propiedad para obtenerlo.  
  
   
  
## Examples  
 En primer lugar, el siguiente ejemplo de código define una clase, una estructura y una estructura con atributos de diseño especial (las estructuras anidadas dentro de la clase). El ejemplo se utiliza el <xref:System.Type.StructLayoutAttribute%2A> propiedad para obtener un <xref:System.Runtime.InteropServices.StructLayoutAttribute> para cada tipo y muestra las propiedades de los atributos.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="rgszNames">Matriz que se pasa con los nombres que se van a asignar.</param>
        <param name="cNames">Número de nombres que se van a asignar.</param>
        <param name="lcid">Contexto de configuración regional en el que se van a interpretar los nombres.</param>
        <param name="rgDispId">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</param>
        <summary>Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Información de tipos que se va a devolver.</param>
        <param name="lcid">Identificador de la configuración regional de la información de tipo.</param>
        <param name="ppTInfo">Puntero al objeto de información de tipo solicitado.</param>
        <summary>Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</param>
        <summary>Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica el miembro.</param>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="lcid">Contexto de la configuración regional en que se interpretan los argumentos.</param>
        <param name="wFlags">Marcas que describen el contexto de la llamada.</param>
        <param name="pDispParams">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</param>
        <param name="pVarResult">Puntero a la ubicación donde se va a almacenar el resultado.</param>
        <param name="pExcepInfo">Puntero a una estructura que contiene información de excepciones.</param>
        <param name="puArgErr">Índice del primer argumento que tiene un error.</param>
        <summary>Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor <see langword="String" /> que representa el nombre del objeto <see langword="Type" /> actual.</summary>
        <returns>Valor <see cref="T:System.String" /> que representa el nombre del objeto <see cref="T:System.Type" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el common language runtime espacio de nombres completo y el nombre de todos los tipos primitivos. Por ejemplo, la instrucción de C# `(long)0.Type().ToString()` devuelve "System.Int64" en lugar de simplemente "Int64".  
  
 Si el actual <xref:System.Type> representa un tipo genérico, el tipo y sus argumentos de tipo se califican por espacio de nombres y por tipo anidado, pero no por ensamblado. Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método devuelve el nombre no completo del parámetro de tipo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Type.Namespace%2A> y <xref:System.Type.Module%2A> propiedades y el `ToString` método <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 En el ejemplo siguiente se comparan las cadenas devueltas por la <xref:System.Type.ToString%2A> método y el `Name`, <xref:System.Type.FullName%2A>, y <xref:System.Type.AssemblyQualifiedName%2A> propiedades.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador del objeto <see cref="T:System.Type" /> actual.</summary>
        <value>Identificador del objeto <see cref="T:System.Type" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` Encapsula un puntero a una estructura de datos interna que representa el tipo. Este identificador es único durante la vida del proceso. El identificador es válido únicamente en el dominio de aplicación en el que se ha obtenido.  
  
   
  
## Examples  
 El ejemplo siguiente devuelve el identificador del tipo correspondiente y pasa el identificador a un método que obtiene el tipo a partir del identificador y lo muestra.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework no admite actualmente esta propiedad.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el inicializador para el tipo.</summary>
        <value>Objeto que contiene el nombre del constructor de clase para <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicializadores de clase también están disponibles a través de la <xref:System.Type.FindMembers%2A> método, o a través de las sobrecargas de los <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, y <xref:System.Type.GetConstructors%2A> los métodos que toman <xref:System.Reflection.BindingFlags> como un parámetro.  
  
 Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad devuelve `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica el tipo proporcionado por Common Language Runtime para representar este tipo.</summary>
        <value>Tipo de sistema subyacente para el objeto <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>