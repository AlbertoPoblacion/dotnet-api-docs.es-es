<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Type.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a40925048dd06746d1e1cda2a76aa4ecaae1b916.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a40925048dd06746d1e1cda2a76aa4ecaae1b916</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</source>
          <target state="translated">Representa declaraciones de tipos: tipos de clase, tipos de interfaz, tipos de matriz, tipos de valor, tipos de enumeración, parámetros de tipo, definiciones de tipo genérico y tipos genéricos construidos abiertos o cerrados.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is the root of the <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> functionality and is the primary way to access metadata.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> es la raíz de la <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> funcionalidad y es el método principal para acceder a metadatos.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Use the members of <ph id="ph1">&lt;xref:System.Type&gt;</ph> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</source>
          <target state="translated">Utilice los miembros de <ph id="ph1">&lt;xref:System.Type&gt;</ph> para obtener información sobre una declaración de tipo, acerca de los miembros de un tipo (por ejemplo, los constructores, métodos, campos, propiedades y eventos de una clase), así como el módulo y el ensamblado en el que se implementa la clase.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</source>
          <target state="translated">No se requieren permisos para usar la reflexión para obtener información sobre los tipos y sus miembros, independientemente de los niveles de acceso de código.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</source>
          <target state="translated">No se requieren permisos para el código usar la reflexión para tener acceso a los miembros públicos, u otros miembros cuyos niveles de acceso serían que sean visibles durante la compilación normal.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Sin embargo, para el código para usar la reflexión para obtener acceso a los miembros que serían normalmente inaccesibles, como métodos privados o internos o campos protegidos de un tipo no hereda la clase, el código debe tener <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is an abstract base class that allows multiple implementations.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> es una clase base abstracta que permite diversas implementaciones.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The system will always provide the derived class <ph id="ph1">`RuntimeType`</ph>.</source>
          <target state="translated">El sistema siempre proporcionará la clase derivada <ph id="ph1">`RuntimeType`</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</source>
          <target state="translated">En la reflexión, todas las clases que comiencen por la palabra en tiempo de ejecución se crean una sola vez por cada objeto en el sistema y compatibilidad con las operaciones de comparación.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In multithreading scenarios, do not lock <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects in order to synchronize access to <ph id="ph2">`static`</ph> data.</source>
          <target state="translated">En escenarios de multithreading, no bloquee <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos con el fin de sincronizar el acceso a <ph id="ph2">`static`</ph> datos.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Other code, over which you have no control, might also lock your class type.</source>
          <target state="translated">Otro código, sobre el que no tiene ningún control, también puede bloquear el tipo de clase.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This might result in a deadlock.</source>
          <target state="translated">Esto puede dar lugar a un interbloqueo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Instead, synchronize access to static data by locking a private <ph id="ph1">`static`</ph> object.</source>
          <target state="translated">En su lugar, sincronizar el acceso a los datos estáticos bloqueando privado <ph id="ph1">`static`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A derived class can access protected members of the calling code's base classes.</source>
          <target state="translated">Una clase derivada puede tener acceso a miembros protegidos de clases base del código que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Also, access is allowed to assembly members of the calling code's assembly.</source>
          <target state="translated">Además, se permite el acceso a los miembros de ensamblado del ensamblado del código de llamada.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</source>
          <target state="translated">Como norma, si se permite el acceso en tiempo de compilación de código, a continuación, se está también permite el acceso en el código en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</source>
          <target state="translated">Interfaces que extienden otras interfaces no heredan los métodos definidos en las interfaces extendidas.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In this section:</source>
          <target state="translated">En esta sección:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>What types does a Type object represent?<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>¿Qué tipos representan un objeto de tipo?<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Retrieving a Type object<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Recuperar un objeto de tipo<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Comparing type objects for equality<ept id="p1">](#Equality)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Comparar objetos de tipo para la igualdad<ept id="p1">](#Equality)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>What types does a Type object represent?</source>
          <target state="translated">¿Qué tipos representan un objeto de tipo?</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This class is thread safe; multiple threads can concurrently read from an instance of this type.</source>
          <target state="translated">Esta clase es seguro para subprocesos; varios subprocesos pueden leer simultáneamente desde una instancia de este tipo.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Type&gt;</ph> class can represent any of the following types:</source>
          <target state="translated">Una instancia de la <ph id="ph1">&lt;xref:System.Type&gt;</ph> clase puede representar cualquiera de los siguientes tipos:</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Classes</source>
          <target state="translated">Clases</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Value types</source>
          <target state="translated">Tipos de valor</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Arrays</source>
          <target state="translated">Matrices</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Enumerations</source>
          <target state="translated">Enumeraciones</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Delegates</source>
          <target state="translated">Delegados</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Constructed generic types and generic type definitions</source>
          <target state="translated">Tipos genéricos construidos y definiciones de tipo genérico</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</source>
          <target state="translated">Argumentos de tipo y parámetros de tipos genéricos construidos, definiciones de tipo genérico y definiciones de método genérico de tipo</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Retrieving a Type object</source>
          <target state="translated">Recuperar un objeto de tipo</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object associated with a particular type can be obtained in the following ways:</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto asociado a un tipo determinado se puede obtener de las maneras siguientes:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The instance <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the type of an instance.</source>
          <target state="translated">La instancia <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> método devuelve un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que representa el tipo de una instancia.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Because all managed types derive from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be called on an instance of any type.</source>
          <target state="translated">Dado que todos los tipos administrados se derivan de <ph id="ph1">&lt;xref:System.Object&gt;</ph>, el <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> método puede llamarse en una instancia de cualquier tipo.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method to determine the runtime type of each object in an object array.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> método para determinar el tipo en tiempo de ejecución de cada objeto en una matriz de objetos.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The static <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> methods return a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a type specified by its fully qualified name.</source>
          <target state="translated">El método estático <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> métodos devuelven un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que representa un tipo especificado por su nombre completo.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph> methods return <ph id="ph4">`Type`</ph> objects that represent the types defined in a module.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph> métodos devuelven <ph id="ph4">`Type`</ph> objetos que representan los tipos definidos en un módulo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The first method can be used to obtain an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects for all the public and private types defined in a module.</source>
          <target state="translated">El primer método se puede utilizar para obtener una matriz de <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos para todos los tipos públicos y privados definidos en un módulo.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>(You can obtain an instance of <ph id="ph1">`Module`</ph> through the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph> method, or through the <ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph> property.)</source>
          <target state="translated">(Puede obtener una instancia de <ph id="ph1">`Module`</ph> a través de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph> método, o a través del <ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph> propiedad.)</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph> object contains a number of methods to retrieve the classes defined in an assembly, including <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph> objeto contiene una serie de métodos para recuperar las clases definidas en un ensamblado, incluyendo <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, y <ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> method returns a filtered list of interface types supported by a type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> método devuelve una lista filtrada de tipos de interfaz admitidos por un tipo.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> method returns a <ph id="ph2">`Type`</ph> object that represents the element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> método devuelve un <ph id="ph2">`Type`</ph> objeto que representa el elemento.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph> methods return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects representing the interface types supported by a type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph> métodos devuelven <ph id="ph3">&lt;xref:System.Type&gt;</ph> objetos que representan los tipos de interfaz admitidos por un tipo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method returns an array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects representing the types specified by an arbitrary set of objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> método devuelve una matriz de <ph id="ph2">&lt;xref:System.Type&gt;</ph> objetos que representan los tipos especificados por un conjunto arbitrario de objetos.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The objects are specified with an array of type <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Los objetos se especifican con una matriz de tipo <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> methods are provided for COM interoperability.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> se proporcionan métodos para la interoperabilidad COM.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>They return a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type specified by a <ph id="ph2">`ProgID`</ph> or <ph id="ph3">`CLSID`</ph>.</source>
          <target state="translated">Devuelven un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa el tipo especificado por un <ph id="ph2">`ProgID`</ph> o <ph id="ph3">`CLSID`</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method is provided for interoperability.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> método se proporciona para la interoperabilidad.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>It returns a <ph id="ph1">`Type`</ph> object that represents the type specified by a class handle.</source>
          <target state="translated">Devuelve un <ph id="ph1">`Type`</ph> objeto que representa el tipo especificado por un identificador de clase.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator, the C++ <ph id="ph2">`typeid`</ph> operator, and the Visual Basic <ph id="ph3">`GetType`</ph> operator obtain the <ph id="ph4">`Type`</ph> object for a type.</source>
          <target state="translated">C# <ph id="ph1">`typeof`</ph> operador, C++ <ph id="ph2">`typeid`</ph> operador y Visual Basic <ph id="ph3">`GetType`</ph> operador obtener el <ph id="ph4">`Type`</ph> un tipo de objeto.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing a constructed generic type, which is an open constructed type if its <ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, and a closed constructed type otherwise.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método devuelve un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que representa un tipo genérico construido, que es un tipo construido abierto si su <ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad devuelve <ph id="ph4">`true`</ph>, y un tipo construido cerrado en caso contrario.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A generic type can be instantiated only if it is closed.</source>
          <target state="translated">Un tipo genérico puede instanciarse solo si está cerrado.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> methods return <ph id="ph4">&lt;xref:System.Type&gt;</ph> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (<ph id="ph5">`ref`</ph> in C#, <ph id="ph6">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> métodos devuelven <ph id="ph4">&lt;xref:System.Type&gt;</ph> objetos que representan, respectivamente, una matriz de un tipo especificado, un puntero a un tipo especificado y el tipo de un parámetro de referencia (<ph id="ph5">`ref`</ph> en C#, <ph id="ph6">`ByRef`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Comparing type objects for equality</source>
          <target state="translated">Comparar objetos de tipo para la igualdad</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a type is unique; that is, two <ph id="ph2">&lt;xref:System.Type&gt;</ph> object references refer to the same object if and only if they represent the same type.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa un tipo es único; es decir, dos <ph id="ph2">&lt;xref:System.Type&gt;</ph> las referencias de objeto hacen referencia al mismo objeto solo si representan el mismo tipo.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This allows for comparison of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects using reference equality.</source>
          <target state="translated">Esto permite la comparación de <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos mediante la igualdad de referencia.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example compares the <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent a number of integer values to determine whether they are of the same type.</source>
          <target state="translated">En el ejemplo siguiente se comparan los <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos que representan un número de valores enteros para determinar si son del mismo tipo.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following  example shows a few representative features of <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">El ejemplo siguiente muestra algunas características representativas de <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator (<ph id="ph2">`GetType`</ph> operator in Visual Basic, <ph id="ph3">`typeid`</ph> operator in Visual C++) is used to get a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">C# <ph id="ph1">`typeof`</ph> operador (<ph id="ph2">`GetType`</ph> operador en Visual Basic, <ph id="ph3">`typeid`</ph> operador en Visual C++) se utiliza para obtener un <ph id="ph4">&lt;xref:System.Type&gt;</ph> que representa el objeto <ph id="ph5">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>From this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object, the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method is used to get a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing the <ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph> overload that takes a starting location and a length.</source>
          <target state="translated">Desde este <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto, el <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> método se utiliza para obtener un <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que representa el <ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph> sobrecarga que toma una ubicación inicial y una longitud.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To identify the overload signature, the code example creates a temporary array containing two <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing <ph id="ph2">`int`</ph> (<ph id="ph3">`Integer`</ph> in Visual Basic).</source>
          <target state="translated">Para identificar la firma de sobrecarga, el ejemplo de código crea una matriz temporal que contiene dos <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos que representan <ph id="ph2">`int`</ph> (<ph id="ph3">`Integer`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To be precise, the array contains two references to the instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> that represents <ph id="ph2">`int`</ph> in the current application domain.</source>
          <target state="translated">Para ser exactos, la matriz contiene dos referencias a la instancia de <ph id="ph1">&lt;xref:System.Type&gt;</ph> que representa <ph id="ph2">`int`</ph> en el dominio de aplicación actual.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>For any type, there is only one instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> per application domain.</source>
          <target state="translated">Para cualquier tipo, hay solo una instancia de <ph id="ph1">&lt;xref:System.Type&gt;</ph> por dominio de aplicación.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The code example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> to invoke the <ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph> method on the string "Hello, World!", and displays the result.</source>
          <target state="translated">El ejemplo de código se utiliza el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> para invocar la <ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph> método en la cadena "Hello, World!" y se muestra el resultado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo es seguro para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>When you inherit from <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, you must override the following members:</source>
          <target state="translated">Al heredar de <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, es necesario invalidar los miembros siguientes:.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Type.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.#ctor">
          <source>This constructor is invoked by derived classes during the construction of type objects.</source>
          <target state="translated">Las clases derivadas, se invoca este constructor durante la construcción de objetos de tipo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the type is declared.</source>
          <target state="translated">Obtiene la propiedad <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> en la que está declarado el tipo.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>For generic types, gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the generic type is defined.</source>
          <target state="translated">Para los tipos genéricos, obtiene la propiedad <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> en la que está definido el tipo genérico.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> instance that describes the assembly containing the current type.</source>
          <target state="translated">Instancia de <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> que describe el ensamblado que contiene el tipo actual.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</source>
          <target state="translated">Para los tipos genéricos, la instancia describe el ensamblado que contiene la definición de tipo genérico, no el ensamblado que crea y usa un tipo construido en particular.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa un tipo genérico construido, esta propiedad devuelve el ensamblado que contiene la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition <ph id="ph1">`MyGenericStack&lt;T&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph> in C++).</source>
          <target state="translated">Por ejemplo, suponga que crea un ensamblado denominado MyGenerics.dll que contiene la definición de tipo genérico <ph id="ph1">`MyGenericStack&lt;T&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of T)`</ph> en Visual Basic, <ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph> en C++).</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of Integer)`</ph> in Visual Basic) in another assembly, the <ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph> property for the constructed type returns an <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents MyGenerics.dll.</source>
          <target state="translated">Si crea una instancia de <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of Integer)`</ph> en Visual Basic) en otro ensamblado, el <ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph> propiedad para el tipo construido devuelve un <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> objeto que representa MyGenerics.dll.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an unassigned generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">De forma similar, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro genérico sin asignar <ph id="ph2">`T`</ph>, esta propiedad devuelve el ensamblado que contiene el tipo genérico que define <ph id="ph3">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> propiedad no está disponible en una implementación concreta. NET, como .NET Core o la plataforma Universal de Windows, use la <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph> propiedad en su lugar.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">En el ejemplo siguiente se muestra el nombre del ensamblado asociado a la clase y el nombre completo del tipo.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="P:System.Type.AssemblyQualifiedName">
          <source>Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object was loaded.</source>
          <target state="translated">Obtiene el nombre calificado con el ensamblado del tipo, que incluye el nombre del ensamblado a partir del cual se ha cargado el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, which includes the name of the assembly from which the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> was loaded, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter.</source>
          <target state="translated">Nombre calificado con el ensamblado de <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, que incluye el nombre del ensamblado a partir del cual se ha cargado <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, o <ph id="ph3">&lt;see langword="null" /&gt;</ph> si la instancia actual representa un parámetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</source>
          <target state="translated">El nombre de un tipo calificado con el ensamblado está formada por el nombre del tipo, incluido su espacio de nombres, seguido por una coma, seguida por el nombre para mostrar del ensamblado.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The display name of an assembly is obtained using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">El nombre para mostrar de un ensamblado se obtiene mediante la <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Por ejemplo, "ProcessorArchitecture = msil".</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Sin embargo, no se incluye en la cadena devuelta por la <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedad por motivos de compatibilidad.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Todos los compiladores que admiten common language runtime emitirán el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando ejecute la consulta, con arreglo a las siguientes convenciones.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Delimiter</source>
          <target state="translated">Delimitador</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Meaning</source>
          <target state="translated">Significado</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Barra diagonal inversa (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Escape character.</source>
          <target state="translated">Carácter de escape.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Comma (,)</source>
          <target state="translated">Coma (,)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Precede al nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Plus sign (+)</source>
          <target state="translated">Signo más (+)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes a nested class.</source>
          <target state="translated">Precede a una clase anidada.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Period (.)</source>
          <target state="translated">Punto (.)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Denota los identificadores de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Brackets ([])</source>
          <target state="translated">Corchetes ([])</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>After a type name, denotes an array of that type.</source>
          <target state="translated">Después de un nombre de tipo, denota una matriz de ese tipo.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For a generic type, encloses the generic type argument list.</source>
          <target state="translated">Para un tipo genérico, incluye la lista de argumentos de tipo genérico.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Within a type argument list, encloses an assembly-qualified type.</source>
          <target state="translated">Dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, the assembly-qualified name for a class might look like this:</source>
          <target state="translated">Por ejemplo, el nombre del ensamblado para una clase podría ser similar al siguiente:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Si el espacio de nombres contiene un signo más, por ejemplo EspacioNombresPrincipal. Sub+EspacioNombres, a continuación, el signo más (+) debería ir precedido de un carácter de escape (<ph id="ph1">\\</ph>) para evitar que se interprete como un separador de anidamiento.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Reflection would emit this string as follows:</source>
          <target state="translated">La reflexión emitiría esta cadena como sigue:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Este nombre completo puede se conserven y se utiliza posteriormente para cargar el <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Para buscar y cargar un <ph id="ph1">&lt;xref:System.Type&gt;</ph>, utilice <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> con el tipo de nombre sólo buscará la <ph id="ph2">&lt;xref:System.Type&gt;</ph> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> con el ensamblado de nombre de tipo calificado buscará la <ph id="ph2">&lt;xref:System.Type&gt;</ph> de cualquier ensamblado.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Para recuperar el nombre del tipo sin estos caracteres finales, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, donde <ph id="ph2">`t`</ph> es el tipo.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Los espacios son relevantes en todos los componentes de nombre de tipo excepto el nombre del ensamblado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">En el nombre del ensamblado, los espacios delante del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Generic arguments of generic types are themselves qualified by assembly name.</source>
          <target state="translated">Argumentos genéricos de los tipos genéricos propios están calificados por el nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, in the assembly-qualified type name for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic), <ph id="ph3">`int`</ph> is expanded to the assembly-qualified type name for <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Por ejemplo, en el nombre de tipo calificado por ensamblado para <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> en Visual Basic), <ph id="ph3">`int`</ph> se expande al nombre de tipo calificado con el ensamblado para <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro genérico, esta propiedad devuelve <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">En el ejemplo siguiente se muestra el nombre del ensamblado asociado a la clase y el nombre completo del tipo.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">En el ejemplo siguiente se comparan las cadenas devueltas por la <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> método y <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="P:System.Type.Attributes">
          <source>Gets the attributes associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene los atributos asociados al objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, unless the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter, in which case the value is unspecified.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> que representa el conjunto de atributos del objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, a menos que el objeto <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represente un parámetro de tipo genérico, en cuyo caso el valor no se especifica.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Some members of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration are masks that represent a group of values.</source>
          <target state="translated">Algunos miembros de la <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeración son máscaras que representan un grupo de valores.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Each group includes one member whose underlying value is zero.</source>
          <target state="translated">Cada grupo incluye a un miembro cuyo valor subyacente es cero.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the underlying value of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> group is zero, as is the <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> group.</source>
          <target state="translated">Por ejemplo, el valor subyacente de la <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph> miembro en el <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> grupo es cero, como es el <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> miembro en el <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> grupo.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Because of this, you must use the mask before testing for those values.</source>
          <target state="translated">Por este motivo, debe usar la máscara antes de probar para esos valores.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The example provides an illustration.</source>
          <target state="translated">En este ejemplo se ilustra.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For most purposes, properties like <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> are easier to use than type attributes.</source>
          <target state="translated">Para la mayoría de los casos, como propiedades <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> son más fáciles de usar que los atributos de tipo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the attributes of the generic type definition.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad devuelve los atributos de la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the attributes returned for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic) are the attributes of <ph id="ph3">`MyGenericClass&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericClass(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Por ejemplo, los atributos devueltos para <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> en Visual Basic) son los atributos del <ph id="ph3">`MyGenericClass&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericClass(Of T)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter — that is, if the <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph3">`true`</ph> — the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> value returned by this property is unspecified.</source>
          <target state="translated">Si actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo genérico, es decir, si la <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad devuelve <ph id="ph3">`true`</ph> : el <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> valor devuelto por esta propiedad no está especificado.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The following example usesthe <ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph> property.</source>
          <target state="translated">El siguiente utiliza ejemplo <ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Type.BaseType">
          <source>Gets the type from which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits.</source>
          <target state="translated">Obtiene el tipo del que hereda directamente el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> from which the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> represents the <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph> class or an interface.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> desde el cual el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual hereda directamente, o <ph id="ph3">&lt;see langword="null" /&gt;</ph> si el objeto <ph id="ph4">&lt;see langword="Type" /&gt;</ph> actual representa la clase <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph> o una interfaz.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base type is the type from which the current type directly inherits.</source>
          <target state="translated">El tipo base es el tipo del que hereda directamente el tipo actual.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source><ph id="ph1">&lt;xref:System.Object&gt;</ph> is the only type that does not have a base type, therefore <ph id="ph2">`null`</ph> is returned as the base type of <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph> es el único tipo que no tiene un tipo base, por lo tanto, <ph id="ph2">`null`</ph> se devuelve como el tipo base del <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>Interfaces inherit from zero or more base interfaces; therefore, this property returns <ph id="ph1">`null`</ph> if the <ph id="ph2">`Type`</ph> object represents an interface.</source>
          <target state="translated">Interfaces de heredan de cero o más interfaces base; por lo tanto, esta propiedad devuelve <ph id="ph1">`null`</ph> si la <ph id="ph2">`Type`</ph> objeto representa una interfaz.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base interfaces can be determined with <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.</source>
          <target state="translated">Las interfaces base se pueden determinar con <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, the base type reflects the generic arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa el tipo de un tipo genérico construido, el tipo base refleja los argumentos genéricos.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For example, consider the following declarations:</source>
          <target state="translated">Por ejemplo, consideremos las siguientes declaraciones:</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the <ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph> property returns <ph id="ph4">`B&lt;int&gt;`</ph>.</source>
          <target state="translated">Para el tipo construido <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> en Visual Basic), el <ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph> propiedad devuelve <ph id="ph4">`B&lt;int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type definition, <ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns the class constraint, that is, the class the type parameter must inherit.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de una definición de tipo genérico, <ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph> devuelve la restricción de clase, es decir, la clase debe heredar el parámetro de tipo.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If there is no class constraint, <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si no hay ninguna restricción de clase, <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> devuelve <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</source>
          <target state="translated">En el ejemplo siguiente se usa la recursividad para mostrar la jerarquía de herencia completa de cada clase que se encuentra en un ensamblado.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The example defines a class named <ph id="ph1">`C`</ph> that derives from a class named <ph id="ph2">`B`</ph>, which, in turn, derives from a class named <ph id="ph3">`A`</ph>.</source>
          <target state="translated">En el ejemplo se define una clase denominada <ph id="ph1">`C`</ph> que se deriva de una clase denominada <ph id="ph2">`B`</ph>, que, a su vez, deriva de una clase denominada <ph id="ph3">`A`</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Type.ContainsGenericParameters">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object has type parameters that have not been replaced by specific types.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual tiene parámetros de tipo que no han sido reemplazados por tipos específicos.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un parámetro de tipo genérico o tiene parámetros de tipo para los que no se han proporcionado tipos específicos; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</source>
          <target state="translated">Para crear una instancia de un tipo, no debe haber ninguna definición de tipo genérico o tipos construidos abiertos en los argumentos de tipo del propio tipo, en los tipos genéricos envolventes, o en todos los elementos del tipo.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</source>
          <target state="translated">Otra manera de decir esto es que, cuando examina de forma recursiva, el tipo no debe contener ningún parámetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Since types can be arbitrarily complex, making this determination is difficult.</source>
          <target state="translated">Puesto que los tipos pueden ser arbitrariamente complejos, es difícil tomar esta determinación.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For convenience and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</source>
          <target state="translated">Por comodidad y para reducir la posibilidad de error, el <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad proporciona un método estándar para distinguir entre tipos construidos cerrados, que se pueden crear instancias, y tipos, que no construye a abrir.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the type cannot be instantiated.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph>, no se pueden crear instancias del tipo.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad busca de forma recursiva para parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for an array whose elements are type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the array is not itself generic.</source>
          <target state="translated">Por ejemplo, devuelve <ph id="ph1">`true`</ph> para una matriz cuyos elementos son de tipo <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> en Visual Basic), incluso si la matriz no es genérico en sí mismo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for arrays.</source>
          <target state="translated">Compare esto con el comportamiento de la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> propiedad, que devuelve <ph id="ph2">`false`</ph> para matrices.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For a set of example classes and a table showing the values of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property, see <ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</source>
          <target state="translated">Para un conjunto de clases de ejemplo y una tabla que muestra los valores de la <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad, vea <ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</source>
          <target state="translated">En el ejemplo siguiente se define una clase genérica con dos parámetros de tipo y, a continuación, define una segunda clase genérica que se deriva de la primera clase.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph> and the second is a type parameter of the derived type.</source>
          <target state="translated">Clase base de la clase derivada tiene dos argumentos de tipo: el primero es <ph id="ph1">&lt;xref:System.Int32&gt;</ph> y el segundo es un parámetro de tipo del tipo derivado.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo se muestra información acerca de estas clases genéricas, incluidas las posiciones notifican por el <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringMethod">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the declaring method, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method.</source>
          <target state="translated">Obtiene un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa el método declarativo si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un parámetro de tipo de un método genérico.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method, a <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents declaring method; otherwise, <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un parámetro de tipo de un método genérico, <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa el método de declaración; de lo contrario, <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The declaring method is a generic method definition.</source>
          <target state="translated">El método declarativo es una definición de método genérico.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>That is, if <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> does not return <ph id="ph2">`null`</ph>, then <ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Es decir, si <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> no devuelve <ph id="ph2">`null`</ph>, a continuación, <ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph> devuelve <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedades identifican la definición de tipo genérico o la definición de método genérico en el que se definió originalmente el parámetro de tipo genérico:</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedad devuelve un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, que <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representa una definición de método genérico y la actual <ph id="ph4">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro de tipo de esa definición de método genérico.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedad devuelve <ph id="ph2">`null`</ph>, la <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> propiedad devuelve siempre un <ph id="ph4">&lt;xref:System.Type&gt;</ph> objeto que representa una definición de tipo genérico y la actual <ph id="ph5">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro de tipo de esa definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Obtener la <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedad en un tipo cuya <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad es <ph id="ph3">`false`</ph> produce una <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> that is returned by the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property is either a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the case of a generic method, or a <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> in the case of a generic constructor.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> devuelto por la <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedad sea una <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> en el caso de un método genérico, o un <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> en el caso de un constructor genérico.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>In the .NET Framework version 2.0, generic constructors are not supported.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, no se admiten constructores genéricos.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</source>
          <target state="translated">En el ejemplo de código siguiente se define una clase que tiene un método genérico, asigna un argumento de tipo para el método e invoca el método genérico construido resultante.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>It also displays information about the generic method definition and the constructed method.</source>
          <target state="translated">También muestra información acerca de la definición de método genérico y el método construido.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>When displaying information about the type parameters of the generic method definition, in the <ph id="ph1">`DisplayGenericMethodInfo`</ph> method, the example code shows the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property for the method's generic type parameter.</source>
          <target state="translated">Para mostrar información sobre los parámetros de tipo de la definición de método genérico, en el <ph id="ph1">`DisplayGenericMethodInfo`</ph> método, el código de ejemplo muestra el valor de la <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedad para el parámetro de tipo genérico del método.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringType">
          <source>Gets the type that declares the current nested type or generic type parameter.</source>
          <target state="translated">Obtiene el tipo que declara el tipo anidado actual o el parámetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo envolvente, si el tipo actual es un tipo anidado; o la definición de tipo genérico, si el tipo actual es un parámetro de tipo de un tipo genérico; o el tipo que declara el método genérico, si el tipo actual es un parámetro de tipo de un método genérico; en caso contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type, this property returns the generic type definition.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro de tipo de un tipo genérico, esta propiedad devuelve la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro de tipo de un método genérico, esta propiedad devuelve el tipo que contiene la definición de método genérico.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the type is generic, the generic type definition is returned.</source>
          <target state="translated">Si el tipo es genérico, se devuelve la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>That is, the following code returns the generic type definition of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class, which contains the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> generic method:</source>
          <target state="translated">Es decir, el código siguiente devuelve la definición de tipo genérico de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase genérica, que contiene el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> método genérico:</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, la <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedades identifican la definición de tipo genérico o la definición de método genérico donde se definió originalmente el parámetro de tipo genérico:</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedad devuelve un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, que <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representa una definición de método genérico y la actual <ph id="ph4">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro de tipo de esa definición de método genérico.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedad devuelve <ph id="ph2">`null`</ph>, la <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> propiedad devuelve siempre un <ph id="ph4">&lt;xref:System.Type&gt;</ph> objeto que representa una definición de tipo genérico y la actual <ph id="ph5">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro de tipo de esa definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Obtener la <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> propiedad en un tipo cuya <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad es <ph id="ph3">`false`</ph> produce una <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>This example displays the declaring type of a method in a derived class.</source>
          <target state="translated">En este ejemplo se muestra el tipo declarativo de un método en una clase derivada.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Type.DefaultBinder">
          <source>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Obtiene una referencia al enlazador predeterminado, que implementa varias reglas internas para seleccionar los miembros adecuados a los que llamará el método <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>A reference to the default binder used by the system.</source>
          <target state="translated">Referencia al enlazador predeterminado que el sistema usa.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</source>
          <target state="translated">El enlazador predeterminado suministrado con common language runtime es aplicable en todas las circunstancias muy específicas.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph> class and pass an instance of that type using the <ph id="ph2">`binder`</ph> parameter of one of the <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> overloads.</source>
          <target state="translated">Si necesita un enlazador que sigue las reglas que difieren de las del enlazador predeterminado proporcionado, definen un tipo derivado de la <ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph> clase y pase una instancia de ese tipo mediante el <ph id="ph2">`binder`</ph> parámetro de uno de los <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> sobrecargas.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Reflection models the accessibility rules of the common type system.</source>
          <target state="translated">La reflexión determina las reglas de accesibilidad del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</source>
          <target state="translated">Por ejemplo, si el llamador está en el mismo ensamblado, el llamador no necesita permisos especiales para los miembros internos.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Otherwise, the caller needs <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">En caso contrario, el llamador necesita <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is consistent with lookup of members that are protected, private, and so on.</source>
          <target state="translated">Esto es coherente con la búsqueda de miembros que están protegidos, privadas y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The general principle is that <ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> should perform only widening conversions, which never lose data.</source>
          <target state="translated">El principio general es que <ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> debe realizar sólo conversiones de ampliación, que nunca se pierden datos.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</source>
          <target state="translated">Un ejemplo de una conversión de ampliación es convertir un valor que es un entero de 32 bits con signo en un valor que es un entero de 64 bits con signo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is distinguished from a narrowing conversion, which may lose data.</source>
          <target state="translated">Esto se diferencia de una conversión de restricción, que podrían perder datos.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</source>
          <target state="translated">Un ejemplo de una conversión de restricción es convertir un entero de 64 bits con signo en un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following table lists the conversions supported by the default binder.</source>
          <target state="translated">En la tabla siguiente se enumera las conversiones compatibles con el enlazador predeterminado.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Source Type</source>
          <target state="translated">Tipo de origen</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Target Type</source>
          <target state="translated">Tipo de destino</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">Cualquier tipo</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Its base type.</source>
          <target state="translated">Su tipo base.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">Cualquier tipo</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The interface it implements.</source>
          <target state="translated">La interfaz que implementa.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char</source>
          <target state="translated">Char</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Unt16, UInt32, Int32, Int64, UInt64 Single o Double</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Byte</source>
          <target state="translated">Byte</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single o Double</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>SByte</source>
          <target state="translated">SByte</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16, Int32, Int64, Single, Double</source>
          <target state="translated">Int16, Int32, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt16</source>
          <target state="translated">UInt16</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">UInt32, Int32, UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16</source>
          <target state="translated">Int16</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32, Int64, Single, Double</source>
          <target state="translated">Int32, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32</source>
          <target state="translated">UInt32</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64, Int64, Single, Double</source>
          <target state="translated">UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32</source>
          <target state="translated">Int32</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64, Single, Double</source>
          <target state="translated">Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64</source>
          <target state="translated">UInt64</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single, Double</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64</source>
          <target state="translated">Int64</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single, Double</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single</source>
          <target state="translated">Single</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Double</source>
          <target state="translated">Doble</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Non-reference</source>
          <target state="translated">Sin referencia</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>By-reference.</source>
          <target state="translated">Por referencia.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following example gets the default binder from the <ph id="ph1">`DefaultBinder`</ph> property, and invokes a member of MyClass by passing the <ph id="ph2">`DefaultBinder`</ph> value as a parameter to <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se obtiene el enlazador predeterminado de la <ph id="ph1">`DefaultBinder`</ph> propiedad y se llama a un miembro de MyClass pasando el <ph id="ph2">`DefaultBinder`</ph> valor como un parámetro a <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>Separates names in the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Separa los nombres en el espacio de nombres de <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>This field is read-only.</source>
          <target state="translated">Este campo es de solo lectura.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>Represents an empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Representa una matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>This field is read-only.</source>
          <target state="translated">Este campo es de solo lectura.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.EmptyTypes">
          <source>The following code example shows the <ph id="ph1">`EmptyTypes`</ph> field used in one of the <ph id="ph2">`GetConstructor`</ph> methods to get a constructor that takes no parameters.</source>
          <target state="translated">El siguiente ejemplo de código muestra la <ph id="ph1">`EmptyTypes`</ph> campo utilizado en uno de los <ph id="ph2">`GetConstructor`</ph> métodos para obtener un constructor que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Determina si el tipo del sistema subyacente del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual coincide con el tipo del sistema subyacente del objeto <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Objeto cuyo tipo de sistema subyacente se va a comparar con el tipo de sistema subyacente del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>For the comparison to succeed, <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> must be able to be cast or converted to an object of type   <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Para que la comparación se realice correctamente, <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> debe poder convertirse en un objeto de tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Determina si el tipo del sistema subyacente del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual es el mismo que el tipo del sistema subyacente del objeto <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo del sistema subyacente de <ph id="ph2">&lt;paramref name="o" /&gt;</ph> coincide con el tipo del sistema subyacente del objeto <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> actual; de lo contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if: .</source>
          <target state="translated">Este método también devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph> si:</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> cannot be cast or converted to a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> no se puede convertir en un objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>It casts <ph id="ph1">`o`</ph> to an object of type <ph id="ph2">&lt;xref:System.Type&gt;</ph> and calls the <ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Proyecta <ph id="ph1">`o`</ph> a un objeto de tipo <ph id="ph2">&lt;xref:System.Type&gt;</ph> y llama a la <ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph> to compare various <ph id="ph2">&lt;xref:System.Type&gt;</ph> object instances with various <ph id="ph3">&lt;xref:System.Object&gt;</ph> instances.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph> para comparar varios <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto instancias con varios <ph id="ph3">&lt;xref:System.Object&gt;</ph> instancias.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>Two things are particularly worth noting about the example:</source>
          <target state="translated">Dos cosas son especialmente debe tener en cuenta sobre el ejemplo:</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents an integer with a <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object that represents an integer return <ph id="ph3">`true`</ph> because <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> is derived from <ph id="ph5">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">La comparación de un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa un entero con un <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objeto que representa un valor devuelto entero <ph id="ph3">`true`</ph> porque <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> se deriva de <ph id="ph5">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a  <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> object (an open generic type) with a <ph id="ph3">`List(Of String)`</ph> object (a closed generic type) returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">La comparación de un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa un <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> objeto (un tipo genérico abierto) con un <ph id="ph3">`List(Of String)`</ph> objeto (un tipo genérico) devuelve <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Objeto cuyo tipo de sistema subyacente se va a comparar con el tipo de sistema subyacente del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Determina si el tipo de sistema subyacente del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual es igual que el tipo de sistema subyacente del objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo del sistema subyacente de <ph id="ph2">&lt;paramref name="o" /&gt;</ph> coincide con el tipo del sistema subyacente del objeto <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> actual; de lo contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Type)">
          <source>The following example uses <ph id="ph1">`Equals`</ph> to compare two types.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">`Equals`</ph> para comparar dos tipos.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>Represents the member filter used on attributes.</source>
          <target state="translated">Representa el filtro de miembros que se usa para los atributos.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>This field is read-only.</source>
          <target state="translated">Este campo es de solo lectura.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">Este campo contiene una referencia al delegado usado por el <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">El método encapsulado por este delegado toma dos parámetros: el primero es un <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objeto y el segundo es un <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">El método determina si el <ph id="ph1">`MemberInfo`</ph> objeto coincide con los criterios especificados por el <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The <ph id="ph1">`Object`</ph> may be assigned the value of any one of the fields on the classes <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">`Object`</ph> puede tener asignado el valor de cualquiera de los campos en las clases de <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, o <ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>For example, the <ph id="ph1">`Object`</ph> can be assigned the value of a field from <ph id="ph2">`FieldAttributes`</ph> such as Public.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">`Object`</ph> puede tener asignado el valor de un campo de <ph id="ph2">`FieldAttributes`</ph> como Public.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>In that case, when the <ph id="ph1">`FilterAttribute`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object is decorated with the public field attribute in metadata.</source>
          <target state="translated">En ese caso, cuando la <ph id="ph1">`FilterAttribute`</ph> delegado se invoca, devolverá <ph id="ph2">`true`</ph> sólo si el método representado por la <ph id="ph3">`MemberInfo`</ph> objeto se decora con el atributo de campo público en metadatos.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The following example gets the <ph id="ph1">`FilterAttribute`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the specified members and their attributes.</source>
          <target state="translated">En el ejemplo siguiente se obtiene la <ph id="ph1">`FilterAttribute`</ph> delegado, se pasa como un parámetro a la <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> método y se muestran los miembros especificados y sus atributos.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>Represents the case-sensitive member filter used on names.</source>
          <target state="translated">Representa el filtro de miembros que distingue mayúsculas de minúsculas y que se aplica a los nombres.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>This field is read-only.</source>
          <target state="translated">Este campo es de solo lectura.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">Este campo contiene una referencia al delegado usado por el <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">El método encapsulado por este delegado toma dos parámetros: el primero es un <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objeto y el segundo es un <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">El método determina si el <ph id="ph1">`MemberInfo`</ph> objeto coincide con los criterios especificados por el <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated">El <ph id="ph1">`Object`</ph> tiene asignado un valor de cadena, que puede incluir un carácter final "*" carácter comodín.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">Coincidencia de cadenas de final de comodín solo se admite.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "Byte*".</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">`Object`</ph> puede tener asignado el valor "Byte *".</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object has a name that begins with "Byte".</source>
          <target state="translated">En ese caso, cuando la <ph id="ph1">`FilterName`</ph> delegado se invoca, devolverá <ph id="ph2">`true`</ph> sólo si el método representado por la <ph id="ph3">`MemberInfo`</ph> objeto tiene un nombre que empiece por "Byte".</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The following code example gets the methods associated with the user-defined <ph id="ph1">`Application`</ph> type.</source>
          <target state="translated">En el ejemplo de código siguiente se obtiene los métodos asociados a definido por el usuario <ph id="ph1">`Application`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Represents the case-insensitive member filter used on names.</source>
          <target state="translated">Representa el filtro de miembros que no distingue mayúsculas de minúsculas y que se aplica a los nombres.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field is read-only.</source>
          <target state="translated">Este campo es de solo lectura.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">Este campo contiene una referencia al delegado usado por el <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">El método encapsulado por este delegado toma dos parámetros: el primero es un <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objeto y el segundo es un <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">El método determina si el <ph id="ph1">`MemberInfo`</ph> objeto coincide con los criterios especificados por el <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated">El <ph id="ph1">`Object`</ph> tiene asignado un valor de cadena, que puede incluir un carácter final "*" carácter comodín.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">Coincidencia de cadenas de final de comodín solo se admite.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "ByTe*".</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">`Object`</ph> puede tener asignado el valor "ByTe *".</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return true only if the method represented by the <ph id="ph2">`MemberInfo`</ph> object has a name that begins with "byte", ignoring case.</source>
          <target state="translated">En ese caso, cuando la <ph id="ph1">`FilterName`</ph> delegado se invoca, devolverá true solo si el método representado por la <ph id="ph2">`MemberInfo`</ph> objeto tiene un nombre que empiece por "byte" mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The following example gets the <ph id="ph1">`MemberFilter`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the methods and their attributes of the <ph id="ph3">`String`</ph> class that begin with the letter "c", disregarding the case.</source>
          <target state="translated">En el ejemplo siguiente se obtiene la <ph id="ph1">`MemberFilter`</ph> delegado, se pasa como un parámetro a la <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> método y muestra los métodos y los atributos de la <ph id="ph3">`String`</ph> clase que comienzan por la letra "c", sin tener en cuenta el caso.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate that compares the interfaces against <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Delegado que compara las interfaces con <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The search criteria that determines whether an interface should be included in the returned array.</source>
          <target state="translated">Criterios de búsqueda que determinan si una interfaz se debe incluir en la matriz devuelta.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una lista filtrada de interfaces implementadas o heredadas por el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no interfaces matching the filter are implemented or inherited by the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una lista filtrada de las interfaces implementadas o heredadas por el <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual, o una matriz vacía de tipo <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> si no hay ninguna interfaz que coincida con el filtro y que haya sido implementada o heredada por el <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph> delegates supplied by the <ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph> class may also be used, in lieu of the <ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph> delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph> delegados proporcionados por el <ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph> clase también puede utilizarse, en lugar de la <ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</source>
          <target state="translated">Todas las interfaces implementadas por esta clase se consideran durante la búsqueda, si declara una clase base o esta clase en Sí.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</source>
          <target state="translated">Este método busca en la jerarquía de clases base, devolviendo cada una de las interfaces coincidentes que cada clase implementa, así como la coincidencia interfaces de cada uno de esos implementa interfaces (es decir, se devuelve el cierre transitivo de las interfaces coincidentes).</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>No duplicate interfaces are returned.</source>
          <target state="translated">No hay ninguna interfaz duplicada se devuelve.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> busca todas las interfaces declaradas en las restricciones en el parámetro de tipo y todas las interfaces que se heredan a través de las interfaces declaran en las restricciones.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type argument of a generic type, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces implemented by the type, whether or not they match constraints.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un argumento de tipo de un tipo genérico, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> busca todas las interfaces implementadas por el tipo, si no coinciden con las restricciones.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> can return generic interfaces, even on types that are not generic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> puede devolver interfaces genéricas, incluso en tipos que no son genéricos.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>For example, a nongeneric type might implement <ph id="ph1">`IEnumerable&lt;int&gt;`</ph> (<ph id="ph2">`IEnumerable(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Por ejemplo, podría implementar un tipo no genérico <ph id="ph1">`IEnumerable&lt;int&gt;`</ph> (<ph id="ph2">`IEnumerable(Of Integer)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</source>
          <target state="translated">En el ejemplo siguiente se busca la interfaz especificada implementada o heredada por el tipo especificado y, a continuación, muestra los nombres de interfaz.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador estático y produce una excepción.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An object that indicates the type of member to search for.</source>
          <target state="translated">Objeto que indica el tipo de miembro que se va a buscar.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The delegate that does the comparisons, returning <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member currently being inspected matches the <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> and <ph id="ph2">&lt;see langword="false" /&gt;</ph> otherwise.</source>
          <target state="translated">Delegado que realiza las comparaciones y que devuelve <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el miembro inspeccionado coincide con <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> y <ph id="ph2">&lt;see langword="false" /&gt;</ph> en caso contrario.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can use the <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph>, <ph id="ph2">&lt;see langword="FilterName" /&gt;</ph>, and <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph> delegates supplied by this class.</source>
          <target state="translated">Es posible usar los delegados <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph>, <ph id="ph2">&lt;see langword="FilterName" /&gt;</ph> y <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph> que esta clase proporciona.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The first uses the fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> as search criteria, and the other two delegates use <ph id="ph4">&lt;see langword="String" /&gt;</ph> objects as the search criteria.</source>
          <target state="translated">El primero usa los campos de <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph> y <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> como criterios de búsqueda, y los otros dos usan objetos <ph id="ph4">&lt;see langword="String" /&gt;</ph> como criterios de búsqueda.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The search criteria that determines whether a member is returned in the array of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects.</source>
          <target state="translated">Criterios de búsqueda que determinan si se devuelve un miembro en la matriz de objetos <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> can be used in conjunction with the <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph> delegate supplied by this class.</source>
          <target state="translated">Los campos de <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph> y <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> se pueden usar junto con el delegado <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph> que esta clase proporciona.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Returns a filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">Devuelve una matriz filtrada de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> del tipo del miembro especificado.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">Matriz filtrada de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> del tipo del miembro especificado.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have members of type <ph id="ph3">&lt;paramref name="memberType" /&gt;</ph> that match the filter criteria.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> en caso de que el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual no tenga miembros del tipo <ph id="ph3">&lt;paramref name="memberType" /&gt;</ph> que coincidan con los criterios del filtro.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los miembros que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Instance`</ph> to include instance members in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Instance`</ph> para incluir los miembros de instancia en la búsqueda.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Static`</ph> to include static members in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Static`</ph> para incluir los miembros estáticos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir miembros públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar solo los miembros declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los miembros que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Valid values for <ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph> are defined in <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</source>
          <target state="translated">Los valores válidos para <ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph> se definen en <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If no such members are found, an empty array is returned.</source>
          <target state="translated">Si no se encuentra ningún miembro de este tipo, se devuelve una matriz vacía.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Para obtener el inicializador de clase (.cctor) utilizando este método, se debe especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> processes any members declared by the class constraint and the interface constraints of the type parameter.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico o un método genérico, <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> procesa los miembros declarados por la restricción de clase y las restricciones de interfaz del parámetro de tipo.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</source>
          <target state="translated">En el ejemplo siguiente se busca a todos los miembros de una clase que coinciden con los criterios de búsqueda especificado y, a continuación, muestra a los miembros coincidentes.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="P:System.Type.FullName">
          <source>Gets the fully qualified name of the type, including its namespace but not its assembly.</source>
          <target state="translated">Obtiene el nombre completo del tipo, incluido su espacio de nombres, pero no su ensamblado.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The fully qualified name of the type, including its namespace but not its assembly; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter, an array type, pointer type, or <ph id="ph2">&lt;see langword="byref" /&gt;</ph> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</source>
          <target state="translated">Nombre completo del tipo, con espacio de nombres y sin ensamblado; o bien, <ph id="ph1">&lt;see langword="null" /&gt;</ph> si la instancia actual representa un parámetro de tipo genérico, un tipo de matriz, un tipo de puntero o un tipo <ph id="ph2">&lt;see langword="byref" /&gt;</ph> basado en un parámetro de tipo, o un tipo genérico que no sea una definición de tipo genérico, pero que contenga parámetros de tipo sin resolver.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>For example, the fully qualified name of the <ph id="ph1">&lt;xref:System.String&gt;</ph> type is <ph id="ph2">`System.String`</ph>.</source>
          <target state="translated">Por ejemplo, el nombre completo de la <ph id="ph1">&lt;xref:System.String&gt;</ph> es de tipo <ph id="ph2">`System.String`</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Contrast this with the assembly-qualified name returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, which consists of the full name plus the full assembly name.</source>
          <target state="translated">Compare esto con el nombre del ensamblado devuelto por la <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedad, que está formada por el nombre completo más el nombre completo del ensamblado.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>If the current type represents a closed generic type, the type arguments in the string returned by the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</source>
          <target state="translated">Si el tipo actual representa un tipo genérico, los argumentos de tipo en la cadena devuelven por la <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> propiedad se califican por su nombre completo del ensamblado, aunque la representación de cadena del propio tipo genérico no se califica por su completo nombre del ensamblado.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</source>
          <target state="translated">En el ejemplo siguiente se ilustra la diferencia en la propiedad FullName para un tipo que representa la definición de tipo genérico y uno que representa un tipo genérico.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property returns <ph id="ph1">`null`</ph> if:</source>
          <target state="translated">Esta propiedad devuelve <ph id="ph1">`null`</ph> si:</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type.</source>
          <target state="translated">Actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro de tipo de un tipo genérico.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example retrieves the type parameter of the <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type and attempts to display its <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se recupera el parámetro de tipo de la <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> tipo e intenta mostrar su <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an array type, a pointer  type, or a <ph id="ph2">`byref`</ph> type that is based on a generic type parameter.</source>
          <target state="translated">Actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa un tipo de matriz, un tipo de puntero, o un <ph id="ph2">`byref`</ph> tipo que se basa en un parámetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example defines a generic type, <ph id="ph1">`Generictype1&lt;T&gt;`</ph>, with three methods: <ph id="ph2">`Display(T[])`</ph>, which is passed an array of type T; <ph id="ph3">`HandleT(T)`</ph>, which is passed a T object; and <ph id="ph4">`ChangeValue(ref T)`</ph>, which is passed a T object by reference.</source>
          <target state="translated">En el ejemplo siguiente se define un tipo genérico, <ph id="ph1">`Generictype1&lt;T&gt;`</ph>, con tres métodos: <ph id="ph2">`Display(T[])`</ph>, que se pasa una matriz de tipo T; <ph id="ph3">`HandleT(T)`</ph>, que se pasa un objeto T; y <ph id="ph4">`ChangeValue(ref T)`</ph>, un objeto T que se pasa por referencia.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Because C# and Visual Basic do not allow us to define T as a pointer in the <ph id="ph1">`HandleT`</ph> method, we have to call the <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents the method's parameter type to create a pointer to a generic type.</source>
          <target state="translated">Dado que C# y Visual Basic no nos permiten definir T como un puntero en la <ph id="ph1">`HandleT`</ph> método, se debe llamar a la <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> método en la <ph id="ph3">&lt;xref:System.Type&gt;</ph> objeto que representa el tipo de parámetro del método para crear un puntero a un tipo genérico.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The output from the example shows that in all three cases, the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">El resultado del ejemplo muestra que, en los tres casos, el <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> propiedad es <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current type contains generic type parameters that have not been replaced by specific types (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>), but the type is not a generic type definition (that is, the <ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph4">`false`</ph></source>
          <target state="translated">El tipo actual contiene parámetros de tipo genérico que no han sido reemplazados por tipos específicos (es decir, el <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph>), pero el tipo no es una definición de tipo genérico (es decir, el <ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> devuelve de propiedad <ph id="ph4">`false`</ph></target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>In the following example, <ph id="ph1">`Derived&lt;T&gt;`</ph> inherits from <ph id="ph2">`Base&lt;T&gt;`</ph>.</source>
          <target state="translated">En el ejemplo siguiente, <ph id="ph1">`Derived&lt;T&gt;`</ph> hereda de <ph id="ph2">`Base&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property obtains the  <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the base type of <ph id="ph3">`Derived&lt;T&gt;`</ph>, and its <ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph> property returns <ph id="ph5">`null`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> propiedad obtiene el <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que representa el tipo base del <ph id="ph3">`Derived&lt;T&gt;`</ph>y su <ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph> propiedad devuelve <ph id="ph5">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>To get a <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> that is not <ph id="ph2">`null`</ph>, you can use the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get the generic type definition, as the example illustrates.</source>
          <target state="translated">Para obtener un <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> que no es <ph id="ph2">`null`</ph>, puede usar el <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> método para obtener la definición de tipo genérico, como se muestra en el ejemplo.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example displays the full name of the specified type.</source>
          <target state="translated">En el ejemplo siguiente se muestra el nombre completo del tipo especificado.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">En el ejemplo siguiente se comparan las cadenas devueltas por la <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> método y <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>Gets a combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> flags that describe the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Obtiene una combinación de marcas <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> que describen la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Combinación bit a bit de valores de <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</source>
          <target state="translated">El valor de esta propiedad contiene marcas que describen si el parámetro de tipo genérico actual es covariante e indicadores que describen las restricciones especiales.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph> value to select the covariance flags, and use the <ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph> value to select the constraint flags.</source>
          <target state="translated">Utilice la <ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph> valor para seleccionar los indicadores de covarianza y usar el <ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph> valor para seleccionar los indicadores de restricción.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">En el ejemplo de código siguiente se define un tipo genérico <ph id="ph1">`Test`</ph> con dos parámetros de tipo que tienen restricciones distintas.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">Cuando se ejecuta el programa, se examinan las restricciones mediante la <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> propiedad y el <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual no es un parámetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es decir, la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">El método invocado no se admite en la clase base.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type or a generic method.</source>
          <target state="translated">Obtiene la posición del parámetro de tipo en la lista de parámetros de tipo del tipo o método genérico que declaró el parámetro, siempre que el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represente un parámetro de tipo de un tipo genérico o de un método genérico.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</source>
          <target state="translated">Posición de un parámetro de tipo en la lista de parámetros de tipo del método o tipo genérico que define el parámetro.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Position numbers begin at 0.</source>
          <target state="translated">Los números de posición comienzan en 0.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> propiedad devuelve la posición de un parámetro de tipo en la lista de parámetros de la definición de tipo genérico o la definición de método genérico donde se definió originalmente el parámetro de tipo.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type or method definition:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedades identifican la definición de método o tipo genérico:</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedad devuelve un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, que <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representa una definición de método genérico y la actual <ph id="ph4">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro de tipo de esa definición de método genérico.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> propiedad devuelve <ph id="ph2">`null`</ph>, la <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> propiedad devuelve siempre un <ph id="ph4">&lt;xref:System.Type&gt;</ph> objeto que representa una definición de tipo genérico y la actual <ph id="ph5">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro de tipo de esa definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>To provide the correct context for the value of the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property, it is necessary to identify the generic type or method a type parameter belongs to.</source>
          <target state="translated">Para proporcionar el contexto correcto para el valor de la <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> propiedad, es necesario identificar el tipo o método genérico al que pertenece un parámetro de tipo.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>For example, consider the return value of the generic method <ph id="ph1">`GetSomething`</ph> in the following code:</source>
          <target state="translated">Por ejemplo, tenga en cuenta el valor devuelto del método genérico <ph id="ph1">`GetSomething`</ph> en el código siguiente:</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The type returned by <ph id="ph1">`GetSomething`</ph> depends on the type arguments supplied to class <ph id="ph2">`A`</ph> and to <ph id="ph3">`GetSomething`</ph> itself.</source>
          <target state="translated">El tipo devuelto por <ph id="ph1">`GetSomething`</ph> depende de los argumentos de tipo proporcionados a clase <ph id="ph2">`A`</ph> y a <ph id="ph3">`GetSomething`</ph> propio.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>You can obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for <ph id="ph2">`GetSomething`</ph>, and from that you can obtain the return type.</source>
          <target state="translated">Puede obtener un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> para <ph id="ph2">`GetSomething`</ph>, y desde el que se puede obtener el tipo de valor devuelto.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type parameters of the return type, <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> returns 0 for both.</source>
          <target state="translated">Cuando examine los parámetros de tipo de valor devuelto, <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> devuelve 0 para ambos.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`V`</ph> is 0 because <ph id="ph2">`V`</ph> is the first type parameter in the type parameter list for class <ph id="ph3">`A`</ph>.</source>
          <target state="translated">La posición de <ph id="ph1">`V`</ph> es 0 porque <ph id="ph2">`V`</ph> es el primer parámetro de tipo en la lista de parámetros de tipo para la clase <ph id="ph3">`A`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`X`</ph> is 0 because <ph id="ph2">`X`</ph> is the first type parameter in the type parameter list for <ph id="ph3">`GetSomething`</ph>.</source>
          <target state="translated">La posición de <ph id="ph1">`X`</ph> es 0 porque <ph id="ph2">`X`</ph> es el primer parámetro de tipo en la lista de parámetros de tipo <ph id="ph3">`GetSomething`</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Calling the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property causes an exception if the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> does not represent a type parameter.</source>
          <target state="translated">Llamar a la <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> propiedad provoca una excepción si la actual <ph id="ph2">&lt;xref:System.Type&gt;</ph> no representa un parámetro de tipo.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type arguments of an open constructed type, use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell which are type parameters and which are types.</source>
          <target state="translated">Cuando examine los argumentos de tipo de un tipo construido abierto, utilice la <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad para indicar que son parámetros de tipo y cuáles son los tipos.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for a type parameter; you can then use the <ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> method to obtain its position and use the <ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> properties to determine the generic method or type definition that defines it.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph> para un parámetro de tipo; a continuación, puede usar el <ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> método obtener su posición y usar el <ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> y <ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> propiedades para determinar el método genérico o que lo define la definición de tipo.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</source>
          <target state="translated">En el ejemplo siguiente se define una clase genérica con dos parámetros de tipo y define una segunda clase genérica que se deriva de la primera clase.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and the second is a type parameter of the derived type.</source>
          <target state="translated">Clase base de la clase derivada tiene dos argumentos de tipo: el primero es <ph id="ph1">&lt;xref:System.Int32&gt;</ph>, y el segundo es un parámetro de tipo del tipo derivado.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo se muestra información acerca de estas clases genéricas, incluidas las posiciones notifican por el <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>The current type does not represent a type parameter.</source>
          <target state="translated">El tipo actual no representa un parámetro de tipo.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es decir, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Type.GenericTypeArguments">
          <source>Gets an array of the generic type arguments for this type.</source>
          <target state="translated">Obtiene una matriz de los argumentos de tipo genérico para este tipo.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>An array of the generic type arguments for this type.</source>
          <target state="translated">Una matriz de argumentos de tipo genérico para este tipo.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</source>
          <target state="translated">Esta propiedad obtiene solo los argumentos de tipo genérico; es decir, los tipos que se han especificado para los parámetros de tipo genérico del tipo actual.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If the current type is a generic type definition, this property returns an empty array.</source>
          <target state="translated">Si el tipo actual es una definición de tipo genérico, esta propiedad devuelve una matriz vacía.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</source>
          <target state="translated">Si se utiliza un tipo genérico en un método genérico o en otro tipo genérico, algunos de sus argumentos de tipo genérico pueden ser parámetros de tipo genérico del método o tipo envolvente.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get the generic type parameters of a type that represents a generic type definition, use the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obtener los parámetros de tipo genérico de un tipo que representa una definición de tipo genérico, use la <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get a <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object for the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, use the <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph> extension method.</source>
          <target state="translated">Para obtener un <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objeto actuales <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto, utilice el <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph> método de extensión.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>Gets the number of dimensions in an array.</source>
          <target state="translated">Obtiene el número de dimensiones de una matriz.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>An integer that contains the number of dimensions in the current type.</source>
          <target state="translated">Entero que contiene el número de dimensiones del tipo actual.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetArrayRank">
          <source>The following example displays the number of dimensions in an array.</source>
          <target state="translated">En el ejemplo siguiente se muestra el número de dimensiones de una matriz.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</source>
          <target state="translated">La funcionalidad de este método no se admite en la clase base y debe implementarse en una clase derivada.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The current type is not an array.</source>
          <target state="translated">El tipo actual no es una matriz.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property and gets a bitmask indicating the attributes associated with the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> y obtiene una máscara de bits que indica los atributos asociados a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> que representa el conjunto de atributos de <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific constructor of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene un constructor específico del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the desired constructor.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de los parámetros del constructor deseado.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects, to get a constructor that takes no parameters.</source>
          <target state="translated">Matriz vacía de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, para obtener un constructor que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Such an empty array is provided by the <ph id="ph1">&lt;see langword="static" /&gt;</ph> field <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated">El campo <ph id="ph1">&lt;see langword="static" /&gt;</ph><ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> proporciona dicha matriz vacía.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Searches for a public instance constructor whose parameters match the types in the specified array.</source>
          <target state="translated">Busca un constructor de instancia público cuyos parámetros coincidan con los tipos de la matriz especificada.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el constructor de instancia público cuyos parámetros coinciden con los tipos de la matriz de tipos de parámetro, si se encuentra; de lo contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</source>
          <target state="translated">Esta sobrecarga de método busca constructores de instancias públicos y no se puede usar para obtener a un inicializador de clase (.cctor).</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>To get a class initializer, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Para obtener un inicializador de clase, use una sobrecarga que toma <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>y especifique <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the requested constructor is non-public, this method returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Si el constructor solicitado no es público, este método devuelve <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">No se puede omitir los parámetros al buscar constructores y métodos.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Solo puede omitir los parámetros al invocar.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método devuelve siempre <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object, and displays the constructor signature.</source>
          <target state="translated">En el ejemplo siguiente se obtiene el tipo de <ph id="ph1">`MyClass`</ph>, obtiene la <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> del objeto y se muestra la firma del constructor.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno de los elementos de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que el constructor debe obtener.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">Matriz vacía del tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (es decir, Type[] types = new Type[0]) para obtener un constructor que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the parameter type array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz de tipo de parámetro.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Busca un constructor cuyos parámetros coincidan con los tipos y modificadores de argumento especificados, mediante las restricciones de enlace también especificadas.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> que representa el constructor que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Si no existe una coincidencia exacta, la <ph id="ph1">`binder`</ph> intentará convertir los tipos de parámetro especificados en la <ph id="ph2">`types`</ph> matriz para seleccionar una coincidencia.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Si el <ph id="ph1">`binder`</ph> no puede seleccionar una coincidencia, a continuación, <ph id="ph2">`null`</ph> se devuelve.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro se pueden utilizar para definir los constructores que deben incluirse en la búsqueda:</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir constructores públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">No se puede omitir los parámetros al buscar constructores y métodos.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Solo puede omitir los parámetros al invocar.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método devuelve siempre <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following program obtains the type of <ph id="ph1">`MyClass1`</ph> class, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object matching the specified binding flags, and displays the signature of the constructor.</source>
          <target state="translated">El programa siguiente obtiene el tipo de <ph id="ph1">`MyClass1`</ph> de la clase, obtiene la <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objeto coincidencia de las marcas de enlace especificadas y muestra la firma del constructor.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno de los elementos de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> y <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> no tienen la misma longitud.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">Objeto que especifica el conjunto de reglas que se va a usar en cuanto al orden y al diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y la pila que se limpia.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que el constructor debe obtener.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">Matriz vacía del tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (es decir, Type[] types = new Type[0]) para obtener un constructor que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Busca un constructor cuyos parámetros coincidan con los modificadores y tipos de argumento especificados, mediante las restricciones de enlace indicadas y la convención de llamadas también especificada.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el constructor que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (la <ph id="ph2">`modifiers`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Si no existe una coincidencia exacta, la <ph id="ph1">`binder`</ph> intentará convertir los tipos de parámetro especificados en la <ph id="ph2">`types`</ph> matriz para seleccionar una coincidencia.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Si el <ph id="ph1">`binder`</ph> no puede seleccionar una coincidencia, a continuación, <ph id="ph2">`null`</ph> se devuelve.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro se pueden utilizar para definir los constructores que deben incluirse en la búsqueda:</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir constructores públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Para obtener el inicializador de clase (.cctor) utilizando este método, se debe especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">No se puede omitir los parámetros al buscar constructores y métodos.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Solo puede omitir los parámetros al invocar.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método devuelve siempre <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass1`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that matches the specified binding flags, and displays the constructor signature.</source>
          <target state="translated">En el ejemplo siguiente se obtiene el tipo de <ph id="ph1">`MyClass1`</ph>, obtiene la <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objeto que coincide con las marcas de enlace especificadas y muestra la firma del constructor.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno de los elementos de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> y <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> no tienen la misma longitud.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">Objeto que especifica el conjunto de reglas que se va a usar en cuanto al orden y al diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y la pila que se limpia.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que el constructor debe obtener.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">Matriz vacía del tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (es decir, Type[] types = new Type[0]) para obtener un constructor que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca un constructor cuyos parámetros coincidan con los tipos y modificadores de argumento especificados, y aplica las restricciones de enlace especificadas y la convención de llamadas especificada.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> que representa el constructor que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (la <ph id="ph2">`modifiers`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Si no existe una coincidencia exacta, la <ph id="ph1">`binder`</ph> intentará convertir los tipos de parámetro especificados en la <ph id="ph2">`types`</ph> matriz para seleccionar una coincidencia.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Si el <ph id="ph1">`binder`</ph> no puede seleccionar una coincidencia, a continuación, <ph id="ph2">`null`</ph> se devuelve.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro se pueden utilizar para definir los constructores que deben incluirse en la búsqueda:</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir constructores públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This method implements <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.</source>
          <target state="translated">Este método implementa <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno de los elementos de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> y <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> no tienen la misma longitud.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">El tipo actual es un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> o <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the constructors of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene los constructores del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>Returns all the public constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Devuelve todos los constructores públicos definidos para el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all the public instance constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, but not including the type initializer (static constructor).</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> que representan todos los constructores de instancias públicos definidos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual, pero sin incluir el inicializador de tipo (constructor estático).</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>If no public instance constructors are defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, or if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method, an empty array of type <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> is returned.</source>
          <target state="translated">Si no se han definido constructores de instancia públicos para el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual o si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un parámetro de tipo en la definición de un tipo genérico o de un método genérico, se devuelve una matriz vacía de tipo <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> método no devuelve constructores en un orden determinado, como el orden de declaración.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los constructores, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Esta sobrecarga de método llama a la <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> sobrecarga del método, con <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">No encontrará a inicializadores de clase (.cctor).</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Para buscar inicializadores de clase, use una sobrecarga que toma <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>y especifique <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Por ejemplo, si clase <ph id="ph1">`C&lt;T&gt;`</ph> tiene un constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> en Visual Basic), la llamada a <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> en <ph id="ph5">`C&lt;int&gt;`</ph> devuelve un <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> que representa <ph id="ph7">`C(int t1)`</ph> en C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo genérico, la <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> método devuelve una matriz vacía.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">Este ejemplo muestra el resultado de la <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> sobrecarga de una clase que tiene dos constructores de instancia y un constructor estático.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The output of this code is:</source>
          <target state="translated">El resultado de este código es:</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> solo usa la sobrecarga <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, el constructor estático no se calcula mediante la <ph id="ph4">`for`</ph> expresión ni se evalúa con <ph id="ph5">`IsStatic`</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> overload, and pass the combination (logical <ph id="ph2">`OR`</ph>) of <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">Para buscar constructores estáticos, utilice el <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> sobrecarga y pase la combinación (lógico <ph id="ph2">`OR`</ph>) de <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, tal y como se muestra en el ejemplo de código siguiente:</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Now the output is:</source>
          <target state="translated">Ahora, el resultado es:</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>True</source>
          <target state="translated">True</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca los constructores definidos para el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual, con las enumeraciones <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints, including the type initializer if it is defined.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> que representa todos los constructores definidos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual que coincidan con las restricciones de enlace especificadas, incluido el inicializador de tipo si está definido.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> if no constructors are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, if none of the defined constructors match the binding constraints, or if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated">Devuelve una matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> si no se definen constructores para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual, si ninguno de los constructores definidos cumple las restricciones de enlace o si el objeto <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un parámetro de tipo en la definición de un tipo genérico o de un método genérico.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> método no devuelve constructores en un orden determinado, como el orden de declaración.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los constructores, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`bindingAttr`</ph> can be used to specify whether to return only public constructors or both public and non-public constructors.</source>
          <target state="translated"><ph id="ph1">`bindingAttr`</ph> puede utilizarse para especificar si se deben devolver sólo los constructores públicos o constructores públicos y no públicos.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Si no existe una coincidencia exacta, la <ph id="ph1">`binder`</ph> intentará convertir los tipos de parámetro especificados en la <ph id="ph2">`types`</ph> matriz para seleccionar una coincidencia.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Si el <ph id="ph1">`binder`</ph> no puede seleccionar una coincidencia, a continuación, <ph id="ph2">`null`</ph> se devuelve.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro se pueden utilizar para definir los constructores que deben incluirse en la búsqueda:</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir constructores públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Constructors of base classes are not returned.</source>
          <target state="translated">Constructores de clases base no se devuelven.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Por ejemplo, si clase <ph id="ph1">`C&lt;T&gt;`</ph> tiene un constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> en Visual Basic), la llamada a <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> en <ph id="ph5">`C&lt;int&gt;`</ph> devuelve un <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> que representa <ph id="ph7">`C(int t1)`</ph> en C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo genérico, la <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> método devuelve una matriz vacía.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">Este ejemplo muestra el resultado de la <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> sobrecarga de una clase que tiene dos constructores de instancia y un constructor estático.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The output of this code is:</source>
          <target state="translated">El resultado de este código es:</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> solo usa la sobrecarga <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph> y <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>, el constructor estático no se calcula mediante la <ph id="ph4">`for`</ph> expresión ni se evalúa con <ph id="ph5">`IsStatic`</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload, and pass it the combination (logical OR) of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">Para buscar constructores estáticos, utilice el <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> sobrecarga y para pasar la combinación (OR lógico) de <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, tal y como se muestra en el ejemplo de código siguiente:</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Now the output is:</source>
          <target state="translated">Ahora, el resultado es:</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>True</source>
          <target state="translated">True</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>Searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> whose <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph> is set.</source>
          <target state="translated">Busca los miembros definidos para el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual cuya clase <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph> esté establecida.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all default members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa todos los miembros predeterminados del objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have default members.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual no tiene miembros predeterminados.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> método no devuelve los miembros en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los miembros, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a property <ph id="ph2">`P`</ph> that returns <ph id="ph3">`T`</ph>, calling <ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns <ph id="ph6">`int P`</ph> in C# (<ph id="ph7">`Property P As Integer`</ph> in Visual Basic).</source>
          <target state="translated">Por ejemplo, si clase <ph id="ph1">`C&lt;T&gt;`</ph> tiene una propiedad <ph id="ph2">`P`</ph> que devuelve <ph id="ph3">`T`</ph>, si se llama <ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> en <ph id="ph5">`C&lt;int&gt;`</ph> devuelve <ph id="ph6">`int P`</ph> en C# (<ph id="ph7">`Property P As Integer`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los miembros de la restricción de clase o los miembros de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following example obtains the default member information of <ph id="ph1">`MyClass`</ph> and displays the default members.</source>
          <target state="translated">En el ejemplo siguiente se obtiene información sobre el miembro predeterminado de <ph id="ph1">`MyClass`</ph> y muestra los miembros predeterminados.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or reference type.</source>
          <target state="translated">Cuando se invalida en una clase derivada, devuelve la clase <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> del objeto englobado o al que hace referencia la matriz, el puntero o el tipo de referencia actual.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer, or reference type, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> del objeto englobado o al que hace referencia la matriz, puntero o tipo de referencia actual; o bien, <ph id="ph2">&lt;see langword="null" /&gt;</ph> si el objeto <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> actual no es una matriz o un puntero, o si no se pasa por referencia, o si representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o de un método genérico.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>This method returns <ph id="ph1">`null`</ph> for the <ph id="ph2">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Este método devuelve <ph id="ph1">`null`</ph> para el <ph id="ph2">&lt;xref:System.Array&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>The following example demonstrates using the <ph id="ph1">`GetElementType`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">`GetElementType`</ph> método.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The value whose name is to be retrieved.</source>
          <target state="translated">Valor cuyo nombre se va a recuperar.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>Returns the name of the constant that has the specified value, for the current enumeration type.</source>
          <target state="translated">Devuelve el nombre de la constante que tiene el valor especificado para el tipo de enumeración actual.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The name of the member of the current enumeration type that has the specified value, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such constant is found.</source>
          <target state="translated">Nombre del miembro del tipo de enumeración actual que tiene el valor especificado o <ph id="ph1">&lt;see langword="null" /&gt;</ph> si no se encuentra tal constante.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">El tipo actual no es una enumeración.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is neither of the current type nor does it have the same underlying type as the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> no es ni de tipo actual ni tiene el mismo tipo subyacente que el tipo actual.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>Returns the names of the members of the current enumeration type.</source>
          <target state="translated">Devuelve los nombres de los miembros del tipo de enumeración actual.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>An array that contains the names of the members of the enumeration.</source>
          <target state="translated">Una matriz que contiene los nombres de los miembros de la enumeración.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</source>
          <target state="translated">Los elementos de la matriz de valores devueltos se ordenan por los valores binarios (es decir, los valores sin signo) de las constantes enumeradas.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</source>
          <target state="translated">Si la matriz contiene constantes enumeradas con el mismo valor, el orden de sus nombres correspondientes no está especificado.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>The current type is not an enumeration.</source>
          <target state="translated">El tipo actual no es una enumeración.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Returns the underlying type of the current enumeration type.</source>
          <target state="translated">Devuelve el tipo subyacente del tipo de enumeración actual.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The underlying type of the current enumeration.</source>
          <target state="translated">Tipo subyacente de la enumeración actual.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>By default, the underlying type of an enumeration in C# and Visual Basic is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">De forma predeterminada, el tipo subyacente de una enumeración en C# y Visual Basic es <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Other integer types can be specified.</source>
          <target state="translated">Se pueden especificar otros tipos enteros.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The current type is not an enumeration.</source>
          <target state="translated">El tipo actual no es una enumeración.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The enumeration type is not valid, because it contains more than one instance field.</source>
          <target state="translated">El tipo de enumeración no es válido, ya que contiene más de un campo de instancia.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>Returns an array of the values of the constants in the current enumeration type.</source>
          <target state="translated">Devuelve una matriz con los valores de las constantes en el tipo de enumeración actual.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>An array that contains the values.</source>
          <target state="translated">Matriz que contiene los valores.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</source>
          <target state="translated">Los elementos de la matriz se ordenan en función de los valores binarios (es decir, los valores sin firmar) de las constantes de enumeración.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The current type is not an enumeration.</source>
          <target state="translated">El tipo actual no es una enumeración.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific event declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene un evento específico declarado o heredado por el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The string containing the name of an event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Cadena que contiene el nombre de un evento que la clase <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual declaró o heredó.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified public event.</source>
          <target state="translated">Devuelve el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> que representa el evento público especificado.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The object representing the specified public event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el evento público especificado que declara o hereda el <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual, si se encuentra; de lo contrario es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Un evento se considera público para la reflexión si tiene al menos un método o descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, el evento se considera privado, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search includes public static and public instance events.</source>
          <target state="translated">La búsqueda incluye eventos de instancia público static y public.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los eventos de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> object and gets the event for a button class for the specified event.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> de objetos y obtiene los eventos para una clase de botón para el evento especificado.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of an event which is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Cadena que contiene el nombre de un evento que la clase <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual declara o hereda.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified event, using the specified binding constraints.</source>
          <target state="translated">Cuando se invalida en una clase derivada, devuelve el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> que representa el evento especificado y aplica las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The object representing the specified event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el evento especificado que declara o hereda el <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual, si se encuentra; de lo contrario, es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro se pueden utilizar para definir qué eventos se deben incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir eventos públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir eventos no públicos (es decir, eventos privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo los eventos declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los eventos que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Un evento se considera público para la reflexión si tiene al menos un método o descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, el evento se considera privado, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los eventos de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method to search a type for a public or non-public event named "Click" that is not <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">El siguiente ejemplo de código utiliza el <ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> método para buscar un tipo para un evento público o no público denominado "Haga clic en" que no sea <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene los eventos declarados o heredados por el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>Returns all the public events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Devuelve todos los eventos públicos declarados o heredados por el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events which are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> que representa todos los eventos públicos declarados o heredados por el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public events.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> si el objeto actual <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> no tiene eventos públicos.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Un evento se considera público para la reflexión si tiene al menos un método o descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, el evento se considera privado, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> método no devuelve eventos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los eventos, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los eventos de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">En el ejemplo siguiente se obtiene una matriz de <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> los objetos, obtiene todos los eventos de un <ph id="ph2">`Button`</ph> clase y muestra los nombres de evento.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">Para compilar el ejemplo de Visual Basic, use la siguiente línea de comandos:</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca los eventos declarados o heredados por el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual y aplica las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all events that are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> que representa todos los eventos declarados o heredados por el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual que cumplen las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have events, or if none of the events match the binding constraints.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual no tiene eventos o si ninguno de los eventos coincide con las restricciones de enlace.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> método no devuelve eventos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los eventos, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro se pueden utilizar para definir qué eventos se deben incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir eventos públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir eventos no públicos (es decir, eventos privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Only protected and internal events on base classes are returned; private events on base classes are not returned.</source>
          <target state="translated">Solo se devuelven los eventos internos en clases base; y protegidos no se devuelven los eventos privados de clases base.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo los eventos declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los eventos que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Un evento se considera público para la reflexión si tiene al menos un método o descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, el evento se considera privado, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los eventos de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects that match the specified binding flags, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">En el ejemplo siguiente se obtiene una matriz de <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objetos que coinciden con los marcadores de enlace especificado, obtiene todos los eventos de un <ph id="ph2">`Button`</ph> clase y muestra los nombres de evento.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">Para compilar el ejemplo de Visual Basic, use la siguiente línea de comandos:</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific field of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene un campo específico del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">Cadena que contiene el nombre del campo de datos que se va a obtener.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>Searches for the public field with the specified name.</source>
          <target state="translated">Busca el campo público con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>An object representing the public field with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el campo público con el nombre especificado, si se encuentra; en caso contrario, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search includes public static and public instance fields.</source>
          <target state="translated">La búsqueda incluye campos de instancia públicos static y public.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los campos de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field, and displays the value of the field.</source>
          <target state="translated">En el ejemplo siguiente se obtiene la <ph id="ph1">`Type`</ph> de objeto para la clase especificada, se obtiene la <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objeto para el campo y muestra el valor del campo.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>This <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> whose <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has not yet been called.</source>
          <target state="translated">Este objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> es <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> a cuyo método <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> aún no se ha llamado.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">Cadena que contiene el nombre del campo de datos que se va a obtener.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified field, using the specified binding constraints.</source>
          <target state="translated">Busca el campo especificado mediante las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the field that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el campo que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro se pueden utilizar para definir qué campos desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir campos públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir campos no públicos (es decir, los campos privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo los campos declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los campos que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los campos de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field that matches the specified binding flags, and displays the value of the field.</source>
          <target state="translated">En el ejemplo siguiente se obtiene la <ph id="ph1">`Type`</ph> de objeto para la clase especificada, se obtiene la <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objeto para el campo que coincide con las marcas de enlace especificadas y muestra el valor del campo.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene los campos del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>Returns all the public fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Devuelve todos los campos públicos del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all the public fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa todos los campos públicos definidos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no public fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> si no hay campos públicos definidos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> método no devuelve campos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los campos, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los campos públicos de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following example shows a use of the <ph id="ph1">`GetFields()`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`GetFields()`</ph> método.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the fields defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca los campos definidos para el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual y aplica las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa todos los campos definidos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual que coincidan con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined fields match the binding constraints.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> si no se han definido campos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual o si ninguno de los campos definidos coincide con las restricciones de enlace.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> método no devuelve campos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los campos, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro se pueden utilizar para definir qué campos desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir campos públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir campos no públicos (es decir, los campos privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</source>
          <target state="translated">Solo se devuelven los campos internos en clases base; y protegidos no se devuelven los campos privados de clases base.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo los campos declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los campos que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los campos públicos de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following example shows a use of the <ph id="ph1">`GetFields(BindingFlags)`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`GetFields(BindingFlags)`</ph> método.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic type.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo de un tipo genérico.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an empty array if the current type is not a generic type.</source>
          <target state="translated">Devuelve una matriz vacía si el tipo actual no es un tipo genérico.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</source>
          <target state="translated">Los elementos de matriz se devuelven en el orden en que aparecen en la lista de argumentos de tipo para el tipo genérico.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a closed constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic type definition.</source>
          <target state="translated">Si el tipo actual es un tipo construido cerrado (es decir, el <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad devuelve <ph id="ph2">`false`</ph>), la matriz devuelta por la <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> método contiene los tipos que se han asignado a los parámetros de tipo genérico de la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a generic type definition, the array contains the type parameters.</source>
          <target state="translated">Si el tipo actual es una definición de tipo genérico, la matriz contiene los parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is an open constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</source>
          <target state="translated">Si el tipo actual es un tipo construido abierto (es decir, el <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph>) en los tipos específicos no se han asignado a todos los parámetros de tipo y parámetros de tipo envolvente métodos ni tipos genéricos, la matriz contiene tanto tipos como tipo de parámetros.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad para distinguirlos.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Para ver una demostración de este escenario, vea el ejemplo de código para el <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</source>
          <target state="translated">El siguiente ejemplo de código utiliza el <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> método para mostrar los argumentos de tipo de un tipo construido y los parámetros de tipo de su definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>See the larger example for sample output.</source>
          <target state="translated">Vea el ejemplo más extenso para la salida de ejemplo.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">El método invocado no se admite en la clase base.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Las clases derivadas deben proporcionar una implementación.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan las restricciones en el parámetro de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan las restricciones en el parámetro de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Each constraint on a generic type parameter is expressed as a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Cada restricción en un parámetro de tipo genérico se expresa como un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph> property to determine whether a constraint is the base class constraint; if the property returns <ph id="ph2">`false`</ph>, the constraint is an interface constraint.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph> propiedad para determinar si una restricción es la restricción de clase base; si la propiedad devuelve <ph id="ph2">`false`</ph>, la restricción es una restricción de interfaz.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>If a type parameter has no class constraint and no interface constraints, an empty array is returned.</source>
          <target state="translated">Si un parámetro de tipo tiene ninguna restricción de clase y no hay restricciones de interfaz, se devuelve una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">En el ejemplo de código siguiente se define un tipo genérico <ph id="ph1">`Test`</ph> con dos parámetros de tipo que tienen restricciones distintas.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">Cuando se ejecuta el programa, se examinan las restricciones mediante la <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> propiedad y el <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual no es un parámetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es decir, la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current generic type can be constructed.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una definición de tipo genérico a partir de la cual se puede construir el tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type from which the current type can be constructed.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa un tipo genérico a partir del cual se puede construir el tipo actual.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">Una definición de tipo genérico es una plantilla desde la que se pueden construir otros tipos.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Por ejemplo, desde la definición de tipo genérico <ph id="ph1">`G&lt;T&gt;`</ph> (expresado en sintaxis de C#; <ph id="ph2">`G(Of T)`</ph> en Visual Basic o <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> en C++) puede construir y crear instancias del tipo <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the generic type definition.</source>
          <target state="translated">Dado un <ph id="ph1">&lt;xref:System.Type&gt;</ph> construido de objeto que representa este tipo, el <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> método devuelve la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If two constructed types are created from the same generic type definition, using the same type arguments, the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for both types.</source>
          <target state="translated">Si dos tipos construidos se crean a partir de la misma definición de tipo genérico, usando los mismos argumentos de tipo, el <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> método devuelve el mismo <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto para ambos tipos.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that already represents a generic type definition, it returns the current <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Si se llama a la <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> método en un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que ya representa una definición de tipo genérico, devuelve el valor actual <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>An array of generic types is not itself generic.</source>
          <target state="translated">Una matriz de tipos genéricos no es genérico en sí mismo.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>In the C# code <ph id="ph1">`A&lt;int&gt;[] v;`</ph> or the Visual Basic code <ph id="ph2">`Dim v() As A(Of Integer)`</ph>, the type of variable <ph id="ph3">`v`</ph> is not generic.</source>
          <target state="translated">En el código de C# <ph id="ph1">`A&lt;int&gt;[] v;`</ph> o el código de Visual Basic <ph id="ph2">`Dim v() As A(Of Integer)`</ph>, el tipo de variable <ph id="ph3">`v`</ph> no es genérico.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Use <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> to determine whether a type is generic before calling <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> para determinar si un tipo es genérico antes de llamar a <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> methods to retrieve the constructed type and the generic type definition.</source>
          <target state="translated">En el ejemplo de código siguiente se crea una instancia de un tipo construido mediante la creación de instancias normal y, a continuación, usa el <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> métodos para recuperar el tipo construido y la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>This example uses the generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type; the constructed type represents a <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph3">`Test`</ph> objects with string keys.</source>
          <target state="translated">Este ejemplo utiliza la interfaz genérica <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> tipo; el tipo construido representa un <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> de <ph id="ph3">`Test`</ph> objetos con claves de cadena.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The current type is not a generic type.</source>
          <target state="translated">El tipo actual no es un tipo genérico.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es decir, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">El método invocado no se admite en la clase base.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Las clases derivadas deben proporcionar una implementación.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Devuelve el código hash de esta instancia.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>The hash code for this instance.</source>
          <target state="translated">Código hash de esta instancia.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>The following example displays the hash code of the <ph id="ph1">`System.Windows.Forms.Button`</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se muestra el código hash de la <ph id="ph1">`System.Windows.Forms.Button`</ph> clase.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific interface implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene una interfaz específica implementada o heredada por el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">Cadena que contiene el nombre de la interfaz que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">Para las interfaces genéricas, este es el nombre con sufijo.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>Searches for the interface with the specified name.</source>
          <target state="translated">Busca la interfaz con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la interfaz con el nombre especificado, implementada o heredada por el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual, si se encuentra; de lo contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Type&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca las restricciones de interfaz y las interfaces heredadas de restricciones de clase o interfaz.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">Para las interfaces genéricas, el <ph id="ph1">`name`</ph> parámetro es el nombre con sufijo y termina con un acento grave (<ph id="ph2">\`</ph>) y el número de parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">Esto es cierto para las definiciones de interfaz genérica e interfaces genéricas construidas.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">``"IExample`1"``</ph>.</source>
          <target state="translated">Por ejemplo, para buscar <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> en Visual Basic) o <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> en Visual Basic), busque <ph id="ph5">``"IExample`1"``</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method to search the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph> interface, and lists the methods of the interface.</source>
          <target state="translated">El siguiente ejemplo de código utiliza el <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> método para buscar el <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> de clases para el <ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph> interfaz y listas de los métodos de la interfaz.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">El ejemplo de código también muestra la <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> sobrecarga del método y el <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un tipo que implementa la misma interfaz genérica con argumentos de tipo distintos.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">Cadena que contiene el nombre de la interfaz que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">Para las interfaces genéricas, este es el nombre con sufijo.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of that part of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para omitir la grafía de la parte de <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> que especifica el nombre de interfaz simple (se debe respetar la grafía de la parte que especifica el espacio de nombres).</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for all parts of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> para realizar una búsqueda de todas las partes de <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> que distinga mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca la interfaz especificada e indica si la búsqueda no debe distinguir entre mayúsculas y minúsculas para el nombre de la interfaz.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la interfaz con el nombre especificado, implementada o heredada por el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual, si se encuentra; de lo contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The <ph id="ph1">`ignoreCase`</ph> parameter applies only to the simple interface name, not to the namespace.</source>
          <target state="translated">El <ph id="ph1">`ignoreCase`</ph> parámetro solo se aplica a nombre de interfaz simple, no al espacio de nombres.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The portion of <ph id="ph1">`name`</ph> that specifies the namespace must have the correct case, or the interface will not be found.</source>
          <target state="translated">La parte de <ph id="ph1">`name`</ph> que especifica el espacio de nombres debe tener la grafía correcta o no se encuentre la interfaz.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, the string "System.icomparable" finds the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface, but the string "system.icomparable" does not.</source>
          <target state="translated">Por ejemplo, la cadena "System.icomparable" encuentra el <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interfaz, pero la cadena "system.icomparable" no es así.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Type&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca las restricciones de interfaz y las interfaces heredadas de restricciones de clase o interfaz.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">Para las interfaces genéricas, el <ph id="ph1">`name`</ph> parámetro es el nombre con sufijo y termina con un acento grave (<ph id="ph2">\`</ph>) y el número de parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">Esto es cierto para las definiciones de interfaz genérica e interfaces genéricas construidas.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">`"IExample`</ph>1"`.</source>
          <target state="translated">Por ejemplo, para buscar <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> en Visual Basic) o <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> en Visual Basic), busque <ph id="ph5">`"IExample`</ph>1"'.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method to perform a case-insensitive search of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
          <target state="translated">El siguiente ejemplo de código utiliza el <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> método para realizar una búsqueda entre mayúsculas y minúsculas de la <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> de clases para el <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">El ejemplo de código también muestra la <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> sobrecarga del método y el <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un tipo que implementa la misma interfaz genérica con argumentos de tipo distintos.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface type to retrieve a mapping for.</source>
          <target state="translated">Tipo de interfaz para el que recuperar una asignación.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the specified interface type.</source>
          <target state="translated">Devuelve una asignación de interfaz para el tipo de interfaz especificado.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>An object that represents the interface mapping for <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la asignación de interfaz para <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</source>
          <target state="translated">El mapa de interfaz indica cómo se asigna una interfaz a los miembros reales en una clase que implementa esa interfaz.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> returned by this method.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, tipo de parámetros se sustituyen por los argumentos de tipo adecuado en los elementos de la <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> devuelto por este método.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method to determine how the <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interface maps to <ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph> methods, and how the <ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph> interface maps to <ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph> properties.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> método para determinar cómo el <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interfaz se asigna a <ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph> métodos y cómo el <ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph> interfaz se asigna a <ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Note that, because the <ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph> interface defines a set of properties, the returned <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> object includes separate <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects for a property's get and set accessors.</source>
          <target state="translated">Tenga en cuenta que, dado el <ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph> interfaz define un conjunto de propiedades, el valor devuelto <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> objeto incluye independiente <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objetos para los descriptores de acceso de set y get de una propiedad.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is not implemented by the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> no está implementado por el tipo actual.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> parameter does not refer to an interface.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> no hace referencia a una interfaz.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is a generic interface, and the current type is an array type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> es una interfaz genérica y el tipo actual es un tipo de matriz.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter; that is, <ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un parámetro de tipo genérico; es decir, <ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> es <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">El método invocado no se admite en la clase base.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Las clases derivadas deben proporcionar una implementación.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene todas las interfaces implementadas o heredadas por el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa todas las interfaces implementadas o heredadas por el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no interfaces are implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en caso de que el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual no implemente ni herede ninguna interfaz.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> method does not return interfaces in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> método no devuelve interfaces en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>Your code must not depend on the order in which interfaces are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven interfaces, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Type&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca las restricciones de interfaz y las interfaces heredadas de restricciones de clase o interfaz.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</source>
          <target state="translated">En el ejemplo siguiente se obtiene el tipo de la clase especificada y muestra todas las interfaces que el tipo implementa o hereda.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>To compile the Visual Basic example, use the following compiler commands:</source>
          <target state="translated">Para compilar el ejemplo de Visual Basic, use los siguientes comandos del compilador:</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador estático y produce una excepción.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the specified members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene los miembros especificados del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>The string containing the name of the public members to get.</source>
          <target state="translated">Cadena que contiene el nombre de los miembros públicos que se van a obtener.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>Searches for the public members with the specified name.</source>
          <target state="translated">Busca los miembros públicos con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa los miembros públicos con el nombre especificado, si se encuentran; de lo contrario, una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search includes public static and public instance members.</source>
          <target state="translated">La búsqueda incluye a miembros de instancia públicos static y public.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> método no devuelve los miembros en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los miembros, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This method overload will not find class initializers (.cctor).</source>
          <target state="translated">Esta sobrecarga del método no encontrará a inicializadores de clase (.cctor).</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Para buscar inicializadores de clase, use una sobrecarga que toma <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>y especifique <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los miembros de la restricción de clase o los miembros de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Para métodos genéricos, no incluya los argumentos de tipo en <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por ejemplo, el código de C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> busca un miembro con el nombre de texto "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", en lugar de para un método denominado <ph id="ph3">`MyMethod`</ph> que tiene un argumento genérico de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following example displays all the members of the <ph id="ph1">`String`</ph> class that start with the letter C.</source>
          <target state="translated">En el ejemplo siguiente se muestra todos los miembros de la <ph id="ph1">`String`</ph> clase que empiezan por la letra C.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">Cadena que contiene el nombre de los miembros que se van a obtener.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">Cero, para que se devuelva una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified members, using the specified binding constraints.</source>
          <target state="translated">Busca los miembros especificados mediante las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa los miembros públicos con el nombre especificado, si se encuentran; de lo contrario, una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> método no devuelve los miembros en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los miembros, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los miembros que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir miembros públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar solo los miembros declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los miembros que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph7">`bindingAttr`</ph>.</source>
          <target state="translated">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar ".cctor" para <ph id="ph1">`name`</ph>, y <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic) para <ph id="ph7">`bindingAttr`</ph>.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los miembros de la restricción de clase o los miembros de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Para métodos genéricos, no incluya los argumentos de tipo en <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por ejemplo, el código de C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> busca un miembro con el nombre de texto "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", en lugar de para un método denominado <ph id="ph3">`MyMethod`</ph> que tiene un argumento genérico de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following example displays all the public static members of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">El ejemplo siguiente muestra todos los miembros estáticos públicos de la <ph id="ph1">`myString`</ph> clase que empiezan por la letra C.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">Cadena que contiene el nombre de los miembros que se van a obtener.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The value to search for.</source>
          <target state="translated">Valor que se va a buscar.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">Cero, para que se devuelva una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Searches for the specified members of the specified member type, using the specified binding constraints.</source>
          <target state="translated">Busca los miembros especificados que sean del tipo de miembro especificado mediante las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa los miembros públicos con el nombre especificado, si se encuentran; de lo contrario, una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> método no devuelve los miembros en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los miembros, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los miembros que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir miembros públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar solo los miembros declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los miembros que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph> for <ph id="ph3">`type`</ph>, and  <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph7">`Or`</ph><ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph9">`bindingAttr`</ph>.</source>
          <target state="translated">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar ".cctor" para <ph id="ph1">`name`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph> para <ph id="ph3">`type`</ph>, y <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph7">`Or`</ph> <ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic) para <ph id="ph9">`bindingAttr`</ph>.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los miembros de la restricción de clase o los miembros de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Para métodos genéricos, no incluya los argumentos de tipo en <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por ejemplo, el código de C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> busca un miembro con el nombre de texto "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", en lugar de para un método denominado <ph id="ph3">`MyMethod`</ph> que tiene un argumento genérico de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following example displays all the methods of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">El ejemplo siguiente muestra todos los métodos de la <ph id="ph1">`myString`</ph> clase que empiezan por la letra C.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A derived class must provide an implementation.</source>
          <target state="translated">La clase derivada debe proporcionar una implementación.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the members (properties, methods, fields, events, and so on) of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene los miembros (propiedades, métodos, campos, eventos, etc.) del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>Returns all the public members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Devuelve todos los miembros públicos del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all the public members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa todos los miembros públicos del objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public members.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual no tiene miembros públicos.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> método no devuelve los miembros en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los miembros, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph6">`Or`</ph><ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph8">`Or`</ph><ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Esta sobrecarga de método llama a la <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> sobrecarga del método, con <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph6">`Or`</ph> <ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph8">`Or`</ph> <ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">No encontrará a inicializadores de clase (.cctor).</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Para buscar inicializadores de clase, use una sobrecarga que toma <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>y especifique <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los miembros de la restricción de clase o los miembros de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph> method overload to collect information about all public members of a specified class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph> sobrecarga del método para recopilar información sobre todos los miembros públicos de una clase especificada.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Zero (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>), to return an empty array.</source>
          <target state="translated">Cero (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>), para que se devuelva una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca los miembros definidos para el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual y aplica las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all members defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa todos los miembros definidos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual que coincidan con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if no members are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined members match the binding constraints.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> si no se han definido miembros para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual o si ninguno de los miembros definidos coincide con las restricciones de enlace.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> método no devuelve los miembros en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los miembros, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los miembros que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir miembros públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Only protected and internal members on base classes are returned; private members on base classes are not returned.</source>
          <target state="translated">Solo se devuelven los miembros internos de las clases base; y protegidos no se devuelven los miembros privados de clases base.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar solo los miembros declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los miembros que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">`Public`</ph> flag or only the <ph id="ph2">`NonPublic`</ph> flag will return the specified members and does not require any other flags.</source>
          <target state="translated">Llamar a este método solamente con el <ph id="ph1">`Public`</ph> marca o solo la <ph id="ph2">`NonPublic`</ph> marca devolverá los miembros especificados y no se necesitarán otros indicadores.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">También puede obtener el inicializador de clase utilizando la <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si t: System. Type actual representa un tipo genérico construido, este método devuelve el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los miembros de la restricción de clase o los miembros de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload to collect information about all public instance members of a specified class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> sobrecarga del método para recopilar información sobre todos los miembros de instancia público de una clase especificada.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific method of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene un método específico del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">Cadena que contiene el nombre del método público que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>Searches for the public method with the specified name.</source>
          <target state="translated">Busca el método público con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>An object that represents the public method with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa al método público con el nombre especificado, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">La búsqueda incluye métodos de instancia público static y public.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If a method is overloaded and has more than one public method, the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">Si un método está sobrecargado y tiene más de un método público, el <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> método produce una <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>In the following example, an exception is thrown because there is more than one public overload of the <ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente, se produce una excepción porque no hay más de una sobrecarga pública de la <ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>On the other hand, because the <ph id="ph1">`Person.ToString`</ph> method overrides  <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> and therefore is not overloaded, the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method is able to retrieve the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Por otro lado, dado que la <ph id="ph1">`Person.ToString`</ph> reemplazos de método <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> y, por tanto, no está sobrecargado, la <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> método es capaz de recuperar el <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">Puede realizar una de las acciones siguientes para recuperar un método específico:</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method and specify a <ph id="ph2">`bindingAttr`</ph> argument that uniquely identifies the method.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> método y especifique un <ph id="ph2">`bindingAttr`</ph> argumento que identifica de forma única el método.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  <ph id="ph1">`bindingAttr`</ph> argument  of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph3">`Or`</ph><ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Por ejemplo, si la excepción se produce porque un tipo tiene una variable static y una sobrecarga de la instancia, puede especificar un <ph id="ph1">`bindingAttr`</ph> argumento de <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph3">`Or`</ph> <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">Llamar a una sobrecarga de la <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> método que incluye un <ph id="ph2">`types`</ph> parámetro que define los tipos de los parámetros del método.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph> method to retrieve an array containing all of the public methods belonging to a type.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph> método para recuperar una matriz que contiene todos los métodos públicos que pertenecen a un tipo.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">A continuación, puede iterar para identificar los métodos duplicados con el nombre <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si t: System. Type actual representa un tipo genérico construido, este método devuelve el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los métodos de la restricción de clase o los métodos de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Para métodos genéricos, no incluya los argumentos de tipo en <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por ejemplo, el código de C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> busca un miembro con el nombre de texto "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", en lugar de para un método denominado <ph id="ph3">`MyMethod`</ph> que tiene un argumento genérico de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The following example gets a method named <ph id="ph1">`MethodA`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se obtiene un método denominado <ph id="ph1">`MethodA`</ph>.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>More than one method is found with the specified name.</source>
          <target state="translated">Se encontró más de un método con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Cadena que contiene el nombre del método que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified method, using the specified binding constraints.</source>
          <target state="translated">Busca el método especificado mediante las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los métodos que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public methods in the search.</source>
          <target state="translated">Especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> para incluir métodos públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> para buscar sólo los métodos declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los métodos que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If a method is overloaded and more than one overload meets the constraints specified by the <ph id="ph1">`bindingAttr`</ph> argument, the method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">Si un método está sobrecargado y más de una sobrecarga cumple las restricciones especificadas por el <ph id="ph1">`bindingAttr`</ph> argumento, el método produce una <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the following example, an exception is thrown because:</source>
          <target state="translated">En el ejemplo siguiente, se produce una excepción porque:</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`DisplayValue`</ph> method, <ph id="ph3">`DisplayValue(String)`</ph> and <ph id="ph4">`DisplayValue(String, Object[])`</ph>.</source>
          <target state="translated">El <ph id="ph1">`TestClass`</ph> tipo tiene dos sobrecargas de instancia público de la <ph id="ph2">`DisplayValue`</ph> método <ph id="ph3">`DisplayValue(String)`</ph> y <ph id="ph4">`DisplayValue(String, Object[])`</ph>.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`Equals`</ph> method,  one of which is inherited from <ph id="ph3">&lt;xref:System.Object&gt;</ph>: <ph id="ph4">`Equals(TestClass)`</ph> and <ph id="ph5">`Equals(Object)`</ph>.</source>
          <target state="translated">El <ph id="ph1">`TestClass`</ph> tipo tiene dos sobrecargas de instancia público de la <ph id="ph2">`Equals`</ph> método, uno de los cuales se hereda de <ph id="ph3">&lt;xref:System.Object&gt;</ph>: <ph id="ph4">`Equals(TestClass)`</ph> y <ph id="ph5">`Equals(Object)`</ph>.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">Puede realizar una de las acciones siguientes para recuperar un método específico:</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Change the binding constraints.</source>
          <target state="translated">Cambie las restricciones de enlace.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the previous example, attempting to retrieve a public instance <ph id="ph1">`Equals`</ph> method that is declared by the type and not inherited successfully retrieves <ph id="ph2">`Equals(TestClass)`</ph>.</source>
          <target state="translated">En el ejemplo anterior, intenta recuperar una instancia pública <ph id="ph1">`Equals`</ph> recupera el método que se declara el tipo y no hereda correctamente <ph id="ph2">`Equals(TestClass)`</ph>.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">Llamar a una sobrecarga de la <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> método que incluye un <ph id="ph2">`types`</ph> parámetro que define los tipos de los parámetros del método.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> método para recuperar una matriz que contiene todos los métodos que pertenecen a un tipo que tienen los atributos de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">A continuación, puede iterar para identificar los métodos duplicados con el nombre <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>This approach is illustrated in the previous example's handler for the <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">Este enfoque se muestra en el controlador del ejemplo anterior para el <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los métodos de la restricción de clase o los métodos de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Para métodos genéricos, no incluya los argumentos de tipo en <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por ejemplo, el código de C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> busca un miembro con el nombre de texto "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", en lugar de para un método denominado <ph id="ph3">`MyMethod`</ph> que tiene un argumento genérico de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the method that matches the specified binding flags.</source>
          <target state="translated">En el ejemplo siguiente se obtiene el método que coincide con los marcadores de enlace especificados.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">Cadena que contiene el nombre del método público que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Una matriz vacía de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (proporcionados por el campo <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>) para obtener un método que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Searches for the specified public method whose parameters match the specified argument types.</source>
          <target state="translated">Busca el método público especificado cuyos parámetros coincidan con los tipos de argumentos especificados.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An object representing the public method whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el método público cuyos parámetros coinciden con los tipos de argumentos especificados, si se encuentra; en caso contrario, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">La búsqueda incluye métodos de instancia público static y public.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">No se puede omitir los parámetros al buscar constructores y métodos.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Solo puede omitir los parámetros al invocar.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los métodos de la restricción de clase o los métodos de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">`name`</ph> parameter cannot include type arguments.</source>
          <target state="translated">El <ph id="ph1">`name`</ph> parámetro no puede incluir argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph> searches for a method with the text name "<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyGenericMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por ejemplo, el código de C# <ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph> busca un método con el nombre de texto "<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>", en lugar de para un método denominado <ph id="ph3">`MyGenericMethod`</ph> que tiene un argumento genérico de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyGenericMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">En su lugar, use <ph id="ph1">`GetMethod("MyGenericMethod")`</ph> con el parámetro apropiado en el <ph id="ph2">`types`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying a variety of argument types.</source>
          <target state="translated">En el ejemplo siguiente se busca sobrecargas concretas de <ph id="ph1">`MethodA`</ph>, especificar una serie de tipos de argumentos.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated">El <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> en el ejemplo se requiere el <ph id="ph2">`/unsafe`</ph> opción del compilador.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example retrieves <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects that represent the <ph id="ph2">`Add`</ph> methods  of a non-generic type (the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> class), an open generic type (the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class), and a closed generic type (the <ph id="ph5">`List(Of String)`</ph> type.</source>
          <target state="translated">En el ejemplo siguiente se recuperan <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objetos que representan el <ph id="ph2">`Add`</ph> métodos de un tipo no genérico (la <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> clase), un tipo genérico abierto (la <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase) y un tipo genérico cerrado (el <ph id="ph5">`List(Of String)`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The example defines a <ph id="ph1">`GetAddMethod`</ph> method that retrieves the appropriate <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">El ejemplo define un <ph id="ph1">`GetAddMethod`</ph> método que recupera la correspondiente <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for an open generic type, it calls the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para proporcionar la <ph id="ph1">`types`</ph> argumento para un tipo genérico abierto, llama el <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for a closed generic type, it retrieves the value of the <ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para proporcionar la <ph id="ph1">`types`</ph> argumento para un tipo genérico, se recupera el valor de la <ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">Se encuentra más de un método con el nombre y los parámetros especificados.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno de los elementos de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">Cadena que contiene el nombre del método público que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Una matriz vacía de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (proporcionados por el campo <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>) para obtener un método que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">Solo se ha de usar cuando se llama mediante la interoperabilidad COM y solo se controlan parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public method whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">Busca el método público especificado cuyos parámetros coincidan con los tipos y modificadores de argumento especificados.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el método público que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (la <ph id="ph2">`modifiers`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">La búsqueda incluye métodos de instancia público static y public.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">No se puede omitir los parámetros al buscar constructores y métodos.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Solo puede omitir los parámetros al invocar.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si t: System. Type actual representa un tipo genérico construido, este método devuelve el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los métodos de la restricción de clase o los métodos de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Para métodos genéricos, no incluya los argumentos de tipo en <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por ejemplo, el código de C# <ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph> busca un miembro con el nombre de texto "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", en lugar de para un método denominado <ph id="ph3">`MyMethod`</ph> que tiene un argumento genérico de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">En su lugar, use <ph id="ph1">`GetMethod("MyMethod")`</ph> con el parámetro apropiado en el <ph id="ph2">`types`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">Se encuentra más de un método con el nombre y los parámetros especificados.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno de los elementos de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Cadena que contiene el nombre del método que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Una matriz vacía de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (proporcionados por el campo <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>) para obtener un método que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">Solo se ha de usar cuando se llama mediante la interoperabilidad COM y solo se controlan parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Busca el método especificado cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, mediante las restricciones de enlace indicadas.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (la <ph id="ph2">`modifiers`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los métodos que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir métodos públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo los métodos declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los métodos que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">No se puede omitir los parámetros al buscar constructores y métodos.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Solo puede omitir los parámetros al invocar.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si t: System. Type actual representa un tipo genérico construido, este método devuelve el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los métodos de la restricción de clase o los métodos de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Para métodos genéricos, no incluya los argumentos de tipo en <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por ejemplo, el código de C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> busca un miembro con el nombre de texto "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", en lugar de para un método denominado <ph id="ph3">`MyMethod`</ph> que tiene un argumento genérico de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints and a variety of argument types.</source>
          <target state="translated">En el ejemplo siguiente se busca sobrecargas concretas de <ph id="ph1">`MethodA`</ph>, especificar las restricciones de enlace y una gran variedad de tipos de argumentos.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated">El <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> en el ejemplo se requiere el <ph id="ph2">`/unsafe`</ph> opción del compilador.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno de los elementos de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Cadena que contiene el nombre del método que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</source>
          <target state="translated">Objeto que especifica el conjunto de reglas que van a usarse en cuanto al orden y diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y la forma en que se limpia la pila.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Una matriz vacía de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (proporcionados por el campo <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>) para obtener un método que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">Solo se ha de usar cuando se llama mediante la interoperabilidad COM y solo se controlan parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Busca el método especificado cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, usando las restricciones de enlace indicadas y la convención de llamada especificada.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (la <ph id="ph2">`modifiers`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`GetXXX`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`GetXXX`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los métodos que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir métodos públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo los métodos declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los métodos que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">No se puede omitir los parámetros al buscar constructores y métodos.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Solo puede omitir los parámetros al invocar.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si t: System. Type actual representa un tipo genérico construido, este método devuelve el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los métodos de la restricción de clase o los métodos de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Para métodos genéricos, no incluya los argumentos de tipo en <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por ejemplo, el código de C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> busca un miembro con el nombre de texto "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", en lugar de para un método denominado <ph id="ph3">`MyMethod`</ph> que tiene un argumento genérico de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints, calling conventions, and a variety of argument types.</source>
          <target state="translated">En el ejemplo siguiente se busca sobrecargas concretas de <ph id="ph1">`MethodA`</ph>, especificar las restricciones de enlace, convenciones de llamada y una variedad de tipos de argumentos.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated">El <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> en el ejemplo se requiere el <ph id="ph2">`/unsafe`</ph> opción del compilador.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno de los elementos de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Cadena que contiene el nombre del método que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</source>
          <target state="translated">Objeto que especifica el conjunto de reglas que se va a usar en cuanto al orden y diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y el proceso encargado de limpiar la pila.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</source>
          <target state="translated">Matriz vacía del tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (es decir, Type[] types = new Type[0]) para obtener un método que no requiera parámetros.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, arguments are not matched.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, no habrá coincidencias con los argumentos.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca el método especificado cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados y aplica las restricciones de enlace especificadas y la convención de llamada especificada.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (la <ph id="ph2">`modifiers`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <ph id="ph1">`types`</ph> is <ph id="ph2">`null`</ph>, arguments are not matched.</source>
          <target state="translated">Si <ph id="ph1">`types`</ph> es <ph id="ph2">`null`</ph>, no habrá coincidencias con los argumentos.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los métodos que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir métodos públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo los métodos declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los métodos que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> y <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> no tienen la misma longitud.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">El tipo actual es un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> o <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene los métodos del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>Returns all the public methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Devuelve todos los métodos públicos del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all the public methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa todos los métodos públicos definidos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no public methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> si no hay métodos públicos definidos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> método no devuelve métodos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los métodos, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructors are not included in the array of methods returned by this call.</source>
          <target state="translated">Los constructores no se incluyen en la matriz de métodos devuelta por esta llamada.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Make a separate call to <ph id="ph1">`GetConstructors()`</ph> to get the constructor methods.</source>
          <target state="translated">Realizar una llamada independiente a <ph id="ph1">`GetConstructors()`</ph> para obtener los métodos de constructor.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">No se puede omitir los parámetros al buscar constructores y métodos.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Solo puede omitir los parámetros al invocar.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si t: System. Type actual representa un tipo genérico construido, este método devuelve el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los métodos de la restricción de clase o los métodos de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the methods defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca los métodos definidos para el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual y aplica las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa todos los métodos definidos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual que coincidan con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined methods match the binding constraints.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> si no se han definido métodos para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual o si ninguno de los métodos definidos coincide con las restricciones de enlace.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> método no devuelve métodos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los métodos, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los métodos que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir métodos públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</source>
          <target state="translated">Solo protegido y se devuelven los métodos internos de las clases base; no se devuelven los métodos privados de clases base.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo los métodos declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los métodos que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">No se puede omitir los parámetros al buscar constructores y métodos.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Solo puede omitir los parámetros al invocar.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si t: System. Type actual representa un tipo genérico construido, este método devuelve el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método busca los métodos de la restricción de clase o los métodos de <ph id="ph2">&lt;xref:System.Object&gt;</ph> si no hay ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following example creates a class with two public methods and one protected method, creates a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyTypeClass`</ph>, gets all public and non-public methods, and displays their names.</source>
          <target state="translated">En el ejemplo siguiente se crea una clase con dos métodos públicos y un método protegido, se crea un <ph id="ph1">`Type`</ph> objeto corresponde a <ph id="ph2">`MyTypeClass`</ph>, obtiene todos los métodos públicos y no públicos y se muestran sus nombres.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific type nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene un tipo específico anidado dentro del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">Cadena que contiene el nombre del tipo anidado que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>Searches for the public nested type with the specified name.</source>
          <target state="translated">Busca el tipo anidado público con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>An object representing the public nested type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el tipo anidado público con el nombre especificado, si se encuentra; en caso contrario, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Utilice el nombre sencillo de la clase anidada para <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">No calificar con el nombre de la clase externa.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</source>
          <target state="translated">Para una clase anidada genérica, utilice el nombre alterado, es decir, agregue un acento grave y el número de argumentos genéricos.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Por ejemplo, utilizar la cadena "interna<ph id="ph1">\`</ph>1" obtener la interfaz genérica de clase anidada <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">No incluya sintaxis específica del lenguaje para los parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los tipos anidados de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Esto ocurre incluso si el tipo genérico envolvente es un tipo construido cerrado.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son genéricos todos los incluso si no tienen ningún parámetro genérico por sí mismos.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Esto no es necesariamente así de los tipos anidados definidos en ensamblados dinámicos o compilados con la <bpt id="p1">[</bpt>Ilasm.exe (ensamblador de IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información sobre los tipos genéricos anidados y sobre la creación de tipos genéricos anidados de sus definiciones de tipo genérico, vea <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">Cadena que contiene el nombre del tipo anidado que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca el tipo anidado especificado y aplica las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa el tipo anidado que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Utilice el nombre sencillo de la clase anidada para <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">No calificar con el nombre de la clase externa.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</source>
          <target state="translated">Para una clase anidada genérica, utilice el nombre alterado, es decir, agregue un acento grave y el número de parámetros genéricos.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Por ejemplo, utilizar la cadena "interna<ph id="ph1">\`</ph>1" obtener la interfaz genérica de clase anidada <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">No incluya sintaxis específica del lenguaje para los parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filtro indicadores pueden utilizarse para definir que anidar tipos debe para incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> para obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">Especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> para incluir los tipos anidados públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> para incluir los tipos anidados no públicos (es decir, privados, internos y protegidos tipos anidados) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">Este método devuelve solo los tipos anidados del tipo actual.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">No busca en las clases base del tipo actual.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> at each level.</source>
          <target state="translated">Para buscar tipos que están anidados en clases base, debe recorrer la jerarquía de herencia, una llamada a <ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> en cada nivel.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> se pasan por alto.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">Llamar a este método solamente con el <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> marca o solo la <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> marca devolverá tipos anidados especificados y no necesitarán otros indicadores.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los tipos anidados de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Esto ocurre incluso si el tipo genérico envolvente es un tipo construido cerrado.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son genéricos todos los incluso si no tienen ningún parámetro genérico por sí mismos.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Esto no es necesariamente así de los tipos anidados definidos en ensamblados dinámicos o compilados con la <bpt id="p1">[</bpt>Ilasm.exe (ensamblador de IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información sobre los tipos genéricos anidados y sobre la creación de tipos genéricos anidados de sus definiciones de tipo genérico, vea <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the types nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene los tipos anidados dentro del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>Returns the public types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Devuelve los tipos públicos anidados en el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the public types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no public types are nested in the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los tipos públicos anidados en el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual (la búsqueda no es recursiva), o una matriz vacía de tipo <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> si no hay tipos públicos anidados en el objeto <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> método no devuelve tipos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los tipos, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Only the public types immediately nested in the current type are returned; the search is not recursive.</source>
          <target state="translated">Se devuelven los tipos públicos anidados inmediatamente en el tipo actual; la búsqueda no es recursiva.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los tipos anidados de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Esto ocurre incluso si el tipo genérico envolvente es un tipo construido cerrado.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son genéricos todos los incluso si no tienen ningún parámetro genérico por sí mismos.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Esto no es necesariamente así de los tipos anidados definidos en ensamblados dinámicos o compilados con la <bpt id="p1">[</bpt>Ilasm.exe (ensamblador de IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información sobre los tipos genéricos anidados y sobre la creación de tipos genéricos anidados de sus definiciones de tipo genérico, vea <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following example defines a nested class and a <ph id="ph1">`struct`</ph> in <ph id="ph2">`MyClass`</ph>, and then obtains objects of the nested types using the type of <ph id="ph3">`MyClass`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se define una clase anidada y un <ph id="ph1">`struct`</ph> en <ph id="ph2">`MyClass`</ph>y, a continuación, obtenga objetos de los tipos anidados mediante el tipo de <ph id="ph3">`MyClass`</ph>.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca los tipos anidados en el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual y aplica las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, if no nested types are found that match the binding constraints.</source>
          <target state="translated">Una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan todos los tipos anidados en el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual que cumplen las restricciones de enlace especificadas (la búsqueda no es recursiva), o una matriz vacía de tipo <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, si no se encuentran tipos anidados que cumplan las restricciones de enlace.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The search for nested types is not recursive.</source>
          <target state="translated">La búsqueda de tipos anidados no es recursiva.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> método no devuelve tipos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los tipos, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filtro indicadores pueden utilizarse para definir que anidar tipos debe para incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> para obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">Especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> para incluir los tipos anidados públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> para incluir los tipos anidados no públicos (es decir, privados, internos y protegidos tipos anidados) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">Este método devuelve solo los tipos anidados del tipo actual.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">No busca en las clases base del tipo actual.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> at each level.</source>
          <target state="translated">Para buscar tipos que están anidados en clases base, debe recorrer la jerarquía de herencia, una llamada a <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> en cada nivel.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> se pasan por alto.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">Llamar a este método solamente con el <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> marca o solo la <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> marca devolverá tipos anidados especificados y no necesitarán otros indicadores.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, este método busca los tipos anidados de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Esto ocurre incluso si el tipo genérico envolvente es un tipo construido cerrado.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son genéricos todos los incluso si no tienen ningún parámetro genérico por sí mismos.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Esto no es necesariamente así de los tipos anidados definidos en ensamblados dinámicos o compilados con la <bpt id="p1">[</bpt>Ilasm.exe (ensamblador de IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información sobre los tipos genéricos anidados y sobre la creación de tipos genéricos anidados de sus definiciones de tipo genérico, vea <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</source>
          <target state="translated">En el ejemplo siguiente se crea dos clases públicas anidadas y dos clases protegidas anidadas y muestra información para las clases que coincidan con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene las propiedades del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>Returns all the public properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Devuelve todas las propiedades públicas del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all public properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> que representa todas las propiedades públicas del objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public properties.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual no tiene propiedades públicas.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Calling this overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> overload with a <ph id="ph2">`bindingAttr`</ph> argument equal to <ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> in C# and  <ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> in Visual Basic.</source>
          <target state="translated">Llamar a esta sobrecarga es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> sobrecarga con un <ph id="ph2">`bindingAttr`</ph> igual al argumento <ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> en C# y <ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> en Visual Basic.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>It returns all public instance and static properties, both those defined by the type represented by the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object as well as those inherited from its base types.</source>
          <target state="translated">Devuelve todas las instancias públicos y propiedades estáticas, tanto las definidas por el tipo representado por el actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto, así como los que se heredaron de sus tipos base.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> método no devuelve propiedades en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven propiedades, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si t: System. Type actual representa un tipo genérico construido, este método devuelve el <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following example demonstrates the use of the <ph id="ph1">`GetProperties`</ph> method.</source>
          <target state="translated">En el siguiente ejemplo se muestra el uso del método <ph id="ph1">`GetProperties`</ph>.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca las propiedades del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual y aplica las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> que representa a todas las propiedades del objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual que coincidan con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have properties, or if none of the properties match the binding constraints.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual no tiene propiedades o si ninguna de las propiedades coincide con las restricciones de enlace.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> método no devuelve propiedades en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven propiedades, porque ese orden varía.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filtro indicadores pueden utilizarse para definir que anidar tipos debe para incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir propiedades públicas en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir propiedades no públicas (es decir, propiedades privadas, internas y protegidas) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</source>
          <target state="translated">Solo se devuelven las propiedades internas de las clases base; y protegidos no se devuelven las propiedades privadas de las clases base.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo las propiedades declaradas en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no las propiedades que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si t: System. Type actual representa un tipo genérico construido, este método devuelve el <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following example defines a class named <ph id="ph1">`PropertyClass`</ph> that includes six properties: two are public, one is private, one is protected, one is internal (<ph id="ph2">`Friend`</ph> in Visual Basic), and one is protected internal (<ph id="ph3">`Protected Friend`</ph> in Visual Basic).</source>
          <target state="translated">En el ejemplo siguiente se define una clase denominada <ph id="ph1">`PropertyClass`</ph> que incluye seis propiedades: dos son públicas, uno es privado, uno está protegido, uno es interno (<ph id="ph2">`Friend`</ph> en Visual Basic), y uno es protected internal (<ph id="ph3">`Protected Friend`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its <ph id="ph1">`get`</ph> and <ph id="ph2">`set`</ph> accessors) for the properties that match the specified binding constraints.</source>
          <target state="translated">A continuación, se muestra parte de la información básica de propiedad (el nombre de la propiedad y el tipo, si es lectura/escritura y la visibilidad de su <ph id="ph1">`get`</ph> y <ph id="ph2">`set`</ph> descriptores de acceso) para las propiedades que coinciden con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific property of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene una propiedad específica del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>Searches for the public property with the specified name.</source>
          <target state="translated">Busca la propiedad pública con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la propiedad pública con el nombre especificado, si se encuentra; en caso contrario, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">La búsqueda incluye propiedades de instancia público static y public.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">Situaciones en las que <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> se produce incluyen lo siguiente:</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">Un tipo contiene dos propiedades indizadas que tienen el mismo nombre pero con distintos números de parámetros.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">Para resolver la ambigüedad, use una sobrecarga de la <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> método que especifica los tipos de parámetro.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A derived type declares a property that hides an inherited property with the same name, by using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">Un tipo derivado declara una propiedad que oculta una propiedad heredada con el mismo nombre, mediante el uso de la <ph id="ph1">`new`</ph> modificador (<ph id="ph2">`Shadows`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use the <ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method overload and add the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> flag to restrict the search to members that are not inherited.</source>
          <target state="translated">Para resolver la ambigüedad, use la <ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> sobrecarga de método y agregue el <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> marca para restringir la búsqueda a los miembros que no se heredan.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexers and Default Properties</source>
          <target state="translated">Los indizadores y las propiedades predeterminadas</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, y <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permite una propiedad indizada sea un valor predeterminado para su tipo.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Por ejemplo, si la variable <ph id="ph1">`myList`</ph> hace referencia a un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, la sintaxis <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> en Visual Basic) recupera el elemento con el índice de 3.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>You can overload the property.</source>
          <target state="translated">Puede sobrecargar la propiedad.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">En C#, esta característica se denomina indizador y no puede ser usan por su nombre.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Sin embargo, un desarrollador de biblioteca de clase puede utilizar el <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> atributo para cambiar el nombre del indizador en los metadatos.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.String&gt;</ph> clase tiene un indizador que se denomina <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Propiedades indizadas creadas con lenguajes distintos de C# pueden tener nombres que no sea de elemento, también.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> método para comprobar la <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Si el tipo tiene <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, el <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> propiedad devuelve el nombre de la propiedad predeterminada.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves a property of that class, and displays the property name.</source>
          <target state="translated">En el ejemplo siguiente se recupera la <ph id="ph1">`Type`</ph> objeto de una clase definida por el usuario, recupera una propiedad de esa clase y muestra el nombre de propiedad.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Internally, this property is referred to in the metadata by the name "Item."</source>
          <target state="translated">Internamente, esta propiedad hace referencia en los metadatos el nombre "Item".</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Any attempt to get <ph id="ph1">`PropertyInfo`</ph> using reflection must specify this internal name in order to correctly return the <ph id="ph2">`PropertyInfo`</ph> property.</source>
          <target state="translated">Cualquier intento de obtener <ph id="ph1">`PropertyInfo`</ph> utilizando la reflexión debe especificar este nombre interno para devolver correctamente la <ph id="ph2">`PropertyInfo`</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">Se encontró más de una propiedad con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">Cadena que contiene el nombre de la propiedad que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified property, using the specified binding constraints.</source>
          <target state="translated">Busca la propiedad especificada, mediante las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la propiedad que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir las propiedades que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir propiedades públicas en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir propiedades no públicas (es decir, propiedades privadas, internas y protegidas) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo las propiedades declaradas en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no las propiedades que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">Situaciones en las que <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> se produce incluyen lo siguiente:</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">Un tipo contiene dos propiedades indizadas que tienen el mismo nombre pero con distintos números de parámetros.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">Para resolver la ambigüedad, use una sobrecarga de la <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> método que especifica los tipos de parámetro.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A derived type declares a property that hides an inherited property with the same name, using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">Un tipo derivado declara una propiedad que oculta una propiedad heredada con el mismo nombre, con el <ph id="ph1">`new`</ph> modificador (<ph id="ph2">`Shadows`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, include <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to restrict the search to members that are not inherited.</source>
          <target state="translated">Para resolver la ambigüedad, incluya <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> para restringir la búsqueda a los miembros que no se heredan.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexers and Default Properties</source>
          <target state="translated">Los indizadores y las propiedades predeterminadas</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, y <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permite una propiedad indizada sea un valor predeterminado para su tipo.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Por ejemplo, si la variable <ph id="ph1">`myList`</ph> hace referencia a un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, la sintaxis <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> en Visual Basic) recupera el elemento con el índice de 3.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You can overload the property.</source>
          <target state="translated">Puede sobrecargar la propiedad.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">En C#, esta característica se denomina indizador y no puede ser usan por su nombre.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Sin embargo, un desarrollador de biblioteca de clase puede utilizar el <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> atributo para cambiar el nombre del indizador en los metadatos.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.String&gt;</ph> clase tiene un indizador que se denomina <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Propiedades indizadas creadas con lenguajes distintos de C# pueden tener nombres que no sea de elemento, también.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> método para comprobar la <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Si el tipo tiene <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, el <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> propiedad devuelve el nombre de la propiedad predeterminada.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</source>
          <target state="translated">En el ejemplo siguiente se recupera el tipo de una clase definida por el usuario, se recupera una propiedad de esa clase y se muestra el nombre de propiedad de acuerdo con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Se encontró más de una propiedad con el nombre especificado y que coincide con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The return type of the property.</source>
          <target state="translated">Tipo de valor devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Searches for the public property with the specified name and return type.</source>
          <target state="translated">Busca la propiedad pública con el nombre especificado y el tipo de valor devuelto.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la propiedad pública con el nombre especificado, si se encuentra; en caso contrario, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">La búsqueda incluye propiedades de instancia público static y public.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexers and Default Properties</source>
          <target state="translated">Los indizadores y las propiedades predeterminadas</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, y <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permite una propiedad indizada sea un valor predeterminado para su tipo.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Por ejemplo, si la variable <ph id="ph1">`myList`</ph> hace referencia a un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, la sintaxis <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> en Visual Basic) recupera el elemento con el índice de 3.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>You can overload the property.</source>
          <target state="translated">Puede sobrecargar la propiedad.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">En C#, esta característica se denomina indizador y no puede ser usan por su nombre.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Sin embargo, un desarrollador de biblioteca de clase puede utilizar el <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> atributo para cambiar el nombre del indizador en los metadatos.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.String&gt;</ph> clase tiene un indizador que se denomina <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Propiedades indizadas creadas con lenguajes distintos de C# pueden tener nombres que no sea de elemento, también.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> método para comprobar la <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Si el tipo tiene <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, el <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> propiedad devuelve el nombre de la propiedad predeterminada.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The following example defines a class with one property and retrieves the name and type of the property.</source>
          <target state="translated">En el ejemplo siguiente se define una clase con una propiedad y recupera el nombre y tipo de la propiedad.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">Se encontró más de una propiedad con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>, o bien, <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Matriz vacía del tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">Busca la propiedad pública especificada cuyos parámetros coincidan con los tipos de argumentos especificados.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la propiedad pública cuyos parámetros coinciden con los tipos de argumentos especificados, si se encuentra; en caso contrario, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">La búsqueda incluye propiedades de instancia público static y public.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Los indizadores y las propiedades predeterminadas</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, y <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permite una propiedad indizada sea un valor predeterminado para su tipo.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Por ejemplo, si la variable <ph id="ph1">`myList`</ph> hace referencia a un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, la sintaxis <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> en Visual Basic) recupera el elemento con el índice de 3.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">Puede sobrecargar la propiedad.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">En C#, esta característica se denomina indizador y no puede ser usan por su nombre.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Sin embargo, un desarrollador de biblioteca de clase puede utilizar el <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> atributo para cambiar el nombre del indizador en los metadatos.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.String&gt;</ph> clase tiene un indizador que se denomina <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Propiedades indizadas creadas con lenguajes distintos de C# pueden tener nombres que no sea de elemento, también.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> método para comprobar la <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Si el tipo tiene <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, el <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> propiedad devuelve el nombre de la propiedad predeterminada.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to <ph id="ph2">`GetProperty`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se recupera la <ph id="ph1">`Type`</ph> objeto de una clase definida por el usuario, recupera la propiedad de esa clase y muestra el nombre de la propiedad y el tipo de la propiedad de acuerdo con lo especificado por los argumentos pasados a <ph id="ph2">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">Se encontró más de una propiedad con el nombre especificado y que coincide con los tipos de argumento especificados.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un elemento de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">Tipo de valor devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Matriz vacía del tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">Busca la propiedad pública especificada cuyos parámetros coincidan con los tipos de argumentos especificados.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la propiedad pública cuyos parámetros coinciden con los tipos de argumentos especificados, si se encuentra; en caso contrario, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">La búsqueda incluye propiedades de instancia público static y public.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Los indizadores y las propiedades predeterminadas</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, y <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permite una propiedad indizada sea un valor predeterminado para su tipo.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Por ejemplo, si la variable <ph id="ph1">`myList`</ph> hace referencia a un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, la sintaxis <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> en Visual Basic) recupera el elemento con el índice de 3.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">Puede sobrecargar la propiedad.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">En C#, esta característica se denomina indizador y no puede ser usan por su nombre.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Sin embargo, un desarrollador de biblioteca de clase puede utilizar el <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> atributo para cambiar el nombre del indizador en los metadatos.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.String&gt;</ph> clase tiene un indizador que se denomina <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Propiedades indizadas creadas con lenguajes distintos de C# pueden tener nombres que no sea de elemento, también.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> método para comprobar la <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Si el tipo tiene <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, el <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> propiedad devuelve el nombre de la propiedad predeterminada.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">Se encontró más de una propiedad con el nombre especificado y que coincide con los tipos de argumento especificados.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un elemento de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Tipo de valor devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Matriz vacía del tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public property whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">Busca la propiedad pública especificada cuyos parámetros coincidan con los tipos y modificadores de los argumentos especificados.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la propiedad pública que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (la <ph id="ph2">`modifiers`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">La búsqueda de <ph id="ph1">`name`</ph> distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">La búsqueda incluye propiedades de instancia público static y public.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Los indizadores y las propiedades predeterminadas</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, y <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permite una propiedad indizada sea un valor predeterminado para su tipo.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Por ejemplo, si la variable <ph id="ph1">`myList`</ph> hace referencia a un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, la sintaxis <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> en Visual Basic) recupera el elemento con el índice de 3.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">Puede sobrecargar la propiedad.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">En C#, esta característica se denomina indizador y no puede ser usan por su nombre.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Sin embargo, un desarrollador de biblioteca de clase puede utilizar el <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> atributo para cambiar el nombre del indizador en los metadatos.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.String&gt;</ph> clase tiene un indizador que se denomina <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Propiedades indizadas creadas con lenguajes distintos de C# pueden tener nombres que no sea de elemento, también.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> método para comprobar la <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Si el tipo tiene <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, el <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> propiedad devuelve el nombre de la propiedad predeterminada.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyPropertyClass`</ph>, and the indexed property of this class is retrieved using the arguments passed to the <ph id="ph3">`GetProperty`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se obtiene un <ph id="ph1">`Type`</ph> objeto correspondiente a <ph id="ph2">`MyPropertyClass`</ph>, y la propiedad indizada de esta clase se recupera mediante los argumentos pasados a la <ph id="ph3">`GetProperty`</ph> método.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified argument types and modifiers.</source>
          <target state="translated">Existe más de una propiedad con el nombre especificado que coincide con los modificadores y tipos de argumentos especificados.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> y <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> no tienen la misma longitud.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un elemento de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">Cadena que contiene el nombre de la propiedad que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Tipo de valor devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Matriz vacía del tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Busca la propiedad especificada cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, mediante las restricciones de enlace indicadas.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la propiedad que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso que es público.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">En caso contrario, la propiedad se considera privada, y debe usar <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (en Visual Basic, combine los valores utilizando <ph id="ph4">`Or`</ph>) para obtenerlo.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (la <ph id="ph2">`modifiers`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir las propiedades que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir propiedades públicas en la búsqueda.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir propiedades no públicas (es decir, propiedades privadas, internas y protegidas) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo las propiedades declaradas en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no las propiedades que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, este método devuelve el <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Los indizadores y las propiedades predeterminadas</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, y <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permite una propiedad indizada sea un valor predeterminado para su tipo.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Por ejemplo, si la variable <ph id="ph1">`myList`</ph> hace referencia a un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, la sintaxis <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> en Visual Basic) recupera el elemento con el índice de 3.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">Puede sobrecargar la propiedad.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">En C#, esta característica se denomina indizador y no puede ser usan por su nombre.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Sin embargo, un desarrollador de biblioteca de clase puede utilizar el <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> atributo para cambiar el nombre del indizador en los metadatos.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.String&gt;</ph> clase tiene un indizador que se denomina <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Propiedades indizadas creadas con lenguajes distintos de C# pueden tener nombres que no sea de elemento, también.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> método para comprobar la <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Si el tipo tiene <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, el <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> propiedad devuelve el nombre de la propiedad predeterminada.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Se encontró más de una propiedad con el nombre especificado y que coincide con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> y <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> no tienen la misma longitud.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un elemento de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">Cadena que contiene el nombre de la propiedad que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cero, para devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace que pueden implicar la selección de un miembro sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Tipo de valor devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Matriz vacía del tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">El enlazador predeterminado no procesa este parámetro.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Cuando se invalida en una clase derivada, busca la propiedad especificada cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, usando las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la propiedad que cumple los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (la <ph id="ph2">`modifiers`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir las propiedades que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Debe especificar <ph id="ph1">`BindingFlags.Instance`</ph> o <ph id="ph2">`BindingFlags.Static`</ph> con el fin de obtener un valor devuelto.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir propiedades públicas en la búsqueda.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir propiedades no públicas (es decir, propiedades privadas, internas y protegidas) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Especifique <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir <ph id="ph2">`public`</ph> y <ph id="ph3">`protected`</ph> miembros estáticos en la jerarquía; <ph id="ph4">`private`</ph> miembros estáticos de las clases heredadas no se incluyen.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar sólo las propiedades declaradas en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no las propiedades que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Se encontró más de una propiedad con el nombre especificado y que coincide con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno de los elementos de <ph id="ph1">&lt;paramref name="types" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> y <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> no tienen la misma longitud.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph>, or <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">El tipo actual es un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the specified type.</source>
          <target state="translated">Obtiene un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo especificado.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>Gets the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene la estructura <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador de clase y genera una excepción.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">Nombre calificado con el ensamblado del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Si el tipo está en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, es suficiente para proporcionar el nombre completo del tipo por su espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search.</source>
          <target state="translated">Obtiene el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> con el nombre especificado, mediante una búsqueda en la que se distingue entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Tipo con el nombre especificado, si se encuentra; de lo contrario <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if you know its namespace-qualified name.</source>
          <target state="translated">Puede usar el <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método para obtener un <ph id="ph2">&lt;xref:System.Type&gt;</ph> de objeto para un tipo en otro ensamblado, si conoce su nombre calificado de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> hace que se cargue el ensamblado especificado en <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">También puede cargar un ensamblado con el <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> método y, a continuación, utilice la <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> métodos de la <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> clase para obtener <ph id="ph5">&lt;xref:System.Type&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or  in C++.</source>
          <target state="translated">Si un tipo está en un ensamblado que se sabe que el programa en tiempo de compilación, resulta más eficaz utilizar en C#, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> en Visual Basic o C++.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> no se encuentra, la llamada a la <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> método <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>It does not throw an exception.</source>
          <target state="translated">No se produce una excepción.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">Para controlar si se produce una excepción, llamar a una sobrecarga de la <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método que tiene un <ph id="ph2">`throwOnError`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> solo funciona en los ensamblados cargados desde el disco.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you call <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">Si se llama a <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> para buscar un tipo definido en un ensamblado dinámico definido mediante el <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, podría producirse un comportamiento incoherente.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">El comportamiento depende de si el ensamblado dinámico es persistente, es decir, se crea usando el <ph id="ph1">`RunAndSave`</ph> o <ph id="ph2">`Save`</ph> modos de acceso a la <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">Si el ensamblado dinámico es persistente y se ha escrito en el disco antes de <ph id="ph1">`GetType`</ph> es llama, el cargador busca el ensamblado guardado en disco, carga ese ensamblado y recupera el tipo de ese ensamblado.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si el ensamblado no se ha guardado en el disco cuando <ph id="ph1">`GetType`</ph> se llama, el método devuelve <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> no entiende los ensamblados dinámicos transitorios; por lo tanto, al llamar a <ph id="ph2">`GetType`</ph> para recuperar un tipo en un transitorio devuelve el ensamblado dinámico <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">Usar <ph id="ph1">`GetType`</ph> en un módulo dinámico, suscribirse a la <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> eventos y llame al método <ph id="ph3">`GetType`</ph> antes de guardar.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">De lo contrario, obtendrá dos copias del ensamblado en la memoria.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">Las matrices o los tipos COM no se buscan, a menos que ya se han cargado en la tabla de clases disponibles.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> puede ser el nombre de tipo calificado por su espacio de nombres o un nombre calificado con el ensamblado que incluya una especificación de nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> incluye el espacio de nombres pero no el nombre del ensamblado, este método busca solo ensamblado del objeto que realiza la llamada y Mscorlib.dll, en ese orden.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">Si typeName es un nombre completo que incluye el nombre del ensamblado parcial o completo, este método busca en el ensamblado especificado.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">Si el ensamblado tiene un nombre seguro, se requiere un nombre de ensamblado completo.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedad devuelve un nombre de tipo completo, incluidos los tipos anidados, el nombre del ensamblado y los argumentos de tipo genérico.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Todos los compiladores que admiten common language runtime emitirán el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando ejecute la consulta, con arreglo a las siguientes convenciones.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Por ejemplo, "ProcessorArchitecture = msil".</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Sin embargo, no se incluye en la cadena devuelta por la <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedad por motivos de compatibilidad.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">También puede cargar tipos creando un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objeto y pasarla a una sobrecarga adecuada de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (método).</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">A continuación, puede usar el <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> método para cargar tipos del ensamblado.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vea también <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Delimiter</source>
          <target state="translated">Delimitador</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Meaning</source>
          <target state="translated">Significado</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Barra diagonal inversa (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Escape character.</source>
          <target state="translated">Carácter de escape.</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backtick (`)</source>
          <target state="translated">Acento grave (')</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">Precede a uno o más dígitos que representa el número de parámetros de tipo, situado al final del nombre de un tipo genérico.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Brackets ([])</source>
          <target state="translated">Corchetes ([])</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">Incluya una lista de argumentos de tipo genérico para un tipo genérico construido; dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Comma (,)</source>
          <target state="translated">Coma (,)</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Precede al nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Period (.)</source>
          <target state="translated">Punto (.)</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Denota los identificadores de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Plus sign (+)</source>
          <target state="translated">Signo más (+)</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes a nested class.</source>
          <target state="translated">Precede a una clase anidada.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">Por ejemplo, el nombre completo para una clase podría ser similar al siguiente:</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Si el espacio de nombres fuera EspacioNombresPrincipal. Sub+EspacioNombres, la cadena tendría que ir delante del signo más (+) con un carácter de escape (<ph id="ph1">\\</ph>) para evitar que se interprete como un separador de anidamiento.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">La reflexión emite esta cadena como sigue:</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Este nombre completo puede se conserven y se utiliza posteriormente para cargar el <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Para buscar y cargar un <ph id="ph1">&lt;xref:System.Type&gt;</ph>, utilice <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> con el tipo de nombre sólo buscará la <ph id="ph2">&lt;xref:System.Type&gt;</ph> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> con el ensamblado de nombre de tipo calificado buscará la <ph id="ph2">&lt;xref:System.Type&gt;</ph> de cualquier ensamblado.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Para recuperar el nombre del tipo sin estos caracteres finales, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, donde <ph id="ph2">`t`</ph> es el tipo.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Los espacios son relevantes en todos los componentes de nombre de tipo excepto el nombre del ensamblado.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">En el nombre del ensamblado, los espacios delante del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">El nombre de un tipo genérico finaliza con un acento grave (<ph id="ph1">\`</ph>) seguido de dígitos que representa el número de argumentos de tipo genérico.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">El propósito de este nombre con sufijo es permitir que los compiladores admitir tipos genéricos con el mismo nombre pero con distintos números de parámetros de tipo, que se producen en el mismo ámbito.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">Por ejemplo, la reflexión devuelve los nombres alterados <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>tupla<ph id="ph3">`2`</ph> de los métodos genéricos <ph id="ph4">`Tuple(Of T)`</ph> y <ph id="ph5">`Tuple(Of T0, T1)`</ph> en Visual Basic, o <ph id="ph6">`Tuple&lt;T&gt;`</ph> y tupla<ph id="ph7">`\&lt;T0, T1&gt;`</ph> en Visual C#.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">Para los tipos genéricos, la lista de argumentos de tipo se incluye entre corchetes y los argumentos de tipo están separados por comas.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">Por ejemplo, un tipo genérico <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> tiene dos parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> de <ph id="ph2">`MyType`</ph> con claves de tipo <ph id="ph3">&lt;xref:System.String&gt;</ph> podría representarse como se indica a continuación:</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">Para especificar un tipo calificado con el ensamblado dentro de una lista de argumentos de tipo, incluya el tipo de ensamblado completo entre corchetes.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">De lo contrario, las comas que separan las partes del nombre completo de ensamblado se interpretan como delimitación de los argumentos de tipo adicionales.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> fromMyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">Por ejemplo, un <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> de <ph id="ph2">`MyType`</ph> fromMyAssembly.dll, con claves de tipo <ph id="ph3">&lt;xref:System.String&gt;</ph>, se puede especificar como sigue:</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">Un tipo calificado con el ensamblado puede escribirse entre corchetes solo cuando aparece dentro de una lista de parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">Las reglas para buscar los ensamblados de tipos completos e incompletos en listas de parámetros de tipo son las mismas que las reglas para tipos no genéricos completos e incompletos.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Tipos que aceptan valores NULL son un caso especial de tipos genéricos.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">Por ejemplo, una que acepta valores NULL <ph id="ph1">&lt;xref:System.Int32&gt;</ph> representado por la cadena "System.Nullable'1[System.Int32"].</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">En C#, C++ y Visual Basic también puede obtener tipos que aceptan valores NULL mediante operadores de tipo.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">Por ejemplo, las que aceptan valores NULL <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> tipo devuelto por <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> en C#, por <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> en C++ y por <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> en Visual Basic.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">En la tabla siguiente se muestra la sintaxis que se usa con <ph id="ph1">`GetType`</ph> para varios tipos.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To Get</source>
          <target state="translated">Para obtener</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Use</source>
          <target state="translated">Usar</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Un que aceptan valores null <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Un puntero no administrado a <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Un puntero no administrado a un puntero a <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Un puntero administrado o una referencia a <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de los punteros, las referencias están limitadas a un nivel.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A parent class and a nested class</source>
          <target state="translated">Una clase principal y una clase anidada</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">Una matriz unidimensional con un límite inferior de 0</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">Una matriz unidimensional con un límite inferior desconocido</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An n-dimensional array</source>
          <target state="translated">Una matriz de n dimensiones</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">Una coma (,) entre paréntesis un total de n-1 veces.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">Por ejemplo, <ph id="ph1">`System.Object[,,]`</ph> representa un tridimensional <ph id="ph2">`Object`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An array of one-dimensional arrays</source>
          <target state="translated">Una matriz de matrices unidimensionales</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">Una matriz bidimensional rectangular con límites inferiores desconocidos</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with one type argument</source>
          <target state="translated">Un tipo genérico con un argumento de tipo</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")'</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two type arguments</source>
          <target state="translated">Un tipo genérico con dos argumentos de tipo</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")'</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">Un tipo genérico con dos argumentos de tipo calificado por ensamblado</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">Un tipo genérico calificado con el ensamblado con un argumento de tipo calificado por ensamblado</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">Un tipo genérico cuyo argumento de tipo es un tipo genérico con dos argumentos de tipo</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se recupera el tipo de <ph id="ph1">`System.Int32`</ph> y usa ese objeto de tipo para mostrar la <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> propiedad de <ph id="ph3">`System.Int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador de clase y genera una excepción.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un tipo de puntero, un tipo <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> como uno de sus argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa una matriz de <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">En <bpt id="p1">[</bpt>.NET para aplicaciones de la Tienda Windows<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o la <bpt id="p2">[</bpt>Biblioteca de clases portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, capture en su lugar la excepción de clase base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">El ensamblado o alguna de sus dependencias no son válidos.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">Actualmente, está cargada la versión 2.0 u otra posterior de Common Language Runtime pero el ensamblado se compiló con una versión posterior.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">Nombre calificado con el ensamblado del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Si el tipo está en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, es suficiente para proporcionar el nombre completo del tipo por su espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para producir una excepción si no se puede encontrar el tipo; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> para devolver <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Si se especifica <ph id="ph1">&lt;see langword="false" /&gt;</ph> se suprimen otras condiciones de excepción, pero no todas.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</source>
          <target state="translated">Obtiene el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> con el nombre especificado, que realiza una búsqueda donde se distingue entre mayúsculas y minúsculas y especifica si se va a producir o no una excepción si no se encuentra el tipo.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Tipo con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Si el tipo no se encuentra, el parámetro <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> especifica si se devuelve <ph id="ph2">&lt;see langword="null" /&gt;</ph> o se produce una excepción.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">En algunos casos, se produce una excepción con independencia del valor de <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">Puede usar el <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método para obtener un <ph id="ph2">&lt;xref:System.Type&gt;</ph> de objeto para un tipo en otro ensamblado, si conoce su nombre calificado de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> hace que se cargue el ensamblado especificado en <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">También puede cargar un ensamblado con el <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> método y, a continuación, utilice la <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> métodos de la <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> clase para obtener <ph id="ph5">&lt;xref:System.Type&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">Si un tipo está en un ensamblado que se sabe que el programa en tiempo de compilación, resulta más eficaz utilizar <ph id="ph1">`typeof`</ph> en C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> en Visual Basic, o <ph id="ph3">`typeid`</ph> en C++.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> solo funciona en los ensamblados cargados desde el disco.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">Si se llama a <ph id="ph1">`GetType`</ph> para buscar un tipo definido en un ensamblado dinámico definido mediante el <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, podría producirse un comportamiento incoherente.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">El comportamiento depende de si el ensamblado dinámico es persistente, es decir, se crea usando el <ph id="ph1">`RunAndSave`</ph> o <ph id="ph2">`Save`</ph> modos de acceso a la <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">Si el ensamblado dinámico es persistente y se ha escrito en el disco antes de <ph id="ph1">`GetType`</ph> es llama, el cargador busca el ensamblado guardado en disco, carga ese ensamblado y recupera el tipo de ese ensamblado.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si el ensamblado no se ha guardado en el disco cuando <ph id="ph1">`GetType`</ph> se llama, el método devuelve <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> no entiende los ensamblados dinámicos transitorios; por lo tanto, al llamar a <ph id="ph2">`GetType`</ph> para recuperar un tipo en un transitorio devuelve el ensamblado dinámico <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">Usar <ph id="ph1">`GetType`</ph> en un módulo dinámico, suscribirse a la <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> eventos y llame al método <ph id="ph3">`GetType`</ph> antes de guardar.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">De lo contrario, obtendrá dos copias del ensamblado en la memoria.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated">El <ph id="ph1">`throwOnError`</ph> parámetro especifica lo que ocurre cuando no se encuentra el tipo y también suprime algunas condiciones de excepción, como se describe en la sección excepciones.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">Algunas excepciones se producen independientemente del valor de <ph id="ph1">`throwOnError`</ph>.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Por ejemplo, si se encuentra el tipo pero no se puede cargar, un <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> se produce incluso si <ph id="ph2">`throwOnError`</ph> es <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">Las matrices o los tipos COM no se buscan, a menos que ya se han cargado en la tabla de clases disponibles.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> puede ser el nombre de tipo calificado por su espacio de nombres o un nombre calificado con el ensamblado que incluya una especificación de nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> incluye el espacio de nombres pero no el nombre del ensamblado, este método busca solo ensamblado del objeto que realiza la llamada y Mscorlib.dll, en ese orden.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">Si typeName es un nombre completo que incluye el nombre del ensamblado parcial o completo, este método busca en el ensamblado especificado.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">Si el ensamblado tiene un nombre seguro, se requiere un nombre de ensamblado completo.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedad devuelve un nombre de tipo completo incluidos los tipos anidados, el nombre de ensamblado y argumentos genéricos.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Todos los compiladores que admiten common language runtime emitirán el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando ejecute la consulta, con arreglo a las siguientes convenciones.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Por ejemplo, "ProcessorArchitecture = msil".</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Sin embargo, no se incluye en la cadena devuelta por la <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedad por motivos de compatibilidad.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">También puede cargar tipos creando un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objeto y pasarla a una sobrecarga adecuada de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (método).</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">A continuación, puede usar el <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> método para cargar tipos del ensamblado.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vea también <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">Delimitador</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">Significado</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Barra diagonal inversa (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">Carácter de escape.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">Acento grave (')</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">Precede a uno o más dígitos que representa el número de parámetros de tipo, situado al final del nombre de un tipo genérico.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">Corchetes ([])</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">Incluya una lista de argumentos de tipo genérico para un tipo genérico construido; dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">Coma (,)</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Precede al nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">Punto (.)</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Denota los identificadores de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">Signo más (+)</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">Precede a una clase anidada.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">Por ejemplo, el nombre completo para una clase podría ser similar al siguiente:</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Si el espacio de nombres fuera EspacioNombresPrincipal. Sub+EspacioNombres, la cadena tendría que ir delante del signo más (+) con un carácter de escape (<ph id="ph1">\\</ph>) para evitar que se interprete como un separador de anidamiento.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">La reflexión emite esta cadena como sigue:</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Este nombre completo puede se conserven y se utiliza posteriormente para cargar el <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Para buscar y cargar un <ph id="ph1">&lt;xref:System.Type&gt;</ph>, utilice <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> con el tipo de nombre sólo buscará la <ph id="ph2">&lt;xref:System.Type&gt;</ph> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> con el ensamblado de nombre de tipo calificado buscará la <ph id="ph2">&lt;xref:System.Type&gt;</ph> de cualquier ensamblado.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Para recuperar el nombre del tipo sin estos caracteres finales, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, donde <ph id="ph2">`t`</ph> es el tipo.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Los espacios son relevantes en todos los componentes de nombre de tipo excepto el nombre del ensamblado.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">En el nombre del ensamblado, los espacios delante del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">El nombre de un tipo genérico finaliza con un acento grave (<ph id="ph1">\`</ph>) seguido de dígitos que representa el número de argumentos de tipo genérico.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">El propósito de este nombre con sufijo es permitir que los compiladores admitir tipos genéricos con el mismo nombre pero con distintos números de parámetros de tipo, que se producen en el mismo ámbito.</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">Por ejemplo, la reflexión devuelve los nombres alterados <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>tupla<ph id="ph3">`2`</ph> de los métodos genéricos <ph id="ph4">`Tuple(Of T)`</ph> y <ph id="ph5">`Tuple(Of T0, T1)`</ph> en Visual Basic, o <ph id="ph6">`Tuple&lt;T&gt;`</ph> y tupla<ph id="ph7">`\&lt;T0, T1&gt;`</ph> en Visual C#.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">Para los tipos genéricos, la lista de argumentos de tipo se incluye entre corchetes y los argumentos de tipo están separados por comas.</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">Por ejemplo, un tipo genérico <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> tiene dos parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> de <ph id="ph2">`MyType`</ph> con claves de tipo <ph id="ph3">&lt;xref:System.String&gt;</ph> podría representarse como se indica a continuación:</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">Para especificar un tipo calificado con el ensamblado dentro de una lista de argumentos de tipo, incluya el tipo de ensamblado completo entre corchetes.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">De lo contrario, las comas que separan las partes del nombre completo de ensamblado se interpretan como delimitación de los argumentos de tipo adicionales.</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">Por ejemplo, un <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> de <ph id="ph2">`MyType`</ph> en MyAssembly.dll, con claves de tipo <ph id="ph3">&lt;xref:System.String&gt;</ph>, se puede especificar como sigue:</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">Un tipo calificado con el ensamblado puede escribirse entre corchetes solo cuando aparece dentro de una lista de parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">Las reglas para buscar los ensamblados de tipos completos e incompletos en listas de parámetros de tipo son las mismas que las reglas para tipos no genéricos completos e incompletos.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Tipos que aceptan valores NULL son un caso especial de tipos genéricos.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">Por ejemplo, una que acepta valores NULL <ph id="ph1">&lt;xref:System.Int32&gt;</ph> representado por la cadena "System.Nullable'1[System.Int32"].</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">En C#, C++ y Visual Basic también puede obtener tipos que aceptan valores NULL mediante operadores de tipo.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">Por ejemplo, las que aceptan valores NULL <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> tipo devuelto por <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> en C#, por <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> en C++ y por <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> en Visual Basic.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">En la tabla siguiente se muestra la sintaxis que se usa con <ph id="ph1">`GetType`</ph> para varios tipos.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To Get</source>
          <target state="translated">Para obtener</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Use</source>
          <target state="translated">Usar</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Un que aceptan valores null <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Un puntero no administrado a <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Un puntero no administrado a un puntero a <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Un puntero administrado o una referencia a <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de los punteros, las referencias están limitadas a un nivel.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">Una clase principal y una clase anidada</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">Una matriz unidimensional con un límite inferior de 0</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">Una matriz unidimensional con un límite inferior desconocido</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">Una matriz de n dimensiones</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">Una coma (,) entre paréntesis un total de n-1 veces.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">Por ejemplo, <ph id="ph1">`System.Object[,,]`</ph> representa un tridimensional <ph id="ph2">`Object`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">La matriz de una matriz bidimensional</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">Una matriz bidimensional rectangular con límites inferiores desconocidos</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">Un tipo genérico con un argumento de tipo</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")'</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">Un tipo genérico con dos argumentos de tipo</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")'</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">Un tipo genérico con dos argumentos de tipo calificado por ensamblado</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">Un tipo genérico calificado con el ensamblado con un argumento de tipo calificado por ensamblado</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">Un tipo genérico cuyo argumento de tipo es un tipo genérico con dos argumentos de tipo</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se recupera el tipo de <ph id="ph1">`System.Int32`</ph> y usa ese objeto de tipo para mostrar la <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> propiedad de <ph id="ph3">`System.Int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type object refers to an assembly that does not exist, this example throws an exception.</source>
          <target state="translated">Si un objeto de tipo hace referencia a un ensamblado que no existe, este ejemplo produce una excepción.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador de clase y genera una excepción.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encuentra el tipo.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene caracteres no válidos, como una pestaña insertada.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> representa un tipo de matriz con un tamaño no válido.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa una matriz de <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene sintaxis no válida.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">Por ejemplo: "MyType[,*,]".</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un tipo de puntero, un tipo <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> como uno de sus argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encontró el ensamblado o alguna de sus dependencias.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">En <bpt id="p1">[</bpt>.NET para aplicaciones de la Tienda Windows<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o la <bpt id="p2">[</bpt>Biblioteca de clases portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, capture en su lugar la excepción de clase base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">El ensamblado o alguna de sus dependencias no son válidos.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">Actualmente, está cargada la versión 2.0 u otra posterior de Common Language Runtime pero el ensamblado se compiló con una versión posterior.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">Nombre calificado con el ensamblado del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Si el tipo está en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, es suficiente para proporcionar el nombre completo del tipo por su espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.Specifying <ph id="ph4">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para producir una excepción si no se puede encontrar el tipo; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para devolver <ph id="ph3">&lt;see langword="null" /&gt;</ph>. Especificar <ph id="ph4">&lt;see langword="false" /&gt;</ph> también suprime algunas otras condiciones de excepción, pero no todas ellas.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para realizar una búsqueda de <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> que no distinga entre mayúsculas y minúsculas; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para realizar una búsqueda de <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> que distinga entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</source>
          <target state="translated">Obtiene el <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> con el nombre indicado, que especifica si se genera una excepción en caso de que no se encuentre el tipo y si se va a realizar una búsqueda donde se distingue entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Tipo con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Si el tipo no se encuentra, el parámetro <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> especifica si se devuelve <ph id="ph2">&lt;see langword="null" /&gt;</ph> o se produce una excepción.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">En algunos casos, se produce una excepción con independencia del valor de <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">Puede usar el <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método para obtener un <ph id="ph2">&lt;xref:System.Type&gt;</ph> de objeto para un tipo en otro ensamblado, si conoce su nombre calificado de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> hace que se cargue el ensamblado especificado en <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">También puede cargar un ensamblado con el <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> método y, a continuación, utilice la <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> métodos de la <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> clase para obtener <ph id="ph5">&lt;xref:System.Type&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">Si un tipo está en un ensamblado que se sabe que el programa en tiempo de compilación, resulta más eficaz utilizar <ph id="ph1">`typeof`</ph> en C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> en Visual Basic, o <ph id="ph3">`typeid`</ph> en C++.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> solo funciona en los ensamblados cargados desde el disco.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">Si se llama a <ph id="ph1">`GetType`</ph> para buscar un tipo definido en un ensamblado dinámico definido mediante el <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, podría producirse un comportamiento incoherente.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">El comportamiento depende de si el ensamblado dinámico es persistente, es decir, se crea usando el <ph id="ph1">`RunAndSave`</ph> o <ph id="ph2">`Save`</ph> modos de acceso a la <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">Si el ensamblado dinámico es persistente y se ha escrito en el disco antes de <ph id="ph1">`GetType`</ph> es llama, el cargador busca el ensamblado guardado en disco, carga ese ensamblado y recupera el tipo de ese ensamblado.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si el ensamblado no se ha guardado en el disco cuando <ph id="ph1">`GetType`</ph> se llama, el método devuelve <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> no entiende los ensamblados dinámicos transitorios; por lo tanto, al llamar a <ph id="ph2">`GetType`</ph> para recuperar un tipo en un transitorio devuelve el ensamblado dinámico <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">Usar <ph id="ph1">`GetType`</ph> en un módulo dinámico, suscribirse a la <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> eventos y llame al método <ph id="ph3">`GetType`</ph> antes de guardar.</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">De lo contrario, obtendrá dos copias del ensamblado en la memoria.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated">El <ph id="ph1">`throwOnError`</ph> parámetro especifica lo que ocurre cuando no se encuentra el tipo y también suprime algunas condiciones de excepción, como se describe en la sección excepciones.</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">Algunas excepciones se producen independientemente del valor de <ph id="ph1">`throwOnError`</ph>.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Por ejemplo, si se encuentra el tipo pero no se puede cargar, un <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> se produce incluso si <ph id="ph2">`throwOnError`</ph> es <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">La siguiente tabla muestra qué miembros de una clase base se devuelven los <ph id="ph1">`Get`</ph> métodos cuando se reflejan en un tipo.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">Tipo de miembro</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Static</source>
          <target state="translated">Estático</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">No estáticos</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">Constructor</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Field</source>
          <target state="translated">Campo</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Un campo siempre es ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Event</source>
          <target state="translated">evento</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Sí.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Un método (virtual y no virtuales) pueden ocultar por nombre u ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">Tipo anidado</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">No es aplicable</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">La regla de sistema de tipo común es que la herencia es igual que la de los métodos que implementa la propiedad.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">La reflexión trata las propiedades como ocultar por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">Véase la nota 2.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devuelven tipos, tipos de parámetro, centinelas y las convenciones de llamada no administradas.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">Se trata de una comparación binaria.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Para la reflexión, propiedades y eventos están ocultos por nombre y firma.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Atributos personalizados no forman parte del sistema de tipos comunes.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">Las matrices o los tipos COM no se buscan, a menos que ya se han cargado en la tabla de clases disponibles.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> puede ser el nombre de tipo calificado por su espacio de nombres o un nombre calificado con el ensamblado que incluya una especificación de nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> incluye el espacio de nombres pero no el nombre del ensamblado, este método busca solo ensamblado del objeto que realiza la llamada y Mscorlib.dll, en ese orden.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">Si typeName es un nombre completo que incluye el nombre del ensamblado parcial o completo, este método busca en el ensamblado especificado.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">Si el ensamblado tiene un nombre seguro, se requiere un nombre de ensamblado completo.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedad devuelve un nombre de tipo completo, incluidos los tipos anidados, el nombre del ensamblado y los argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Todos los compiladores que admiten common language runtime emitirán el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando ejecute la consulta, con arreglo a las siguientes convenciones.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Por ejemplo, "ProcessorArchitecture = msil".</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Sin embargo, no se incluye en la cadena devuelta por la <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedad por motivos de compatibilidad.</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">También puede cargar tipos creando un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objeto y pasarla a una sobrecarga adecuada de la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> (método).</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">A continuación, puede usar el <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> método para cargar tipos del ensamblado.</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vea también <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">Delimitador</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">Significado</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Barra diagonal inversa (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">Carácter de escape.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">Acento grave (')</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">Precede a uno o más dígitos que representa el número de parámetros de tipo, situado al final del nombre de un tipo genérico.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">Corchetes ([])</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">Incluya una lista de argumentos de tipo genérico para un tipo genérico construido; dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">Coma (,)</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Precede al nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">Punto (.)</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Denota los identificadores de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">Signo más (+)</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">Precede a una clase anidada.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">Por ejemplo, el nombre completo para una clase podría ser similar al siguiente:</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Si el espacio de nombres fuera EspacioNombresPrincipal. Sub+EspacioNombres, la cadena tendría que ir delante del signo más (+) con un carácter de escape (<ph id="ph1">\\</ph>) para evitar que se interprete como un separador de anidamiento.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">La reflexión emite esta cadena como sigue:</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Este nombre completo puede se conserven y se utiliza posteriormente para cargar el <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Para buscar y cargar un <ph id="ph1">&lt;xref:System.Type&gt;</ph>, utilice <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> con el tipo de nombre sólo buscará la <ph id="ph2">&lt;xref:System.Type&gt;</ph> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> con el ensamblado de nombre de tipo calificado buscará la <ph id="ph2">&lt;xref:System.Type&gt;</ph> de cualquier ensamblado.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Para recuperar el nombre del tipo sin estos caracteres finales, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, donde <ph id="ph2">`t`</ph> es el tipo.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Los espacios son relevantes en todos los componentes de nombre de tipo excepto el nombre del ensamblado.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">En el nombre del ensamblado, los espacios delante del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">El nombre de un tipo genérico finaliza con un acento grave (<ph id="ph1">\`</ph>) seguido de dígitos que representa el número de argumentos de tipo genérico.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">El propósito de este nombre con sufijo es permitir que los compiladores admitir tipos genéricos con el mismo nombre pero con distintos números de parámetros de tipo, que se producen en el mismo ámbito.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">Por ejemplo, la reflexión devuelve los nombres alterados <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>tupla<ph id="ph3">`2`</ph> de los métodos genéricos <ph id="ph4">`Tuple(Of T)`</ph> y <ph id="ph5">`Tuple(Of T0, T1)`</ph> en Visual Basic, o <ph id="ph6">`Tuple&lt;T&gt;`</ph> y tupla<ph id="ph7">`\&lt;T0, T1&gt;`</ph> en Visual C#.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">Para los tipos genéricos, la lista de argumentos de tipo se incluye entre corchetes y los argumentos de tipo están separados por comas.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">Por ejemplo, un tipo genérico <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> tiene dos parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> de <ph id="ph2">`MyType`</ph> con claves de tipo <ph id="ph3">&lt;xref:System.String&gt;</ph> podría representarse como se indica a continuación:</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">Para especificar un tipo calificado con el ensamblado dentro de una lista de argumentos de tipo, incluya el tipo de ensamblado completo entre corchetes.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">De lo contrario, las comas que separan las partes del nombre completo de ensamblado se interpretan como delimitación de los argumentos de tipo adicionales.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">Por ejemplo, un <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> de <ph id="ph2">`MyType`</ph> en MyAssembly.dll, con claves de tipo <ph id="ph3">&lt;xref:System.String&gt;</ph>, se puede especificar como sigue:</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">Un tipo calificado con el ensamblado puede escribirse entre corchetes solo cuando aparece dentro de una lista de parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">Las reglas para buscar los ensamblados de tipos completos e incompletos en listas de parámetros de tipo son las mismas que las reglas para tipos no genéricos completos e incompletos.</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Tipos que aceptan valores NULL son un caso especial de tipos genéricos.</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">Por ejemplo, una que acepta valores NULL <ph id="ph1">&lt;xref:System.Int32&gt;</ph> representado por la cadena "System.Nullable'1[System.Int32"].</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">En C#, C++ y Visual Basic también puede obtener tipos que aceptan valores NULL mediante operadores de tipo.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">Por ejemplo, las que aceptan valores NULL <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> tipo devuelto por <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> en C#, por <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> en C++ y por <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> en Visual Basic.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">En la tabla siguiente se muestra la sintaxis que se usa con <ph id="ph1">`GetType`</ph> para varios tipos.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To Get</source>
          <target state="translated">Para obtener</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Use</source>
          <target state="translated">Usar</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Un que aceptan valores null <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Un puntero no administrado a <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Un puntero no administrado a un puntero a <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Un puntero administrado o una referencia a <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de los punteros, las referencias están limitadas a un nivel.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">Una clase principal y una clase anidada</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">Una matriz unidimensional con un límite inferior de 0</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">Una matriz unidimensional con un límite inferior desconocido</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">Una matriz de n dimensiones</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">Una coma (,) entre paréntesis un total de n-1 veces.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">Por ejemplo, <ph id="ph1">`System.Object[,,]`</ph> representa un tridimensional <ph id="ph2">`Object`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">La matriz de una matriz bidimensional</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">Una matriz bidimensional rectangular con límites inferiores desconocidos</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">Un tipo genérico con un argumento de tipo</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")'</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">Un tipo genérico con dos argumentos de tipo</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")'</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">Un tipo genérico con dos argumentos de tipo calificado por ensamblado</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">Un tipo genérico calificado con el ensamblado con un argumento de tipo calificado por ensamblado</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">Un tipo genérico cuyo argumento de tipo es un tipo genérico con dos argumentos de tipo</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador de clase y genera una excepción.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encuentra el tipo.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene caracteres no válidos, como una pestaña insertada.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> representa un tipo de matriz con un tamaño no válido.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa una matriz de <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene sintaxis no válida.</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">Por ejemplo: "MyType[,*,]".</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un tipo de puntero, un tipo <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> como uno de sus argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encontró el ensamblado o alguna de sus dependencias.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">El ensamblado o alguna de sus dependencias no son válidos.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">Actualmente, está cargada la versión 2.0 u otra posterior de Common Language Runtime pero el ensamblado se compiló con una versión posterior.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The name of the type to get.</source>
          <target state="translated">Nombre del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">Si se proporciona el parámetro <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept>, el nombre del tipo puede ser cualquier cadena que <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> pueda resolver.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Si se proporciona el parámetro <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> o se usa la resolución de tipos estándar, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> debe ser un nombre calificado con el ensamblado (vea <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), a menos que el tipo esté en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, en cuyo caso basta con aplicar el nombre de tipo calificado con su espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Método que busca y devuelve el ensamblado especificado en <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">El nombre del ensamblado se pasa a <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> como un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> no contiene el nombre de un ensamblado, no se llama a <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">Si no se proporciona <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>, se realiza la resolución de ensamblados estándar.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">Hacerlo podría tener como resultado la elevación de privilegios para el código malintencionado.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Use solo los métodos que proporciona o con los que está familiarizado.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">Método que busca y devuelve el tipo especificado por <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> del ensamblado devuelto por <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> o mediante la resolución de ensamblados estándar.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If no assembly is provided, the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> method can provide one.</source>
          <target state="translated">Si no se proporciona ningún ensamblado, el método <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> podrá proporcionar uno.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">El método también toma un parámetro que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas; se pasa <ph id="ph1">&lt;see langword="false" /&gt;</ph> a ese parámetro.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">Obtiene el tipo con el nombre especificado, que, de manera opcional, puede proporcionar métodos personalizados para resolver el ensamblado y el tipo.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The type with the specified name, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the type is not found.</source>
          <target state="translated">Tipo con el nombre especificado, o <ph id="ph1">&lt;see langword="null" /&gt;</ph> si no se encuentra el tipo.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Escenarios de uso para este método y los detalles sobre la <ph id="ph1">`assemblyResolver`</ph> y <ph id="ph2">`typeResolver`</ph> parámetros pueden encontrarse en el <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> no se encuentra, la llamada a la <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> método <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>It does not throw an exception.</source>
          <target state="translated">No se produce una excepción.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">Para controlar si se produce una excepción, llamar a una sobrecarga de la <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método que tiene un <ph id="ph2">`throwOnError`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`throwOnError`</ph> and <ph id="ph4">`ignoreCase`</ph> parameters.</source>
          <target state="translated">Llamar a esta sobrecarga del método es igual que llamar a la <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> sobrecarga del método y especificando <ph id="ph2">`false`</ph> para el <ph id="ph3">`throwOnError`</ph> y <ph id="ph4">`ignoreCase`</ph> parámetros.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador de clase y genera una excepción.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">Se produce un error cuando <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> se analiza en un nombre de tipo y un nombre de ensamblado (por ejemplo, cuando el nombre del tipo simple incluye un carácter especial sin escape).</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un tipo de puntero, un tipo <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> como uno de sus argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa una matriz de <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contiene un nombre de ensamblado no válido.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es un nombre de ensamblado válido sin un nombre de tipo.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">El ensamblado o alguna de sus dependencias no son válidos.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">Nombre del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">Si se proporciona el parámetro <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept>, el nombre del tipo puede ser cualquier cadena que <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> pueda resolver.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Si se proporciona el parámetro <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> o se usa la resolución de tipos estándar, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> debe ser un nombre calificado con el ensamblado (vea <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), a menos que el tipo esté en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, en cuyo caso basta con aplicar el nombre de tipo calificado con su espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Método que busca y devuelve el ensamblado especificado en <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">El nombre del ensamblado se pasa a <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> como un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> no contiene el nombre de un ensamblado, no se llama a <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">Si no se proporciona <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>, se realiza la resolución de ensamblados estándar.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">Hacerlo podría tener como resultado la elevación de privilegios para el código malintencionado.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Use solo los métodos que proporciona o con los que está familiarizado.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">Método que busca y devuelve el tipo especificado por <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> del ensamblado devuelto por <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> o mediante la resolución de ensamblados estándar.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">Si no se proporciona ningún ensamblado, el método podrá proporcionar uno.</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">El método también toma un parámetro que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas; se pasa <ph id="ph1">&lt;see langword="false" /&gt;</ph> a ese parámetro.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para producir una excepción si no se puede encontrar el tipo; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> para devolver <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Si se especifica <ph id="ph1">&lt;see langword="false" /&gt;</ph> se suprimen otras condiciones de excepción, pero no todas.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">Obtiene el tipo con el nombre indicado, que especifica si se va a iniciar una excepción en caso de que el tipo no se encuentre y que, de manera opcional, puede proporcionar métodos personalizados para resolver el ensamblado y el tipo.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Tipo con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Si el tipo no se encuentra, el parámetro <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> especifica si se devuelve <ph id="ph2">&lt;see langword="null" /&gt;</ph> o se produce una excepción.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">En algunos casos, se produce una excepción con independencia del valor de <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Escenarios de uso para este método y los detalles sobre la <ph id="ph1">`assemblyResolver`</ph> y <ph id="ph2">`typeResolver`</ph> parámetros pueden encontrarse en el <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`ignoreCase`</ph> parameter.</source>
          <target state="translated">Llamar a esta sobrecarga del método es igual que llamar a la <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> sobrecarga del método y especificando <ph id="ph2">`false`</ph> para el <ph id="ph3">`ignoreCase`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador de clase y genera una excepción.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encuentra el tipo.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene caracteres no válidos, como una pestaña insertada.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> representa un tipo de matriz con un tamaño no válido.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa una matriz de <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">Se produce un error cuando <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> se analiza en un nombre de tipo y un nombre de ensamblado (por ejemplo, cuando el nombre del tipo simple incluye un carácter especial sin escape).</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene la sintaxis no válida (por ejemplo, "MyType [, *,]").</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un tipo de puntero, un tipo <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> como uno de sus argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encontró el ensamblado o alguna de sus dependencias.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contiene un nombre de ensamblado no válido.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es un nombre de ensamblado válido sin un nombre de tipo.</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">El ensamblado o alguna de sus dependencias no son válidos.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">Nombre del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">Si se proporciona el parámetro <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept>, el nombre del tipo puede ser cualquier cadena que <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> pueda resolver.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Si se proporciona el parámetro <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> o se usa la resolución de tipos estándar, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> debe ser un nombre calificado con el ensamblado (vea <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), a menos que el tipo esté en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, en cuyo caso basta con aplicar el nombre de tipo calificado con su espacio de nombres.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Método que busca y devuelve el ensamblado especificado en <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">El nombre del ensamblado se pasa a <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> como un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">Si <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> no contiene el nombre de un ensamblado, no se llama a <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">Si no se proporciona <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>, se realiza la resolución de ensamblados estándar.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">Hacerlo podría tener como resultado la elevación de privilegios para el código malintencionado.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Use solo los métodos que proporciona o con los que está familiarizado.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">Método que busca y devuelve el tipo especificado por <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> del ensamblado devuelto por <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> o mediante la resolución de ensamblados estándar.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">Si no se proporciona ningún ensamblado, el método podrá proporcionar uno.</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept> is passed to that parameter.</source>
          <target state="translated">El método también toma un parámetro que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas; se pasa el valor de <bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept> a ese parámetro.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para producir una excepción si no se puede encontrar el tipo; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> para devolver <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Si se especifica <ph id="ph1">&lt;see langword="false" /&gt;</ph> se suprimen otras condiciones de excepción, pero no todas.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para realizar una búsqueda de <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> que no distinga entre mayúsculas y minúsculas; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para realizar una búsqueda de <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> que distinga entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">Obtiene el tipo con el nombre indicado, que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas y si se va a iniciar una excepción en caso de que el tipo no se encuentre y que, de manera opcional, puede proporcionar métodos personalizados para resolver el ensamblado y el tipo.</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Tipo con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Si el tipo no se encuentra, el parámetro <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> especifica si se devuelve <ph id="ph2">&lt;see langword="null" /&gt;</ph> o se produce una excepción.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">En algunos casos, se produce una excepción con independencia del valor de <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use this method overload and its associated overloads (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) to replace the default implementation of the <ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph> method with more flexible implementations.</source>
          <target state="translated">Utilice esta sobrecarga del método y sus sobrecargas asociadas (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> y <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) para reemplazar la implementación predeterminada de la <ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph> método con las implementaciones más flexibles.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</source>
          <target state="translated">Al proporcionar sus propios métodos que resuelven los nombres de tipo y los nombres de los ensamblados que contienen, puede hacer lo siguiente:</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Control which version of an assembly a type is loaded from.</source>
          <target state="translated">Controlar qué versión de un ensamblado se carga un tipo de.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Provide another place to look for a type name that does not include an assembly name.</source>
          <target state="translated">Proporcione otra ubicación para buscar un nombre de tipo que no incluya un nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Load assemblies using partial assembly names.</source>
          <target state="translated">Cargar ensamblados con nombres de ensamblado parciales.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the common language runtime (CLR).</source>
          <target state="translated">Devolver las subclases de <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> que no se crean por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</source>
          <target state="translated">Por ejemplo, en la serialización tolerante a versiones este método le permite buscar un ensamblado "ajuste perfecto" con un nombre parcial.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Other overloads of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method require an assembly-qualified type name, which includes the version number.</source>
          <target state="translated">Otras sobrecargas de la <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método requiere un nombre de tipo calificado por ensamblado, que incluye el número de versión.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Alternate implementations of the type system may need to return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the CLR; all types that are returned by other overloads of the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method are runtime types.</source>
          <target state="translated">Implementaciones alternativas del sistema de tipos pueden necesitar devolver subclases de <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> que no se crean mediante CLR; todos los tipos que son devueltos por otras sobrecargas de la <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> método son tipos de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Usage Notes</source>
          <target state="translated">Notas de uso</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method overload and its associated overloads parse <ph id="ph1">`typeName`</ph> into the name of a type and the name of an assembly, and then resolve the names.</source>
          <target state="translated">Esta sobrecarga del método y sus sobrecargas asociadas analizar <ph id="ph1">`typeName`</ph> en el nombre de un tipo y el nombre de un ensamblado y, a continuación, resolver los nombres.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</source>
          <target state="translated">Resolución del nombre del ensamblado se produce antes de la resolución del nombre de tipo, porque un nombre de tipo se debe resolver en el contexto de un ensamblado.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you are unfamiliar with the concept of assembly-qualified type names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property.</source>
          <target state="translated">Si no está familiarizado con el concepto de nombres de tipo calificado por ensamblado, consulte el <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is not an assembly-qualified name, assembly resolution is skipped.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> no es un nombre calificado con el ensamblado, se omite la resolución de ensamblados.</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the <ph id="ph1">`typeResolver`</ph> parameter.</source>
          <target state="translated">Nombres de tipo incompletos se pueden resolver en el contexto de Mscorlib.dll o el ensamblado que se ejecuta actualmente o puede proporcionar opcionalmente un ensamblado en el <ph id="ph1">`typeResolver`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section.</source>
          <target state="translated">Los efectos de incluir u omitir el nombre del ensamblado de tipos diferentes de resolución de nombres se muestran como una tabla en la <bpt id="p1">[</bpt>resolución de nombre mixto<ept id="p1">](#mixed_name_resolution)</ept> sección.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>General usage notes:</source>
          <target state="translated">Notas de uso general:</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Do not pass methods to <ph id="ph1">`assemblyResolver`</ph> or <ph id="ph2">`typeResolver`</ph> if they come from unknown or untrusted callers.</source>
          <target state="translated">No pase métodos a <ph id="ph1">`assemblyResolver`</ph> o <ph id="ph2">`typeResolver`</ph> si proceden de llamadores desconocidos o que no se confía.</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Use solo los métodos que proporciona o con los que está familiarizado.</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</source>
          <target state="translated">Uso de métodos de llamadores desconocidos o que no se confía podrían elevación de privilegios para el código malintencionado.</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you omit the <ph id="ph1">`assemblyResolver`</ph> and/or <ph id="ph2">`typeResolver`</ph> parameters, the value of the <ph id="ph3">`throwOnError`</ph> parameter is passed to the methods that perform the default resolution.</source>
          <target state="translated">Si se omite la <ph id="ph1">`assemblyResolver`</ph> o <ph id="ph2">`typeResolver`</ph> parámetros, el valor de la <ph id="ph3">`throwOnError`</ph> parámetro se pasa a los métodos que realizan la resolución predeterminada.</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`throwOnError`</ph> is <ph id="ph2">`true`</ph>, this method throws a <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> when <ph id="ph4">`typeResolver`</ph> returns <ph id="ph5">`null`</ph>, and a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> when <ph id="ph7">`assemblyResolver`</ph> returns <ph id="ph8">`null`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`throwOnError`</ph> es <ph id="ph2">`true`</ph>, este método produce una <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> cuando <ph id="ph4">`typeResolver`</ph> devuelve <ph id="ph5">`null`</ph>y un <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> cuando <ph id="ph7">`assemblyResolver`</ph> devuelve <ph id="ph8">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method does not catch exceptions thrown by <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">Este método no detecta las excepciones producidas por <ph id="ph1">`assemblyResolver`</ph> y <ph id="ph2">`typeResolver`</ph>.</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You are responsible for any exceptions that are thrown by the resolver methods.</source>
          <target state="translated">Usted es responsable de las excepciones producidas por los métodos de resolución.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Assemblies</source>
          <target state="translated">Resolver ensamblados</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method receives an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, which is produced by parsing the string assembly name that is included in <ph id="ph3">`typeName`</ph>.</source>
          <target state="translated">El <ph id="ph1">`assemblyResolver`</ph> método recibe un <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objeto, que está formado por el nombre de ensamblado de cadena que se incluye en el análisis <ph id="ph3">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not contain an assembly name, <ph id="ph2">`assemblyResolver`</ph> is not called and <ph id="ph3">`null`</ph> is passed to <ph id="ph4">`typeResolver`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> no contiene un nombre de ensamblado, <ph id="ph2">`assemblyResolver`</ph> no se llama y <ph id="ph3">`null`</ph> se pasa a <ph id="ph4">`typeResolver`</ph>.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is not supplied, standard assembly probing is used to locate the assembly.</source>
          <target state="translated">Si <ph id="ph1">`assemblyResolver`</ph> no es estándar, proporcionado ensamblado sondeo se usa para buscar el ensamblado.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method does not do standard probing; in that case you must ensure that your <ph id="ph3">`assemblyResolver`</ph> can handle all the assemblies you pass to it.</source>
          <target state="translated">Si <ph id="ph1">`assemblyResolver`</ph> se proporciona, el <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> método realiza la búsqueda estándar; en ese caso debe asegurarse de que su <ph id="ph3">`assemblyResolver`</ph> puede administrar todos los ensamblados que se pasa a él.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method should return <ph id="ph2">`null`</ph> if the assembly cannot be resolved.</source>
          <target state="translated">El <ph id="ph1">`assemblyResolver`</ph> método debe devolver <ph id="ph2">`null`</ph> si no se puede resolver el ensamblado.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called and no further processing occurs; additionally, if <ph id="ph4">`throwOnError`</ph> is <ph id="ph5">`true`</ph>, a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Si <ph id="ph1">`assemblyResolver`</ph> devuelve <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> no se llama y no se realiza ningún procesamiento adicional; además, si <ph id="ph4">`throwOnError`</ph> es <ph id="ph5">`true`</ph>, un <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> se produce.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> that is passed to <ph id="ph2">`assemblyResolver`</ph> is a partial name, one or more of its parts are <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> que se pasa a <ph id="ph2">`assemblyResolver`</ph> es un partial nombre, uno o más de sus partes son <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if it has no version, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Por ejemplo, si no tiene ninguna versión, el <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> propiedad es <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> property, and the <ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> method all return <ph id="ph4">`null`</ph>, then only the simple name of the assembly was supplied.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> propiedad, el <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> propiedad y el <ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> método devuelven <ph id="ph4">`null`</ph>, a continuación, se proporciona solo el nombre simple del ensamblado.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method can use or ignore all parts of the assembly name.</source>
          <target state="translated">El <ph id="ph1">`assemblyResolver`</ph> método podrá utilizar u omitir todas las partes del nombre del ensamblado.</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different assembly resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">Los efectos de las opciones de resolución de ensamblado diferentes se muestran como una tabla en la <bpt id="p1">[</bpt>resolución de nombre mixto<ept id="p1">](#mixed_name_resolution)</ept> sección para nombres de tipo simple y ensamblado.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Types</source>
          <target state="translated">Resolución de tipos</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not specify an assembly name, <ph id="ph2">`typeResolver`</ph> is always called.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> no especifica un nombre de ensamblado, <ph id="ph2">`typeResolver`</ph> siempre se llama.</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> specifies an assembly name, <ph id="ph2">`typeResolver`</ph> is called only when the assembly name is successfully resolved.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> especifica un nombre de ensamblado, <ph id="ph2">`typeResolver`</ph> se llama solo cuando se ha resuelto correctamente el nombre del ensamblado.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> or standard assembly probing returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called.</source>
          <target state="translated">Si <ph id="ph1">`assemblyResolver`</ph> o ensamblados estándar sondeo devuelve <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> , no se llama.</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method receives three arguments:</source>
          <target state="translated">El <ph id="ph1">`typeResolver`</ph> método recibe tres argumentos:</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly to search or <ph id="ph1">`null`</ph> if <ph id="ph2">`typeName`</ph> does not contain an assembly name.</source>
          <target state="translated">El ensamblado que se va a buscar o <ph id="ph1">`null`</ph> si <ph id="ph2">`typeName`</ph> no contiene un nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The simple name of the type.</source>
          <target state="translated">El nombre simple del tipo.</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a nested type, this is the outermost containing type.</source>
          <target state="translated">En el caso de un tipo anidado, éste es el tipo contenedor más externo.</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a generic type, this is the simple name of the generic type.</source>
          <target state="translated">En el caso de un tipo genérico, este es el nombre simple del tipo genérico.</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A Boolean value that is <ph id="ph1">`true`</ph> if the case of type names is to be ignored.</source>
          <target state="translated">Un valor booleano que es <ph id="ph1">`true`</ph> si es el caso de nombres de tipo que se pasen por alto.</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The implementation determines the way these arguments are used.</source>
          <target state="translated">La implementación determina la manera en que se emplean estos argumentos.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method should return <ph id="ph2">`null`</ph> if it cannot resolve the type.</source>
          <target state="translated">El <ph id="ph1">`typeResolver`</ph> método debe devolver <ph id="ph2">`null`</ph> si no se puede resolver el tipo.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeResolver`</ph> returns <ph id="ph2">`null`</ph> and <ph id="ph3">`throwOnError`</ph> is <ph id="ph4">`true`</ph>, this overload of <ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`typeResolver`</ph> devuelve <ph id="ph2">`null`</ph> y <ph id="ph3">`throwOnError`</ph> es <ph id="ph4">`true`</ph>, esta sobrecarga de <ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph> produce una <ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different type resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">Los efectos de las opciones de resolución de tipo diferentes se muestran como una tabla en la <bpt id="p1">[</bpt>resolución de nombre mixto<ept id="p1">](#mixed_name_resolution)</ept> sección para nombres de tipo simple y ensamblado.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Nested Types</source>
          <target state="translated">Resolución de tipos anidados</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is a nested type, only the name of the outermost containing type is passed to <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`typeName`</ph> es un tipo anidado, solo el nombre del exterior que contiene el tipo se pasa a <ph id="ph2">`typeResolver`</ph>.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>When <ph id="ph1">`typeResolver`</ph> returns this type, the <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> method is called recursively until the innermost nested type has been resolved.</source>
          <target state="translated">Cuando <ph id="ph1">`typeResolver`</ph> devuelve este tipo, el <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> método se llama de forma recursiva hasta que se ha resuelto el tipo anidado más interno.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Generic Types</source>
          <target state="translated">Resolución de tipos genéricos</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> se llama de forma recursiva para resolver tipos genéricos: primero para resolver el tipo genérico y después se resuelven sus argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a type argument is generic, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve its type arguments, and so on.</source>
          <target state="translated">Si un argumento de tipo es genérico, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> se llama de forma recursiva para resolver sus argumentos de tipo y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The combination of <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> that you provide must be capable of resolving all levels of this recursion.</source>
          <target state="translated">La combinación de <ph id="ph1">`assemblyResolver`</ph> y <ph id="ph2">`typeResolver`</ph> que proporcione debe ser capaz de resolver todos los niveles de esta recursividad.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, suppose you supply an <ph id="ph1">`assemblyResolver`</ph> that controls the loading of <ph id="ph2">`MyAssembly`</ph>.</source>
          <target state="translated">Por ejemplo, suponga que proporciona un <ph id="ph1">`assemblyResolver`</ph> que controla la carga de <ph id="ph2">`MyAssembly`</ph>.</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Suppose you want to resolve the generic type <ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id="ph2">`Dictionary(Of String, MyType)`</ph> in Visual Basic).</source>
          <target state="translated">Imagine que desea resolver el tipo genérico <ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id="ph2">`Dictionary(Of String, MyType)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You might pass the following generic type name:</source>
          <target state="translated">Se puede pasar el nombre de tipo genérico siguiente:</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Notice that <ph id="ph1">`MyType`</ph> is the only assembly-qualified type argument.</source>
          <target state="translated">Tenga en cuenta que <ph id="ph1">`MyType`</ph> es el argumento de tipo calificado por ensamblado solo.</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The names of the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph2">&lt;xref:System.String&gt;</ph> classes are not assembly-qualified.</source>
          <target state="translated">Los nombres de los <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> y <ph id="ph2">&lt;xref:System.String&gt;</ph> clases no están calificado con el ensamblado.</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Your <ph id="ph1">`typeResolver`</ph> must be able handle either an assembly or <ph id="ph2">`null`</ph>, because it will receive <ph id="ph3">`null`</ph> for <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Su <ph id="ph1">`typeResolver`</ph> debe controlar ya sea un ensamblado o <ph id="ph2">`null`</ph>, ya que recibirá una excepción <ph id="ph3">`null`</ph> para <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> y <ph id="ph5">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>It can handle that case by calling an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</source>
          <target state="translated">Puede administrar ese caso llamando a una sobrecarga de la <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método que toma una cadena, porque ambos de los nombres de tipo incompletos están en Mscorlib.dll:</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</source>
          <target state="translated">El <ph id="ph1">`assemblyResolver`</ph> método no se llama para el tipo de diccionario y el tipo de cadena, porque esos nombres de tipo no están calificado con el ensamblado.</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Now suppose that instead of <ph id="ph1">`System.String`</ph>, the first generic argument type is <ph id="ph2">`YourType`</ph>, from <ph id="ph3">`YourAssembly`</ph>:</source>
          <target state="translated">Ahora suponga que en lugar de <ph id="ph1">`System.String`</ph>, el primer tipo de argumento genérico es <ph id="ph2">`YourType`</ph>, de <ph id="ph3">`YourAssembly`</ph>:</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve <ph id="ph1">`YourType`</ph> without an assembly-qualified name.</source>
          <target state="translated">Dado que este ensamblado es ni Mscorlib.dll ni el ensamblado que se ejecuta actualmente, no se puede resolver <ph id="ph1">`YourType`</ph> no tiene un nombre calificado con el ensamblado.</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because your <ph id="ph1">`assemblyResolve`</ph> will be called recursively, it must be able to handle this case.</source>
          <target state="translated">Dado que su <ph id="ph1">`assemblyResolve`</ph> será llama de forma recursiva, debe ser capaz de tratar este caso.</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Instead of returning <ph id="ph1">`null`</ph> for assemblies other than <ph id="ph2">`MyAssembly`</ph>, it now performs an assembly load using the supplied <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object.</source>
          <target state="translated">En lugar de devolver <ph id="ph1">`null`</ph> ensamblados distinto <ph id="ph2">`MyAssembly`</ph>, ahora se realiza una carga de ensamblado con el <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">Volver a <bpt id="p1">[</bpt>notas de uso<ept id="p1">](#usage_notes)</ept>.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Type Names with Special Characters</source>
          <target state="translated">Resolución de nombres de tipo con caracteres especiales</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Certain characters have special meanings in assembly-qualified names.</source>
          <target state="translated">Ciertos caracteres tienen significados especiales en los nombres de ensamblado.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</source>
          <target state="translated">Si un nombre de tipo simple contiene estos caracteres, los caracteres producen errores de análisis cuando el nombre sencillo forma parte de un nombre calificado con el ensamblado.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">Para evitar los errores del análisis, debe indicar los caracteres especiales con una barra diagonal inversa antes de pasar el nombre calificado con el ensamblado a la <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if a type is named <ph id="ph1">`Strange]Type`</ph>, the escape character must be added ahead of the square bracket as follows: <ph id="ph2">`Strange\]Type`</ph>.</source>
          <target state="translated">Por ejemplo, si un tipo se denomina <ph id="ph1">`Strange]Type`</ph>, debe agregarse el carácter de escape delante del corchete como sigue: <ph id="ph2">`Strange\]Type`</ph>.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</source>
          <target state="translated">Los nombres con estos caracteres especiales no se puede crear en Visual Basic o C#, pero pueden crearse mediante el lenguaje intermedio de Microsoft (MSIL) o emitir ensamblados dinámicos.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table shows the special characters for type names.</source>
          <target state="translated">La tabla siguiente muestran los caracteres especiales para nombres de tipo.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Character</source>
          <target state="translated">Carácter</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">Significado</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`,`</ph> (comma)</source>
          <target state="translated"><ph id="ph1">`,`</ph> (coma)</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for assembly-qualified names.</source>
          <target state="translated">Delimitador para los nombres de ensamblado.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`[]`</ph> (square brackets)</source>
          <target state="translated"><ph id="ph1">`[]`</ph> (corchetes)</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</source>
          <target state="translated">Como un par de sufijo, indica un tipo de matriz; como un par de delimitador, agrega listas de argumentos genéricas y nombres calificados con el ensamblado.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`&amp;`</ph> (ampersand)</source>
          <target state="translated"><ph id="ph1">`&amp;`</ph> (y comercial)</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a reference type.</source>
          <target state="translated">Como sufijo, indica que un tipo es un tipo de referencia.</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`*`</ph> (asterisk)</source>
          <target state="translated"><ph id="ph1">`*`</ph> (asterisco)</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a pointer type.</source>
          <target state="translated">Como sufijo, indica que un tipo es un tipo de puntero.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`+`</ph> (plus)</source>
          <target state="translated"><ph id="ph1">`+`</ph> (signo más)</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for nested types.</source>
          <target state="translated">Delimitador para los tipos anidados.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`\`</ph> (backslash)</source>
          <target state="translated"><ph id="ph1">`\`</ph> (barra diagonal inversa)</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">Carácter de escape.</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Properties such as <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> return correctly escaped strings.</source>
          <target state="translated">Propiedades como <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> devuelto correctamente las cadenas de caracteres de escape.</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You must pass correctly escaped strings to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">Debe pasar correctamente cadenas de escape para el <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In turn, the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method passes correctly escaped names to <ph id="ph2">`typeResolver`</ph> and to the default type resolution methods.</source>
          <target state="translated">A su vez, el <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> método pasa los nombres de escape correctamente a <ph id="ph2">`typeResolver`</ph> y a los métodos de resolución de tipo predeterminado.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you need to compare a name to an unescaped name in <ph id="ph1">`typeResolver`</ph>, you must remove the escape characters.</source>
          <target state="translated">Si necesita comparar un nombre con un nombre sin escape en <ph id="ph1">`typeResolver`</ph>, debe quitar los caracteres de escape.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">Volver a <bpt id="p1">[</bpt>notas de uso<ept id="p1">](#usage_notes)</ept>.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Mixed Name Resolution</source>
          <target state="translated">Resolución de nombres mixta</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table summarizes the interactions between <ph id="ph1">`assemblyResolver`</ph>, <ph id="ph2">`typeResolver`</ph>, and default name resolution, for all combinations of type name and assembly name in <ph id="ph3">`typeName`</ph>:</source>
          <target state="translated">En la tabla siguiente se resume las interacciones entre <ph id="ph1">`assemblyResolver`</ph>, <ph id="ph2">`typeResolver`</ph>y resolución de nombres de forma predeterminada, para todas las combinaciones de nombre de tipo y nombre del ensamblado <ph id="ph3">`typeName`</ph>:</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Contents of type name</source>
          <target state="translated">Contenido de nombre de tipo</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Assembly resolver method</source>
          <target state="translated">Método de resolución de ensamblado</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Type resolver method</source>
          <target state="translated">Método de resolución de tipo</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Result</source>
          <target state="translated">Resultado</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">tipo de ensamblado</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">nulo</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">nulo</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Equivalente a llamar a la <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">tipo de ensamblado</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">Proporciona</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">nulo</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Devuelve el ensamblado o devuelve <ph id="ph2">`null`</ph> si no se puede resolver el ensamblado.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</source>
          <target state="translated">Si el ensamblado se ha resuelto, el <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método se usa para cargar el tipo del ensamblado; en caso contrario, no hay ningún intento para resolver el tipo.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">tipo de ensamblado</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">nulo</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">Proporciona</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to converting the assembly name to an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph> method overload to get the assembly.</source>
          <target state="translated">Equivalente a convertir el nombre del ensamblado a un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> objeto y llamar a la <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método para obtener el ensamblado.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">Si el ensamblado se resuelve, se pasa a <ph id="ph1">`typeResolver`</ph>; en caso contrario, <ph id="ph2">`typeResolver`</ph> no se llama y no hay ningún intento adicional para resolver el tipo.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">tipo de ensamblado</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">Proporciona</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">Proporciona</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Devuelve el ensamblado o devuelve <ph id="ph2">`null`</ph> si no se puede resolver el ensamblado.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">Si el ensamblado se resuelve, se pasa a <ph id="ph1">`typeResolver`</ph>; en caso contrario, <ph id="ph2">`typeResolver`</ph> no se llama y no hay ningún intento adicional para resolver el tipo.</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">type</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">null, proporcionado</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">nulo</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Equivalente a llamar a la <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</source>
          <target state="translated">Porque no se proporcionó el nombre del ensamblado, se buscan sólo Mscorlib.dll y ensamblado actualmente en ejecución.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">Si <ph id="ph1">`assemblyResolver`</ph> es siempre se omite.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">type</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">null, proporcionado</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">Proporciona</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> is called, and <ph id="ph2">`null`</ph> is passed for the assembly.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> se llama a, y <ph id="ph2">`null`</ph> se pasa para el ensamblado.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> can provide a type from any assembly, including assemblies it loads for the purpose.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> puede proporcionar un tipo de cualquier ensamblado, incluidos los ensamblados que se carga para el propósito.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">Si <ph id="ph1">`assemblyResolver`</ph> es siempre se omite.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>assembly</source>
          <target state="translated">ensamblado</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">null, proporcionado</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">null, proporcionado</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> se produce porque el nombre del ensamblado se analiza como si fuera un nombre de tipo calificado con el ensamblado.</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This results in an invalid assembly name.</source>
          <target state="translated">Esto da como resultado un nombre de ensamblado no válido.</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to: <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>, <bpt id="p2">[</bpt>Resolving Assemblies<ept id="p2">](#resolving_assemblies)</ept>, <bpt id="p3">[</bpt>Resolving Types<ept id="p3">](#resolving_types)</ept>.</source>
          <target state="translated">Volver a: <bpt id="p1">[</bpt>notas de uso<ept id="p1">](#usage_notes)</ept>, <bpt id="p2">[</bpt>resolver ensamblados<ept id="p2">](#resolving_assemblies)</ept>, <bpt id="p3">[</bpt>resolver los tipos<ept id="p3">](#resolving_types)</ept>.</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador de clase y genera una excepción.</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encuentra el tipo.</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene caracteres no válidos, como una pestaña insertada.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> representa un tipo de matriz con un tamaño no válido.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa una matriz de <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">Se produce un error cuando <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> se analiza en un nombre de tipo y un nombre de ensamblado (por ejemplo, cuando el nombre del tipo simple incluye un carácter especial sin escape).</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene la sintaxis no válida (por ejemplo, "MyType [, *,]").</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un tipo de puntero, un tipo <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> como uno de sus argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encontró el ensamblado o alguna de sus dependencias.</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contiene un nombre de ensamblado no válido.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es un nombre de ensamblado válido sin un nombre de tipo.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">El ensamblado o alguna de sus dependencias no son válidos.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of objects whose types to determine.</source>
          <target state="translated">Matriz de objetos cuyos tipos se han de determinar.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>Gets the types of the objects in the specified array.</source>
          <target state="translated">Obtiene los tipos de los objetos de la matriz especificada.</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the types of the corresponding elements in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa todos los tipos de los elementos correspondientes de <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method to list the types of the elements of an array.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> método para enumerar los tipos de los elementos de una matriz.</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>One or more of the elements in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios elementos de <ph id="ph1">&lt;paramref name="args" /&gt;</ph> son <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The class initializers are invoked and at least one throws an exception.</source>
          <target state="translated">Se invocan los inicializadores de clase y al menos uno genera una excepción.</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The type whose underlying type code to get.</source>
          <target state="translated">Tipo cuyo código de tipo subyacente se debe obtener.</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>Gets the underlying type code of the specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene el código de tipo subyacente del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The code of the underlying type, or <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Código de tipo subyacente o <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph> si <ph id="ph2">&lt;paramref name="type" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can change the behavior of this method by overriding the <ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> method.</source>
          <target state="translated">Al heredar de <ph id="ph1">&lt;xref:System.Type&gt;</ph>, puede cambiar el comportamiento de este método invalidando el <ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The following code example demonstrates how the <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> enumeration can be used.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo el <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> pueden usar la enumeración.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>In a decision block inside the <ph id="ph1">`WriteObjectInfo`</ph> method, the <ph id="ph2">&lt;xref:System.TypeCode&gt;</ph> of an <ph id="ph3">&lt;xref:System.Object&gt;</ph> parameter is examined, and an appropriate message is written to the console.</source>
          <target state="translated">En un bloque de decisión dentro de la <ph id="ph1">`WriteObjectInfo`</ph> método, el <ph id="ph2">&lt;xref:System.TypeCode&gt;</ph> de un <ph id="ph3">&lt;xref:System.Object&gt;</ph> parámetro se examina y se escribe un mensaje adecuado en la consola.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>Returns the underlying type code of this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> instance.</source>
          <target state="translated">Devuelve el código de tipo subyacente de esta instancia de <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>The type code of the underlying type.</source>
          <target state="translated">Código de tipo del tipo subyacente.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>This method provides the implementation for the <ph id="ph1">`static`</ph> (in C#) or <ph id="ph2">`Shared`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> method.</source>
          <target state="translated">Este método proporciona la implementación para la <ph id="ph1">`static`</ph> (en C#) o <ph id="ph2">`Shared`</ph> (en Visual Basic) <ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can override this method to provide your own implementation of <ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.</source>
          <target state="translated">Al heredar de <ph id="ph1">&lt;xref:System.Type&gt;</ph>, puede invalidar este método para proporcionar su propia implementación de <ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">Obtiene el tipo asociado al identificador de clase especificado (CLSID).</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Identificador CLSID del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">Obtiene el tipo asociado al identificador de clase especificado (CLSID).</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> independientemente de que CLSID sea válido.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> método es compatible con acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Puede recuperar el valor de la <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> propiedad para determinar si el tipo devuelto por este método es un objeto COM.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Puede llamar a la <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) conoce.</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">Crear instancias de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the<ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Obtener un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa el<ph id="ph2">`__ComObject`</ph> que se corresponde con el CLSID mediante una llamada a la <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> método para crear una instancia del objeto COM.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>See the example for an illustration.</source>
          <target state="translated">Vea el ejemplo para ver una ilustración.</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> overload ignores any exception that may occur when instantiating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object based on the <ph id="ph3">`clsid`</ph> argument.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> sobrecarga pasa por alto cualquier excepción que se puede producir al crear instancias de un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto basado en la <ph id="ph3">`clsid`</ph> argumento.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Note that no exception is thrown if <ph id="ph1">`clsid`</ph> is not found in the registry.</source>
          <target state="translated">Tenga en cuenta que se inicia ninguna excepción si <ph id="ph1">`clsid`</ph> no se encuentra en el registro.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">En el ejemplo siguiente se usa el CLSID de Microsoft Word <bpt id="p1">[</bpt>objeto Application<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> para recuperar un tipo COM que representa la aplicación Microsoft Word.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">A continuación, crea una instancia del tipo mediante una llamada a la <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> método y cierra mediante una llamada a la <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> (método).</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework.</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Todos los objetos administrados, los que son visibles para COM incluidos (es decir, su <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> atributo es <ph id="ph2">&lt;see langword="true" /&gt;</ph>) tiene un GUID que es devuelto por la <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Aunque el método devuelve un <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objetos de objeto que se corresponde con el GUID de .NET Framework, no puede usar dicha <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> objeto que se va a crear una instancia de tipo mediante una llamada a la <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> método, tal como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">En su lugar, el <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> solo debe usarse para recuperar el GUID de un objeto COM no administrado y resultante <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> objeto que se pasa a la <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> el método debe representar un objeto COM no administrado.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Identificador CLSID del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para producir cualquier excepción que se genere.</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> para pasar por alto cualquier excepción que se produzca.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Obtiene el tipo asociado al identificador de clase (CLSID) especificado, que debe indicar si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> independientemente de que CLSID sea válido.</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> método es compatible con acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro.</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Puede recuperar el valor de la <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> propiedad para determinar si el tipo devuelto por este método es un objeto COM.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Puede llamar a la <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) conoce.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">Crear instancias de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Obtener un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa el <ph id="ph2">`__ComObject`</ph> que se corresponde con el CLSID mediante una llamada a la <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> método para crear una instancia del objeto COM.</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>See the example for an illustration.</source>
          <target state="translated">Vea el ejemplo para ver una ilustración.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">Las excepciones como <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> se producirá cuando se especifica <ph id="ph2">`true`</ph> para <ph id="ph3">`throwOnError`</ph>, pero no se producirá ningún error para identificadores CLSID no registrados.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">En el ejemplo siguiente se usa el CLSID de Microsoft Word <bpt id="p1">[</bpt>objeto Application<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> para recuperar un tipo COM que representa la aplicación Microsoft Word.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">A continuación, crea una instancia del tipo mediante una llamada a la <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> método y cierra mediante una llamada a la <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> (método).</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">Se produce una excepción si se produce un error al cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Todos los objetos administrados, los que son visibles para COM incluidos (es decir, su <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> atributo es <ph id="ph2">&lt;see langword="true" /&gt;</ph>) tiene un GUID que es devuelto por la <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Aunque el método devuelve un <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objetos de objeto que se corresponde con el GUID de .NET Framework, no puede usar dicha <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> objeto que se va a crear una instancia de tipo mediante una llamada a la <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> método, tal como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">En su lugar, el <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> solo debe usarse para recuperar el GUID de un objeto COM no administrado y resultante <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> objeto que se pasa a la <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> el método debe representar un objeto COM no administrado.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Identificador CLSID del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">Servidor desde el que se va a cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Si el nombre de servidor es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, el resultado que el método devuelve automáticamente es el equipo local.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server.</source>
          <target state="translated">Obtiene el tipo asociado al identificador de clase (CLSID) especificado desde el servidor especificado.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> independientemente de que CLSID sea válido.</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> método es compatible con acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro.</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Puede recuperar el valor de la <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> propiedad para determinar si el tipo devuelto por este método es un objeto COM.</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Puede llamar a la <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) conoce.</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">Crear instancias de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Obtener un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa el <ph id="ph2">`__ComObject`</ph> que se corresponde con el CLSID mediante una llamada a la <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> método para crear una instancia del objeto COM.</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">En el ejemplo siguiente se usa el CLSID de Microsoft Word <bpt id="p1">[</bpt>objeto Application<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> para recuperar un tipo COM que representa la aplicación Microsoft Word desde un servidor llamado computer17.central.contoso.com. A continuación, crea una instancia del tipo mediante una llamada a la <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> método y cierra mediante una llamada a la <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> (método).</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Todos los objetos administrados, los que son visibles para COM incluidos (es decir, su <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> atributo es <ph id="ph2">&lt;see langword="true" /&gt;</ph>) tiene un GUID que es devuelto por la <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Aunque el método devuelve un <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objetos de objeto que se corresponde con el GUID de .NET Framework, no puede usar dicha <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> objeto que se va a crear una instancia de tipo mediante una llamada a la <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> método, tal como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">En su lugar, el <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> solo debe usarse para recuperar el GUID de un objeto COM no administrado y resultante <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> objeto que se pasa a la <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> el método debe representar un objeto COM no administrado.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Identificador CLSID del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">Servidor desde el que se va a cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Si el nombre de servidor es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, el resultado que el método devuelve automáticamente es el equipo local.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para producir cualquier excepción que se genere.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> para pasar por alto cualquier excepción que se produzca.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Obtiene el tipo asociado al identificador de clase (CLSID) indicado desde el servidor especificado y debe indicarse si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> independientemente de que CLSID sea válido.</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> método es compatible con acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Puede recuperar el valor de la <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> propiedad para determinar si el tipo devuelto por este método es un objeto COM.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Puede llamar a la <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) conoce.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">Crear instancias de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Obtener un <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa el <ph id="ph2">`__ComObject`</ph> que se corresponde con el CLSID mediante una llamada a la <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> método para crear una instancia del objeto COM.</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">Las excepciones como <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> se producirá cuando se especifica <ph id="ph2">`true`</ph> para <ph id="ph3">`throwOnError`</ph>, pero no se producirá ningún error para identificadores CLSID no registrados.</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">En el ejemplo siguiente se usa el CLSID de Microsoft Word <bpt id="p1">[</bpt>objeto Application<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> para recuperar un tipo COM que representa la aplicación Microsoft Word desde un servidor llamado computer17.central.contoso.com. A continuación, crea una instancia del tipo mediante una llamada a la <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> método y cierra mediante una llamada a la <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> (método).</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">Se produce una excepción si se produce un error al cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Todos los objetos administrados, los que son visibles para COM incluidos (es decir, su <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> atributo es <ph id="ph2">&lt;see langword="true" /&gt;</ph>) tiene un GUID que es devuelto por la <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Although the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> method returns a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for a particular managed object, you can't use that <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Aunque la <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> método devuelve un <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> objeto que se corresponde con el GUID para un determinado objeto administrado, no puede usar dicha <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> objeto que se va a crear una instancia de tipo mediante una llamada a la <ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> método, como en el ejemplo siguiente se se muestra.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">En su lugar, el <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> solo debe usarse para recuperar el GUID de un objeto COM no administrado y resultante <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> objeto que se pasa a la <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> el método debe representar un objeto COM no administrado.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The object that refers to the type.</source>
          <target state="translated">Objeto que hace referencia al tipo.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>Gets the type referenced by the specified type handle.</source>
          <target state="translated">Obtiene el tipo al que hace referencia el identificador de tipos especificado.</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The type referenced by the specified <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph> property of <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El tipo al que hace referencia el <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph> especificado o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si la propiedad <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph> de <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> es <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Los identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object from a <ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph> provided by the <ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se utiliza el <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> método para obtener un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto desde un <ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph> proporcionada por el <ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador de clase y genera una excepción.</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified program identifier (ProgID).</source>
          <target state="translated">Obtiene el tipo asociado al identificador de programa (ProgID) especificado.</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">ProgID del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene el tipo asociado al identificador de programa (ProgID) especificado y devuelve null si se produce un error al cargar <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The type associated with the specified ProgID, if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Tipo asociado al ProgID especificado si <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Este método se proporciona para la compatibilidad con COM.</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">ProgID no se utilizan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">ProgID del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para producir cualquier excepción que se genere.</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> para pasar por alto cualquier excepción que se produzca.</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Obtiene el tipo asociado al identificador de programa (ProgID) especificado; debe indicarse si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (ProgID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Tipo asociado al identificador de programa (ProgID) especificado si <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Este método se proporciona para la compatibilidad con COM.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Los identificadores de programa no se utilizan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</source>
          <target state="translated">En el ejemplo siguiente se recupera un tipo pasando un ProgID, especificar si se producirá una excepción si el ProgID no es válido.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, along with any applicable exception message.</source>
          <target state="translated">En el ejemplo, a continuación, muestra el identificador ClassID relacionado con el ProgID, junto con cualquier mensaje de excepción es aplicable.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The specified ProgID is not registered.</source>
          <target state="translated">El ProgID especificado no está registrado.</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The progID of the type to get.</source>
          <target state="translated">ProgID del tipo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">Servidor desde el que se va a cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Si el nombre de servidor es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, el resultado que el método devuelve automáticamente es el equipo local.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</source>
          <target state="translated">Obtiene el tipo asociado al identificador de programa (ProgID) especificado desde el servidor especificado y devuelve null si se produce un error al cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Tipo asociado al identificador de programa (ProgID) especificado si <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Este método se proporciona para la compatibilidad con COM.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Los identificadores de programa no se utilizan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">En el ejemplo siguiente se recupera un tipo pasando un ProgID y nombre de servidor.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">A continuación, en el ejemplo se muestra el identificador ClassID relacionado con el ProgID o produce una excepción si el ProgID o el nombre del servidor no es válido.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The progID of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Identificador de programa (ProgID) del <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que se va a obtener.</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">Servidor desde el que se va a cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Si el nombre de servidor es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, el resultado que el método devuelve automáticamente es el equipo local.</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para producir cualquier excepción que se genere.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> para pasar por alto cualquier excepción que se produzca.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Obtiene el tipo asociado al identificador de programa (ProgID) indicado desde el servidor especificado; debe indicarse si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Tipo asociado al identificador de programa (ProgID) especificado si <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Este método se proporciona para la compatibilidad con COM.</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Los identificadores de programa no se utilizan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">En el ejemplo siguiente se recupera un tipo pasando un ProgID y nombre de servidor.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">En el ejemplo, a continuación, muestra el identificador ClassID relacionado con el ProgID, que especifica si se va a producir una excepción si el ProgID o el nombre del servidor no es válido.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The specified progID is not registered.</source>
          <target state="translated">El ProgID especificado no está registrado.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The object for which to get the type handle.</source>
          <target state="translated">Objeto para el que se va a obtener el identificador Type.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>Gets the handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of a specified object.</source>
          <target state="translated">Obtiene el identificador para la clase <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de un objeto especificado.</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Identificador para la clase <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> del objeto <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Los identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The following example defines the class <ph id="ph1">`MyClass1`</ph>, gets an instance of it, and retrieves the runtime handle of the object.</source>
          <target state="translated">En el ejemplo siguiente se define la clase <ph id="ph1">`MyClass1`</ph>, obtiene una instancia del mismo y recupera el identificador de ejecución del objeto.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" uid="P:System.Type.GUID">
          <source>Gets the GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene el GUID asociado al objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">GUID asociado al objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>A GUID is associated with a type using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> attribute.</source>
          <target state="translated">Un GUID se asocia a un tipo mediante el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The following example creates the class <ph id="ph1">`MyClass1`</ph> with a public method, creates a <ph id="ph2">`Type`</ph> object corresponding to <ph id="ph3">`MyClass1`</ph>, and gets the <ph id="ph4">&lt;xref:System.Guid&gt;</ph> structure using the <ph id="ph5">`GUID`</ph> property of the <ph id="ph6">`Type`</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se crea la clase <ph id="ph1">`MyClass1`</ph> con un método público, se crea un <ph id="ph2">`Type`</ph> objeto correspondiente a <ph id="ph3">`MyClass1`</ph>y obtiene la <ph id="ph4">&lt;xref:System.Guid&gt;</ph> estructura mediante la <ph id="ph5">`GUID`</ph> propiedad de la <ph id="ph6">`Type`</ph> clase.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="P:System.Type.HasElementType">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual engloba o hace referencia a otro tipo; es decir, si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual es una matriz o un puntero, o si se pasa por referencia.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es una matriz o un puntero, o si se pasa por referencia; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>For example, Type.GetType("Int32[]").HasElementType returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementType returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Por ejemplo, Type.GetType("Int32[]"). HasElementType devuelve <ph id="ph1">`true`</ph>, pero Type.GetType("Int32"). HasElementType devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>HasElementType also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">HasElementType también devuelve <ph id="ph1">`true`</ph> para "Int32 *" y "Int32 &amp;".</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>The following example returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph> depending on whether or not the object is an array, a reference type, or a pointer.</source>
          <target state="translated">El ejemplo siguiente devuelve <ph id="ph1">`true`</ph> o <ph id="ph2">`false`</ph> dependiendo de si el objeto es una matriz, un tipo de referencia o un puntero.</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph> property and determines whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">Cuando se invalida en una clase derivada, implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph> y determina si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual engloba a otro tipo o hace referencia a él; es decir, si el objeto <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> actual es una matriz o un puntero, o se pasa por referencia.</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es una matriz o un puntero, o si se pasa por referencia; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>For example, Type.GetType("Int32[]").HasElementTypeImpl returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementTypeImpl returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Por ejemplo, Type.GetType("Int32[]"). HasElementTypeImpl devuelve <ph id="ph1">`true`</ph>, pero Type.GetType("Int32"). HasElementTypeImpl devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>HasElementTypeImpl also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">HasElementTypeImpl también devuelve <ph id="ph1">`true`</ph> para "Int32 *" y "Int32 &amp;".</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The following example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se define la clase <ph id="ph1">`MyTypeDelegator`</ph>, lo que invalida el <ph id="ph2">`HasElementTypeImpl`</ph> método.</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">La clase principal comprueba la <ph id="ph1">`HasElementType`</ph> propiedad y muestra el elemento de tipo.</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Invokes a specific member of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Invoca a un miembro específico del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">Cadena que contiene el nombre del constructor, el método, la propiedad o el miembro de campo al que se va a invocar.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">Cadena vacía ("") para llamar al miembro predeterminado.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">Para los miembros de <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph>, cadena que representa el identificador DispID, por ejemplo "[DispID=3]".</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">El acceso puede corresponder a uno de los marcadores <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>, como <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, etc.</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">No es necesario especificar el tipo de búsqueda.</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">Si se omite el tipo de búsqueda, se usan <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">Observe que la definición explícita de un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> puede resultar necesaria para llamar correctamente a sobrecargas de método con argumentos variables.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Objeto donde debe invocarse al miembro especificado.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">Matriz que contiene los argumentos que se van a pasar al miembro al cual se va a invocar.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</source>
          <target state="translated">Invoca al miembro especificado, aplica las restricciones de enlace igualmente especificadas y compara la lista de argumentos indicada.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">Objeto que representa el valor devuelto del miembro invocado.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">No se puede utilizar <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> para invocar un método genérico.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los miembros que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir miembros públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private and protected members) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir los miembros no públicos (es decir, miembros privados y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir miembros estáticos en la jerarquía.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar solo los miembros declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los miembros que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> indicadores de invocación pueden usarse para denotar la acción que realizará con el miembro:</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> para invocar un constructor.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> se omite.</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">No es válido con otros indicadores de invocación.</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> para invocar un método, pero no un constructor o un inicializador de tipo.</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`SetField`</ph> o <ph id="ph2">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">Si <ph id="ph1">`InvokeMethod`</ph> se especifica por sí mismo, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, y <ph id="ph4">`BindingFlags.Static`</ph> se incluyen automáticamente.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> Para obtener el valor de un campo.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`SetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> Para establecer el valor de un campo.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`GetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> Para obtener una propiedad.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> Para establecer una propiedad.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">Un método se invocará si se cumplen las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">El número de parámetros en la declaración del método es igual al número de argumentos en la <ph id="ph1">`args`</ph> matriz (a menos que se definan argumentos predeterminados en el miembro y <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> se especifica).</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">El tipo de cada argumento se puede convertir por el enlazador al tipo del parámetro.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">El enlazador encontrará todos los métodos de búsqueda de coincidencias.</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">Estos métodos se encuentran en función del tipo de enlace que se solicite (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> valores <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, y así sucesivamente).</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">Después de selecciona el método, se invoca.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">En ese momento se comprueba la accesibilidad.</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">La búsqueda puede controlar qué conjunto de métodos que se buscan basándose en el atributo de accesibilidad asociado al método.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> método de la <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> clase es responsable de seleccionar el método que se debe invocar.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">El enlazador predeterminado selecciona a la coincidencia más específica.</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">Se omiten las restricciones de acceso de código de plena confianza; es decir, constructores privados, métodos, campos y propiedades pueden ser acceso y se invocan a través de <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> cada vez que el código es de plena confianza.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Puede usar <ph id="ph1">`Type.InvokeMember`</ph> para establecer un campo en un valor determinado mediante la especificación de <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">Por ejemplo, si desea establecer un campo de instancia pública denominado F en la clase C y F es un <ph id="ph1">`String`</ph>, puede utilizar código como:</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">Si F es un <ph id="ph1">`String[]`</ph>, puede utilizar código como:</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">que inicializará el campo F en esta nueva matriz.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">También puede utilizar <ph id="ph1">`Type.InvokeMember`</ph> para establecer una posición en una matriz si se suministra el índice del valor y, a continuación, en el siguiente valor mediante código como el siguiente:</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">Esto cambiará la cadena "z" en la matriz que contiene F a la cadena "b".</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">Cuando se invoca un <ph id="ph1">`IDispatch`</ph> miembro, puede especificar el identificador DispID en lugar del nombre de miembro, con el formato de cadena "[DispID = ##]".</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">Por ejemplo, si el identificador DispID de MyComMethod es 3, puede especificar la cadena "[DispID = 3]" en lugar de "MyComMethod".</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">Invocación de un miembro por DispID es más rápido que consultar el miembro por su nombre.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">En escenarios de agregación compleja, el identificador DispID a veces es la única manera de invocar al miembro deseado.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, este método se puede utilizar para tener acceso a miembros no públicos si se ha concedido el autor de llamada <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con el <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> marca y, si el conjunto de permisos de los miembros no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Para utilizar esta funcionalidad, la aplicación debe utilizar <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o posterior como destino.</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following example uses <ph id="ph1">`InvokeMember`</ph> to access members of a type.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">`InvokeMember`</ph> para obtener acceso a miembros de un tipo.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> no contiene <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> y <ph id="ph3">&lt;paramref name="name" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> no es un atributo <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> válido.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> no contiene una de las siguientes marcas de enlace:  <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> o <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combinado con <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> o <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene tanto <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> como <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene tanto <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> como <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combinado con <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> o <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> y <ph id="ph3">&lt;paramref name="args" /&gt;</ph> tiene más de un elemento.</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">Se llama a este método en un objeto COM pero no se pasa una de las siguientes marcas de enlace: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> o <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Una de las matrices de parámetros con nombre contiene una cadena que es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">El miembro especificado es un inicializador de clase.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">No se encuentran el campo o la propiedad.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">No se encuentra ningún método que coincida con los argumentos en <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un tipo que contiene parámetros de tipo abierto, es decir, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> devuelve <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">No se puede invocar al miembro especificado en <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">Más de un método coincide con los criterios de enlace.</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The .NET Compact Framework does not currently support this method.</source>
          <target state="translated">.NET Compact Framework no admite actualmente este método.</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated">El método representado por <ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene uno o más parámetros de tipo genérico no especificados.</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Es decir, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> del método devuelve <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">para tener acceso a miembros no públicos, independientemente de su concesión establecido.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>to call unmanaged code.</source>
          <target state="translated">para llamar a código no administrado.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">Cadena que contiene el nombre del constructor, el método, la propiedad o el miembro de campo al que se va a invocar.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">Cadena vacía ("") para llamar al miembro predeterminado.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">Para los miembros de <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph>, cadena que representa el identificador DispID, por ejemplo "[DispID=3]".</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">El acceso puede corresponder a uno de los marcadores <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>, como <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, etc.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">No es necesario especificar el tipo de búsqueda.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">Si se omite el tipo de búsqueda, se usan <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar la propiedad <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">Observe que la definición explícita de un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> puede resultar necesaria para llamar correctamente a sobrecargas de método con argumentos variables.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Objeto donde debe invocarse al miembro especificado.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">Matriz que contiene los argumentos que se van a pasar al miembro al cual se va a invocar.</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">Objeto que representa la configuración regional de globalización que se va a usar, que puede ser necesaria para las conversiones específicas de la configuración regional, como pasar un tipo numérico <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar el <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> del subproceso actual.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</source>
          <target state="translated">Invoca al miembro especificado, aplica las restricciones de enlace especificadas y compara la lista de argumentos y la referencia cultural igualmente especificadas.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">Objeto que representa el valor devuelto del miembro invocado.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph2">`culture`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`culture`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (la <ph id="ph2">`culture`</ph> parámetro), puede utilizar la abstracta <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph4">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">No se puede utilizar <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> para invocar un método genérico.</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los miembros que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir miembros públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir miembros estáticos en la jerarquía.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar solo los miembros declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los miembros que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> indicadores de invocación pueden usarse para denotar la acción que realizará con el miembro:</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> para invocar un constructor.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> se omite.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">No es válido con otros indicadores de invocación.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> para invocar un método, pero no un constructor o un inicializador de tipo.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`SetField`</ph> o <ph id="ph2">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">Si <ph id="ph1">`InvokeMethod`</ph> se especifica por sí mismo, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, y <ph id="ph4">`BindingFlags.Static`</ph> se incluyen automáticamente.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> Para obtener el valor de un campo.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`SetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> Para establecer el valor de un campo.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`GetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> Para obtener una propiedad.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> Para establecer una propiedad.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">Un método se invocará si se cumplen las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">El número de parámetros en la declaración del método es igual al número de argumentos en la <ph id="ph1">`args`</ph> matriz (a menos que se definan argumentos predeterminados en el miembro y <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> se especifica).</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">El tipo de cada argumento se puede convertir por el enlazador al tipo del parámetro.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">El enlazador encontrará todos los métodos de búsqueda de coincidencias.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">Estos métodos se encuentran en función del tipo de enlace que se solicite (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> valores <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, y así sucesivamente).</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">Después de selecciona el método, se invoca.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">En ese momento se comprueba la accesibilidad.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">La búsqueda puede controlar qué conjunto de métodos que se buscan basándose en el atributo de accesibilidad asociado al método.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> método de la <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> clase es responsable de seleccionar el método que se debe invocar.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">El enlazador predeterminado selecciona a la coincidencia más específica.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</source>
          <target state="translated">Se omiten las restricciones de acceso de código de plena confianza; es decir, las propiedades, métodos, campos y constructores privados se pueden obtener acceso a y llamadas mediante reflexión siempre que el código es de plena confianza.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Puede usar <ph id="ph1">`Type.InvokeMember`</ph> para establecer un campo en un valor determinado mediante la especificación de <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph> you can use code such as:</source>
          <target state="translated">Por ejemplo, si desea establecer un campo de instancia pública denominado F en la clase C y F es un <ph id="ph1">`String`</ph> puede usar código como:</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">Si F es un <ph id="ph1">`String[]`</ph>, puede utilizar código como:</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">que inicializará el campo F en esta nueva matriz.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">También puede utilizar <ph id="ph1">`Type.InvokeMember`</ph> para establecer una posición en una matriz si se suministra el índice del valor y, a continuación, en el siguiente valor mediante código como el siguiente:</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">Esto cambiará la cadena "z" en la matriz que contiene F a la cadena "b".</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">Cuando se invoca un <ph id="ph1">`IDispatch`</ph> miembro puede especificar el identificador DispID en lugar del nombre de miembro, con el formato de cadena "[DispID = ##]".</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">Por ejemplo, si el identificador DispID de MyComMethod es 3, puede especificar la cadena "[DispID = 3]" en lugar de "MyComMethod".</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">Invocación de un miembro por DispID es más rápido que consultar el miembro por su nombre.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">En escenarios de agregación compleja, el identificador DispID a veces es la única manera de invocar al miembro deseado.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, este método se puede utilizar para tener acceso a miembros no públicos si se ha concedido el autor de llamada <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con el <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> marca y, si el conjunto de permisos de los miembros no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Para utilizar esta funcionalidad, la aplicación debe utilizar <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o posterior como destino.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> no contiene <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> y <ph id="ph3">&lt;paramref name="name" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> no es un atributo <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> válido.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> no contiene una de las siguientes marcas de enlace:  <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> o <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combinado con <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> o <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene tanto <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> como <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene tanto <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> como <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combinado con <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> o <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> y <ph id="ph3">&lt;paramref name="args" /&gt;</ph> tiene más de un elemento.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">Se llama a este método en un objeto COM pero no se pasa una de las siguientes marcas de enlace: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> o <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Una de las matrices de parámetros con nombre contiene una cadena que es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member is a class initializer.</source>
          <target state="translated">El miembro especificado es un inicializador de clase.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The field or property cannot be found.</source>
          <target state="translated">No se encuentran el campo o la propiedad.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">No se encuentra ningún método que coincida con los argumentos en <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un tipo que contiene parámetros de tipo abierto, es decir, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> devuelve <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">No se puede invocar al miembro especificado en <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">Más de un método coincide con los criterios de enlace.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated">El método representado por <ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene uno o más parámetros de tipo genérico no especificados.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Es decir, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> del método devuelve <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">para tener acceso a miembros no públicos, independientemente de su concesión establecido.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>to call unmanaged code.</source>
          <target state="translated">para llamar a código no administrado.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">Cadena que contiene el nombre del constructor, el método, la propiedad o el miembro de campo al que se va a invocar.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">Cadena vacía ("") para llamar al miembro predeterminado.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">Para los miembros de <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph>, cadena que representa el identificador DispID, por ejemplo "[DispID=3]".</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">El acceso puede corresponder a uno de los marcadores <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>, como <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, etc.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">No es necesario especificar el tipo de búsqueda.</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">Si se omite el tipo de búsqueda, se usan <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (Nothing in Visual Basic), to use the <ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (Nothing en Visual Basic) para usar la propiedad <ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">Observe que la definición explícita de un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> puede resultar necesaria para llamar correctamente a sobrecargas de método con argumentos variables.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Objeto donde debe invocarse al miembro especificado.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">Matriz que contiene los argumentos que se van a pasar al miembro al cual se va a invocar.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> que representan los atributos asociados al elemento correspondiente de la matriz <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter's associated attributes are stored in the member's signature.</source>
          <target state="translated">Los atributos asociados a un parámetro se almacenan en la firma del miembro.</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder processes this parameter only when calling a COM component.</source>
          <target state="translated">El enlazador predeterminado solo procesa este parámetro cuando se llama a un componente COM.</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> que representa la configuración regional de globalización que se va a usar, que puede ser necesaria para las conversiones específicas de la configuración regional, como pasar un tipo numérico String a Double.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">o bien</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">Referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic) para usar el <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> del subproceso actual.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the names of the parameters to which the values in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array are passed.</source>
          <target state="translated">Matriz que contiene los nombres de los parámetros a los que se pasan los valores de la matriz <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</source>
          <target state="translated">Cuando se invalida en una clase derivada, invoca al miembro especificado, aplica las restricciones de enlace igualmente especificadas y realiza una comparación con la lista de argumentos, los modificadores y la referencia cultural indicados.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">Objeto que representa el valor devuelto del miembro invocado.</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> llama a un miembro de constructor o método, obtiene o establece una propiedad de miembro, obtiene o establece a un miembro de campo de datos, u Obtiene o establece un elemento de un miembro de la matriz.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">No se puede utilizar <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> para invocar un método genérico.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">Cuando se invoca un <ph id="ph1">`IDispatch`</ph> miembro puede especificar el identificador DispID en lugar del nombre de miembro, con el formato de cadena "[DispID = ##]".</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">Por ejemplo, si el identificador DispID de MyComMethod es 3, puede especificar la cadena "[DispID = 3]" en lugar de "MyComMethod".</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">Invocación de un miembro por DispID es más rápido que consultar el miembro por su nombre.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">En escenarios de agregación compleja, el identificador DispID a veces es la única manera de invocar al miembro deseado.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph3">`modifiers`</ph> and <ph id="ph4">`culture`</ph> parameters), you can use the abstract <ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph6">`modifiers`</ph> and <ph id="ph7">`culture`</ph>.</source>
          <target state="translated">Aunque el enlazador predeterminado no procesa <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> o <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (la <ph id="ph3">`modifiers`</ph> y <ph id="ph4">`culture`</ph> parámetros), puede utilizar la abstracta <ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> clase para escribir un enlazador personalizado que procesan <ph id="ph6">`modifiers`</ph> y <ph id="ph7">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> solo se utiliza cuando se llama mediante la interoperabilidad COM, y se administran sólo los parámetros que se pasan por referencia.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <ph id="ph1">`namedParameters`</ph> array gets the value in the corresponding element in the <ph id="ph2">`args`</ph> array.</source>
          <target state="translated">Cada parámetro de la matriz <ph id="ph1">`namedParameters`</ph> obtiene el valor en el elemento correspondiente de la matriz <ph id="ph2">`args`</ph>.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <ph id="ph1">`args`</ph> is greater than the length of <ph id="ph2">`namedParameters`</ph>, the remaining argument values are passed in order.</source>
          <target state="translated">Si la longitud de <ph id="ph1">`args`</ph> es mayor que la longitud de <ph id="ph2">`namedParameters`</ph>, los valores de argumento restantes se pasan por orden.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`namedParameters`</ph> array can be used to change the order of arguments in an input array.</source>
          <target state="translated">El <ph id="ph1">`namedParameters`</ph> matriz puede utilizarse para cambiar el orden de los argumentos de una matriz de entrada.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, given the method <ph id="ph1">`M(string a, int b)`</ph> (<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> in Visual Basic) and the input array <ph id="ph3">`{ 42, "x" }`</ph>, the input array can be passed unchanged to <ph id="ph4">`args`</ph> if the array <ph id="ph5">`{ "b", "a" }`</ph> is supplied for <ph id="ph6">`namedParameters`</ph>.</source>
          <target state="translated">Por ejemplo, dado el método <ph id="ph1">`M(string a, int b)`</ph> (<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> en Visual Basic) y la matriz de entrada <ph id="ph3">`{ 42, "x" }`</ph>, la matriz de entrada se puede pasar sin cambios al <ph id="ph4">`args`</ph> si la matriz <ph id="ph5">`{ "b", "a" }`</ph> proporcionado para <ph id="ph6">`namedParameters`</ph>.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de filtro pueden utilizarse para definir los miembros que desea incluir en la búsqueda:</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.Public`</ph> para incluir miembros públicos en la búsqueda.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.NonPublic`</ph> para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">Especificar <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> para incluir miembros estáticos en la jerarquía.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> marcas de modificador se pueden utilizar para cambiar el funcionamiento de la búsqueda:</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> para omitir la grafía de <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> para buscar solo los miembros declarados en el <ph id="ph2">&lt;xref:System.Type&gt;</ph>, no los miembros que simplemente se han heredado.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">El siguiente <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> indicadores de invocación pueden usarse para denotar la acción que realizará con el miembro:</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> para invocar un constructor.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> se omite.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">No es válido con otros indicadores de invocación.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> para invocar un método, pero no un constructor o un inicializador de tipo.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`SetField`</ph> o <ph id="ph2">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">Si <ph id="ph1">`InvokeMethod`</ph> se especifica por sí mismo, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, y <ph id="ph4">`BindingFlags.Static`</ph> se incluyen automáticamente.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> Para obtener el valor de un campo.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`SetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> Para establecer el valor de un campo.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`GetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> Para obtener una propiedad.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> Para establecer una propiedad.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">No es válido con <ph id="ph1">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">Un método se invocará si se cumplen las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">El número de parámetros en la declaración del método es igual al número de argumentos en la <ph id="ph1">`args`</ph> matriz (a menos que se definan argumentos predeterminados en el miembro y <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> se especifica).</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">El tipo de cada argumento se puede convertir por el enlazador al tipo del parámetro.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">El enlazador encontrará todos los métodos de búsqueda de coincidencias.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">Estos métodos se encuentran en función del tipo de enlace que se solicite (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> valores <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, y así sucesivamente).</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">Después de selecciona el método, se invoca.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">En ese momento se comprueba la accesibilidad.</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">La búsqueda puede controlar qué conjunto de métodos que se buscan basándose en el atributo de accesibilidad asociado al método.</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> método de la <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> clase es responsable de seleccionar el método que se debe invocar.</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">El enlazador predeterminado selecciona a la coincidencia más específica.</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> can be used to invoke methods with parameters that have default values.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> puede utilizarse para invocar métodos con parámetros que tienen valores predeterminados.</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To bind to these methods, Reflection requires <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph> to be specified.</source>
          <target state="translated">Para enlazar a estos métodos, Reflection requiere <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph> que se especifique.</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For a parameter that has a default value, you can either supply a different value, or supply <ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph> to use the default value.</source>
          <target state="translated">Para un parámetro que tiene un valor predeterminado, puede proporcionar un valor distinto o proporcionar <ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph> para usar el valor predeterminado.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, consider a method such as MyMethod(int x, float y = 2.0).</source>
          <target state="translated">Por ejemplo, considere un método como MyMethod (int x, float y = 2.0).</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <ph id="ph1">`Missing.Value`</ph> for the second argument.</source>
          <target state="translated">Para invocar este método solamente con el primer argumento como MyMethod (4), pase uno de los marcadores de enlace anterior y pasar dos argumentos, es decir, 4 para el primer argumento y <ph id="ph1">`Missing.Value`</ph> para el segundo argumento.</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Unless you use <ph id="ph1">`Missing.Value`</ph>, you may not omit optional parameters with the <ph id="ph2">`Invoke`</ph> method.</source>
          <target state="translated">A menos que use <ph id="ph1">`Missing.Value`</ph>, no se puede omitir los parámetros opcionales con el <ph id="ph2">`Invoke`</ph> método.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If you must do so, use <ph id="ph1">`InvokeMember`</ph> instead.</source>
          <target state="translated">Si debe hacerlo, use <ph id="ph1">`InvokeMember`</ph> en su lugar.</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">Se omiten las restricciones de acceso de código de plena confianza; es decir, constructores privados, métodos, campos y propiedades pueden ser acceso y se invocan a través de <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> cada vez que el código es de plena confianza.</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Puede usar <ph id="ph1">`Type.InvokeMember`</ph> para establecer un campo en un valor determinado mediante la especificación de <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">Por ejemplo, si desea establecer un campo de instancia pública denominado F en la clase C y F es un <ph id="ph1">`String`</ph>, puede utilizar código como:</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">Si F es un <ph id="ph1">`String[]`</ph>, puede utilizar código como:</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">que inicializará el campo F en esta nueva matriz.</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">También puede utilizar <ph id="ph1">`Type.InvokeMember`</ph> para establecer una posición en una matriz si se suministra el índice del valor y, a continuación, en el siguiente valor mediante código como el siguiente:</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">Esto cambiará la cadena "z" en la matriz que contiene F a la cadena "b".</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, este método se puede utilizar para tener acceso a miembros no públicos si se ha concedido el autor de llamada <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con el <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> marca y, si el conjunto de permisos de los miembros no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Para utilizar esta funcionalidad, la aplicación debe utilizar <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o posterior como destino.</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> no contiene <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> y <ph id="ph3">&lt;paramref name="name" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> y <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> no tienen la misma longitud.</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> no es un atributo <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> válido.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> no contiene una de las siguientes marcas de enlace:  <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> o <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combinado con <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> o <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene tanto <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> como <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene tanto <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> como <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combinado con <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> o <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contiene <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> y <ph id="ph3">&lt;paramref name="args" /&gt;</ph> tiene más de un elemento.</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The named parameter array is larger than the argument array.</source>
          <target state="translated">La matriz de parámetros con nombre es mayor que la matriz de argumentos.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">Se llama a este método en un objeto COM pero no se pasa una de las siguientes marcas de enlace: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> o <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Una de las matrices de parámetros con nombre contiene una cadena que es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">El miembro especificado es un inicializador de clase.</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">No se encuentran el campo o la propiedad.</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">No se encuentra ningún método que coincida con los argumentos en <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No member can be found that has the argument names supplied in <ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph>.</source>
          <target state="translated">No se puede encontrar ningún miembro con los nombres de argumento proporcionados en <ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un tipo que contiene parámetros de tipo abierto, es decir, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> devuelve <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">No se puede invocar al miembro especificado en <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">Más de un método coincide con los criterios de enlace.</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated">El método representado por <ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene uno o más parámetros de tipo genérico no especificados.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Es decir, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> del método devuelve <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">para tener acceso a miembros no públicos, independientemente de su concesión establecido.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>to call unmanaged code.</source>
          <target state="translated">para llamar a código no administrado.</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" uid="P:System.Type.IsAbstract">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is abstract and must be overridden.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> es abstracto y se debe invalidar.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is abstract; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es abstracto; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> in the following cases:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph> en los casos siguientes:</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</source>
          <target state="translated">El tipo actual es abstracto; es decir, no se pueden crear instancias, pero solo puede actuar como clase base para las clases derivadas.</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>In C#, abstract classes are marked with the <bpt id="p1">[</bpt>abstract<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> keyword; in Visual Basic, they are marked with the <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> keyword.</source>
          <target state="translated">En C#, clases abstractas se marcan con la <bpt id="p1">[</bpt>abstracta<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> palabra clave; en Visual Basic, se marcan con la <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> palabra clave.</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is an interface.</source>
          <target state="translated">El tipo actual es una interfaz.</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The following example creates an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent the following types:contains type returns <ph id="ph2">`true`</ph> if the specified object is <ph id="ph3">`abstract`</ph>; otherwise, it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crea una matriz de <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos que representan los tipos siguientes: contiene los valores devueltos de tipo <ph id="ph2">`true`</ph> si el objeto especificado es <ph id="ph3">`abstract`</ph>; en caso contrario, devuelve <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`AbstractClass`</ph>, an abstract class (a class marked as <ph id="ph2">`abstract`</ph> in C# and <ph id="ph3">`MustInherit`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">`AbstractClass`</ph>, una clase abstracta (una clase marcada como <ph id="ph2">`abstract`</ph> en C# y <ph id="ph3">`MustInherit`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`DerivedClass`</ph>, a class that inherits from <ph id="ph2">`AbstractClass`</ph>.</source>
          <target state="translated"><ph id="ph1">`DerivedClass`</ph>, una clase que hereda de <ph id="ph2">`AbstractClass`</ph>.</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`SingleClass`</ph>, a non-inheritable class.</source>
          <target state="translated"><ph id="ph1">`SingleClass`</ph>, una clase no heredable.</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>It is defined as <ph id="ph1">`sealed`</ph> in C# and <ph id="ph2">`NotInheritable`</ph> in Visual Basic.</source>
          <target state="translated">Se define como <ph id="ph1">`sealed`</ph> en C# y <ph id="ph2">`NotInheritable`</ph> en Visual Basic.</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ITypeInfo`</ph>, an interface.</source>
          <target state="translated"><ph id="ph1">`ITypeInfo`</ph>, una interfaz.</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ImplementingClass`</ph>, a class that implements the <ph id="ph2">`ITypeInfo`</ph> interface.</source>
          <target state="translated"><ph id="ph1">`ImplementingClass`</ph>, una clase que implementa el <ph id="ph2">`ITypeInfo`</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The method returns <ph id="ph1">`true`</ph> only for <ph id="ph2">`AbstractClass`</ph>, the abstract class, and <ph id="ph3">`ITypeInfo`</ph>, the interface.</source>
          <target state="translated">El método devuelve <ph id="ph1">`true`</ph> sólo para <ph id="ph2">`AbstractClass`</ph>, la clase abstracta, y <ph id="ph3">`ITypeInfo`</ph>, la interfaz.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" uid="P:System.Type.IsAnsiClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene un valor que indica si se selecciona el atributo de formato de cadena <ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se selecciona el atributo de formato de cadena <ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph> para <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selecciona los atributos de formato de cadena.</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">Los atributos de formato de cadena mejoran la interoperabilidad al definir cómo deben interpretarse las cadenas.</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico, esta propiedad pertenece a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The following example gets the field information and checks for the <ph id="ph1">`AnsiClass`</ph> attribute.</source>
          <target state="translated">En el ejemplo siguiente se obtiene la información de campo y busca el <ph id="ph1">`AnsiClass`</ph> atributo.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" uid="P:System.Type.IsArray">
          <source>Gets a value that indicates whether the type is an array.</source>
          <target state="translated">Obtiene un valor que indica si el tipo es una matriz.</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is an array; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo actual es una matriz; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the <ph id="ph3">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> propiedad devuelve <ph id="ph2">`false`</ph> para el <ph id="ph3">&lt;xref:System.Array&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>It also returns <ph id="ph1">`false`</ph> if the current instance is a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a collection type or an interface designed to work with collections, such as <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
          <target state="translated">También devuelve <ph id="ph1">`false`</ph> si la instancia actual es un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que representa un tipo de colección o una interfaz diseñada para trabajar con colecciones, como <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> o <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>To check for an array, use code such as:</source>
          <target state="translated">Para comprobar si una matriz, use código como:</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si el tipo actual representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o de método genérico, esta propiedad siempre devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array.</source>
          <target state="translated">Cuando se invalida en una clase derivada, implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph> y determina si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es una matriz.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es una matriz; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class must return <ph id="ph2">`false`</ph> because it is an object, not an array.</source>
          <target state="translated">Una instancia de la <ph id="ph1">&lt;xref:System.Array&gt;</ph> debe devolver la clase <ph id="ph2">`false`</ph> porque es un objeto, no una matriz.</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>The following example overrides the <ph id="ph1">`IsArrayImpl`</ph> method in the <ph id="ph2">`MyTypeDelegator`</ph> class, checks if a variable is an array, and displays the result.</source>
          <target state="translated">El siguiente ejemplo se reemplaza el <ph id="ph1">`IsArrayImpl`</ph> método en el <ph id="ph2">`MyTypeDelegator`</ph> de la clase, comprueba si una variable es una matriz y muestra el resultado.</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">Tipo que se va a comparar con el tipo actual.</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Determines whether an instance of a specified type can be assigned to an instance of the current type.</source>
          <target state="translated">Determina si una instancia del tipo especificado se puede asignar a una instancia del tipo actual.</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si alguna de las condiciones siguientes es "true":</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> and the current instance represent the same type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> y la instancia actual representan el mismo tipo.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived either directly or indirectly from the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> se deriva de forma directa o indirecta de la instancia actual.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived directly from the current instance if it inherits from the current instance; <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> se deriva directamente de la instancia actual si se hereda de la instancia actual, mientras que <ph id="ph2">&lt;paramref name="c" /&gt;</ph> se deriva indirectamente de la instancia actual si se hereda de una sucesión de una o varias clases que se heredan de la instancia actual.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The current instance is an interface that <ph id="ph1">&lt;paramref name="c" /&gt;</ph> implements.</source>
          <target state="translated">La instancia actual es una interfaz que <ph id="ph1">&lt;paramref name="c" /&gt;</ph> implementa.</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is a generic type parameter, and the current instance represents one of the constraints of <ph id="ph2">&lt;paramref name="c" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> es un parámetro de tipo genérico y la instancia actual representa una de las restricciones de <ph id="ph2">&lt;paramref name="c" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>In the following example, the current instance is a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente, la instancia actual es un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa la clase <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> is a generic type whose generic type parameter must be of type    <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> es un tipo genérico cuyo parámetro de tipo genérico debe ser del tipo <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Passing its generic type parameter to the <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> indicates that  an instance of the generic type parameter can be assigned to an <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">La acción de pasar su parámetro de tipo genérico a <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> indica que se puede asignar una instancia del parámetro de tipo genérico a un objeto <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> represents a value type, and the current instance represents <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (<bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> representa un tipo de valor y la instancia actual representa <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (<bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are true, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="false" /&gt;</ph> si ninguna de estas condiciones son true o si <ph id="ph2">&lt;paramref name="c" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method can be used to determine whether an instance of <ph id="ph2">`c`</ph> can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> método se puede utilizar para determinar si una instancia de <ph id="ph2">`c`</ph> puede asignarse a una instancia del tipo actual, el método es muy útil al administrar los objetos cuyos tipos no se conocen en tiempo de diseño y permite la asignación condicional, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method thus ensures that a line of code like the following will execute at runtime without throwing an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> exception or a similar exception:</source>
          <target state="translated">Este método garantiza que por lo tanto, una línea de código como el siguiente se ejecutará en tiempo de ejecución sin producir una <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> excepción o una excepción similar:</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>A generic type definition is not assignable from a closed constructed type.</source>
          <target state="translated">Una definición de tipo genérico no es asignable de un tipo construido cerrado.</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>That is, you cannot assign the closed constructed type <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) to a variable of type <ph id="ph3">`MyGenericList&lt;T&gt;`</ph>.</source>
          <target state="translated">Es decir, no se puede asignar el tipo construido cerrado <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> en Visual Basic) a una variable de tipo <ph id="ph3">`MyGenericList&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>If the <ph id="ph1">`c`</ph> parameter is of type <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, the result is based on the type that is to be built.</source>
          <target state="translated">Si el <ph id="ph1">`c`</ph> parámetro es de tipo <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, el resultado se basa en el tipo que se van a compilar.</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following code example demonstrates this using a built type named <ph id="ph1">`B`</ph>.</source>
          <target state="translated">El ejemplo de código siguiente muestra esto utilizando un tipo integrado denominado <ph id="ph1">`B`</ph>.</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following example demonstrates the <ph id="ph1">`IsAssignableFrom`</ph> method using defined classes, integer arrays, and generics.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">`IsAssignableFrom`</ph> utilizando el método definido por clases, matrices de enteros y genéricos.</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene un valor que indica si se selecciona el atributo de formato de cadena <ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se selecciona el atributo de formato de cadena <ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph> para <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selecciona los atributos de formato de cadena.</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">Los atributos de formato de cadena mejoran la interoperabilidad al definir cómo deben interpretarse las cadenas.</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</source>
          <target state="translated">Obtiene un valor que indica si los campos de tipo de la actual se disponen automáticamente mediante Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> del tipo actual incluye <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Esta propiedad se proporciona por comodidad.</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">Como alternativa, puede usar el <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> valor de enumeración para seleccionar los atributos de diseño de tipo y, a continuación, probar si <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> se establece.</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>,<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>,<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> valores de enumeración indican la manera en que los campos del tipo se disponen en memoria.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">Para los tipos dinámicos, puede especificar <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> cuando se crea el tipo.</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</source>
          <target state="translated">En el código, aplicar el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> atribuir a la <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph> valor de enumeración para el tipo, para permitir que el tiempo de ejecución a determinar la manera adecuada para diseñar la clase.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">No se puede utilizar el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> método para determinar si el <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> se ha aplicado a un tipo.</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The following example creates an instance of the type and displays the <ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se crea una instancia del tipo y muestra el <ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" uid="P:System.Type.IsByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> se pasa por referencia.</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> se pasa por referencia; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>To get to the actual type, dereference the type that was passed by reference, and then call <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> on that type.</source>
          <target state="translated">Para obtener el tipo real, desreferenciar el tipo que se pasó por referencia y, a continuación, llamar a <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> en ese tipo.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsByRef`</ph> property to check whether a specified type is passed by reference.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`IsByRef`</ph> propiedad para comprobar si un tipo especificado se pasa por referencia.</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">En el ejemplo se define la clase <ph id="ph1">`MyTypeDelegator`</ph>, lo que invalida el <ph id="ph2">`HasElementTypeImpl`</ph> método.</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">La clase principal comprueba la <ph id="ph1">`HasElementType`</ph> propiedad y muestra el elemento de tipo.</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">Cuando se invalida en una clase derivada, implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> y determina si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> se pasa por referencia.</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> se pasa por referencia; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" uid="P:System.Type.IsClass">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a class or a delegate; that is, not a value type or interface.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> es una clase o un delegado, es decir, no es un tipo de valor ni una interfaz.</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a class; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es una clase; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for classes as well as delegates.</source>
          <target state="translated">Esta propiedad devuelve <ph id="ph1">`true`</ph> para clases, así como los delegados.</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>It returns <ph id="ph1">`false`</ph> for value types (for structures and enumerations) even if they are boxed.</source>
          <target state="translated">Devuelve <ph id="ph1">`false`</ph> para tipos de valor (para las estructuras y enumeraciones) incluso si se han convertido.</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`true`</ph>.If the current <ph id="ph3">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns <ph id="ph4">`true`</ph> if the generic type definition is a class definition; that is, it does not define an interface or a value type.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`true`</ph>. Si la actual <ph id="ph3">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad devuelve <ph id="ph4">`true`</ph> si la definición de tipo genérico es una definición de clase; es decir, no define una interfaz o un tipo de valor.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for <ph id="ph2">`Type`</ph> instances that represent the <ph id="ph3">&lt;xref:System.Enum&gt;</ph> and <ph id="ph4">&lt;xref:System.ValueType&gt;</ph> classes.</source>
          <target state="translated">Esta propiedad devuelve <ph id="ph1">`true`</ph> para <ph id="ph2">`Type`</ph> instancias que representan el <ph id="ph3">&lt;xref:System.Enum&gt;</ph> y <ph id="ph4">&lt;xref:System.ValueType&gt;</ph> clases.</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</source>
          <target state="translated">Estas dos clases son los tipos base para las enumeraciones y tipos de valor, respectivamente, pero no son enumeraciones ni tipos de valor por sí mismos.</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph> properties.</source>
          <target state="translated">Para obtener más información, consulte el <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> valor de enumeración distingue una declaración de tipo como clase o interfaz. Sin embargo, las clases y tipos de valor se marcan con la <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If you retrieve the value of a type's Attributes property and use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> value to determine whether a type is a class instead of a value type, you must also call the <ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph> property.</source>
          <target state="translated">Si se recupera el valor de propiedad de atributos y el uso de un tipo el <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> valor para determinar si un tipo es una clase en lugar de un tipo de valor, también debe llamar a la <ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The example for the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration contains additional information as well as anexample.</source>
          <target state="translated">El ejemplo de la <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeración contiene información adicional, así como anexample.</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The following example creates an instance of a type and indicates whether the type is a class.</source>
          <target state="translated">En el ejemplo siguiente se crea una instancia de un tipo y se indica si el tipo es una clase.</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" uid="P:System.Type.IsCOMObject">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> es un objeto COM.</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un objeto COM; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">Este método devuelve <ph id="ph1">`false`</ph> para interfaces COM porque no son objetos.</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">Interfaces COM pueden implementarse mediante objetos de Microsoft .NET Framework.</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>You can also load a COM class and get a <ph id="ph1">`Type`</ph> object for that COM class by using the <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.</source>
          <target state="translated">También puede cargar una clase COM y obtener un <ph id="ph1">`Type`</ph> objeto para esa clase COM utilizando el <bpt id="p1">[</bpt>Tlbimp.exe (importador de la biblioteca de tipos)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> herramienta.</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">Cuando se invalida en una clase derivada, implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph> y determina si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un objeto COM.</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un objeto COM; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">Este método devuelve <ph id="ph1">`false`</ph> para interfaces COM porque no son objetos.</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">Interfaces COM pueden implementarse mediante objetos de Microsoft .NET Framework.</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">Obtiene un valor que indica si este objeto representa un tipo genérico construido.</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>You can create instances of a constructed generic type.</source>
          <target state="translated">Puede crear instancias de un tipo genérico construido.</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este objeto representa una definición de tipo genérico construido; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>A constructed generic type has had explicit types supplied for all of its generic type parameters.</source>
          <target state="translated">Un tipo genérico construido ha tenido un tipo explícito proporcionado para todos sus parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>It is also referred to as a closed generic type.</source>
          <target state="translated">También se denomina un tipo genérico.</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>When this property is <ph id="ph1">`true`</ph>, you can create instances of the current type; when it is <ph id="ph2">`false`</ph>, you can't.</source>
          <target state="translated">Cuando esta propiedad es <ph id="ph1">`true`</ph>, se pueden crear instancias del tipo actual; cuando se <ph id="ph2">`false`</ph>, no se puede.</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" uid="P:System.Type.IsContextful">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> puede estar hospedado en un contexto.</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> puede estar hospedado en un contexto; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</source>
          <target state="translated">Un contexto intercepta las llamadas a los miembros de clase y aplica las directivas que se aplican a la clase, como la sincronización.</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>For more detailed information on remoting contexts, see <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.</source>
          <target state="translated">Para obtener más información acerca de los contextos de comunicación remota, vea <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> propiedades de la <ph id="ph4">&lt;xref:System.Type&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">Comprueba si el tipo especificado puede estar hospedado en el contexto, puede calcular las referencias por referencia y si el tipo es un tipo de datos primitivo.</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated">Implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph> y determina si la clase <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> puede hospedarse en un contexto.</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> puede estar hospedado en un contexto; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</source>
          <target state="translated">Un contexto intercepta las llamadas a los miembros de clase y aplicar directivas que se aplican a la clase, como la sincronización.</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsContextfulImpl`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`IsContextfulImpl`</ph> método.</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" uid="P:System.Type.IsEnum">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa una enumeración.</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual representa una enumeración; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property returns <ph id="ph1">`true`</ph> for an enumeration, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">Esta propiedad devuelve <ph id="ph1">`true`</ph> para una enumeración, pero no para el <ph id="ph2">&lt;xref:System.Enum&gt;</ph> propio tipo.</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>The following example demonstrates how to use the <ph id="ph1">`IsEnum`</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">`IsEnum`</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The value to be tested.</source>
          <target state="translated">Valor que se va a probar.</target>       </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>Returns a value that indicates whether the specified value exists in the current enumeration type.</source>
          <target state="translated">Devuelve un valor que indica si el valor especificado existe en el tipo de enumeración actual.</target>       </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is a member of the current enumeration type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el valor especificado es un miembro del tipo de enumeración actual; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">El tipo actual no es una enumeración.</target>       </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that cannot be the underlying type of an enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es de un tipo que no puede ser un tipo subyacente de una enumeración.</target>       </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The COM type that is tested for equivalence with the current type.</source>
          <target state="translated">Tipo COM cuya equivalencia con el tipo actual se comprueba.</target>       </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Determines whether two COM types have the same identity and are eligible for type equivalence.</source>
          <target state="translated">Determina si dos tipos COM tienen la misma identidad y se pueden usar para la equivalencia de tipos.</target>       </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the COM types are equivalent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si los tipos COM son equivalentes; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</source>
          <target state="translated">Este método también devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph> si un tipo está en un ensamblado que se carga para la ejecución y el otro está en un ensamblado que se carga en el contexto de solo reflexión.</target>       </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</source>
          <target state="translated">A partir del <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, common language runtime admite la incrustación de información de tipo para los tipos COM directamente en los ensamblados administrados, en lugar de exigir a los ensamblados administrados obtener información de tipo para los tipos COM de ensamblados de interoperabilidad.</target>       </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</source>
          <target state="translated">Dado que la información de tipos incrustada solo incluye los tipos y miembros que realmente usa un ensamblado administrado, dos ensamblados administrados pueden tener vistas muy diferentes del mismo tipo COM.</target>       </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Each managed assembly has a different <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to represent its view of the COM type.</source>
          <target state="translated">Cada ensamblado administrado tiene un objeto <ph id="ph1">&lt;xref:System.Type&gt;</ph> diferente para representar su vista del tipo COM.</target>       </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</source>
          <target state="translated">Common Language Runtime admite la equivalencia de tipos entre estas distintas vistas de interfaces, estructuras, enumeraciones y delegados.</target>       </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</source>
          <target state="translated">La equivalencia de tipos significa que un objeto COM que se pasa de un ensamblado administrado a otro se puede convertir al tipo administrado adecuado en el ensamblado receptor.</target>       </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> método permite a un ensamblado determinar que un objeto COM obtenido desde otro ensamblado tiene la misma identidad de COM que uno de los tipos de interoperabilidad de primera insertados propios de ensamblado y, por tanto, se puede convertir a ese tipo.</target>       </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Type Equivalence and Embedded Interop Types<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>equivalencia de tipos y tipos de interoperabilidad incrustados<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" uid="P:System.Type.IsExplicitLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</source>
          <target state="translated">Obtiene un valor que indica si los campos del tipo actual se disponen en los desplazamientos especificados explícitamente.</target>       </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> del tipo actual incluye <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Esta propiedad se proporciona por comodidad.</target>       </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">Como alternativa, puede usar el <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> valor de enumeración para seleccionar los atributos de diseño de tipo y, a continuación, probar si <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> se establece.</target>       </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> valores de enumeración indican la manera en que los campos del tipo se disponen en memoria.</target>       </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">Para los tipos dinámicos, puede especificar <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> cuando se crea el tipo.</target>       </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</source>
          <target state="translated">En el código, aplicar el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> atribuir a la <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> valor de enumeración para el tipo, para especificar que los desplazamientos a la que se iniciará los campos se especifican explícitamente.</target>       </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">No se puede utilizar el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> método para determinar si el <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> se ha aplicado a un tipo.</target>       </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The following example creates an instance of a type and displays the value of its <ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se crea una instancia de un tipo y muestra el valor de su <ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>It uses the <ph id="ph1">`MySystemTime`</ph> class, which is also in the code example for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>.</source>
          <target state="translated">Usa el <ph id="ph1">`MySystemTime`</ph> (clase), que también está en el ejemplo de código para <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericParameter">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or method.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un parámetro de tipo en la definición de un método o tipo genérico.</target>       </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type definition or generic method definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> representa un parámetro de tipo de una definición de tipo genérico o de una definición de método genérico; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent generic type parameters can be obtained by calling the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition, or the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos que representan los parámetros de tipo genérico se pueden obtener mediante una llamada a la <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> método de un <ph id="ph3">&lt;xref:System.Type&gt;</ph> objeto que representa una definición de tipo genérico, o la <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> método de una <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa un método genérico definición.</target>       </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a generic type or method definition, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for every element of the resulting array.</source>
          <target state="translated">Para un tipo genérico o la definición de método, el <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph> para todos los elementos de la matriz resultante.</target>       </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a closed constructed type or method, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for every element of the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method.</source>
          <target state="translated">Para un tipo construido cerrado o un método, el <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad devuelve <ph id="ph2">`false`</ph> para todos los elementos de la matriz devuelta por la <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</source>
          <target state="translated">Para un tipo construido abierto o un método, algunos elementos de la matriz podrían ser tipos específicos y otros podrían ser parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> returns <ph id="ph2">`false`</ph> for the types and <ph id="ph3">`true`</ph> for the type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> Devuelve <ph id="ph2">`false`</ph> para los tipos y <ph id="ph3">`true`</ph> para los parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property demonstrates a generic class with a mixture of types and type parameters.</source>
          <target state="translated">El ejemplo de código para el <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad muestra una clase genérica con una mezcla de tipos y parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to test for generic type parameters in a generic type.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propiedad que se va a probar para parámetros de tipo genérico en un tipo genérico.</target>       </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">Obtiene un valor que indica si el tipo actual es genérico.</target>       </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is a generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Si el tipo actual es un tipo genérico; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents a generic type.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> propiedad para determinar si un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto representa un tipo genérico.</target>       </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents an open constructed type or a closed constructed type.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad para determinar si un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto representa un tipo construido abierto o un tipo construido cerrado.</target>       </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> if the immediate type is not generic.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> propiedad devuelve <ph id="ph2">`false`</ph> si el tipo inmediato no es genérico.</target>       </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose elements are of type <ph id="ph1">`A&lt;int&gt;`</ph> (<ph id="ph2">`A(Of Integer)`</ph> in Visual Basic) is not itself a generic type.</source>
          <target state="translated">Por ejemplo, una matriz cuyos elementos son de tipo <ph id="ph1">`A&lt;int&gt;`</ph> (<ph id="ph2">`A(Of Integer)`</ph> en Visual Basic) no es un tipo genérico.</target>       </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table summarizes the invariant conditions for common terms used in generic reflection.</source>
          <target state="translated">En la tabla siguiente se resume las condiciones invariables para términos comunes utilizados en la reflexión genérica.</target>       </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Term</source>
          <target state="translated">Término</target>       </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariant</source>
          <target state="translated">Invariable</target>       </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type definition</source>
          <target state="translated">definición de tipo genérico</target>       </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Defines a generic type.</source>
          <target state="translated">Define un tipo genérico.</target>       </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>A constructed type is created by calling the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition and specifying an array of type arguments.</source>
          <target state="translated">Se crea un tipo construido mediante una llamada a la <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método en un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que representa una definición de tipo genérico y especifica una matriz de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be called only on generic type definitions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> puede llamarse solo en definiciones de tipo genérico.</target>       </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Any generic type definition is a generic type (the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>), but the converse is not true.</source>
          <target state="translated">Cualquier definición de tipo genérico es un tipo genérico (la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> propiedad es <ph id="ph2">`true`</ph>), pero la conversión no es verdadera.</target>       </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type</source>
          <target state="translated">tipo genérico</target>       </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be a generic type definition, an open constructed type, or a closed constructed type.</source>
          <target state="translated">Puede ser una definición de tipo genérico, un tipo construido abierto o un tipo construido cerrado.</target>       </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that an array type whose element type is generic is not itself a generic type.</source>
          <target state="translated">Tenga en cuenta que un tipo de matriz cuyo tipo de elemento es genérico no es un tipo genérico.</target>       </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The same is true of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing a pointer to a generic type.</source>
          <target state="translated">Lo mismo puede decirse de una <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa un puntero a un tipo genérico.</target>       </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>open constructed type</source>
          <target state="translated">tipo construido abierto</target>       </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Se trata de un tipo genérico que ha sin asignar parámetros de tipo, un tipo que está anidado en una definición de tipo genérico o en un tipo construido abierto o un tipo genérico que tiene un argumento de tipo para el que el <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>It is not possible to create an instance of an open constructed type.</source>
          <target state="translated">No es posible crear una instancia de un tipo construido abierto.</target>       </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that not all open constructed types are generic.</source>
          <target state="translated">Tenga en cuenta que no se podrá abrir todos los tipos construidos son genéricos.</target>       </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</source>
          <target state="translated">Por ejemplo, una matriz cuyo tipo de elemento es una definición de tipo genérico no es genérica, y un puntero a un tipo construido abierto no es genérico.</target>       </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>closed constructed type</source>
          <target state="translated">tipo construido cerrado</target>       </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> es <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When examined recursively, the type has no unassigned generic parameters.</source>
          <target state="translated">Cuando examina de forma recursiva, el tipo no tiene sin asignar parámetros genéricos.</target>       </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type parameter</source>
          <target state="translated">parámetro de tipo genérico</target>       </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>In a generic type definition, a placeholder for a type that will be assigned later.</source>
          <target state="translated">En una definición de tipo genérico, un marcador de posición para un tipo que se va a asignar más adelante.</target>       </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type argument</source>
          <target state="translated">argumento de tipo genérico</target>       </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be any type, including a generic type parameter.</source>
          <target state="translated">Puede ser cualquier tipo, incluido un parámetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Type arguments are specified as an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method when creating a constructed generic type.</source>
          <target state="translated">Argumentos de tipo se especifican como una matriz de <ph id="ph1">&lt;xref:System.Type&gt;</ph> los objetos pasan a la <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método cuando se crea un tipo genérico construido.</target>       </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>If instances of the resulting type are to be created, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property must be <ph id="ph2">`false`</ph> for all the type arguments.</source>
          <target state="translated">Si son instancias del tipo resultante que se creará, el <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad debe ser <ph id="ph2">`false`</ph> para todos los argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example and table illustrate some of these terms and invariants.</source>
          <target state="translated">El ejemplo de código y la tabla siguientes muestran algunas de estas condiciones e invariables.</target>       </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">`Derived`</ph> class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</source>
          <target state="translated">La <ph id="ph1">`Derived`</ph> clase resulta de especial interés porque su tipo base es un tipo construido que tiene una mezcla de tipos y parámetros de tipo en su lista de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table shows examples that use and build on the classes <ph id="ph1">`Base`</ph>, <ph id="ph2">`Derived`</ph>, and <ph id="ph3">`G`</ph>.</source>
          <target state="translated">La siguiente tabla muestra ejemplos que usan y basan en las clases de <ph id="ph1">`Base`</ph>, <ph id="ph2">`Derived`</ph>, y <ph id="ph3">`G`</ph>.</target>       </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When the C++ and C# code is the same, only one entry is shown.</source>
          <target state="translated">Cuando el código de C++ y C# es el mismo, se muestra sólo una entrada.</target>       </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariants</source>
          <target state="translated">Invariables</target>       </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">Para este tipo:</target>       </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">Para este tipo:</target>       </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> es <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For the type of variable <ph id="ph1">`d`</ph>:</source>
          <target state="translated">Para el tipo de variable <ph id="ph1">`d`</ph>:</target>       </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because <ph id="ph3">`d`</ph> is an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> es <ph id="ph2">`false`</ph> porque <ph id="ph3">`d`</ph> es una matriz.</target>       </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> es <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> es <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">`T`</ph>, <ph id="ph2">`U`</ph>, and <ph id="ph3">`V`</ph> (everywhere they appear)</source>
          <target state="translated"><ph id="ph1">`T`</ph>, <ph id="ph2">`U`</ph>, y <ph id="ph3">`V`</ph> (everywhere aparecen)</target>       </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because there is no way to constrain a type parameter to generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> es <ph id="ph2">`false`</ph> porque no hay ninguna manera de restringir un parámetro de tipo para tipos genéricos.</target>       </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> es <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because <ph id="ph3">`T`</ph>, <ph id="ph4">`U`</ph>, and <ph id="ph5">`V`</ph> are themselves generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> es <ph id="ph2">`true`</ph> porque <ph id="ph3">`T`</ph>, <ph id="ph4">`U`</ph>, y <ph id="ph5">`V`</ph> son parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This does not imply anything about type arguments that are assigned to them later.</source>
          <target state="translated">Esto no implica nada sobre los argumentos de tipo que se les asignan más adelante.</target>       </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The type of field <ph id="ph1">`F`</ph></source>
          <target state="translated">El tipo de campo <ph id="ph1">`F`</ph></target>       </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph> because a type has been assigned to the type parameter of <ph id="ph3">`G`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> es <ph id="ph2">`false`</ph> porque se ha asignado un tipo para el parámetro de tipo de <ph id="ph3">`G`</ph>.</target>       </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that this is equivalent to having called the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">Tenga en cuenta que esto es equivalente a haber llamado a la <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the type of field <ph id="ph3">`F`</ph> has a type argument that is an open constructed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> es <ph id="ph2">`true`</ph> porque el tipo de campo <ph id="ph3">`F`</ph> tiene un argumento de tipo es un tipo construido abierto.</target>       </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The constructed type is open because its type argument (that is, <ph id="ph1">`Base`</ph>) is a generic type definition.</source>
          <target state="translated">El tipo construido es abierto porque su argumento de tipo (es decir, <ph id="ph1">`Base`</ph>) es una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Esto ilustra la naturaleza recursiva de la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The nested class <ph id="ph1">`Nested`</ph></source>
          <target state="translated">La clase anidada <ph id="ph1">`Nested`</ph></target>       </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>, even though the <ph id="ph3">`Nested`</ph> class has no generic type parameters of its own, because it is nested in a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> es <ph id="ph2">`true`</ph>, incluso si la <ph id="ph3">`Nested`</ph> clase no tiene ningún parámetro de tipo genérico propios, porque está anidada en un tipo genérico.</target>       </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>That is, you can call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method and supply the type parameter of the enclosing type, <ph id="ph2">`Derived`</ph>.</source>
          <target state="translated">Es decir, puede llamar a la <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método y proporcione el parámetro de tipo del tipo envolvente, <ph id="ph2">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the enclosing type, <ph id="ph3">`Derived`</ph>, has generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> es <ph id="ph2">`true`</ph> porque incluye tipo, <ph id="ph3">`Derived`</ph>, tiene parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Esto ilustra la naturaleza recursiva de la <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example displays the value of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> properties for the types described in the Remarks section.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra el valor de la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> propiedades de los tipos descritos en la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For explanations of the property values, see the accompanying table in Remarks.</source>
          <target state="translated">Para obtener una explicación de los valores de propiedad, vea la tabla que aparece en la sección Comentarios.</target>       </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type definition, from which other generic types can be constructed.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa una definición de tipo genérico, a partir de la cual se pueden construir otros tipos genéricos.</target>       </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> representa una definición de tipo genérico; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">Una definición de tipo genérico es una plantilla desde la que se pueden construir otros tipos.</target>       </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic), by calling the <ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with a generic argument list containing the <ph id="ph7">&lt;xref:System.Int32&gt;</ph> type.</source>
          <target state="translated">Por ejemplo, desde la definición de tipo genérico <ph id="ph1">`G&lt;T&gt;`</ph> (expresado en sintaxis de C#; <ph id="ph2">`G(Of T)`</ph> en Visual Basic o <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> en C++) puede construir y crear instancias del tipo <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> en Visual Basic), mediante una llamada a la <ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método con una lista de argumento genérico que contiene el <ph id="ph7">&lt;xref:System.Int32&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method gets the generic type definition back again.</source>
          <target state="translated">Dado un <ph id="ph1">&lt;xref:System.Type&gt;</ph> construido de objeto que representa este tipo, el <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> método vuelve la definición de tipo genérico de nuevo.</target>       </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property to determine whether you can create new types from the current type.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> propiedad para determinar si puede crear nuevos tipos del tipo actual.</target>       </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, you can call the <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create new generic types.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph>, puede llamar a la <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método para crear nuevos tipos genéricos.</target>       </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>The following example displays information about a type, including whether or not it is a generic type definition.</source>
          <target state="translated">En el ejemplo siguiente se muestra información sobre un tipo, incluso si no es una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</source>
          <target state="translated">Se muestra información para un tipo construido, para su definición de tipo genérico y para un tipo normal.</target>       </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" uid="P:System.Type.IsImport">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph> attribute applied, indicating that it was imported from a COM type library.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> tiene aplicado un atributo <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>, lo que indica que se ha importado de una biblioteca de tipos COM.</target>       </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> tiene un atributo <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>; de lo contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The object to compare with the current type.</source>
          <target state="translated">Objeto que se va a comparar con el tipo actual.</target>       </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>Determines whether the specified object is an instance of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Determina si el objeto especificado es una instancia del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> is in the inheritance hierarchy of the object represented by <ph id="ph3">&lt;paramref name="o" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an interface that <ph id="ph5">&lt;paramref name="o" /&gt;</ph> implements.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see langword="Type" /&gt;</ph> actual se encuentra en la jerarquía de herencia del objeto representado por <ph id="ph3">&lt;paramref name="o" /&gt;</ph>, o si el objeto <ph id="ph4">&lt;see langword="Type" /&gt;</ph> actual es una interfaz que implementa <ph id="ph5">&lt;paramref name="o" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if neither of these conditions is the case, if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an open generic type (that is, <ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph6">&lt;see langword="true" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> si no se cumple ninguna de estas condiciones, o si <ph id="ph2">&lt;paramref name="o" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>, o si el objeto <ph id="ph4">&lt;see langword="Type" /&gt;</ph> actual es un tipo genérico abierto (es decir, la propiedad <ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> devuelve <ph id="ph6">&lt;see langword="true" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>A constructed type is not an instance of its generic type definition.</source>
          <target state="translated">Un tipo construido no es una instancia de su definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>That is, <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) is not an instance of <ph id="ph3">`MyGenericList&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericList(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Es decir, <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> en Visual Basic) no es una instancia de <ph id="ph3">`MyGenericList&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericList(Of T)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The following example demonstrates the use of the <ph id="ph1">`IsInstanceOfType`</ph> method.</source>
          <target state="translated">En el siguiente ejemplo se muestra el uso del método <ph id="ph1">`IsInstanceOfType`</ph>.</target>       </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" uid="P:System.Type.IsInterface">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; that is, not a class or a value type.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> es una interfaz, es decir, no es una clase ni un tipo de valor.</target>       </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es una interfaz; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> distinguishes a type declaration as class, interface or value type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> distingue una declaración de tipo clase, interfaz o tipo de valor.</target>       </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The following example creates an interface, checks for the interface type, and indicates whether a class has the <ph id="ph1">`IsInterface`</ph> property set.</source>
          <target state="translated">En el ejemplo siguiente se crea una interfaz, busca el tipo de interfaz e indica si una clase tiene la <ph id="ph1">`IsInterface`</ph> del conjunto de propiedades.</target>       </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" uid="P:System.Type.IsLayoutSequential">
          <source>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</source>
          <target state="translated">Obtiene un valor que indica si los campos del tipo actual se disponen secuencialmente, en el orden que se definieron o emitieron en los metadatos.</target>       </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> del tipo actual incluye <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Esta propiedad se proporciona por comodidad.</target>       </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">Como alternativa, puede usar el <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> valor de enumeración para seleccionar los atributos de diseño de tipo y, a continuación, probar si <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> se establece.</target>       </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> valores de enumeración indican la manera en que los campos del tipo se disponen en memoria.</target>       </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">Para los tipos dinámicos, puede especificar <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> cuando se crea el tipo.</target>       </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that layout is sequential.</source>
          <target state="translated">En el código, aplicar el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> atribuir a la <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> valor de enumeración para el tipo, para especificar que el diseño es secuencial.</target>       </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">No se puede utilizar el <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> método para determinar si el <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> se ha aplicado a un tipo.</target>       </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Para obtener más información, vea la sección 9.1.2 de la especificación para la documentación de Common Language Infrastructure (CLI), "Partition II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</target>       </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The following example creates an instance of a class for which the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> class has been set, checks for the <ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph> property, and displays the result.</source>
          <target state="translated">En el ejemplo siguiente se crea una instancia de una clase para la que el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> valor de enumeración en el <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> (clase) se ha establecido, busca el <ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph> propiedad y se muestra el resultado.</target>       </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" uid="P:System.Type.IsMarshalByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> se calcula por referencia.</target>       </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> se calcula por referencia; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> propiedades de la <ph id="ph4">&lt;xref:System.Type&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">Comprueba si el tipo especificado puede estar hospedado en el contexto, puede calcular las referencias por referencia y si el tipo es un tipo de datos primitivo.</target>       </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated">Implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph> y determina si las referencias de <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> se calculan por referencia.</target>       </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> se calcula por referencia; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>The following example determines whether the given type is marshaled by reference and displays the result.</source>
          <target state="translated">En el ejemplo siguiente se determina si el tipo especificado se calcula por referencia y muestra el resultado.</target>       </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" uid="P:System.Type.IsNested">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type whose definition is nested inside the definition of another type.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual representa un tipo cuya definición está anidada dentro de la definición de otro tipo.</target>       </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested inside another type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> está anidado dentro de otro tipo; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for all nested types, regardless of visibility.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph> para todos los tipos, independientemente de la visibilidad anidadas.</target>       </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>To test for nesting and visibility at the same time, use the related properties <ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.</source>
          <target state="translated">Para probar el anidamiento y la visibilidad al mismo tiempo, utilice las propiedades relacionadas <ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, o <ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> enumeration member selects the visibility attributes for a type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> miembro de enumeración selecciona los atributos de visibilidad para un tipo.</target>       </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">En el ejemplo siguiente se crea una clase externa con un número de clases anidadas que contengan varios tipos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">A continuación, recupera el valor de un número de relacionados con la visibilidad <ph id="ph1">&lt;xref:System.Type&gt;</ph> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</target>       </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedAssembly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y solo se ve dentro de su propio ensamblado.</target>       </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y solo se ve dentro de su propio ensamblado; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selecciona los atributos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">En el ejemplo siguiente se crea una clase externa con un número de clases anidadas que contengan varios tipos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">A continuación, recupera el valor de un número de relacionados con la visibilidad <ph id="ph1">&lt;xref:System.Type&gt;</ph> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</target>       </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamANDAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y solo está visible para las clases que pertenezcan tanto a su propia familia como a su propio ensamblado.</target>       </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y solo está visible para las clases que pertenezcan a su propia familia y a su propio ensamblado; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selecciona los atributos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</source>
          <target state="translated">Los lenguajes C# y Visual Basic no incluyen la semántica que le permite definir un tipo anidado que solo es visible para los tipos protegidos en su propio ensamblado.</target>       </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">`protected internal`</ph> visibility in C# and <ph id="ph2">`Protected Friend`</ph> visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</source>
          <target state="translated"><ph id="ph1">`protected internal`</ph> visibilidad en C# y <ph id="ph2">`Protected Friend`</ph> visibilidad en Visual Basic define un tipo anidado que esté visible para los tipos protegidos y a los tipos en el mismo ensamblado.</target>       </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Type&gt;</ph> familia del objeto se define como todos los objetos de la misma <ph id="ph2">&lt;xref:System.Type&gt;</ph> y de sus subtipos.</target>       </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">En el ejemplo siguiente se crea una clase externa con un número de clases anidadas que contengan varios tipos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">A continuación, recupera el valor de un número de relacionados con la visibilidad <ph id="ph1">&lt;xref:System.Type&gt;</ph> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</target>       </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamily">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y solo se ve dentro de su propia familia.</target>       </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y solo se ve dentro de su propia familia; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selecciona los atributos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Type&gt;</ph> familia del objeto se define como todos los objetos exactamente del mismo <ph id="ph2">&lt;xref:System.Type&gt;</ph> y de sus subtipos.</target>       </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">En el ejemplo siguiente se crea una clase externa con un número de clases anidadas que contengan varios tipos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">A continuación, recupera el valor de un número de relacionados con la visibilidad <ph id="ph1">&lt;xref:System.Type&gt;</ph> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</target>       </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamORAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to either its own family or to its own assembly.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y solo está visible para las clases que pertenezcan a su propia familia o a su propio ensamblado.</target>       </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y solo está visible para las clases que pertenezcan a su propia familia o a su propio ensamblado; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the visibility of a type is <ph id="ph1">`protected internal`</ph> in C# or <ph id="ph2">`Protected Friend`</ph> in Visual Basic, the <ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Si la visibilidad de un tipo es <ph id="ph1">`protected internal`</ph> en C# o <ph id="ph2">`Protected Friend`</ph> en Visual Basic, la <ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> propiedad devuelve <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selecciona los atributos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Type&gt;</ph> familia del objeto se define como todos los objetos exactamente del mismo <ph id="ph2">&lt;xref:System.Type&gt;</ph> y de sus subtipos.</target>       </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">En el ejemplo siguiente se crea una clase externa con un número de clases anidadas que contengan varios tipos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">A continuación, recupera el valor de un número de relacionados con la visibilidad <ph id="ph1">&lt;xref:System.Type&gt;</ph> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</target>       </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPrivate">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y se ha declarado privado.</target>       </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> está anidado y se ha declarado privado; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selecciona los atributos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">En el ejemplo siguiente se crea una clase externa con un número de clases anidadas que contengan varios tipos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">A continuación, recupera el valor de un número de relacionados con la visibilidad <ph id="ph1">&lt;xref:System.Type&gt;</ph> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</target>       </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPublic">
          <source>Gets a value indicating whether a class is nested and declared public.</source>
          <target state="translated">Obtiene un valor que indica si hay una clase anidada que se ha declarado pública.</target>       </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the class is nested and declared public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la clase está anidada y se ha declarado pública; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selecciona los atributos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">En el ejemplo siguiente se crea una clase externa con un número de clases anidadas que contengan varios tipos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">A continuación, recupera el valor de un número de relacionados con la visibilidad <ph id="ph1">&lt;xref:System.Type&gt;</ph> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</target>       </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" uid="P:System.Type.IsNotPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> no se ha declarado público.</target>       </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> no se ha declarado público y no es un tipo anidado; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Do not use this property with nested types; use the <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> property instead.</source>
          <target state="translated">No utilice esta propiedad con tipos anidados; Utilice la <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> propiedad en su lugar.</target>       </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>This example usesthe <ph id="ph1">`IsNotPublic`</ph> property to get the visibility of the type.</source>
          <target state="translated">Este ejemplo utiliza <ph id="ph1">`IsNotPublic`</ph> propiedad que se va a obtener la visibilidad del tipo.</target>       </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The following code example demonstrates why you cannot use <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> for nested classes.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra por qué no se puede utilizar <ph id="ph1">`IsPublic`</ph> y <ph id="ph2">`IsNotPublic`</ph> para las clases anidadas.</target>       </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">`IsNestedPublic`</ph> and <ph id="ph4">`IsNestedPrivate`</ph>.</source>
          <target state="translated">Para las clases anidadas, omita los resultados de <ph id="ph1">`IsPublic`</ph> y <ph id="ph2">`IsNotPublic`</ph> y preste atención sólo a los resultados de <ph id="ph3">`IsNestedPublic`</ph> y <ph id="ph4">`IsNestedPrivate`</ph>.</target>       </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The reflection output for this code fragment would be as follows:</source>
          <target state="translated">El resultado de la reflexión para este fragmento de código sería como sigue:</target>       </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Class</source>
          <target state="translated">Clase</target>       </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNotPublic</source>
          <target state="translated">IsNotPublic</target>       </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsPublic</source>
          <target state="translated">IsPublic</target>       </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPublic</source>
          <target state="translated">IsNestedPublic</target>       </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPrivate</source>
          <target state="translated">IsNestedPrivate</target>       </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>A</source>
          <target state="translated">A</target>       </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>B</source>
          <target state="translated">B</target>       </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" uid="P:System.Type.IsPointer">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> es un puntero.</target>       </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un puntero; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>The following example shows a use of the <ph id="ph1">`IsPointer`</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`IsPointer`</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">Cuando se invalida en una clase derivada, implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> y determina si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un puntero.</target>       </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un puntero; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" uid="P:System.Type.IsPrimitive">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> es uno de los tipos primitivos.</target>       </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es uno de los tipos primitivos; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>, <ph id="ph12">&lt;xref:System.Char&gt;</ph>, <ph id="ph13">&lt;xref:System.Double&gt;</ph>, and <ph id="ph14">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">Los tipos primitivos son <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>, <ph id="ph12">&lt;xref:System.Char&gt;</ph>, <ph id="ph13">&lt;xref:System.Double&gt;</ph>, y <ph id="ph14">&lt;xref:System.Single&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> propiedades de la <ph id="ph4">&lt;xref:System.Type&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">Comprueba si el tipo especificado puede estar hospedado en el contexto, puede calcular las referencias por referencia y si el tipo es un tipo de datos primitivo.</target>       </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">Cuando se invalida en una clase derivada, implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph> y determina si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es uno de los tipos primitivos.</target>       </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es uno de los tipos primitivos; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.Char&gt;</ph>, <ph id="ph11">&lt;xref:System.Double&gt;</ph>, and <ph id="ph12">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">Los tipos primitivos son <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.Char&gt;</ph>, <ph id="ph11">&lt;xref:System.Double&gt;</ph>, y <ph id="ph12">&lt;xref:System.Single&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The following example determines whether the given type is a primitive type and displays the result.</source>
          <target state="translated">En el ejemplo siguiente se determina si el tipo especificado es un tipo primitivo y muestra el resultado.</target>       </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" uid="P:System.Type.IsPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared public.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> se ha declarado público.</target>       </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> se ha declarado el público y no es un tipo anidado; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>Do not use with nested types; use <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> instead.</source>
          <target state="translated">No se debe usar con tipos anidados; Utilice <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> en su lugar.</target>       </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad devuelve <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selecciona los atributos de visibilidad.</target>       </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph>, checks for the <ph id="ph2">`IsPublic`</ph> property, and displays the result.</source>
          <target state="translated">En el ejemplo siguiente se crea una instancia de <ph id="ph1">`MyTestClass`</ph>, busca la <ph id="ph2">`IsPublic`</ph> propiedad y se muestra el resultado.</target>       </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>.</source>
          <target state="translated">Para las clases anidadas, omita los resultados de <ph id="ph1">`IsPublic`</ph> y <ph id="ph2">`IsNotPublic`</ph> y preste atención sólo a los resultados de <ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> y <ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" uid="P:System.Type.IsSealed">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> se declaró "sealed".</target>       </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> se declara "sealed"; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>The following example creates an instance of a <ph id="ph1">`sealed`</ph> class, checks for the <ph id="ph2">`IsSealed`</ph> property, and displays the result.</source>
          <target state="translated">En el ejemplo siguiente se crea una instancia de un <ph id="ph1">`sealed`</ph> de la clase, busca la <ph id="ph2">`IsSealed`</ph> propiedad y se muestra el resultado.</target>       </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">Obtiene un valor que indica si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual y, por tanto, puede realizar operaciones críticas.</target>       </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si es transparente.</target>       </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> propiedades notifican el nivel de transparencia del tipo en su nivel de confianza actual, determinado por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</target>       </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Nivel de seguridad</target>       </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Crítico</target>       </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">Crítico seguro</target>       </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Transparente</target>       </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</target>       </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</target>       </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</target>       </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">El ensamblado y todos sus tipos se tratan como transparente.</target>       </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</target>       </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</target>       </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre la reflexión y transparencia, consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de las transparencias, consulte <bpt id="p1">[</bpt>cambios de seguridad<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Obtiene un valor que indica si el tipo actual es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</target>       </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo actual es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si es crítico para la seguridad o transparente.</target>       </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> propiedades notifican el nivel de transparencia del tipo en su nivel de confianza actual, determinado por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</target>       </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Nivel de seguridad</target>       </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Crítico</target>       </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">Crítico seguro</target>       </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Transparente</target>       </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</target>       </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</target>       </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</target>       </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">El ensamblado y todos sus tipos se tratan como transparente.</target>       </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</target>       </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</target>       </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre la reflexión y transparencia, consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de las transparencias, consulte <bpt id="p1">[</bpt>cambios de seguridad<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">Obtiene un valor que indica si el tipo actual es transparente en el nivel de confianza actual y, por tanto, no puede realizar operaciones críticas.</target>       </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo es transparente para la seguridad en el nivel de confianza actual; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si esta propiedad devuelve <ph id="ph1">`true`</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> devuelven propiedades <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> propiedades notifican el nivel de transparencia del tipo en su nivel de confianza actual, determinado por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</target>       </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</target>       </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</target>       </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">El ensamblado y todos sus tipos se tratan como transparente.</target>       </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</target>       </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</target>       </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre la reflexión y transparencia, consulte <bpt id="p1">[</bpt>consideraciones de seguridad para la reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de las transparencias, consulte <bpt id="p1">[</bpt>cambios de seguridad<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" uid="P:System.Type.IsSerializable">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is serializable.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> es serializable.</target>       </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is serializable; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es serializable; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Types that are defined in the .NET Standard are not marked with <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>.</source>
          <target state="translated">Tipos que se definen en el estándar de .NET no se marcan con <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Instead, each .NET implementation determines whether a type is serializable.</source>
          <target state="translated">En su lugar, cada implementación de .NET determina si un tipo es serializable.</target>       </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>At run time, you can use the <ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph> property to determine whether that implementation supports serialization of an instance of the type.</source>
          <target state="translated">En tiempo de ejecución, puede utilizar el <ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph> propiedad para determinar si esa implementación admite la serialización de una instancia del tipo.</target>       </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to determine if a .NET Standard object is serializable<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>.</source>
          <target state="translated">Para obtener más información y un ejemplo, vea <bpt id="p1">[</bpt>cómo determinar si un objeto .NET estándar es serializable<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph> class, sets the [Serializable] attribute, and checks the <ph id="ph2">`IsSerializable`</ph> property for <ph id="ph3">`true`</ph> or <ph id="ph4">`false`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crea una instancia de <ph id="ph1">`MyTestClass`</ph> (clase), Establece el atributo [Serializable] y comprueba el <ph id="ph2">`IsSerializable`</ph> propiedad <ph id="ph3">`true`</ph> o <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" uid="P:System.Type.IsSpecialName">
          <source>Gets a value indicating whether the type has a name that requires special handling.</source>
          <target state="translated">Obtiene un valor que indica si el tipo tiene un nombre que requiere un tratamiento especial.</target>       </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type has a name that requires special handling; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo tiene un nombre que requiere un tratamiento especial; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</source>
          <target state="translated">Los nombres que comienzan por o contengan un carácter de subrayado (_), los descriptores de acceso de propiedad y métodos de sobrecarga de operadores son ejemplos de tipos que pueden requerir un tratamiento especial por parte de algunos compiladores.</target>       </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">Tipo que se va a comparar con el tipo actual.</target>       </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Determines whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> derives from the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Determina si el <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual se deriva del <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> derives from <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el <ph id="ph2">&lt;see langword="Type" /&gt;</ph> actual se quita de <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> and the current <ph id="ph3">&lt;see langword="Type" /&gt;</ph> are equal.</source>
          <target state="translated">Este método también devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph> si <ph id="ph2">&lt;paramref name="c" /&gt;</ph> y el <ph id="ph3">&lt;see langword="Type" /&gt;</ph> actual son iguales.</target>       </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to determine any of the following:</source>
          <target state="translated">Puede llamar a la <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> método para determinar ninguno de los siguientes:</target>       </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether one class derives from another.</source>
          <target state="translated">Si una clase se deriva de otro.</target>       </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">Si un tipo se deriva de <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> is a more efficient way to determine whether a type is a value type.</source>
          <target state="translated">Sin embargo, el <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> es una manera más eficaz para determinar si un tipo es un tipo de valor.</target>       </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</source>
          <target state="translated">Si un tipo se deriva de <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph> method is a more efficient way to determine whether a type is an enumeration.</source>
          <target state="translated">Sin embargo, la <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph> método es una forma más eficaz para determinar si un tipo es una enumeración.</target>       </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type is a delegate, that is, whether it derives from either <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> or <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>.</source>
          <target state="translated">Si un tipo es un delegado, es decir, si deriva desde <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> o <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> no se puede usar el método para determinar si una interfaz se deriva de otra interfaz, o si una clase implementa una interfaz.</target>       </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method for that purpose, as the following example shows.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> método para ese propósito, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> if it has no class constraint.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o de método genérico, se deriva de su restricción de clase o de <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> si no tiene ninguna restricción de clase.</target>       </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Except when used with interfaces, <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> is the converse of <ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.</source>
          <target state="translated">Excepto cuando se usa con interfaces, <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> es el elemento opuesto de <ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>That is, if <ph id="ph1">`t1.IsSubclassOf(t2)`</ph> is <ph id="ph2">`true`</ph>, then <ph id="ph3">`t2.IsAssignableFrom(t1)`</ph> is also <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Es decir, si <ph id="ph1">`t1.IsSubclassOf(t2)`</ph> es <ph id="ph2">`true`</ph>, a continuación, <ph id="ph3">`t2.IsAssignableFrom(t1)`</ph> también es <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Este método puede reemplazarse por una clase derivada.</target>       </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The following example creates a class named <ph id="ph1">`Class1`</ph> and a derived class named <ph id="ph2">`DerivedC1`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crea una clase denominada <ph id="ph1">`Class1`</ph> y una clase derivada denominada <ph id="ph2">`DerivedC1`</ph>.</target>       </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>It calls the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to show that <ph id="ph2">`DerivedC1`</ph> is a subclass of <ph id="ph3">`Class1`</ph>.</source>
          <target state="translated">Lo llama el <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> método para mostrar que <ph id="ph2">`DerivedC1`</ph> es una subclase de <ph id="ph3">`Class1`</ph>.</target>       </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" uid="P:System.Type.IsUnicodeClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene un valor que indica si se selecciona el atributo de formato de cadena <ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> para el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se selecciona el atributo de formato de cadena <ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph> para <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> is used to select the string format attributes.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> se utiliza para seleccionar los atributos de formato de cadena.</target>       </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">Los atributos de formato de cadena mejoran la interoperabilidad al definir cómo deben interpretarse las cadenas.</target>       </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" uid="P:System.Type.IsValueType">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a value type.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> es un tipo de valor.</target>       </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un tipo de valor; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</source>
          <target state="translated">Tipos de valor son tipos que se representan como secuencias de bits; tipos de valor no son interfaces o clases.</target>       </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are referred to as "structs" in some programming languages.</source>
          <target state="translated">Tipos de valor se conocen como "structs" en algunos lenguajes de programación.</target>       </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Enums are a special case of value types.</source>
          <target state="translated">Las enumeraciones son un caso especial de tipos de valor.</target>       </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`false`</ph> for the <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> class, because <ph id="ph3">&lt;xref:System.ValueType&gt;</ph> is not a value type itself.</source>
          <target state="translated">Esta propiedad devuelve <ph id="ph1">`false`</ph> para el <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> de la clase, porque <ph id="ph3">&lt;xref:System.ValueType&gt;</ph> no es un tipo de valor.</target>       </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>It is the base class for all value types, and therefore any value type can be assigned to it.</source>
          <target state="translated">Es la clase base para todos los tipos de valor y, por lo tanto, cualquier tipo de valor puede asignarse a él.</target>       </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This would not be possible if <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> itself was a value type.</source>
          <target state="translated">Esto no sería posible si <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> propio encontró un tipo de valor.</target>       </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are boxed when they are assigned to a field of type <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">Tipos de valor son una conversión boxing cuando se asignan a un campo de tipo <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`true`</ph> for enumerations, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">Esta propiedad devuelve <ph id="ph1">`true`</ph> para las enumeraciones, pero no para el <ph id="ph2">&lt;xref:System.Enum&gt;</ph> propio tipo.</target>       </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>For an example that demonstrates this behavior, see <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.</source>
          <target state="translated">Para obtener un ejemplo que muestra este comportamiento, consulte <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property is read-only.</source>
          <target state="translated">Esta propiedad es de sólo lectura.</target>       </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>The following example creates a variable of type <ph id="ph1">`MyEnum`</ph>, checks for the <ph id="ph2">`IsValueType`</ph> property, and displays the result.</source>
          <target state="translated">En el ejemplo siguiente se crea una variable de tipo <ph id="ph1">`MyEnum`</ph>, busca la <ph id="ph2">`IsValueType`</ph> propiedad y se muestra el resultado.</target>       </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; that is, not a class or an interface.</source>
          <target state="translated">Implementa la propiedad <ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph> y determina si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un tipo de valor; es decir, no es una clase ni una interfaz.</target>       </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> es un tipo de valor; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>This method is provided to enable the implementation of alternate type systems.</source>
          <target state="translated">Este método se proporciona para habilitar la implementación de sistemas de tipos alternativos.</target>       </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>It is not generally used in application code.</source>
          <target state="translated">No se utiliza normalmente en el código de aplicación.</target>       </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" uid="P:System.Type.IsVisible">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be accessed by code outside the assembly.</source>
          <target state="translated">Obtiene un valor que indica si se puede obtener acceso al objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> mediante el código fuera del ensamblado.</target>       </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a public type or a public nested type such that all the enclosing types are public; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual es un tipo público o un tipo anidado público del que todos los tipos envolventes son públicos; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>Use this property to determine whether a type is part of the public interface of a component assembly.</source>
          <target state="translated">Utilice esta propiedad para determinar si un tipo es parte de la interfaz pública de un ensamblado de componente.</target>       </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>The following code example tests two classes, only one of which is visible outside the assembly.</source>
          <target state="translated">En el ejemplo de código siguiente se prueba dos clases, solo uno de los cuales está visible fuera del ensamblado.</target>       </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una matriz del tipo actual.</target>       </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</target>       </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</target>       </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> método proporciona un medio para generar tipos de matriz cuyos tipos de elemento se calculan en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Tenga en cuenta<ept id="p1">**</ept> common language runtime distingue entre vectores (es decir, las matrices unidimensionales que siempre son de base cero) y matrices multidimensionales.</target>       </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">Un vector, que siempre tiene sólo una dimensión, no es igual a una matriz multidimensional que se produce a tener solamente una dimensión.</target>       </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>This method overload can only be used to create vector types, and it is the only way to create a vector type.</source>
          <target state="translated">Esta sobrecarga del método sólo puede utilizarse para crear tipos de vector y es la única manera de crear un tipo de vector.</target>       </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> method overload to create multidimensional array types.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> sobrecarga del método para crear tipos de matrices multidimensionales.</target>       </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se crea la matriz, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> en Visual Basic) y los tipos de puntero para la <ph id="ph3">`Test`</ph> clase.</target>       </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">El método invocado no se admite en la clase base.</target>       </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Las clases derivadas deben proporcionar una implementación.</target>       </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">El tipo actual es <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">El tipo actual es un tipo <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Es decir, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">Número de dimensiones de la matriz.</target>       </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>This number must be less than or equal to 32.</source>
          <target state="translated">Este número debe ser menor o igual que 32.</target>       </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una matriz del tipo actual, con el número de dimensiones especificado.</target>       </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>An object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Objeto que representa una matriz del tipo actual, con el número de dimensiones especificado.</target>       </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> método proporciona un medio para generar tipos de matriz cuyos tipos de elemento se calculan en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated">Common language runtime distingue entre vectores (es decir, las matrices unidimensionales que siempre son de base cero) y matrices multidimensionales.</target>       </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">Un vector, que siempre tiene sólo una dimensión, no es igual a una matriz multidimensional que se produce a tener solamente una dimensión.</target>       </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>You cannot use this method overload to create a vector type; if <ph id="ph1">`rank`</ph> is 1, this method overload returns a multidimensional array type that happens to have one dimension.</source>
          <target state="translated">No se puede utilizar esta sobrecarga del método para crear un tipo de vector; Si <ph id="ph1">`rank`</ph> es 1, esta sobrecarga del método devuelve un tipo de matriz multidimensional que posee una dimensión.</target>       </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph> method overload to create vector types.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph> sobrecarga del método para crear tipos de vector.</target>       </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se crea la matriz, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> en Visual Basic) y los tipos de puntero para la <ph id="ph3">`Test`</ph> clase.</target>       </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>For example, 0 or negative.</source>
          <target state="translated">Por ejemplo, 0 o negativo.</target>       </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">No se admite el método invocado en la clase base.</target>       </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">El tipo actual es <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">El tipo actual es un tipo <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Es decir, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is greater than 32.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> es mayor que 32.</target>       </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo actual cuando se pasa como un parámetro <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo actual cuando se pasa como un parámetro <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> método proporciona una manera de generar <ph id="ph2">`ref`</ph> tipos (<ph id="ph3">`ByRef`</ph> en Visual Basic) para el parámetro se enumeran.</target>       </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32&amp;`</ph>.</source>
          <target state="translated">Mediante la sintaxis de lenguaje intermedio de Microsoft (MSIL), si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, este método devuelve un <ph id="ph3">&lt;xref:System.Type&gt;</ph> que representa el objeto <ph id="ph4">`Int32&amp;`</ph>.</target>       </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se crea la matriz, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> en Visual Basic) y los tipos de puntero para la <ph id="ph3">`Test`</ph> clase.</target>       </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">El método invocado no se admite en la clase base.</target>       </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">El tipo actual es <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">El tipo actual es un tipo <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Es decir, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type.</source>
          <target state="translated">Matriz de tipos que se va a sustituir por los parámetros del tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the resulting constructed type.</source>
          <target state="translated">Sustituye los elementos de una matriz de tipos por los parámetros de tipo de la definición de tipo genérico actual y devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo construido resultante.</target>       </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo construido formado al sustituir los elementos de <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> por los parámetros del tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a particular constructed type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método le permite escribir código que asigna tipos específicos a los parámetros de tipo de una definición de tipo genérico, creando así una <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que representa un tipo construido en particular.</target>       </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to create run-time instances of the constructed type.</source>
          <target state="translated">Puede utilizar esta <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto para crear instancias de tiempo de ejecución del tipo construido.</target>       </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Types constructed with <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</source>
          <target state="translated">Tipos construyan con <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> puede ser abierto, es decir, algunos de sus argumentos de tipo pueden ser parámetros de tipo de métodos genéricos o tipos de inclusión.</target>       </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You might use such open constructed types when you emit dynamic assemblies.</source>
          <target state="translated">Puede usar estos tipos construidos abiertos al emitir ensamblados dinámicos.</target>       </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For example, consider the classes <ph id="ph1">`Base`</ph> and <ph id="ph2">`Derived`</ph> in the following code.</source>
          <target state="translated">Por ejemplo, considere las clases <ph id="ph1">`Base`</ph> y <ph id="ph2">`Derived`</ph> en el código siguiente.</target>       </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To generate <ph id="ph1">`Derived`</ph> in a dynamic assembly, it is necessary to construct its base type.</source>
          <target state="translated">Para generar <ph id="ph1">`Derived`</ph> en un ensamblado dinámico, es necesario construir su tipo base.</target>       </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To do this, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the class <ph id="ph3">`Base`</ph>, using the generic type arguments <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and the type parameter <ph id="ph5">`V`</ph> from <ph id="ph6">`Derived`</ph>.</source>
          <target state="translated">Para ello, llame a la <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método en un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que representa la clase <ph id="ph3">`Base`</ph>, usando los argumentos de tipo genérico <ph id="ph4">&lt;xref:System.Int32&gt;</ph> y el parámetro de tipo <ph id="ph5">`V`</ph> de <ph id="ph6">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Because types and generic type parameters are both represented by <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, an array containing both can be passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">Dado que los tipos y parámetros de tipo genérico se representan mediante <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos, una matriz que contiene ambos puede pasarse a la <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A constructed type such as <ph id="ph1">`Base&lt;int, V&gt;`</ph> is useful when emitting code, but you cannot call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on this type because it is not a generic type definition.</source>
          <target state="translated">Un tipo construido como <ph id="ph1">`Base&lt;int, V&gt;`</ph> es útil cuando emisión de código, pero no se puede llamar el <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método en este tipo porque no es una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create a closed constructed type that can be instantiated, first call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the generic type definition and then call <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> with the desired type arguments.</source>
          <target state="translated">Para crear un tipo construido cerrado que se puede crear instancias, primero llame a la <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> método para obtener un <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto que representa la definición de tipo genérico y, a continuación, llame a <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> con los argumentos de tipo deseado.</target>       </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object returned by <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> is the same as the <ph id="ph3">&lt;xref:System.Type&gt;</ph> obtained by calling the <ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph> method of the resulting constructed type, or the <ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph> method of any constructed type that was created from the same generic type definition using the same type arguments.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto devuelto por <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> es el mismo que el <ph id="ph3">&lt;xref:System.Type&gt;</ph> obtenido mediante una llamada a la <ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph> método resultante construido tipo, o la <ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph> construir de método de cualquier tipo que se creó desde la misma genérico definición de tipo con los mismos argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of generic types is not itself a generic type.</source>
          <target state="translated">Una matriz de tipos genéricos no es un tipo genérico.</target>       </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You cannot call <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on an array type such as <ph id="ph2">`C&lt;T&gt;[]`</ph> (<ph id="ph3">`Dim ac() As C(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">No se puede llamar <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> en una matriz de tipo como <ph id="ph2">`C&lt;T&gt;[]`</ph> (<ph id="ph3">`Dim ac() As C(Of T)`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a closed generic type from <ph id="ph1">`C&lt;T&gt;[]`</ph>, call <ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph> to obtain the generic type definition <ph id="ph3">`C&lt;T&gt;`</ph>; call <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on the generic type definition to create the constructed type; and finally call the <ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method on the constructed type to create the array type.</source>
          <target state="translated">Para construir un tipo genérico de <ph id="ph1">`C&lt;T&gt;[]`</ph>, llame a <ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph> para obtener la definición de tipo genérico <ph id="ph3">`C&lt;T&gt;`</ph>; llame a <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> en la definición de tipo genérico para crear el tipo construido; y por último, llame a la <ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> método en el tipo construido para crear el tipo de matriz.</target>       </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The same is true of pointer types and <ph id="ph1">`ref`</ph> types (<ph id="ph2">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated">Lo mismo puede decirse de tipos de puntero y <ph id="ph1">`ref`</ph> tipos (<ph id="ph2">`ByRef`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Nested Types</source>
          <target state="translated">Tipos anidados</target>       </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</source>
          <target state="translated">Si se define un tipo genérico con C#, C++ o Visual Basic, sus tipos anidados son todos los genéricos.</target>       </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</source>
          <target state="translated">Esto es cierto incluso si los tipos anidados no tienen ningún parámetro de tipo de sus propios, porque los tres lenguajes incluyen los parámetros de tipo de tipos envolventes en las listas de parámetros de tipo de tipos anidados.</target>       </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following classes:</source>
          <target state="translated">Tenga en cuenta las siguientes clases:</target>       </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The type parameter list of the nested class <ph id="ph1">`Inner`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, the first of which is the type parameter of its enclosing class.</source>
          <target state="translated">La lista de parámetros de tipo de la clase anidada <ph id="ph1">`Inner`</ph> tiene dos parámetros de tipo, <ph id="ph2">`T`</ph> y <ph id="ph3">`U`</ph>, el primero de los cuales es el parámetro de tipo de su clase envolvente.</target>       </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Similarly, the type parameter list of the nested class <ph id="ph1">`Innermost1`</ph> has three type parameters, <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph>, and <ph id="ph4">`V`</ph>, with <ph id="ph5">`T`</ph> and <ph id="ph6">`U`</ph> coming from its enclosing classes.</source>
          <target state="translated">De forma similar, la lista de parámetros de tipo de la clase anidada <ph id="ph1">`Innermost1`</ph> tiene tres parámetros de tipo, <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph>, y <ph id="ph4">`V`</ph>, con <ph id="ph5">`T`</ph> y <ph id="ph6">`U`</ph> procedentes de sus clases envolventes.</target>       </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The nested class <ph id="ph1">`Innermost2`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, which come from its enclosing classes.</source>
          <target state="translated">La clase anidada <ph id="ph1">`Innermost2`</ph> tiene dos parámetros de tipo, <ph id="ph2">`T`</ph> y <ph id="ph3">`U`</ph>, que proceden de sus clases envolventes.</target>       </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</source>
          <target state="translated">Si la lista de parámetros del tipo envolvente tiene más de un parámetro de tipo, todos los parámetros de tipo en orden se incluyen en la lista de parámetros de tipo del tipo anidado.</target>       </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a generic type from the generic type definition for a nested type, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</source>
          <target state="translated">Para construir un tipo genérico de la definición de tipo genérico para un tipo anidado, llame a la <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método con la matriz formada al concatenar las matrices de argumento de tipo de todos los tipos envolventes, que comienza con el tipo genérico exterior y finaliza con la matriz de argumentos de tipo de anidamiento, escriba si tiene sus propios parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create an instance of <ph id="ph1">`Innermost1`</ph>, call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing three types, to be assigned to T, U, and V. To create an instance of <ph id="ph3">`Innermost2`</ph>, call the <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing two types, to be assigned to T and U.</source>
          <target state="translated">Para crear una instancia de <ph id="ph1">`Innermost1`</ph>, llame a la <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método con una matriz que contiene tres tipos, que se asignará a T, U y V. Para crear una instancia de <ph id="ph3">`Innermost2`</ph>, llame a la <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método con una matriz que contiene dos tipos, que se asignará a T y U.</target>       </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</source>
          <target state="translated">El lenguaje propaga los parámetros de tipo de tipos envolventes de esta manera, por lo que puede usar los parámetros de tipo de un tipo envolvente para definir los campos de tipos anidados.</target>       </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Otherwise, the type parameters would not be in scope within the bodies of the nested types.</source>
          <target state="translated">En caso contrario, los parámetros de tipo no sería en el ámbito dentro de los cuerpos de los tipos anidados.</target>       </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Es posible definir tipos anidados sin propagar los parámetros de tipo de tipos envolventes mediante la emisión de código de un ensamblado dinámico o mediante el uso de la <bpt id="p1">[</bpt>Ilasm.exe (ensamblador de IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following code for the MSIL assembler:</source>
          <target state="translated">Considere el siguiente código para el ensamblador MSIL:</target>       </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>In this example, it is not possible to define a field of type <ph id="ph1">`T`</ph> or <ph id="ph2">`U`</ph> in class <ph id="ph3">`Innermost`</ph>, because those type parameters are not in scope.</source>
          <target state="translated">En este ejemplo, no es posible definir un campo de tipo <ph id="ph1">`T`</ph> o <ph id="ph2">`U`</ph> en clase <ph id="ph3">`Innermost`</ph>, ya que los parámetros de tipo no están en ámbito.</target>       </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</source>
          <target state="translated">El siguiente código ensamblador define clases anidadas que se comportan de la manera que si estuvieran definidas en C++, Visual Basic y C#:</target>       </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine nested classes defined in the high-level languages and observe this naming scheme.</source>
          <target state="translated">Puede usar el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para examinar las clases anidadas definidas en los lenguajes de alto nivel y observar este esquema de nomenclatura.</target>       </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create a constructed type from the generic type definition for the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> método para crear un tipo construido a partir de la definición de tipo genérico para el <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The constructed type represents a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`Test`</ph> objects with string keys.</source>
          <target state="translated">Representa el tipo construido un <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> de <ph id="ph2">`Test`</ph> objetos con claves de cadena.</target>       </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The current type does not represent a generic type definition.</source>
          <target state="translated">El tipo actual no representa una definición de un tipo genérico.</target>       </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es decir, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cualquier elemento de <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is not the same as the number of type parameters in the current generic type definition.</source>
          <target state="translated">El número de elementos de <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> no coincide con el número de parámetros de tipo de la definición de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</source>
          <target state="translated">Algún elemento de <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> no satisface las restricciones especificadas para el parámetro de tipo correspondiente del tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> contains an element that is a pointer type (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>), a by-ref type (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>), or <ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> contiene un elemento que es un tipo de puntero (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> devuelve <ph id="ph3">&lt;see langword="true" /&gt;</ph>), un tipo por referencia (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> devuelve <ph id="ph5">&lt;see langword="true" /&gt;</ph>) o <ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">El método invocado no se admite en la clase base.</target>       </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Las clases derivadas deben proporcionar una implementación.</target>       </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa un puntero al tipo actual.</target>       </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa un puntero al tipo actual.</target>       </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> método proporciona un medio para generar tipos de puntero para listas de parámetros.</target>       </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32*`</ph>.</source>
          <target state="translated">Mediante la sintaxis de lenguaje intermedio de Microsoft (MSIL), si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, este método devuelve un <ph id="ph3">&lt;xref:System.Type&gt;</ph> que representa el objeto <ph id="ph4">`Int32*`</ph>.</target>       </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se crea la matriz, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> en Visual Basic) y los tipos de puntero para la <ph id="ph3">`Test`</ph> clase.</target>       </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">El método invocado no se admite en la clase base.</target>       </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">El tipo actual es <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">El tipo actual es un tipo <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Es decir, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" uid="P:System.Type.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">Obtiene un valor de <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> que indica que este miembro es un tipo o un tipo anidado.</target>       </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">Valor de <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> que indica que este miembro es un tipo o un tipo anidado.</target>       </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Esta propiedad invalida <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects—for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>—the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph> when a given member is a nested type.</source>
          <target state="translated">Por lo tanto, cuando se examina un conjunto de <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objetos, por ejemplo, la matriz devuelta por <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>: el <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> propiedad devuelve <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph> cuando un miembro determinado es un tipo anidado.</target>       </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se ha construido el tipo.</target>       </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> en Visual Basic), el valor de esta propiedad está determinado por <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>The following code example shows the <ph id="ph1">`MemberType`</ph> field as a parameter to the <ph id="ph2">`GetMember`</ph> method:</source>
          <target state="translated">El siguiente ejemplo de código muestra la <ph id="ph1">`MemberType`</ph> campo como un parámetro a la <ph id="ph2">`GetMember`</ph> método:</target>       </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>Represents a missing value in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> information.</source>
          <target state="translated">Representa un valor que falta en la información de <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>This field is read-only.</source>
          <target state="translated">Este campo es de solo lectura.</target>       </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>Use the <ph id="ph1">`Missing`</ph> field for invocation through reflection to obtain the default value of a parameter.</source>
          <target state="translated">Use la <ph id="ph1">`Missing`</ph> campo para la invocación mediante reflexión para obtener el valor predeterminado de un parámetro.</target>       </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>If the <ph id="ph1">`Missing`</ph> field is passed in for a parameter value and there is no default value for that parameter, an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> is thrown.</source>
          <target state="translated">Si el <ph id="ph1">`Missing`</ph> campo se pasa un valor de parámetro y no hay ningún valor predeterminado para ese parámetro, un <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> se produce.</target>       </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>The following code example shows the use of the <ph id="ph1">`Missing`</ph> field to invoke a method with its default arguments.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra el uso de la <ph id="ph1">`Missing`</ph> campo para invocar un método con sus argumentos predeterminados.</target>       </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>This code produces the following output:</source>
          <target state="translated">Este código genera el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 55.3 c = 12</source>
          <target state="translated">a = 10 b = 55.3 c = 12</target>       </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.3 c = 1</source>
          <target state="translated">a = 10 b = 1.3 c = 1</target>       </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.2 c = 1</source>
          <target state="translated">a = 10 b = 1.2 c = 1</target>       </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" uid="P:System.Type.Module">
          <source>Gets the module (the DLL) in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">Obtiene el módulo (la DLL) en que se define el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>The module in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">Módulo en el que se define el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico construido, esta propiedad devuelve el módulo en el que se ha definido la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>For example, if you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>, the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property for the constructed type returns the module in which <ph id="ph3">`MyGenericStack&lt;T&gt;`</ph> is defined.</source>
          <target state="translated">Por ejemplo, si se crea una instancia de <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>, <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> propiedad para el tipo construido devuelve el módulo en el que <ph id="ph3">`MyGenericStack&lt;T&gt;`</ph> está definido.</target>       </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">De forma similar, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro genérico <ph id="ph2">`T`</ph>, esta propiedad devuelve el ensamblado que contiene el tipo genérico que define <ph id="ph3">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">`Module`</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> y <ph id="ph2">`Module`</ph> propiedades y la <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> método <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" uid="P:System.Type.Namespace">
          <source>Gets the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene el espacio de nombres de <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>The namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>; <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current instance has no namespace or represents a generic parameter.</source>
          <target state="translated">Espacio de nombres de <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>; <ph id="ph2">&lt;see langword="null" /&gt;</ph> si la instancia actual no tiene un espacio de nombres o representa un parámetro genérico.</target>       </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</source>
          <target state="translated">Un espacio de nombres es una lógica comodidad de nomenclatura de tiempo de diseño, que se utiliza principalmente para definir un ámbito en una aplicación y organizar clases y otros tipos en una sola estructura jerárquica.</target>       </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>From the viewpoint of the runtime, there are no namespaces.</source>
          <target state="translated">Desde el punto de vista del tiempo de ejecución, no hay ningún espacio de nombres.</target>       </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa el tipo de un tipo genérico construido, esta propiedad devuelve el espacio de nombres que contiene la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the namespace that contains the generic type definition that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">De forma similar, si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro genérico <ph id="ph2">`T`</ph>, esta propiedad devuelve el espacio de nombres que contiene la definición de tipo genérico que define <ph id="ph3">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto representa un parámetro genérico, esta propiedad devuelve <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>This following example demonstrates a use of the <ph id="ph1">`Namespace`</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`Namespace`</ph> y <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> propiedades y la <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> método <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">Primer objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">Segundo objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica si dos objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> son iguales.</target>       </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> es igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; en caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">Primer objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">Segundo objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica si dos objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> no son iguales.</target>       </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="left" /&gt;</ph> no es igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" uid="P:System.Type.ReflectedType">
          <source>Gets the class object that was used to obtain this member.</source>
          <target state="translated">Obtiene el objeto de clase usado para obtener este miembro.</target>       </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>The <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object through which this <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object was obtained.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="Type" /&gt;</ph> a través del cual se obtuvo este objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>For <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, the value of this property is always the same as the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property.</source>
          <target state="translated">Para <ph id="ph1">&lt;xref:System.Type&gt;</ph> objetos, el valor de esta propiedad siempre es el mismo que el valor de la <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>This example displays the reflected type of a nested class.</source>
          <target state="translated">En este ejemplo se muestra el tipo reflejado de una clase anidada.</target>       </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Nombre calificado con el ensamblado del <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que se va a obtener.</target>       </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw a <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph> if the type cannot be found; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to return <ph id="ph4">&lt;see langword="null" /&gt;</ph> if the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para iniciar una excepción <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph> si no se puede encontrar el tipo; <ph id="ph3">&lt;see langword="false" /&gt;</ph> para devolver <ph id="ph4">&lt;see langword="null" /&gt;</ph> si el tipo no se puede encontrar.</target>       </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Si se especifica <ph id="ph1">&lt;see langword="false" /&gt;</ph> se suprimen otras condiciones de excepción, pero no todas.</target>       </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para realizar una búsqueda de <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> que no distinga mayúsculas de minúsculas; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para realizar una búsqueda de <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> que distinga mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</source>
          <target state="translated">Obtiene el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> con el nombre indicado, que especifica si se va a realizar una búsqueda donde se distingue entre mayúsculas y minúsculas y si se va a producir una excepción en caso de que no se encuentre el tipo.</target>       </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type is loaded for reflection only, not for execution.</source>
          <target state="translated">Se carga el tipo solo para reflexión, no para ejecución.</target>       </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Tipo con el nombre especificado, si se encuentra; de lo contrario <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Si el tipo no se encuentra, el parámetro <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> especifica si se devuelve <ph id="ph2">&lt;see langword="null" /&gt;</ph> o se produce una excepción.</target>       </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph>.</source>
          <target state="translated">En algunos casos, se produce una excepción con independencia del valor de <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Vea la sección Excepciones.</target>       </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly containing the type is not already loaded into the reflection-only context, using the <ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> method is equivalent to first loading the assembly for reflection only, using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, and then loading the type by calling the assembly's <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si el ensamblado que contiene el tipo ya no se carga en el contexto de solo reflexión, usando la <ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> método es equivalente al primer al cargar el ensamblado solo para reflexión, mediante el <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> método y, a continuación, cargar el tipo mediante una llamada del ensamblado <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For information about assembly-qualified names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obtener información acerca de los nombres de ensamblado, consulte el <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For additional details on specifying type names, see the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Para obtener más información sobre cómo especificar nombres de tipo, consulte el <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</source>
          <target state="translated">Si el ensamblado ya está cargado para la ejecución, se carga otra copia en el contexto de solo reflexión.</target>       </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwIfNotFound`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated">El <ph id="ph1">`throwIfNotFound`</ph> parámetro especifica lo que ocurre cuando no se encuentra el tipo y también suprime algunas condiciones de excepción, como se describe en la sección excepciones.</target>       </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwIfNotFound`</ph>.</source>
          <target state="translated">Algunas excepciones se producen independientemente del valor de <ph id="ph1">`throwIfNotFound`</ph>.</target>       </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the assembly is not valid, a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph> is thrown even if <ph id="ph2">`throwIfNotFound`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Por ejemplo, si el ensamblado no es válido, un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph> se produce incluso si <ph id="ph2">`throwIfNotFound`</ph> es <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For more information about using the reflection-only context, see <bpt id="p1">[</bpt>How to: Load Assemblies into the Reflection-Only Context<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de cómo utilizar el contexto de solo reflexión, vea <bpt id="p1">[</bpt>Cómo: cargar ensamblados en el contexto de only<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</target>       </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Se invoca un inicializador de clase y genera una excepción.</target>       </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encuentra el tipo.</target>       </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene caracteres no válidos, como una pestaña insertada.</target>       </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> representa un tipo de matriz con un tamaño no válido.</target>       </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa una matriz de objetos <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> does not include the assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> no incluye el nombre del ensamblado.</target>       </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax; for example, "MyType[,*,]".</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contiene sintaxis no válida; por ejemplo, "MyType[,*,]".</target>       </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un tipo de puntero, un tipo <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> como uno de sus argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</target>       </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> y no se encontró el ensamblado o alguna de sus dependencias.</target>       </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</target>       </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">El ensamblado o alguna de sus dependencias no son válidos.</target>       </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</target>       </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the layout of the current type.</source>
          <target state="translated">Obtiene una clase <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> que describe el diseño del tipo actual.</target>       </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the gross layout features of the current type.</source>
          <target state="translated">Obtiene una clase <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> que describe las características de diseño generales del tipo actual.</target>       </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> is not returned by the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> no se devuelve por la <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Instead, use this property to get it.</source>
          <target state="translated">En su lugar, utilice esta propiedad para obtenerlo.</target>       </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</source>
          <target state="translated">En primer lugar, en el ejemplo de código siguiente se define una clase, una estructura y una estructura con atributos de diseño especiales (las estructuras están anidadas dentro de la clase).</target>       </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph> property to obtain a <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> for each type, and displays the properties of the attributes.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph> propiedad que se va a obtener un <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> para cada tipo y muestra las propiedades de los atributos.</target>       </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">El método invocado no se admite en la clase base.</target>       </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz que se pasa con los nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Número de nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contexto de configuración regional en el que se van a interpretar los nombres.</target>       </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</target>       </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</target>       </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Información de tipos que se va a devolver.</target>       </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificador de la configuración regional de la información de tipo.</target>       </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>A pointer to the requested type information object.</source>
          <target state="translated">Puntero al objeto de información de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</target>       </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</target>       </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</target>       </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica el miembro.</target>       </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contexto de la configuración regional en que se interpretan los argumentos.</target>       </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Marcas que describen el contexto de la llamada.</target>       </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</target>       </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntero a la ubicación donde se va a almacenar el resultado.</target>       </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntero a una estructura que contiene información de excepciones.</target>       </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Índice del primer argumento que tiene un error.</target>       </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</target>       </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::Invoke`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>Returns a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</source>
          <target state="translated">Devuelve un valor <ph id="ph1">&lt;see langword="String" /&gt;</ph> que representa el nombre del objeto <ph id="ph2">&lt;see langword="Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que representa el nombre del objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This method returns the fully qualified common language runtime namespace and name for all primitive types.</source>
          <target state="translated">Este método devuelve el common language runtime espacio de nombres completo y el nombre de todos los tipos primitivos.</target>       </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>For example, the C# instruction, <ph id="ph1">`(long)0.Type().ToString()`</ph> returns "System.Int64" instead of merely "Int64".</source>
          <target state="translated">Por ejemplo, la instrucción de C# <ph id="ph1">`(long)0.Type().ToString()`</ph> devuelve "System.Int64" en lugar de simplemente "Int64".</target>       </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un tipo genérico, el tipo y sus argumentos de tipo se califican por espacio de nombres y por tipo anidado, pero no por ensamblado.</target>       </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo o método genérico, este método devuelve el nombre no completo del parámetro de tipo.</target>       </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">`ToString`</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> propiedades y la <ph id="ph3">`ToString`</ph> método <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">En el ejemplo siguiente se comparan las cadenas devueltas por la <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> método y <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>Gets the handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Obtiene el identificador del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Identificador del objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source><ph id="ph1">`TypeHandle`</ph> encapsulates a pointer to an internal data structure that represents the type.</source>
          <target state="translated"><ph id="ph1">`TypeHandle`</ph> Encapsula un puntero a una estructura de datos interna que representa el tipo.</target>       </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>This handle is unique during the process lifetime.</source>
          <target state="translated">Este identificador es único durante la vida del proceso.</target>       </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle is valid only in the application domain in which it was obtained.</source>
          <target state="translated">El identificador es válido únicamente en el dominio de aplicación en el que se obtuvo.</target>       </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</source>
          <target state="translated">En el ejemplo siguiente se devuelve el identificador del tipo correspondiente y pasa el identificador a un método que obtiene el tipo a partir del identificador y lo muestra.</target>       </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>The .NET Compact Framework does not currently support this property.</source>
          <target state="translated">.NET Compact Framework no admite actualmente esta propiedad.</target>       </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" uid="P:System.Type.TypeInitializer">
          <source>Gets the initializer for the type.</source>
          <target state="translated">Obtiene el inicializador para el tipo.</target>       </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>An object that contains the name of the class constructor for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Objeto que contiene el nombre del constructor de clase para <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>Class initializers are also available through the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, or through overloads of the <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> methods that take <ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph> as a parameter.</source>
          <target state="translated">Inicializadores de clase también están disponibles a través de la <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> método, o a través de las sobrecargas de la <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> métodos que toman <ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph> como un parámetro.</target>       </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Type&gt;</ph> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad devuelve <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" uid="P:System.Type.UnderlyingSystemType">
          <source>Indicates the type provided by the common language runtime that represents this type.</source>
          <target state="translated">Indica el tipo proporcionado por Common Language Runtime para representar este tipo.</target>       </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.UnderlyingSystemType">
          <source>The underlying system type for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Tipo de sistema subyacente para el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>