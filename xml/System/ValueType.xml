<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ValueType.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53b756fc1621dab1597966503a0af93b3c8478663.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3b756fc1621dab1597966503a0af93b3c8478663</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.ValueType">
          <source>Provides the base class for value types.</source>
          <target state="translated">Proporciona la clase base para los tipos de valor.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source><ph id="ph1">&lt;xref:System.ValueType&gt;</ph> overrides the virtual methods from <ph id="ph2">&lt;xref:System.Object&gt;</ph> with more appropriate implementations for value types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ValueType&gt;</ph> invalida los métodos virtuales de <ph id="ph2">&lt;xref:System.Object&gt;</ph> implementaciones más adecuado para los tipos de valor.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>See also <ph id="ph1">&lt;xref:System.Enum&gt;</ph>, which inherits from <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">Vea también <ph id="ph1">&lt;xref:System.Enum&gt;</ph>, que hereda de <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Data types are separated into value types and reference types.</source>
          <target state="translated">Tipos de datos se dividen en tipos de valor y tipos de referencia.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Value types are either stack-allocated or allocated inline in a structure.</source>
          <target state="translated">Tipos de valor se asignan a la pila o asignados en línea en una estructura.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Reference types are heap-allocated.</source>
          <target state="translated">Tipos de referencia son asignados por montón.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Both reference and value types are derived from the ultimate base class <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Tipos de referencia y valor se derivan de la clase base fundamental <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>In cases where it is necessary for a value type to behave like an object, a wrapper that makes the value type look like a reference object is allocated on the heap, and the value type's value is copied into it.</source>
          <target state="translated">En casos donde es necesario para un tipo de valor que se comportan como un objeto, un contenedor que hace que el tipo de valor parezca un objeto de referencia se asigna en el montón y el valor del tipo de valor se copia en él.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>The wrapper is marked so the system knows that it contains a value type.</source>
          <target state="translated">El contenedor se marca para que el sistema sepa que contiene un tipo de valor.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>This process is known as boxing, and the reverse process is known as unboxing.</source>
          <target state="translated">Este proceso se conoce como conversión boxing, y el proceso inverso se conoce como conversión unboxing.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Boxing and unboxing allow any type to be treated as an object.</source>
          <target state="translated">Conversiones boxing y unboxing permiten tratar como un objeto de cualquier tipo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Although <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> is the implicit base class for value types, you cannot create a class that inherits from <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> directly.</source>
          <target state="translated">Aunque <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> es la clase base implícita de tipos de valor, no se puede crear una clase que hereda de <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> directamente.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Instead, individual compilers provide a language keyword or construct (such as <ph id="ph1">`struct`</ph> in C# and <ph id="ph2">`Structure`</ph>…<ph id="ph3">`End Structure`</ph></source>
          <target state="translated">En su lugar, los compiladores individuales proporcionan una palabra clave del lenguaje o construir (como <ph id="ph1">`struct`</ph> en C# y <ph id="ph2">`Structure`</ph>...<ph id="ph3">`End Structure`</ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>in Visual Basic) to support the creation of value types.</source>
          <target state="translated">en Visual Basic) para admitir la creación de tipos de valor.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Aside from serving as the base class for value types in the .NET Framework, the <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> structure is generally not used directly in code.</source>
          <target state="translated">Además de sirve como clase base para los tipos de valor en .NET Framework, el <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> estructura generalmente no se utiliza directamente en el código.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>However, it can be used as a parameter in method calls to restrict possible arguments to value types instead of all objects, or to permit a method to handle a number of different value types.</source>
          <target state="translated">Sin embargo, se puede utilizar como un parámetro en las llamadas de método para restringir los posibles argumentos a tipos de valor en lugar de todos los objetos, o para permitir que un método para administrar un número de tipos de valores diferentes.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>The following example illustrates how <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> prevents reference types from being passed to methods.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> impide que los tipos de referencia que se pasan a métodos.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>It defines a class named <ph id="ph1">`Utility`</ph> that contains four methods: <ph id="ph2">`IsNumeric`</ph>, which indicates whether its argument is a number; <ph id="ph3">`IsInteger`</ph>, which indicates whether its argument is an integer; <ph id="ph4">`IsFloat`</ph>, which indicates whether its argument is a floating-point number; and <ph id="ph5">`Compare`</ph>, which indicates the relationship between two numeric values.</source>
          <target state="translated">Se define una clase denominada <ph id="ph1">`Utility`</ph> que contiene cuatro métodos: <ph id="ph2">`IsNumeric`</ph>, lo que indica si el argumento es un número; <ph id="ph3">`IsInteger`</ph>, lo que indica si el argumento es un entero; <ph id="ph4">`IsFloat`</ph>, lo que indica si el argumento es un número de punto flotante; y <ph id="ph5">`Compare`</ph>, lo que indica la relación entre dos valores numéricos.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>In each case, the method parameters are of type <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>, and reference types are prevented from being passed to the methods.</source>
          <target state="translated">En cada caso, los parámetros del método son del tipo <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>, y se evita que se pasan a los métodos de tipos de referencia.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>The following example illustrates calls to the methods of the <ph id="ph1">`Utility`</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se muestra las llamadas a los métodos de la <ph id="ph1">`Utility`</ph> clase.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.ValueType.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.ValueType.Equals(System.Object)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Objeto que se va a comparar con la instancia actual.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.ValueType.Equals(System.Object)">
          <source>Indicates whether this instance and a specified object are equal.</source>
          <target state="translated">Indica si esta instancia y un objeto especificado son iguales.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.ValueType.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> and this instance are the same type and represent the same value; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> y esta instancia son del mismo tipo y representan el mismo valor; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.ValueType.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> and provides the default implementation of value equality for all value types in the .NET Framework.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.ValueType.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> reemplazos de método <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> y proporciona la implementación predeterminada de igualdad de valores para todos los tipos de valor en .NET Framework.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>If none of the fields of the current instance and <ph id="ph1">`obj`</ph> are reference types, the <ph id="ph2">&lt;xref:System.ValueType.Equals%2A&gt;</ph> method performs a byte-by-byte comparison of the two objects in memory.</source>
          <target state="translated">Si ninguno de los campos de la instancia actual y <ph id="ph1">`obj`</ph> son tipos de referencia, el <ph id="ph2">&lt;xref:System.ValueType.Equals%2A&gt;</ph> método realiza una comparación byte a byte de los dos objetos en memoria.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>Otherwise, it uses reflection to compare the corresponding fields of <ph id="ph1">`obj`</ph> and this instance.</source>
          <target state="translated">En caso contrario, utiliza la reflexión para comparar los campos correspondientes de <ph id="ph1">`obj`</ph> y esta instancia.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>Particularly if your value type contains fields that are reference types, you should override the <ph id="ph1">&lt;xref:System.ValueType.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">Especialmente si el tipo de valor contiene campos que son tipos de referencia, se debe invalidar el <ph id="ph1">&lt;xref:System.ValueType.Equals%28System.Object%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>This can improve performance and enable you to more closely represent the meaning of equality for the type.</source>
          <target state="translated">Esto puede mejorar el rendimiento y permitirle más estrechamente representan el significado de igualdad para el tipo.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Notas de la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>When you call the <ph id="ph1">&lt;xref:System.ValueType.Equals%2A&gt;</ph> method on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structure, it provides the default behavior for value types that don’t override <ph id="ph3">&lt;xref:System.ValueType.Equals%2A&gt;</ph>.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">&lt;xref:System.ValueType.Equals%2A&gt;</ph> método en un <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> estructura, proporciona el comportamiento predeterminado para los tipos de valor que no se invalidan <ph id="ph3">&lt;xref:System.ValueType.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Esto forma parte de la compatibilidad que .NET Framework proporciona para la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (consulte <bpt id="p1">[</bpt>.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structures can’t override <ph id="ph2">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, even if they’re written with C# or Visual Basic, because they can’t have methods.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> no pueden reemplazar a las estructuras <ph id="ph2">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, incluso si está escritos con C# o Visual Basic, ya que no pueden tener métodos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>(In addition, structures in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> itself don’t inherit <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) However, they appear to have <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">(Además, las estructuras de la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> no heredar <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) Sin embargo, parece que tienen <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>The following example demonstrates how the <ph id="ph1">&lt;xref:System.ValueType.Equals%2A&gt;</ph> method can be overridden by a derived value type.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo el <ph id="ph1">&lt;xref:System.ValueType.Equals%2A&gt;</ph> método puede reemplazarse por un tipo de valor derivado.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.ValueType.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Devuelve el código hash de esta instancia.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.ValueType.GetHashCode">
          <source>A 32-bit signed integer that is the hash code for this instance.</source>
          <target state="translated">Entero de 32 bits con signo, que es el código hash de esta instancia.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method applies to types derived from <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> método se aplica a los tipos derivados de <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>One or more fields of the derived type is used to calculate the return value.</source>
          <target state="translated">Uno o varios campos del tipo derivado se usa para calcular el valor devuelto.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>If you call the derived type's <ph id="ph1">`GetHashCode`</ph> method, the return value is not likely to be suitable for use as a key in a hash table.</source>
          <target state="translated">Si se llama al método del tipo derivado <ph id="ph1">`GetHashCode`</ph> método, el valor devuelto no es probable que sea adecuado para su uso como una clave en una tabla hash.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>Additionally, if the value of one or more of those fields changes, the return value might become unsuitable for use as a key in a hash table.</source>
          <target state="translated">Además, si cambia el valor de uno o varios de esos campos, el valor devuelto puede volverse no es adecuado para su uso como una clave en una tabla hash.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>In either case, consider writing your own implementation of the <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method that more closely represents the concept of a hash code for the type.</source>
          <target state="translated">En cualquier caso, considere la posibilidad de escribir su propia implementación de la <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> método que representa el concepto de un código hash para el tipo de forma más estrecha.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph2">&lt;xref:System.Collections.Hashtable?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Hashtable?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Notas de la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>When you call the <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structure, it provides the default behavior for value types that don’t override <ph id="ph3">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> método en un <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> estructura, proporciona el comportamiento predeterminado para los tipos de valor que no se invalidan <ph id="ph3">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Esto forma parte de la compatibilidad que .NET Framework proporciona para la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (consulte <bpt id="p1">[</bpt>.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structures can’t override <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>, even if they’re written with C# or Visual Basic, because they can’t have methods.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> no pueden reemplazar a las estructuras <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>, incluso si está escritos con C# o Visual Basic, ya que no pueden tener métodos.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>(In addition, structures in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> itself don’t inherit <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) However, they appear to have <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">(Además, las estructuras de la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> no heredar <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) Sin embargo, parece que tienen <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>The following example demonstrates how the <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method can be overridden by a derived value type.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo el <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> método puede reemplazarse por un tipo de valor derivado.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.ValueType.ToString">
          <source>Returns the fully qualified type name of this instance.</source>
          <target state="translated">Devuelve el nombre de tipo completo de esta instancia.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.ValueType.ToString">
          <source>The fully qualified type name.</source>
          <target state="translated">Nombre completo del tipo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>The <ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> method overrides the <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method and provides the default implementation of the <ph id="ph3">`ToString`</ph> method for value types.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> reemplazos de método la <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método y proporciona la implementación predeterminada de la <ph id="ph3">`ToString`</ph> método para tipos de valor.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>(Value types are types defined by the <ph id="ph1">`struct`</ph> keyword in C#, and by the <ph id="ph2">`Structure`</ph>...<ph id="ph3">`End Structure`</ph> construct in Visual Basic.) Functionally, however, the implementation is that same as that of <ph id="ph4">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>: the method returns the fully qualified type name.</source>
          <target state="translated">(Tipos de valor son tipos definidos por el <ph id="ph1">`struct`</ph> palabra clave en C# y por la <ph id="ph2">`Structure`</ph>... <ph id="ph3">`End Structure`</ph> construir en Visual Basic.) Funcionalmente, sin embargo, la implementación es es igual que el de <ph id="ph4">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>: el método devuelve el nombre de tipo completo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>Value types defined by the <ph id="ph1">`struct`</ph> keyword in C# and the <ph id="ph2">`Structure`</ph>...<ph id="ph3">`End Structure`</ph> construct in Visual Basic typically override the <ph id="ph4">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide a more meaningful string representation of the value type.</source>
          <target state="translated">Valor de tipos definidos por el <ph id="ph1">`struct`</ph> palabra clave de C# y el <ph id="ph2">`Structure`</ph>... <ph id="ph3">`End Structure`</ph> construcción en Visual Basic normalmente invalidar la <ph id="ph4">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> método para proporcionar una representación de cadena más significativa del tipo de valor.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>The following example illustrates the difference.</source>
          <target state="translated">En el siguiente ejemplo se ilustra la diferencia.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>It defines two value types, <ph id="ph1">`EmployeeA`</ph> and <ph id="ph2">`EmployeeB`</ph>, creates an instance of each, and calls its <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated">Define dos tipos de valor, <ph id="ph1">`EmployeeA`</ph> y <ph id="ph2">`EmployeeB`</ph>, crea una instancia de cada uno y llama a su <ph id="ph3">`ToString`</ph> método.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>Because the <ph id="ph1">`EmployeeA`</ph> structure does not override the <ph id="ph2">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> method, it displays only the fully qualified type name.</source>
          <target state="translated">Dado que la <ph id="ph1">`EmployeeA`</ph> estructura no reemplaza el <ph id="ph2">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> método, muestra sólo el nombre de tipo completo.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>The <ph id="ph1">`EmployeeB.ToString`</ph> method, on the other hand, provides meaningful information about the object.</source>
          <target state="translated">El <ph id="ph1">`EmployeeB.ToString`</ph> método, por otro lado, proporciona información significativa sobre el objeto.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>Note that, although enumeration types are also value types, they derive from the <ph id="ph1">&lt;xref:System.Enum&gt;</ph> class, which overrides  <ph id="ph2">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Tenga en cuenta que, aunque los tipos de enumeración también son tipos de valor, derivan de la <ph id="ph1">&lt;xref:System.Enum&gt;</ph> de la clase, lo que invalida <ph id="ph2">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>Notes for the Windows Runtime</source>
          <target state="translated">Notas para el tiempo de ejecución de Windows</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>When you call the <ph id="ph1">&lt;xref:System.ValueType.ToString%2A&gt;</ph> method on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structure, it provides the default behavior for value types that don’t override <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">&lt;xref:System.ValueType.ToString%2A&gt;</ph> método en un <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> estructura, proporciona el comportamiento predeterminado para los tipos de valor que no se invalidan <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Esto forma parte de la compatibilidad que .NET Framework proporciona para la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (consulte <bpt id="p1">[</bpt>.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structures can’t override <ph id="ph2">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, even if they’re written with C# or Visual Basic, because they can’t have methods.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> no pueden reemplazar a las estructuras <ph id="ph2">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, incluso si está escritos con C# o Visual Basic, ya que no pueden tener métodos.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>(In addition, structures in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> itself don’t inherit <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) However, they appear to have <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">(Además, las estructuras de la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> no heredar <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) Sin embargo, parece que tienen <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>