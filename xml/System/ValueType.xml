<Type Name="ValueType" FullName="System.ValueType">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="33378379d2e91ec17aa2980f5a53aa8e59d1b2bd" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36427340" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ValueType" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit ValueType extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ValueType" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueType" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueType abstract" />
  <TypeSignature Language="F#" Value="type ValueType = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona la clase base para los tipos de valor.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueType> invalida los métodos virtuales de <xref:System.Object> implementaciones más adecuado para los tipos de valor. Vea también <xref:System.Enum>, que hereda de <xref:System.ValueType>.  
  
 Tipos de datos se dividen en tipos de valor y tipos de referencia. Tipos de valor se asignan a la pila o asignados en línea en una estructura. Tipos de referencia son asignados por montón. Tipos de referencia y valor se derivan de la clase base fundamental <xref:System.Object>. En casos donde es necesario para un tipo de valor que se comportan como un objeto, un contenedor que hace que el tipo de valor parezca un objeto de referencia se asigna en el montón y el valor del tipo de valor se copia en él. El contenedor se marca para que el sistema sepa que contiene un tipo de valor. Este proceso se conoce como conversión boxing, y el proceso inverso se conoce como conversión unboxing. Conversiones boxing y unboxing permiten tratar como un objeto de cualquier tipo.  
  
 Aunque <xref:System.ValueType> es la clase base implícita de tipos de valor, no se puede crear una clase que hereda de <xref:System.ValueType> directamente. En su lugar, los compiladores individuales proporcionan una palabra clave del lenguaje o construir (como `struct` en C# y `Structure`...`End Structure` en Visual Basic) para admitir la creación de tipos de valor.  
  
 Además de sirve como clase base para los tipos de valor en .NET Framework, el <xref:System.ValueType> estructura generalmente no se utiliza directamente en el código. Sin embargo, se puede utilizar como un parámetro en las llamadas de método para restringir los posibles argumentos a tipos de valor en lugar de todos los objetos, o para permitir que un método para administrar un número de tipos de valores diferentes. En el ejemplo siguiente se muestra cómo <xref:System.ValueType> impide que los tipos de referencia que se pasan a métodos. Se define una clase denominada `Utility` que contiene cuatro métodos: `IsNumeric`, lo que indica si el argumento es un número; `IsInteger`, lo que indica si el argumento es un entero; `IsFloat`, lo que indica si el argumento es un número de punto flotante; y `Compare`, lo que indica la relación entre dos valores numéricos. En cada caso, los parámetros del método son del tipo <xref:System.ValueType>, y se evita que se pasan a los métodos de tipos de referencia.  
  
 [!code-csharp[System.ValueType.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#1)]
 [!code-vb[System.ValueType.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#1)]  
  
 En el ejemplo siguiente se muestra las llamadas a los métodos de la `Utility` clase.  
  
 [!code-csharp[System.ValueType.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#2)]
 [!code-vb[System.ValueType.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Enum" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueType.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueType();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ValueType" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="valueType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con la instancia actual.</param>
        <summary>Indica si esta instancia y un objeto especificado son iguales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="obj" /> y esta instancia son del mismo tipo y representan el mismo valor; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ValueType.Equals%28System.Object%29?displayProperty=nameWithType> reemplazos de método <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> y proporciona la implementación predeterminada de igualdad de valores para todos los tipos de valor en .NET Framework.  
  
 Si ninguno de los campos de la instancia actual y `obj` son tipos de referencia, el <xref:System.ValueType.Equals%2A> método realiza una comparación byte a byte de los dos objetos en memoria. En caso contrario, utiliza la reflexión para comparar los campos correspondientes de `obj` y esta instancia.  
  
> [!TIP]
>  Especialmente si el tipo de valor contiene campos que son tipos de referencia, se debe invalidar el <xref:System.ValueType.Equals%28System.Object%29> método. Esto puede mejorar el rendimiento y permitirle más estrechamente representan el significado de igualdad para el tipo.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Cuando se llama a la <xref:System.ValueType.Equals%2A> método en un [!INCLUDE[wrt](~/includes/wrt-md.md)] estructura, proporciona el comportamiento predeterminado para los tipos de valor que no se invalidan <xref:System.ValueType.Equals%2A>. Esto forma parte de la compatibilidad que .NET Framework proporciona para la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] no pueden reemplazar a las estructuras <xref:System.ValueType.Equals%2A>, incluso si está escritos con C# o Visual Basic, ya que no pueden tener métodos. (Además, las estructuras de la [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.ValueType>.) Sin embargo, parece que tienen <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, y <xref:System.ValueType.GetHashCode%2A> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo el <xref:System.ValueType.Equals%2A> método puede reemplazarse por un tipo de valor derivado.  
  
 [!code-cpp[ValueType.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/ValueType.Equals Example/CPP/source.cpp#1)]
 [!code-csharp[ValueType.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/ValueType.Equals Example/CS/source.cs#1)]
 [!code-vb[ValueType.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ValueType.Equals Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="valueType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de esta instancia.</summary>
        <returns>Entero de 32 bits con signo, que es el código hash de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ValueType.GetHashCode%2A> método se aplica a los tipos derivados de <xref:System.ValueType>. Uno o varios campos del tipo derivado se usa para calcular el valor devuelto. Si se llama al método del tipo derivado `GetHashCode` método, el valor devuelto no es probable que sea adecuado para su uso como una clave en una tabla hash. Además, si cambia el valor de uno o varios de esos campos, el valor devuelto puede volverse no es adecuado para su uso como una clave en una tabla hash. En cualquier caso, considere la posibilidad de escribir su propia implementación de la <xref:System.ValueType.GetHashCode%2A> método que representa el concepto de un código hash para el tipo de forma más estrecha.  
  
 Para obtener más información, vea <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Collections.Hashtable?displayProperty=nameWithType>.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Cuando se llama a la <xref:System.ValueType.GetHashCode%2A> método en un [!INCLUDE[wrt](~/includes/wrt-md.md)] estructura, proporciona el comportamiento predeterminado para los tipos de valor que no se invalidan <xref:System.ValueType.GetHashCode%2A>. Esto forma parte de la compatibilidad que .NET Framework proporciona para la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] no pueden reemplazar a las estructuras <xref:System.ValueType.GetHashCode%2A>, incluso si está escritos con C# o Visual Basic, ya que no pueden tener métodos. (Además, las estructuras de la [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.ValueType>.) Sin embargo, parece que tienen <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, y <xref:System.ValueType.GetHashCode%2A> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo el <xref:System.ValueType.GetHashCode%2A> método puede reemplazarse por un tipo de valor derivado.  
  
 [!code-cpp[ValueType.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/ValueType.Equals Example/CPP/source.cpp#1)]
 [!code-csharp[ValueType.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/ValueType.Equals Example/CS/source.cs#1)]
 [!code-vb[ValueType.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ValueType.Equals Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="valueType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el nombre de tipo completo de esta instancia.</summary>
        <returns>Nombre completo del tipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ValueType.ToString%2A?displayProperty=nameWithType> reemplazos de método la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método y proporciona la implementación predeterminada de la `ToString` método para tipos de valor. (Tipos de valor son tipos definidos por el `struct` palabra clave en C# y por la `Structure`... `End Structure` construir en Visual Basic.) Funcionalmente, sin embargo, la implementación es es igual que el de <xref:System.Object.ToString%2A?displayProperty=nameWithType>: el método devuelve el nombre de tipo completo.  
  
 Valor de tipos definidos por el `struct` palabra clave de C# y el `Structure`... `End Structure` construcción en Visual Basic normalmente invalidar la <xref:System.ValueType.ToString%2A?displayProperty=nameWithType> método para proporcionar una representación de cadena más significativa del tipo de valor. En el siguiente ejemplo se ilustra la diferencia. Define dos tipos de valor, `EmployeeA` y `EmployeeB`, crea una instancia de cada uno y llama a su `ToString` método. Dado que la `EmployeeA` estructura no reemplaza el <xref:System.ValueType.ToString%2A?displayProperty=nameWithType> método, muestra sólo el nombre de tipo completo. El `EmployeeB.ToString` método, por otro lado, proporciona información significativa sobre el objeto.  
  
 [!code-csharp[System.ValueType.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.ValueType.ToString/cs/ToString2.cs#1)]
 [!code-vb[System.ValueType.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.ValueType.ToString/vb/ToString2.vb#1)]  
  
 Tenga en cuenta que, aunque los tipos de enumeración también son tipos de valor, derivan de la <xref:System.Enum> de la clase, lo que invalida <xref:System.ValueType.ToString%2A?displayProperty=nameWithType>.  
  
## <a name="notes-for-the-windows-runtime"></a>Notas para el tiempo de ejecución de Windows  
 Cuando se llama a la <xref:System.ValueType.ToString%2A> método en un [!INCLUDE[wrt](~/includes/wrt-md.md)] estructura, proporciona el comportamiento predeterminado para los tipos de valor que no se invalidan <xref:System.ValueType.ToString%2A>. Esto forma parte de la compatibilidad que .NET Framework proporciona para la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] no pueden reemplazar a las estructuras <xref:System.ValueType.ToString%2A>, incluso si está escritos con C# o Visual Basic, ya que no pueden tener métodos. (Además, las estructuras de la [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.ValueType>.) Sin embargo, parece que tienen <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, y <xref:System.ValueType.GetHashCode%2A> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>