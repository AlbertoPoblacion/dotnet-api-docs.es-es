<Type Name="UnhandledExceptionEventArgs" FullName="System.UnhandledExceptionEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2bc5b27ab8c70f87bc485bcd049f405e98420956" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30727769" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnhandledExceptionEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnhandledExceptionEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.UnhandledExceptionEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class UnhandledExceptionEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnhandledExceptionEventArgs : EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona datos para el evento que se produce cuando existe una excepción que no está controlada por ningún dominio de la aplicación.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UnhandledExceptionEventArgs> proporciona acceso al objeto de excepción y una marca que indica si common language runtime está finalizando. El <xref:System.UnhandledExceptionEventArgs> es uno de los parámetros pasados en <xref:System.UnhandledExceptionEventHandler> para el <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> eventos.  
  
 Para obtener más información sobre los delegados de controladores de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="E:System.AppDomain.UnhandledException" />
    <altmember cref="T:System.UnhandledExceptionEventHandler" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnhandledExceptionEventArgs (object exception, bool isTerminating);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object exception, bool isTerminating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UnhandledExceptionEventArgs.#ctor(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (exception As Object, isTerminating As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnhandledExceptionEventArgs(System::Object ^ exception, bool isTerminating);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="exception" Type="System.Object" />
        <Parameter Name="isTerminating" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="exception">Excepción no controlada.</param>
        <param name="isTerminating">
          Es <see langword="true" /> si el tiempo de ejecución está finalizando; de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.UnhandledExceptionEventArgs" /> con el objeto de la excepción y una marca de finalización de Common Language Runtime.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptionObject">
      <MemberSignature Language="C#" Value="public object ExceptionObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ExceptionObject" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.ExceptionObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExceptionObject As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ExceptionObject { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto de la excepción no controlada.</summary>
        <value>Objeto de la excepción no controlada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve un objeto de tipo <xref:System.Object> en lugar de uno derivado de <xref:System.Exception>. Aunque Common Language Specification requiere que se derivan todos los tipos de excepción <xref:System.Exception>, es posible que los métodos que se produzcan excepciones con objetos no derivados de <xref:System.Exception>. Puede hacer lo siguiente para que funcione con esta excepción:  
  
-   Aplicar el <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute> atributo con un <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute.WrapNonExceptionThrows%2A?displayProperty=nameWithType> valo `true` al ensamblado que contiene el controlador de eventos. Esto incluye todas las excepciones no derivadas de la <xref:System.Exception> clase en un <xref:System.Runtime.CompilerServices.RuntimeWrappedException> objeto. Se puede, a continuación, convierte (en C#) o de forma segura convertir (en Visual Basic), el objeto devuelto por esta propiedad en un <xref:System.Exception> objeto y recuperar el objeto de excepción original desde la <xref:System.Runtime.CompilerServices.RuntimeWrappedException.WrappedException%2A?displayProperty=nameWithType> propiedad. Tenga en cuenta que algunos compiladores, como los compiladores de C# y Visual Basic, se aplican automáticamente este atributo.  
  
-   Convierte el objeto devuelto por esta propiedad en un <xref:System.Exception> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.AppDomain.UnhandledException> eventos. Define un controlador de eventos `MyHandler`, que se invoca cuando se produce una excepción no controlada en el dominio de aplicación predeterminado. A continuación, inicia dos excepciones. La primera se controla mediante un **try/catch** bloque. El segundo es no controlado y se invoca el `MyHandle` rutina antes de que finalice la aplicación.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute" />
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeWrappedException" />
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si Common Language Runtime está finalizando.</summary>
        <value>
          Es <see langword="true" /> si el tiempo de ejecución está finalizando; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partir de la versión 2.0 de .NET Framework, esta propiedad devuelve `true` para la mayoría de las excepciones, de no controladas, a menos que se utiliza un indicador de compatibilidad de aplicaciones para revertir al comportamiento de las versiones 1.0 y 1.1. El motivo es que más de las excepciones no controladas en subprocesos, incluidos los subprocesos del grupo de subprocesos, se pueden continuar Naturalmente, normalmente como resultado la finalización de la aplicación. Para obtener más información, incluida una lista de los casos en los que el tiempo de ejecución no finaliza, vea [excepciones en subprocesos administrados](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
## <a name="version-information"></a>Información de versión  
 Lo siguiente se aplica a las versiones 1.0 y 1.1 de .NET Framework: esta propiedad devuelve `true` cuando se reciben en una excepción, pero no controlada por el subproceso principal de la aplicación. Esta propiedad también devuelve `true` si un subproceso no administrado está ejecutando código administrado y recibe una excepción no controlada. Por último, esta propiedad devuelve `false` para el grupo de subprocesos y los subprocesos administrados creados por una aplicación, porque las versiones 1.0 y 1.1 detectar las excepciones no controladas en tales subprocesos y pasar por alto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>