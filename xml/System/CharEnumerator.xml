<Type Name="CharEnumerator" FullName="System.CharEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a0340579d687eb3f073235cd7693bf9b430e5f80" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37481135" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class CharEnumerator : ICloneable, System.Collections.Generic.IEnumerator&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit CharEnumerator extends System.Object implements class System.Collections.Generic.IEnumerator`1&lt;char&gt;, class System.Collections.IEnumerator, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.CharEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class CharEnumerator&#xA;Implements ICloneable, IEnumerator(Of Char)" />
  <TypeSignature Language="C++ CLI" Value="public ref class CharEnumerator sealed : ICloneable, System::Collections::Generic::IEnumerator&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type CharEnumerator = class&#xA;    interface IEnumerator&#xA;    interface ICloneable&#xA;    interface IEnumerator&lt;char&gt;&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Supports iterating over a <see cref="T:System.String" /> object and reading its individual characters. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.CharEnumerator> proporciona acceso de solo lectura a los caracteres de una referencia <xref:System.String> objeto. Por ejemplo, el `foreach` instrucción de los lenguajes de programación de Microsoft Visual Basic y C#, que recorre en iteración los elementos de una colección, recupera un <xref:System.CharEnumerator> desde un <xref:System.String> objeto para recorrer en iteración los caracteres en el que objeto.  
  
 No hay ningún constructor público para <xref:System.CharEnumerator>. En su lugar, llame a un <xref:System.String> del objeto <xref:System.String.GetEnumerator%2A> método para obtener un <xref:System.CharEnumerator> que se inicializa para hacer referencia a la cadena.  
  
 Un <xref:System.CharEnumerator> mantiene un índice interno a los caracteres de la cadena de la <xref:System.CharEnumerator> referencias. El estado del índice es válidos y no cuando hace referencia a una posición de carácter lógicamente delante del primer carácter o después del último carácter en la cadena cuando hace referencia a un carácter en la cadena. El índice se inicializa en una posición situada lógicamente delante del primer carácter y se establece en una posición después del último carácter cuando se completa la iteración. Se produce una excepción si intenta obtener acceso a un carácter mientras el índice no es válido.  
  
 El <xref:System.CharEnumerator.MoveNext%2A> método incrementa el índice en uno, por lo que se tiene acceso a su vez a los caracteres inicial y posteriores. El <xref:System.CharEnumerator.Reset%2A> método establece el índice en una posición situada lógicamente delante del primer carácter. El <xref:System.CharEnumerator.Current%2A> propiedad recupera el carácter al que hace referencia actualmente el índice. El <xref:System.CharEnumerator.Clone%2A> método crea una copia de la <xref:System.CharEnumerator>.  
  
> [!NOTE]
>  Varias instancias independientes de <xref:System.CharEnumerator> a través de uno o varios subprocesos pueden tener acceso a una única instancia de <xref:System.String>. Esta clase se implementa para admitir la <xref:System.Collections.IEnumerator> interfaz. Para obtener más información acerca del uso de un enumerador, vea el <xref:System.Collections.IEnumerator> tema.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.CharEnumerator> clase para enumerar los caracteres individuales de una cadena. Crea una instancia de un <xref:System.CharEnumerator> objeto mediante una llamada a la <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> método, se desplaza de un carácter a la siguiente mediante una llamada a la <xref:System.CharEnumerator.MoveNext%2A> método y muestra el carácter actual al recuperar el valor de la <xref:System.CharEnumerator.Current%2A> propiedad.  
  
 [!code-cpp[System.CharEnumerator.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#1)]
 [!code-csharp[System.CharEnumerator.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#1)]
 [!code-vb[System.CharEnumerator.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#1)]  
  
 Sin embargo, tenga en cuenta que la misma operación puede realizarse un poco más intuitiva con `foreach` (en C#) o `For Each` (en Visual Basic), como en el ejemplo siguiente se muestra.  
  
 [!code-cpp[System.CharEnumerator.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#2)]
 [!code-csharp[System.CharEnumerator.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#2)]
 [!code-vb[System.CharEnumerator.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.String" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Collections.ICollection" />
  </Docs>
  <Members>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="charEnumerator.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a copy of the current <see cref="T:System.CharEnumerator" /> object.</summary>
        <returns>An <see cref="T:System.Object" /> that is a copy of the current <see cref="T:System.CharEnumerator" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto es una copia de esta instancia de <xref:System.CharEnumerator> y su estado actual. Esto es útil para guardar su estado al recorrer un <xref:System.String> objeto.  
  
 Por ejemplo, suponga que la aplicación utiliza una instancia original de <xref:System.CharEnumerator> para iterar por cada carácter de un <xref:System.String>. Cuando se detecta un carácter único, la aplicación detiene el procesamiento y se invoca el <xref:System.CharEnumerator.Clone%2A> método. De hecho, esto ahorra la <xref:System.CharEnumerator> índice del objeto en el <xref:System.String>.  
  
 La aplicación utiliza el duplicado para desplazarse a otra parte de la `String` para realizar un procesamiento auxiliar. El inconveniente de esta navegación es que el clon pierde la pista de la posición donde se detuvo el procesamiento. Sin embargo, cuando finalice el procesamiento auxiliar, la aplicación descarta el clon y usa el original <xref:System.CharEnumerator> instancia para reanudar el trabajo en el <xref:System.String> donde se detuvo el procesamiento original.  
  
> [!NOTE]
>  Este método se implementa para admitir la <xref:System.ICloneable> interfaz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public char Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Current" />
      <MemberSignature Language="DocId" Value="P:System.CharEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Current { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : char" Usage="System.CharEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IEnumerator`1.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the currently referenced character in the string enumerated by this <see cref="T:System.CharEnumerator" /> object.</summary>
        <value>El carácter Unicode que se hace referencia actualmente este <see cref="T:System.CharEnumerator" /> objeto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.CharEnumerator> clase mantiene un índice interno a la cadena enumerada y el <xref:System.CharEnumerator.Current%2A> propiedad devuelve el carácter que se hace referencia actualmente por el índice. Esta propiedad se debe invocar solo cuando el índice es válido; en caso contrario, se produce una excepción.  
  
 El índice siempre es válido para una cadena vacía (""). El índice también es válido después de la <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> o <xref:System.CharEnumerator.Reset%2A> se llama al método. Cuando se llama a alguno de estos métodos, invocar el <xref:System.CharEnumerator.MoveNext%2A> método para ajustar el índice hasta el primer carácter de la cadena enumerada. El índice es válido siempre que el <xref:System.CharEnumerator.MoveNext%2A> devuelve del método `true`.  
  
 <xref:System.CharEnumerator.Current%2A> no se mueve el índice y las llamadas consecutivas a <xref:System.CharEnumerator.Current%2A> devuelven el mismo carácter hasta que <xref:System.CharEnumerator.MoveNext%2A>, <xref:System.CharEnumerator.Reset%2A>, o <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> se llama.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.CharEnumerator> clase para enumerar los caracteres individuales de una cadena. Crea una instancia de un <xref:System.CharEnumerator> objeto mediante una llamada a la <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> método, se desplaza de un carácter a la siguiente mediante una llamada a la <xref:System.CharEnumerator.MoveNext%2A> método y muestra el carácter actual al recuperar el valor de la <xref:System.CharEnumerator.Current%2A> propiedad.  
  
 [!code-cpp[System.CharEnumerator.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#1)]
 [!code-csharp[System.CharEnumerator.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#1)]
 [!code-vb[System.CharEnumerator.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#1)]  
  
 Sin embargo, tenga en cuenta que la misma operación puede realizarse un poco más intuitiva con `foreach` (en C#) o `For Each` (en Visual Basic), como en el ejemplo siguiente se muestra.  
  
 [!code-cpp[System.CharEnumerator.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#2)]
 [!code-csharp[System.CharEnumerator.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#2)]
 [!code-vb[System.CharEnumerator.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The index is invalid; that is, it is before the first or after the last character of the enumerated string.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="charEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.CharEnumerator" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.CharEnumerator.Dispose%2A> cuando haya terminado de usar <xref:System.CharEnumerator>. El método <xref:System.CharEnumerator.Dispose%2A> deja el <xref:System.CharEnumerator> en un estado no utilizable. Después de llamar a <xref:System.CharEnumerator.Dispose%2A>, debe liberar todas las referencias a la <xref:System.CharEnumerator> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.CharEnumerator> estaba ocupando.  
  
 Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a <xref:System.CharEnumerator.Dispose%2A> antes de liberar la última referencia al objeto <xref:System.CharEnumerator>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.CharEnumerator> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="charEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Increments the internal index of the current <see cref="T:System.CharEnumerator" /> object to the next character of the enumerated string.</summary>
        <returns>
          <see langword="true" /> if the index is successfully incremented and within the enumerated string; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.CharEnumerator> clase mantiene un índice interno a la cadena enumerada y el <xref:System.CharEnumerator.MoveNext%2A> método incrementa el índice en uno. Llame a <xref:System.CharEnumerator.MoveNext%2A> después de llamar a <xref:System.String.GetEnumerator%2A> o <xref:System.CharEnumerator.Reset%2A> se incrementa la posición del carácter actual hasta el primer carácter de la cadena enumerada. Compruebe que el valor devuelto es `true` para determinar que la posición del carácter actual es válida.  
  
 Si el índice ya está más allá del último carácter de la cadena enumerada, no se cambia el índice y `false` se devuelve.  
  
 Tenga en cuenta que si la cadena enumerada está vacía (""), el estado de la <xref:System.CharEnumerator> siempre es válido. Esto es porque el índice interno para el <xref:System.CharEnumerator> está inicialmente delante del primer carácter de la cadena enumerada y, por tanto, no es válido. <xref:System.CharEnumerator.MoveNext%2A> lógicamente, Establece el índice después del último carácter (inexistente) de la cadena enumerada que tampoco es válido.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.CharEnumerator> clase para enumerar los caracteres individuales de una cadena. Crea una instancia de un <xref:System.CharEnumerator> objeto mediante una llamada a la <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> método, se desplaza de un carácter a la siguiente mediante una llamada a la <xref:System.CharEnumerator.MoveNext%2A> método y muestra el carácter actual al recuperar el valor de la <xref:System.CharEnumerator.Current%2A> propiedad.  
  
 [!code-cpp[System.CharEnumerator.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#1)]
 [!code-csharp[System.CharEnumerator.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#1)]
 [!code-vb[System.CharEnumerator.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#1)]  
  
 Sin embargo, tenga en cuenta que la misma operación puede realizarse un poco más intuitiva con `foreach` (en C#) o `For Each` (en Visual Basic), como en el ejemplo siguiente se muestra.  
  
 [!code-cpp[System.CharEnumerator.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#2)]
 [!code-csharp[System.CharEnumerator.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#2)]
 [!code-vb[System.CharEnumerator.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="charEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes the index to a position logically before the first character of the enumerated string.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.CharEnumerator> clase mantiene un índice interno a la cadena enumerada y el <xref:System.CharEnumerator.Reset%2A> método establece el índice en el estado no válido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.CharEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.CharEnumerator.System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the currently referenced character in the string enumerated by this <see cref="T:System.CharEnumerator" /> object. For a description of this member, see <see cref="P:System.Collections.IEnumerator.Current" />.</summary>
        <value>El carácter Unicode con conversión boxing actualmente hace referencia este <see cref="T:System.CharEnumerator" /> objeto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.CharEnumerator> se convierte en una interfaz <xref:System.Collections.IEnumerator>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Enumeration has not started.  -or-  Enumeration has ended.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>