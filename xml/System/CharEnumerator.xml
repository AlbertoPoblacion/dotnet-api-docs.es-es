<Type Name="CharEnumerator" FullName="System.CharEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0570f4e2dd53178598e0e6fbf7b325d2cd252378" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30728379" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class CharEnumerator : ICloneable, System.Collections.Generic.IEnumerator&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit CharEnumerator extends System.Object implements class System.Collections.Generic.IEnumerator`1&lt;char&gt;, class System.Collections.IEnumerator, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.CharEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class CharEnumerator&#xA;Implements ICloneable, IEnumerator(Of Char)" />
  <TypeSignature Language="C++ CLI" Value="public ref class CharEnumerator sealed : ICloneable, System::Collections::Generic::IEnumerator&lt;char&gt;" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Admite la iteración en un objeto <see cref="T:System.String" /> y la lectura de sus caracteres individuales. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.CharEnumerator> proporciona acceso de solo lectura a los caracteres de una referencia <xref:System.String> objeto. Por ejemplo, el `foreach` instrucción de los lenguajes de programación Microsoft Visual Basic y C#, que recorre en iteración los elementos de una colección, recupera un <xref:System.CharEnumerator> desde un <xref:System.String> objeto para recorrer en iteración los caracteres de ese objeto.  
  
 No hay ningún constructor público para <xref:System.CharEnumerator>. En su lugar, llame a un <xref:System.String> del objeto <xref:System.String.GetEnumerator%2A> método para obtener un <xref:System.CharEnumerator> que se inicializa para hacer referencia a la cadena.  
  
 A <xref:System.CharEnumerator> mantiene un índice interno a los caracteres de la cadena de la <xref:System.CharEnumerator> referencias. El estado del índice es válidos y no cuando hace referencia a una posición de carácter lógicamente delante del primer carácter o después del último carácter en la cadena cuando hace referencia a un carácter en la cadena. El índice se inicializa en una posición lógicamente delante del primer carácter y se establece en una posición después del último carácter cuando se completa la iteración. Se produce una excepción si intenta tener acceso a un carácter cuando el índice no es válido.  
  
 El <xref:System.CharEnumerator.MoveNext%2A> método incrementa el índice en uno, por lo que se obtiene acceso a su vez a los caracteres inicial y posteriores. El <xref:System.CharEnumerator.Reset%2A> método establece el índice en una posición lógicamente delante del primer carácter. El <xref:System.CharEnumerator.Current%2A> propiedad recupera el carácter al que hace referencia actualmente el índice. El <xref:System.CharEnumerator.Clone%2A> método crea una copia de la <xref:System.CharEnumerator>.  
  
> [!NOTE]
>  Varias instancias independientes de <xref:System.CharEnumerator> a través de uno o varios subprocesos pueden tener acceso a una sola instancia de <xref:System.String>. Esta clase se implementa para admitir el <xref:System.Collections.IEnumerator> interfaz. Para obtener más información sobre el uso de un enumerador, vea el <xref:System.Collections.IEnumerator> tema.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza la <xref:System.CharEnumerator> clase para enumerar los caracteres individuales de una cadena. Crea una instancia de un <xref:System.CharEnumerator> objeto mediante una llamada a la <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> método, se desplaza de un carácter a la siguiente mediante una llamada a la <xref:System.CharEnumerator.MoveNext%2A> método y muestra el carácter actual recuperando el valor de la <xref:System.CharEnumerator.Current%2A> propiedad.  
  
 [!code-cpp[System.CharEnumerator.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#1)]
 [!code-csharp[System.CharEnumerator.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#1)]
 [!code-vb[System.CharEnumerator.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#1)]  
  
 Sin embargo, tenga en cuenta que se puede realizar la misma operación algo más intuitiva usando `foreach` (en C#) o `For Each` (en Visual Basic), como en el ejemplo siguiente se muestra.  
  
 [!code-cpp[System.CharEnumerator.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#2)]
 [!code-csharp[System.CharEnumerator.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#2)]
 [!code-vb[System.CharEnumerator.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.String" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Collections.ICollection" />
  </Docs>
  <Members>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia del objeto <see cref="T:System.CharEnumerator" /> actual.</summary>
        <returns>
          <see cref="T:System.Object" /> que es una copia del objeto <see cref="T:System.CharEnumerator" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto es una copia de esta instancia de <xref:System.CharEnumerator> y su estado actual. Esto es útil para guardar el estado que se va iterando a través de un <xref:System.String> objeto.  
  
 Por ejemplo, suponga que la aplicación utiliza una instancia original de <xref:System.CharEnumerator> para recorrer en iteración cada carácter en un <xref:System.String>. Cuando se detecta un carácter único, la aplicación detiene el procesamiento y se invoca el <xref:System.CharEnumerator.Clone%2A> método. En efecto, esto ahorra la <xref:System.CharEnumerator> índice del objeto en el <xref:System.String>.  
  
 La aplicación utiliza el duplicado para desplazarse a otra parte de la `String` para realizar un procesamiento auxiliar. El efecto secundario de esta navegación es que el duplicado no puede realizar un seguimiento de la posición donde se detuvo el procesamiento. Sin embargo, una vez completado el procesamiento auxiliar, la aplicación desecha el duplicado y utiliza la versión original <xref:System.CharEnumerator> instancia para reanudar el trabajo en el <xref:System.String> donde se detuvo el procesamiento original.  
  
> [!NOTE]
>  Este método se implementa para admitir el <xref:System.ICloneable> interfaz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public char Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Current" />
      <MemberSignature Language="DocId" Value="P:System.CharEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Current { char get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IEnumerator`1.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el carácter al que se hace referencia actualmente en la cadena enumerada por este objeto <see cref="T:System.CharEnumerator" />.</summary>
        <value>Carácter Unicode al que hace referencia actualmente este objeto <see cref="T:System.CharEnumerator" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.CharEnumerator> clase mantiene un índice interno a la cadena enumerada y el <xref:System.CharEnumerator.Current%2A> propiedad devuelve el carácter que se hace referencia mediante el índice. Esta propiedad se debe invocar solo cuando el índice es válido; en caso contrario, se produce una excepción.  
  
 El índice siempre es válido para una cadena vacía (""). El índice también es válido después de la <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> o <xref:System.CharEnumerator.Reset%2A> se llama al método. Después de llamar a cualquiera de estos métodos, invocar el <xref:System.CharEnumerator.MoveNext%2A> método para ajustar el índice hasta el primer carácter de la cadena enumerada. El índice es válido siempre que el <xref:System.CharEnumerator.MoveNext%2A> método `true`.  
  
 <xref:System.CharEnumerator.Current%2A> no mueve el índice y llamadas consecutivas a <xref:System.CharEnumerator.Current%2A> devuelven el mismo carácter hasta que <xref:System.CharEnumerator.MoveNext%2A>, <xref:System.CharEnumerator.Reset%2A>, o <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> se llama.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza la <xref:System.CharEnumerator> clase para enumerar los caracteres individuales de una cadena. Crea una instancia de un <xref:System.CharEnumerator> objeto mediante una llamada a la <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> método, se desplaza de un carácter a la siguiente mediante una llamada a la <xref:System.CharEnumerator.MoveNext%2A> método y muestra el carácter actual recuperando el valor de la <xref:System.CharEnumerator.Current%2A> propiedad.  
  
 [!code-cpp[System.CharEnumerator.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#1)]
 [!code-csharp[System.CharEnumerator.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#1)]
 [!code-vb[System.CharEnumerator.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#1)]  
  
 Sin embargo, tenga en cuenta que se puede realizar la misma operación algo más intuitiva usando `foreach` (en C#) o `For Each` (en Visual Basic), como en el ejemplo siguiente se muestra.  
  
 [!code-cpp[System.CharEnumerator.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#2)]
 [!code-csharp[System.CharEnumerator.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#2)]
 [!code-vb[System.CharEnumerator.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El índice no es válido; es decir, está delante del primer carácter o detrás del último carácter de la cadena enumerada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.CharEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.CharEnumerator.Dispose%2A> cuando haya terminado de usar <xref:System.CharEnumerator>. El método <xref:System.CharEnumerator.Dispose%2A> deja el <xref:System.CharEnumerator> en un estado no utilizable. Después de llamar a <xref:System.CharEnumerator.Dispose%2A>, debe liberar todas las referencias a la <xref:System.CharEnumerator> para que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.CharEnumerator> estaba ocupando.  
  
 Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a <xref:System.CharEnumerator.Dispose%2A> antes de liberar la última referencia al objeto <xref:System.CharEnumerator>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.CharEnumerator> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Incrementa el índice interno del objeto <see cref="T:System.CharEnumerator" /> actual hasta el siguiente carácter de la cadena enumerada.</summary>
        <returns>
          Es <see langword="true" /> si el índice se incrementa correctamente y dentro de la cadena enumerada; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.CharEnumerator> clase mantiene un índice interno a la cadena enumerada y el <xref:System.CharEnumerator.MoveNext%2A> método incrementa el índice en uno. Llame a <xref:System.CharEnumerator.MoveNext%2A> después de llamar a <xref:System.String.GetEnumerator%2A> o <xref:System.CharEnumerator.Reset%2A> para incrementar la posición de carácter actual hasta el primer carácter de la cadena enumerada. Compruebe que el valor devuelto es `true` para determinar que la posición del carácter actual es válida.  
  
 Si el índice está después del último carácter de la cadena enumerada, no se cambia el índice y `false` se devuelve.  
  
 Tenga en cuenta que si la cadena enumerada está vacía (""), el estado de la <xref:System.CharEnumerator> siempre es válido. Esto es porque el índice interno para el <xref:System.CharEnumerator> está inicialmente delante del primer carácter de la cadena enumerada y, por tanto, no es válido. <xref:System.CharEnumerator.MoveNext%2A> establece lógicamente el índice después del último carácter (inexistente) de la cadena enumerada que tampoco es válido.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza la <xref:System.CharEnumerator> clase para enumerar los caracteres individuales de una cadena. Crea una instancia de un <xref:System.CharEnumerator> objeto mediante una llamada a la <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> método, se desplaza de un carácter a la siguiente mediante una llamada a la <xref:System.CharEnumerator.MoveNext%2A> método y muestra el carácter actual recuperando el valor de la <xref:System.CharEnumerator.Current%2A> propiedad.  
  
 [!code-cpp[System.CharEnumerator.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#1)]
 [!code-csharp[System.CharEnumerator.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#1)]
 [!code-vb[System.CharEnumerator.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#1)]  
  
 Sin embargo, tenga en cuenta que se puede realizar la misma operación algo más intuitiva usando `foreach` (en C#) o `For Each` (en Visual Basic), como en el ejemplo siguiente se muestra.  
  
 [!code-cpp[System.CharEnumerator.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#2)]
 [!code-csharp[System.CharEnumerator.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#2)]
 [!code-vb[System.CharEnumerator.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa el índice en una posición situada lógicamente delante del primer carácter de la cadena enumerada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.CharEnumerator> clase mantiene un índice interno a la cadena enumerada y el <xref:System.CharEnumerator.Reset%2A> método establece el índice en el estado no válido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.CharEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el carácter al que se hace referencia actualmente en la cadena enumerada por este objeto <see cref="T:System.CharEnumerator" />. Para una descripción de este miembro, vea <see cref="P:System.Collections.IEnumerator.Current" />.</summary>
        <value>Carácter Unicode al que se ha aplicado la conversión boxing y al que hace referencia actualmente este objeto <see cref="T:System.CharEnumerator" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.CharEnumerator> se convierte en una interfaz <xref:System.Collections.IEnumerator>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La enumeración no se ha iniciado.  
  
 O bien  
  
 La enumeración ha finalizado.</exception>
      </Docs>
    </Member>
  </Members>
</Type>