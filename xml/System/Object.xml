<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Object.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe07da621eb36bda643f3e0a1e5b1a3ef53120877ab9.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">da621eb36bda643f3e0a1e5b1a3ef53120877ab9</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</source>
          <target state="translated">Admite todas las clases de la jerarquía de clases de .NET Framework y proporciona servicios de bajo nivel a las clases derivadas.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</source>
          <target state="translated">Se trata de la clase base fundamental de todas las clases de .NET Framework; es la raíz de la jerarquía de tipos.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Languages typically do not require a class to declare inheritance from <ph id="ph1">&lt;xref:System.Object&gt;</ph> because the inheritance is implicit.</source>
          <target state="translated">Idiomas no suelen requieran una clase para declarar la herencia de <ph id="ph1">&lt;xref:System.Object&gt;</ph> porque la herencia está implícita.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Because all classes in the .NET Framework are derived from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, every method defined in the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class is available in all objects in the system.</source>
          <target state="translated">Dado que se derivan todas las clases de .NET Framework <ph id="ph1">&lt;xref:System.Object&gt;</ph>, todos los métodos definidos en la <ph id="ph2">&lt;xref:System.Object&gt;</ph> clase está disponible en todos los objetos en el sistema.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Derived classes can and do override some of these methods, including:</source>
          <target state="translated">Las clases derivadas pueden e invalidar algunos de estos métodos, incluyendo:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> - Supports comparisons between objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> -Admite comparaciones entre objetos.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> - Performs cleanup operations before an object is automatically reclaimed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> -Realiza operaciones de limpieza antes de que un objeto sea reclamado automáticamente.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> - Generates a number corresponding to the value of the object to support the use of a hash table.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> -Genera un número correspondiente al valor del objeto que admite el uso de una tabla hash.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> - Manufactures a human-readable text string that describes an instance of the class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> -Crea una cadena de texto legible que describe una instancia de la clase.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Performance Considerations</source>
          <target state="translated">Consideraciones sobre el rendimiento</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">Si está diseñando una clase, como una colección, que debe administrar cualquier tipo de objeto, puede crear miembros de clase que acepten instancias de la <ph id="ph1">&lt;xref:System.Object&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>However, the process of boxing and unboxing a type carries a performance cost.</source>
          <target state="translated">Sin embargo, el proceso de conversión boxing y unboxing a un tipo implica un costo de rendimiento.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</source>
          <target state="translated">Si conoce que la nueva clase controlará con frecuencia ciertos tipos de valor puede utilizar uno de dos tácticas para minimizar el costo de la conversión boxing.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Create a general method that accepts an <ph id="ph1">&lt;xref:System.Object&gt;</ph> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</source>
          <target state="translated">Crear un método general que acepta un <ph id="ph1">&lt;xref:System.Object&gt;</ph> tipo y un conjunto de sobrecargas de método específico del tipo que acepten cada tipo de valor que se espera que la clase controle con frecuencia.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</source>
          <target state="translated">Si no existe un método específico del tipo que acepta el tipo de parámetro que realiza la llamada, se produce ninguna conversión boxing y se invoca el método específico del tipo.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</source>
          <target state="translated">Si no hay ningún argumento de método que coincida con el tipo de parámetro que realiza la llamada, el parámetro es una conversión boxing y se invoca el método general.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Design your type and its members to use generics.</source>
          <target state="translated">Diseñar su tipo y sus miembros para que utilicen genéricos.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</source>
          <target state="translated">Common language runtime crea un tipo genérico cerrado cuando se crea una instancia de la clase y especificar un argumento de tipo genérico.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The generic method is type-specific and can be invoked without boxing the calling parameter.</source>
          <target state="translated">El método genérico es específico del tipo y se puede invocar sin conversión boxing al parámetro de llamada.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Although it is sometimes necessary to develop general purpose classes that accept and return <ph id="ph1">&lt;xref:System.Object&gt;</ph> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</source>
          <target state="translated">Aunque a veces es necesario desarrollar clases de propósito general que aceptan y devuelven <ph id="ph1">&lt;xref:System.Object&gt;</ph> tipos, puede mejorar el rendimiento proporcionando también una clase específica del tipo para controlar un tipo de uso frecuente.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</source>
          <target state="translated">Por ejemplo, si se proporciona una clase que es específica para establecer y obtener valores booleanos, elimina el costo de aplicar conversiones boxing y unboxing valores booleanos.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The following example defines a Point type derived from the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class and overrides many of the virtual methods of the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se define un tipo de punto derivado de la <ph id="ph1">&lt;xref:System.Object&gt;</ph> clase y se reemplazan muchos de los métodos virtuales de la <ph id="ph2">&lt;xref:System.Object&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>In addition, the example shows how to call many of the static and instance methods of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">Además, en el ejemplo se muestra cómo llamar a muchos de los métodos estático y métodos de la instancia la <ph id="ph1">&lt;xref:System.Object&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Estático público (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) miembros de este tipo son seguros para subprocesos.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Instance members are not guaranteed to be thread-safe.</source>
          <target state="translated">No se garantiza que los miembros de instancia sea seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Object.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.#ctor">
          <source>This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">Este constructor llama a constructores de clases derivadas, pero también se puede utilizar para crear directamente una instancia de la <ph id="ph1">&lt;xref:System.Object&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Determines whether two object instances are equal.</source>
          <target state="translated">Determina si dos instancias de objeto son iguales.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>The object to compare with the current object.</source>
          <target state="translated">Objeto que se va a comparar con el objeto actual.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>Determines whether the specified object is equal to the current object.</source>
          <target state="translated">Determina si el objeto especificado es igual al objeto actual.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified object  is equal to the current object; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto especificado es igual al objeto actual; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type of comparison between the current instance and the <ph id="ph1">`obj`</ph> parameter depends on whether the current instance is a reference type or a value type.</source>
          <target state="translated">El tipo de comparación entre la instancia actual y la <ph id="ph1">`obj`</ph> parámetro depende de si la instancia actual es un tipo de referencia o un tipo de valor.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a reference type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for reference equality, and a call to the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method is equivalent to a call to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Si la instancia actual es un tipo de referencia, el <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> método comprueba la igualdad de referencia y una llamada a la <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> método es equivalente a una llamada a la <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality means that the object variables that are compared refer to the same object.</source>
          <target state="translated">Igualdad de referencia significa que las variables de objeto que se comparan hacen referencia al mismo objeto.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example illustrates the result of such a comparison.</source>
          <target state="translated">En el ejemplo siguiente se muestra el resultado de una comparación de este tipo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> class, which is a reference type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1a`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">Define un <ph id="ph1">`Person`</ph> (clase), que es un tipo de referencia, y llama el <ph id="ph2">`Person`</ph> constructor de clase para crear dos instancias de nuevo <ph id="ph3">`Person`</ph> objetos, <ph id="ph4">`person1a`</ph> y <ph id="ph5">`person2`</ph>, que tienen el mismo valor.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It also assigns <ph id="ph1">`person1a`</ph> to another object variable, <ph id="ph2">`person1b`</ph>.</source>
          <target state="translated">También asigna <ph id="ph1">`person1a`</ph> a otra variable de objeto, <ph id="ph2">`person1b`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person1b`</ph> are equal because they reference the same object.</source>
          <target state="translated">Como se muestra en el ejemplo, el salida <ph id="ph1">`person1a`</ph> y <ph id="ph2">`person1b`</ph> son iguales porque hacen referencia al mismo objeto.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person2`</ph> are not equal, although they have the same value.</source>
          <target state="translated">Sin embargo, <ph id="ph1">`person1a`</ph> y <ph id="ph2">`person2`</ph> no son iguales, aunque tienen el mismo valor.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a value type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for value equality.</source>
          <target state="translated">Si la instancia actual es un tipo de valor, la <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> método comprueba la igualdad de valor.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality means the following:</source>
          <target state="translated">Igualdad de valores significa lo siguiente:</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The two objects are of the same type.</source>
          <target state="translated">Los dos objetos son del mismo tipo.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the following example shows, a <ph id="ph1">&lt;xref:System.Byte&gt;</ph> object that has a value of 12 does not equal an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> object that has a value of 12, because the two objects have different run-time types.</source>
          <target state="translated">Como se muestra en el ejemplo siguiente, un <ph id="ph1">&lt;xref:System.Byte&gt;</ph> objeto que tiene un valor de 12 no es igual a un <ph id="ph2">&lt;xref:System.Int32&gt;</ph> objeto que tiene un valor de 12, porque los dos objetos tienen distintos tipos de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The values of the public and private fields of the two objects are equal.</source>
          <target state="translated">Los valores de los campos públicos y privados de los dos objetos son iguales.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example tests for value equality.</source>
          <target state="translated">En el ejemplo siguiente se comprueba la igualdad de valor.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> structure, which is a value type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">Define un <ph id="ph1">`Person`</ph> estructura, que es un tipo de valor, y llama el <ph id="ph2">`Person`</ph> constructor de clase para crear dos instancias de nuevo <ph id="ph3">`Person`</ph> objetos, <ph id="ph4">`person1`</ph> y <ph id="ph5">`person2`</ph>, que tienen el mismo valor.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, although the two object variables refer to different objects, <ph id="ph1">`person1`</ph> and <ph id="ph2">`person2`</ph> are equal because they have the same value for the private <ph id="ph3">`personName`</ph> field.</source>
          <target state="translated">Como se muestra en el resultado del ejemplo, aunque las dos variables de objeto hacen referencia a objetos diferentes, <ph id="ph1">`person1`</ph> y <ph id="ph2">`person2`</ph> son iguales porque tienen el mismo valor para la privada <ph id="ph3">`personName`</ph> campo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class is the base class for all types in the .NET Framework, the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method provides the default equality comparison for all other types.</source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Object&gt;</ph> clase es la clase base para todos los tipos de .NET Framework, el <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> método proporciona la comparación de igualdad predeterminado para todos los demás tipos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, types often override the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method to implement value equality.</source>
          <target state="translated">Sin embargo, los tipos a menudo invalidar la <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> método para implementar la igualdad de valor.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For more information, see the Notes for Callers and Notes for Inheritors sections.</source>
          <target state="translated">Para obtener más información, vea las notas para los autores de llamadas y notas de secciones de los herederos.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Notas de la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> sobrecarga del método en una clase de la <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, proporciona el comportamiento predeterminado para las clases que no se invalidan <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Esto forma parte de la compatibilidad que .NET Framework proporciona para la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (consulte <bpt id="p1">[</bpt>.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement an <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">Las clases en el <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> no heredar <ph id="ph2">&lt;xref:System.Object&gt;</ph>y actualmente no se implementa un <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">Sin embargo, parece que tienen <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, y <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> las clases que se escriben en C# o Visual Basic pueden invalidar la <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Callers</source>
          <target state="translated">Notas para los llamadores</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Derived classes frequently override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to implement value equality.</source>
          <target state="translated">Las clases derivadas reemplazan con frecuencia el <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> método para implementar la igualdad de valor.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition, types also frequently provide an additional strongly typed overload to the <ph id="ph1">`Equals`</ph> method, typically by implementing the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">Además, los tipos también suelen proporcionan una sobrecarga fuertemente tipada adicional a la <ph id="ph1">`Equals`</ph> método, normalmente mediante la implementación de la <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">`Equals`</ph> method to test for equality, you should know whether the current instance overrides <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> and understand how a particular call to an <ph id="ph3">`Equals`</ph> method is resolved.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">`Equals`</ph> método para comprobar la igualdad, debe saber si la instancia actual invalida <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> y entender cómo una determinada llamada a un <ph id="ph3">`Equals`</ph> método se ha resuelto.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</source>
          <target state="translated">En caso contrario, puede estar realizando una prueba de igualdad que es diferente de los previstos, y el método puede devolver un valor inesperado.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example provides an illustration.</source>
          <target state="translated">Esto se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It instantiates three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects with identical strings, and then makes four calls to <ph id="ph2">`Equals`</ph> methods.</source>
          <target state="translated">Crea una instancia de tres <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objetos con cadenas idénticas y, a continuación, realiza cuatro llamadas a <ph id="ph2">`Equals`</ph> métodos.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The first method call returns <ph id="ph1">`true`</ph>, and the remaining three return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">La primera llamada al método devuelve <ph id="ph1">`true`</ph>y el rendimiento de tres restantes <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the first case, the strongly typed <ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph> method overload, which tests for value equality, is called.</source>
          <target state="translated">En el primer caso, fuertemente tipado <ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método, que comprueba la igualdad de valor, se llama.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the strings assigned to the two <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are equal, the method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Dado que las cadenas se asignan a los dos <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objetos son iguales, el método devuelve <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> does not override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Sin embargo, <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> no invalida <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because of this, when the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object is cast to an <ph id="ph2">&lt;xref:System.Object&gt;</ph>, when a <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> instance is assigned to a variable of type <ph id="ph4">&lt;xref:System.Object&gt;</ph>, and when the <ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method is passed two <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> objects, the default <ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is called.</source>
          <target state="translated">Por este motivo, cuando la <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objeto se convierte en una <ph id="ph2">&lt;xref:System.Object&gt;</ph>, cuando un <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> instancia se asigna a una variable de tipo <ph id="ph4">&lt;xref:System.Object&gt;</ph>y cuándo el <ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> se pasa al método dos <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> objetos, el valor predeterminado <ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> se llama al método.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> is a reference type, this is equivalent to passing the two <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Dado que <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> es un tipo de referencia, es equivalente a pasar los dos <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objetos a la <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Although all three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects contain identical strings, they refer to three distinct objects.</source>
          <target state="translated">Aunque las tres <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objetos contienen cadenas idénticas, hacen referencia a tres objetos distintos.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As a result, these three method calls return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Como resultado, estos tres métodos llama devuelto <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can compare the current object to another object for reference equality by calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Puede comparar el objeto actual con otro objeto para la igualdad de referencia mediante una llamada a la <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In Visual Basic, you can also use the <ph id="ph1">`is`</ph> keyword (for example, <ph id="ph2">`If Me Is otherObject Then ...`</ph>).</source>
          <target state="translated">En Visual Basic, también puede utilizar el <ph id="ph1">`is`</ph> palabra clave (por ejemplo, <ph id="ph2">`If Me Is otherObject Then ...`</ph>).</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Inheritors</source>
          <target state="translated">Notas para los herederos</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you define your own type, that type inherits the functionality defined by the <ph id="ph1">`Equals`</ph> method of its base type.</source>
          <target state="translated">Al definir su propio tipo, ese tipo hereda la funcionalidad definida por el <ph id="ph1">`Equals`</ph> método de su tipo base.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following table lists the default implementation of the <ph id="ph1">`Equals`</ph> method for the major categories of types in the .NET Framework.</source>
          <target state="translated">La tabla siguiente muestra la implementación predeterminada de la <ph id="ph1">`Equals`</ph> método para las categorías principales de tipos en .NET Framework.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Type category</source>
          <target state="translated">Categoría de tipo</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Equality defined by</source>
          <target state="translated">Igualdad definida por</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Comments</source>
          <target state="translated">Comentarios</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Class derived directly from <ph id="ph1">&lt;xref:System.Object&gt;</ph></source>
          <target state="translated">Clase se deriva directamente <ph id="ph1">&lt;xref:System.Object&gt;</ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality; equivalent to calling <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Igualdad de referencia; equivalente a llamar a <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Structure</source>
          <target state="translated">Estructura</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</source>
          <target state="translated">Igualdad de valor; comparación byte a byte directa o en la comparación de campo a campo mediante la reflexión.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Enumeration</source>
          <target state="translated">Enumeración</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Values must have the same enumeration type and the same underlying value.</source>
          <target state="translated">Valores deben tener el mismo tipo de enumeración y el mismo valor subyacente.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegates must have the same type with identical invocation lists.</source>
          <target state="translated">Delegados deben tener el mismo tipo con listas de invocaciones idénticos.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Interface</source>
          <target state="translated">Interfaz</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality.</source>
          <target state="translated">Igualdad de referencia.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For a value type, you should always override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, because tests for equality that rely on reflection offer poor performance.</source>
          <target state="translated">Para un tipo de valor, debe invalidar siempre <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, ya que comprueba la igualdad que se basan en la reflexión ofrece un rendimiento deficiente.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can also override the default implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</source>
          <target state="translated">También puede invalidar la implementación predeterminada de <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> para los tipos de referencia para comprobar la igualdad de valores en lugar de la igualdad de referencia y para definir el significado exacto de igualdad de valores.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Such implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> return <ph id="ph2">`true`</ph> if the two objects have the same value, even if they are not the same instance.</source>
          <target state="translated">Este tipo de implementaciones de <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> devolver <ph id="ph2">`true`</ph> si los dos objetos tienen el mismo valor, aunque no sean la misma instancia.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</source>
          <target state="translated">El implementador de tipos decide qué constituye el valor de un objeto, pero suele ser todos o algunos de los datos almacenados en las variables de instancia del objeto.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, the value of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object is based on the characters of the string; the <ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method overrides the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to return <ph id="ph4">`true`</ph> for any two string instances that contain the same characters in the same order.</source>
          <target state="translated">Por ejemplo, el valor de un <ph id="ph1">&lt;xref:System.String&gt;</ph> objeto se basa en los caracteres de la cadena; la <ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> reemplazos de método la <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> método devuelva <ph id="ph4">`true`</ph> para cualquiera de dos cadenas instancias que contienen los mismos caracteres en el mismo orden.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows how to override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to test for value equality.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo invalidar el <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> método para comprobar la igualdad de valor.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method for the <ph id="ph2">`Person`</ph> class.</source>
          <target state="translated">Reemplaza el <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> método para el <ph id="ph2">`Person`</ph> clase.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`Person`</ph> accepted its base class implementation of equality, two <ph id="ph2">`Person`</ph> objects would be equal only if they referenced a single object.</source>
          <target state="translated">Si <ph id="ph1">`Person`</ph> aceptado su implementación de la clase base de la igualdad de los dos <ph id="ph2">`Person`</ph> objetos sería iguales sólo si hace referencia a un único objeto.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, in this case, two <ph id="ph1">`Person`</ph> objects are equal if they have the same value for the <ph id="ph2">`Person.Id`</ph> property.</source>
          <target state="translated">Sin embargo, en este caso, dos <ph id="ph1">`Person`</ph> objetos son iguales si tienen el mismo valor para el <ph id="ph2">`Person.Id`</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition to overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, you can implement the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface to provide a strongly typed test for equality.</source>
          <target state="translated">Además de invalidar <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, puede implementar la <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interfaz para proporcionar una prueba de igualdad fuertemente tipada.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following statements must be true for all implementations of the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">Las instrucciones siguientes deben ser true para todas las implementaciones de la <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the list, <ph id="ph1">`x`</ph>, <ph id="ph2">`y`</ph>, and <ph id="ph3">`z`</ph> represent object references that are not <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">En la lista, <ph id="ph1">`x`</ph>, <ph id="ph2">`y`</ph>, y <ph id="ph3">`z`</ph> representan referencias a objetos que no son <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(x)`</ph> returns <ph id="ph2">`true`</ph>, except in cases that involve floating-point types.</source>
          <target state="translated"><ph id="ph1">`x.Equals(x)`</ph> Devuelve <ph id="ph2">`true`</ph>, excepto en los casos que implican tipos de punto flotante.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</source>
          <target state="translated">Vea ISO/IEC/IEEE 60559:2011, Information technology--microprocesador sistemas--aritmética de coma flotante.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns the same value as <ph id="ph2">`y.Equals(x)`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> Devuelve el mismo valor que <ph id="ph2">`y.Equals(x)`</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns <ph id="ph2">`true`</ph> if both <ph id="ph3">`x`</ph> and <ph id="ph4">`y`</ph> are <ph id="ph5">`NaN`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> Devuelve <ph id="ph2">`true`</ph> si <ph id="ph3">`x`</ph> y <ph id="ph4">`y`</ph> son <ph id="ph5">`NaN`</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph> returns <ph id="ph2">`true`</ph>, then <ph id="ph3">`x.Equals(z)`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph> devuelve <ph id="ph2">`true`</ph>, a continuación, <ph id="ph3">`x.Equals(z)`</ph> devuelve <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Successive calls to <ph id="ph1">`x.Equals(y)`</ph> return the same value as long as the objects referenced by <ph id="ph2">`x`</ph> and <ph id="ph3">`y`</ph> are not modified.</source>
          <target state="translated">Las llamadas sucesivas a <ph id="ph1">`x.Equals(y)`</ph> devuelven el mismo valor siempre y cuando los objetos al que hace referencia <ph id="ph2">`x`</ph> y <ph id="ph3">`y`</ph> no se modifican.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(null)`</ph> returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(null)`</ph> devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> must not throw exceptions; they should always return a value.</source>
          <target state="translated">Las implementaciones de <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> no deben producir excepciones; siempre deben devolver un valor.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, if <ph id="ph1">`obj`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph> method should return <ph id="ph4">`false`</ph> instead of throwing an <ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
          <target state="translated">Por ejemplo, si <ph id="ph1">`obj`</ph> es <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph> método debe devolver <ph id="ph4">`false`</ph> en lugar de producir una <ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Follow these guidelines when overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</source>
          <target state="translated">Siga estas directrices al reemplazar <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> must override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Los tipos que implementan <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> debe invalidar <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> must also override <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>; otherwise, hash tables  might not work correctly.</source>
          <target state="translated">Tipos que reemplazan <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> también debe invalidar <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>; en caso contrario, las tablas hash no funcionen correctamente.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should consider implementing the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface to support strongly typed tests for equality.</source>
          <target state="translated">Puede implementar la <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interfaz para admitir fuertemente tipados comprueba la igualdad.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Your <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> implementation should return results that are consistent with <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">Su <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> implementación debe devolver resultados coherentes con <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to return the same result as the equality operator.</source>
          <target state="translated">Si su lenguaje de programación admite la sobrecarga de operadores y sobrecargar el operador de igualdad para un tipo determinado, también debe invalidar el <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> método para devolver el mismo resultado que el operador de igualdad.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This  helps ensure that class library code that uses <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> (such as <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) behaves in a manner that is consistent with the way the equality operator is used by application code.</source>
          <target state="translated">Esto ayuda a garantizar que código de biblioteca de clase que usa <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> (como <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> y <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) se comporta de forma que sea coherente con la manera en que se usa el operador de igualdad por código de aplicación.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Reference Types</source>
          <target state="translated">Instrucciones para tipos de referencia</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a reference type:</source>
          <target state="translated">Las siguientes directrices se aplican a reemplazar <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> para un tipo de referencia:</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Consider overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> if the semantics of the type are based on the fact that the type represents some value(s).</source>
          <target state="translated">Considere la posibilidad de reemplazar <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> si la semántica del tipo es basada en el hecho de que el tipo representa algunos valores.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Most reference types must not overload the equality operator, even if they override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">La mayoría de los tipos de referencia no deben sobrecargar el operador de igualdad, aunque reemplacen <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</source>
          <target state="translated">Sin embargo, si va a implementar un tipo de referencia destinado a tener semántica de valor, como un tipo de número complejo, debe reemplazar el operador de igualdad.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should not override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> on a mutable reference type.</source>
          <target state="translated">No se debe reemplazar <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> en un tipo de referencia mutable.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is because overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> requires that you also override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, as discussed in the previous section.</source>
          <target state="translated">Esto es porque reemplazar <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> requiere que también invalidar el <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> método, como se describe en la sección anterior.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</source>
          <target state="translated">Esto significa que puede cambiar el código hash de una instancia de un tipo de referencia mutable durante su duración, lo que puede producir el objeto que se va a ser perdidos en una tabla hash.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Value Types</source>
          <target state="translated">Instrucciones para tipos de valor</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a value type:</source>
          <target state="translated">Las siguientes directrices se aplican a reemplazar <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> para un tipo de valor:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you are defining a value type that includes one or more fields whose values are reference types, you should override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Si va a definir un tipo de valor que incluye uno o más campos cuyos valores son tipos de referencia, debe invalidar <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> implementation provided by <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> implementación proporcionada por <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> realiza una comparación byte a byte para los tipos de valor cuyos campos son todos los tipos de valor, pero utiliza la reflexión para realizar una comparación de campo a campo de tipos de valor cuyos campos son tipos de referencia.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and your development language supports operator overloading, you must overload the equality operator.</source>
          <target state="translated">Si invalida <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> y el lenguaje de programación admite la sobrecarga de operadores, debe sobrecargar el operador de igualdad.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should implement the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">Debe implementar la <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Calling the strongly typed <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> method avoids boxing the <ph id="ph2">`obj`</ph> argument.</source>
          <target state="translated">Al llamar a fuertemente tipado <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> método evita la conversión boxing el <ph id="ph2">`obj`</ph> argumento.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows a <ph id="ph1">`Point`</ph> class that overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method to provide value equality, and a <ph id="ph3">`Point3D`</ph> class that is derived from <ph id="ph4">`Point`</ph>.</source>
          <target state="translated">El siguiente ejemplo se muestra un <ph id="ph1">`Point`</ph> clase que invalide la <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> método para proporcionar la igualdad de valor y un <ph id="ph3">`Point3D`</ph> clase que se deriva de <ph id="ph4">`Point`</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point`</ph> overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to test for value equality, the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is not called.</source>
          <target state="translated">Dado que <ph id="ph1">`Point`</ph> invalida <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> para comprobar la igualdad de valor, la <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> no se llama el método.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`Point3D.Equals`</ph> calls <ph id="ph2">`Point.Equals`</ph> because <ph id="ph3">`Point`</ph> implements <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> in a manner that provides value equality.</source>
          <target state="translated">Sin embargo, <ph id="ph1">`Point3D.Equals`</ph> llamadas <ph id="ph2">`Point.Equals`</ph> porque <ph id="ph3">`Point`</ph> implementa <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> de forma que se proporciona igualdad de valor.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method checks to make sure that the <ph id="ph2">`obj`</ph> argument is not <bpt id="p1">**</bpt>null<ept id="p1">**</ept> and that it references an instance of the same type as this object.</source>
          <target state="translated">El <ph id="ph1">`Point.Equals`</ph> método comprueba para asegurarse de que el <ph id="ph2">`obj`</ph> el argumento no es <bpt id="p1">**</bpt>null<ept id="p1">**</ept> y que hace referencia a una instancia del mismo tipo que este objeto.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If either check fails, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si bien la comprobación da error, el método devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method calls the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine whether the run-time types of the two objects are identical.</source>
          <target state="translated">El <ph id="ph1">`Point.Equals`</ph> llamadas al método el <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> método para determinar si los tipos de tiempo de ejecución de los dos objetos son idénticos.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the method used a check of the form <ph id="ph1">`obj is Point`</ph> in C# or <ph id="ph2">`TryCast(obj, Point)`</ph> in Visual Basic, the check would return <ph id="ph3">`true`</ph> in cases where <ph id="ph4">`obj`</ph> is an instance of a derived class of <ph id="ph5">`Point`</ph>, even though <ph id="ph6">`obj`</ph> and the current instance are not of the same run-time type.</source>
          <target state="translated">Si el método utilizó una comprobación de la forma <ph id="ph1">`obj is Point`</ph> en C# o <ph id="ph2">`TryCast(obj, Point)`</ph> en Visual Basic, la comprobación devolverá <ph id="ph3">`true`</ph> en casos donde <ph id="ph4">`obj`</ph> es una instancia de una clase derivada de <ph id="ph5">`Point`</ph>, aunque <ph id="ph6">`obj`</ph> y actual instancia no son del mismo tipo de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Having verified that both objects are of the same type, the method casts <ph id="ph1">`obj`</ph> to type <ph id="ph2">`Point`</ph> and returns the result of comparing the instance fields of the two objects.</source>
          <target state="translated">Una vez comprobado que ambos objetos son del mismo tipo, el método convierte <ph id="ph1">`obj`</ph> al tipo <ph id="ph2">`Point`</ph> y devuelve el resultado de la comparación de los campos de instancia de los dos objetos.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In <ph id="ph1">`Point3D.Equals`</ph>, the inherited <ph id="ph2">`Point.Equals`</ph> method, which overrides <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>, is invoked before anything else is done.</source>
          <target state="translated">En <ph id="ph1">`Point3D.Equals`</ph>, los heredados <ph id="ph2">`Point.Equals`</ph> método, que invalida <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>, se invoca antes de realizar cualquier otra cosa.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point3D`</ph> is a sealed class (<ph id="ph2">`NotInheritable`</ph> in Visual Basic), a check in the form <ph id="ph3">`obj is Point`</ph> in C# or <ph id="ph4">`TryCast(obj, Point)`</ph> in Visual Basic is adequate to ensure that <ph id="ph5">`obj`</ph> is a <ph id="ph6">`Point3D`</ph> object.</source>
          <target state="translated">Dado que <ph id="ph1">`Point3D`</ph> es una clase sealed (<ph id="ph2">`NotInheritable`</ph> en Visual Basic), una comprobación en el formulario <ph id="ph3">`obj is Point`</ph> en C# o <ph id="ph4">`TryCast(obj, Point)`</ph> en Visual Basic es el adecuado para asegurarse de que <ph id="ph5">`obj`</ph> es un <ph id="ph6">`Point3D`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If it is a <ph id="ph1">`Point3D`</ph> object, it is cast to a <ph id="ph2">`Point`</ph> object and passed to the base class implementation of <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">Si es un <ph id="ph1">`Point3D`</ph> de objeto, se convierte en una <ph id="ph2">`Point`</ph> objeto y pasan a la implementación de clase base <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Only when the inherited <ph id="ph1">`Point.Equals`</ph> method returns <ph id="ph2">`true`</ph> does the method compare the <ph id="ph3">`z`</ph> instance fields introduced in the derived class.</source>
          <target state="translated">Solo cuando los heredados <ph id="ph1">`Point.Equals`</ph> método <ph id="ph2">`true`</ph> el método de comparación la <ph id="ph3">`z`</ph> campos presentados en la clase derivada de la instancia.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example defines a <ph id="ph1">`Rectangle`</ph> class that internally implements a rectangle as two <ph id="ph2">`Point`</ph> objects.</source>
          <target state="translated">En el ejemplo siguiente se define un <ph id="ph1">`Rectangle`</ph> clase que implementa internamente un rectángulo como dos <ph id="ph2">`Point`</ph> objetos.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Rectangle`</ph> class also overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to provide for value equality.</source>
          <target state="translated">El <ph id="ph1">`Rectangle`</ph> también clase invalidaciones <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> para proporcionar la igualdad de valores.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Some languages such as C# and Visual Basic support operator overloading.</source>
          <target state="translated">Algunos lenguajes como C# y Visual Basic admiten la sobrecarga de operadores.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When a type overloads the equality operator, it must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to provide the same functionality.</source>
          <target state="translated">Cuando un tipo sobrecarga el operador de igualdad, también debe invalidar el <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> método para proporcionar la misma funcionalidad.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is typically accomplished by writing the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method in terms of the overloaded equality operator, as in the following example.</source>
          <target state="translated">Esto se consigue normalmente escribiendo el <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> método en términos del operador de igualdad sobrecargado, como en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Complex`</ph> is a value type, it cannot be derived from.</source>
          <target state="translated">Dado que <ph id="ph1">`Complex`</ph> es un tipo de valor, no puede derivar de.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Therefore, the override to <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method need not call <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> to determine the precise run-time type of each object, but can instead use the <ph id="ph3">`is`</ph> operator in C# or the <ph id="ph4">`TypeOf`</ph> operator in Visual Basic to check the type of the <ph id="ph5">`obj`</ph> parameter.</source>
          <target state="translated">Por lo tanto, la invalidación para <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> no necesita llamar al método <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> para determinar el tiempo de ejecución preciso escriba de cada objeto, pero en su lugar, use la <ph id="ph3">`is`</ph> operador de C# o la <ph id="ph4">`TypeOf`</ph> operador en Visual Basic para comprobar el tipo de la <ph id="ph5">`obj`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">Primer objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">Segundo objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>Determines whether the specified object instances are considered equal.</source>
          <target state="translated">Determina si las instancias del objeto especificado se consideran iguales.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the objects are considered equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si los dos objetos se consideran iguales; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If both <ph id="ph1">&lt;paramref name="objA" /&gt;</ph> and <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Si tanto <ph id="ph1">&lt;paramref name="objA" /&gt;</ph> como <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> son <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, el método devuelve <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The static <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method indicates whether two objects, <ph id="ph2">`objA`</ph> and  <ph id="ph3">`objB`</ph>, are equal.</source>
          <target state="translated">El método estático <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> método indica si dos objetos, <ph id="ph2">`objA`</ph> y <ph id="ph3">`objB`</ph>, son iguales.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It also enables you to test objects whose value is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> for equality.</source>
          <target state="translated">También permite probar los objetos cuyo valor es <bpt id="p1">**</bpt>null<ept id="p1">**</ept> igualdad.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It compares <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> for equality as follows:</source>
          <target state="translated">Compara <ph id="ph1">`objA`</ph> y <ph id="ph2">`objB`</ph> para la igualdad como sigue:</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether the two objects represent the same object reference.</source>
          <target state="translated">Determina si los dos objetos representan la misma referencia de objeto.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If they do, the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Si es así, el método devuelve <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This test is equivalent to calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Esta prueba es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>In addition, if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Además, si ambos <ph id="ph1">`objA`</ph> y <ph id="ph2">`objB`</ph> son <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, el método devuelve <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether either <ph id="ph1">`objA`</ph> or <ph id="ph2">`objB`</ph> is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">Determina si el <ph id="ph1">`objA`</ph> o <ph id="ph2">`objB`</ph> es <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If so, it returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si es así, devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If the two objects do not represent the same object reference and neither is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, it calls <ph id="ph1">`objA`</ph>.<ph id="ph2">`Equals`</ph>(<ph id="ph3">`objB`</ph>) and returns the result.</source>
          <target state="translated">Si los dos objetos no representan la misma referencia de objeto y ninguna de ellas es <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, llama a <ph id="ph1">`objA`</ph>.<ph id="ph2">`Equals`</ph> (<ph id="ph3">`objB`</ph>) y devuelve el resultado.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This means that if <ph id="ph1">`objA`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, this override is called.</source>
          <target state="translated">Esto significa que si <ph id="ph1">`objA`</ph> invalida el <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> se llama al método, esta invalidación.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method and compares it with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> método y lo compara con el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Object.Finalize">
          <source>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</source>
          <target state="translated">Permite que un objeto intente liberar recursos y realizar otras operaciones de limpieza antes de que sea reclamado por la recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método se usa para realizar operaciones de limpieza en los recursos no administrados mantenidos por el objeto actual antes de que se destruya el objeto.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The method is protected and therefore is accessible only through this class or through a derived class.</source>
          <target state="translated">El método está protegido y, por tanto, es accesible sólo a través de esta clase o una clase derivada.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this section:</source>
          <target state="translated">En esta sección:</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>How finalization works<ept id="p1">](#How)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Cómo funciona la finalización<ept id="p1">](#How)</ept></target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>Notes for implementers<ept id="p1">](#Notes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Notas para los implementadores<ept id="p1">](#Notes)</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>La alternativa SafeHandle<ept id="p1">](#SafeHandle)</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>How finalization works</source>
          <target state="translated">Cómo funciona la finalización</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object&gt;</ph> class provides no implementation for the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, and the garbage collector does not mark types derived from <ph id="ph3">&lt;xref:System.Object&gt;</ph> for finalization unless they override the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Object&gt;</ph> clase no proporciona una implementación para el <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> método y el recolector de elementos no utilizados no marcar tipos derivados de <ph id="ph3">&lt;xref:System.Object&gt;</ph> para la finalización, a menos que invalide la <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a type does override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</source>
          <target state="translated">Si un tipo de invalidar el <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método, el recolector de elementos no utilizados agrega una entrada para cada instancia del tipo a una estructura interna denominada cola de finalización.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</source>
          <target state="translated">La cola de finalización contiene entradas para todos los objetos del montón administrado cuyo código de finalización debe ejecutarse antes de que el recolector de elementos no utilizados pueda reclamar su memoria.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The garbage collector then calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method automatically under the following conditions:</source>
          <target state="translated">El recolector de elementos no utilizados, a continuación, llama el <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método automáticamente en las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Después de que el recolector de elementos no utilizados ha detectado que un objeto es inaccesible, a menos que el objeto haya sido excluido del proceso de finalización mediante una llamada a la <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown of an application domain, unless the object is exempt from finalization.</source>
          <target state="translated">Durante el cierre de un dominio de aplicación, a menos que el objeto está exento de finalización.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown, even objects that are still accessible are finalized.</source>
          <target state="translated">Durante el cierre, finalizados incluso objetos que siguen siendo accesibles.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph> and the <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method has not been subsequently called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> se llama automáticamente una sola vez en una instancia determinada, a menos que el objeto se registre de nuevo mediante un mecanismo como <ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> método no se ha llamado posteriormente.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> operations have the following limitations:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> las operaciones tienen las siguientes limitaciones:</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The exact time when the finalizer executes is undefined.</source>
          <target state="translated">La hora exacta cuando se ejecuta el finalizador es indefinida.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To ensure deterministic release of resources for instances of your class, implement a <ph id="ph1">`Close`</ph> method or provide a <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">Para garantizar la liberación determinista de recursos para implementar instancias de la clase, un <ph id="ph1">`Close`</ph> método o proporcione un <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementación.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</source>
          <target state="translated">No se garantizan que los finalizadores de dos objetos de ejecución en cualquier orden determinado, incluso si un objeto hace referencia a la otra.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</source>
          <target state="translated">Es decir, si un objeto tiene una referencia al objeto B y ambos tienen finalizadores, objeto B podría ya ha finalizado cuando se inicia el finalizador del objeto.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The thread on which the finalizer runs is unspecified.</source>
          <target state="translated">El subproceso en el que se ejecuta el finalizador no está especificado.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method might not run to completion or might not run at all under the following exceptional circumstances:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método podría no ejecutarse hasta su finalización o podría no ejecutarse en absoluto en las siguientes circunstancias excepcionales:</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</source>
          <target state="translated">Si otro finalizador se bloquea indefinidamente (queda en un bucle infinito, intenta obtener un bloqueo, nunca puede obtener y así sucesivamente).</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</source>
          <target state="translated">Dado el tiempo de ejecución intenta ejecutar los finalizadores hasta su finalización, podrían no se llame a otros finalizadores si un finalizador se bloquea de forma indefinida.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If the process terminates without giving the runtime a chance to clean up.</source>
          <target state="translated">Si el proceso termina sin que el tiempo de ejecución una oportunidad para limpiar.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</source>
          <target state="translated">En este caso, la primera notificación de terminación del proceso de tiempo de ejecución es una notificación DLL_PROCESS_DETACH.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</source>
          <target state="translated">El tiempo de ejecución continúa finalizar los objetos durante el cierre sólo si el número de objetos susceptibles de finalización sigue reduciéndose.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> or an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active <ph id="ph3">`try`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> blocks or finalizers are executed.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> o un reemplazo de <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> inicia una excepción y el tiempo de ejecución no está hospedado por una aplicación que reemplace la directiva predeterminada, el runtime finaliza el proceso y no active <ph id="ph3">`try`</ph> <ph id="ph4">/</ph> <ph id="ph5">`finally`</ph> bloques o los finalizadores se ejecutan.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This behavior ensures process integrity if the finalizer cannot free or destroy resources.</source>
          <target state="translated">Este comportamiento garantiza la integridad del proceso si el finalizador no puede liberar ni destruir recursos.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Overriding the Finalize method</source>
          <target state="translated">Invalidación del método Finalize</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should override <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</source>
          <target state="translated">Debe invalidar <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> para una clase que usa recursos no administrados, como identificadores de archivo o las conexiones de base de datos que deben liberarse cuando se descarta el objeto administrado que se usa durante la recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You shouldn't implement a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for managed objects because the garbage collector releases managed resources automatically.</source>
          <target state="translated">No debe implementar un <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método para objetos administrados, porque el recolector de elementos no utilizados libera los recursos administrados automáticamente.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> el objeto está disponible que contiene el recurso no administrado, la alternativa recomendada es implementar el patrón de dispose con un controlador seguro y no reemplazar <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see <bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept> section.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>alternativa SafeHandle el<ept id="p1">](#SafeHandle)</ept> sección.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method does nothing by default, but you should override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> only if necessary, and only to release unmanaged resources.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> método no hace nada de forma predeterminada, pero se debe invalidar <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> solo si es necesario y solo para liberar recursos no administrados.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</source>
          <target state="translated">Reclamar memoria suele tardar mucho más tiempo si se ejecuta una operación de finalización, porque requiere al menos dos recolecciones de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In addition, you should override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for reference types only.</source>
          <target state="translated">Además, debe invalidar el <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> solo tipos de método como referencia.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The common language runtime only finalizes reference types.</source>
          <target state="translated">Common language runtime finaliza solo los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It ignores finalizers on value types.</source>
          <target state="translated">Omite los finalizadores en tipos de valor.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The scope of the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">El ámbito de la <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> método es <ph id="ph2">`protected`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should maintain this limited scope when you override the method in your class.</source>
          <target state="translated">Mantenga este ámbito limitado cuando reemplace el método en su clase.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>By keeping a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method protected, you prevent users of your application from calling an object's <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method directly.</source>
          <target state="translated">Manteniendo un <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método protegido, los usuarios de la aplicación de la llamada a un objeto <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> método directamente.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Every implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> in a derived type must call its base type's implementation of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">Todas las implementaciones de <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> en un tipo derivado debe llamar a la implementación de su tipo base de <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is the only case in which application code is allowed to call <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">Este es el único caso en la aplicación que se puede llamar a código <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>An object's <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method shouldn't call a method on any objects other than that of its base class.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método no debe llamar a un método en cualquier objeto que no sean de su clase base.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</source>
          <target state="translated">El motivo es que los otros objetos a los que se llama podrían ser recolectados al mismo tiempo que el objeto que llama, por ejemplo, en el caso de un cierre de Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The C# compiler does not allow you to override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">El compilador de C# no permite invalidar el <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead, you provide a finalizer by implementing a <bpt id="p1">[</bpt>destructor<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept> for your class.</source>
          <target state="translated">En su lugar, proporciona un finalizador implementando un <bpt id="p1">[</bpt>destructor<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept> para la clase.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>A C# destructor automatically calls the destructor of its base class.</source>
          <target state="translated">Un destructor de C# llama automáticamente al destructor de su clase base.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Visual C++ also provides its own syntax for implementing the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Visual C++ también proporciona su propia sintaxis para implementar el <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see the "Destructors and finalizers" section of <bpt id="p1">[</bpt>How to: Define and Consume Classes and Structs (C++/CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>.</source>
          <target state="translated">Para obtener más información, vea la sección "Destructores y finalizadores" de <bpt id="p1">[</bpt>Cómo: definir y utilizar clases y Structs (C++ / CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</source>
          <target state="translated">Dado que la colección de elementos no utilizados es no determinista, no conoce con precisión cuando el recolector de elementos no utilizados realiza finalización.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To release resources immediately, you can also choose to implement the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> and the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Para liberar recursos inmediatamente, también puede elegir implementar la <bpt id="p1">[</bpt>patrón de dispose<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> y <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method to free unmanaged resources in the event that the <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementación se puede llamar a los consumidores de la clase para liberar recursos no administrados, y puede usar el <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> método para liberar recursos no administrados en caso de que el <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> no se llama el método.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> puede realizar casi cualquier acción, como el restablecimiento de un objeto (es decir, hacer que el objeto accesible nuevo) después de que se ha limpiado durante la recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>However, the object can only be resurrected once; <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> cannot be called on resurrected objects during garbage collection.</source>
          <target state="translated">Sin embargo, el objeto sólo puede restablecerse una vez; <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> no puede llamarse en objetos restablecidos durante la recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>There is one action that your implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> should never take: it should never throw an exception.</source>
          <target state="translated">Hay una acción que la implementación de <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> nunca debe realizar: jamás deberá producir una excepción.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If any exceptions thrown by methods called from the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method are unhandled by the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the runtime assumes that the <ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph> method returned and continues to call the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods of other objects.</source>
          <target state="translated">Si llama a las excepciones producidas por los métodos de la <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> son no controlada por el método por el <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> método, el tiempo de ejecución supone que la <ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph> método devuelto y continúa llamar a la <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> métodos de otros objetos.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The SafeHandle alternative</source>
          <target state="translated">La alternativa SafeHandle</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> and <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> terminate the finalizer.</source>
          <target state="translated">Crear los finalizadores confiables a menudo es difícil, porque no se puede realizar suposiciones sobre el estado de la aplicación y que excepciones no controladas de sistema como <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> y <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> finalizar el finalizador.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</source>
          <target state="translated">En lugar de implementar un finalizador de la clase para liberar recursos no administrados, puede usar un objeto que se deriva de la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph> clase para encapsular los recursos no administrados y, a continuación, implementar el patrón de dispose sin un finalizador.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The .NET Framework provides the following classes in the <ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph> namespace that are derived from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</source>
          <target state="translated">.NET Framework proporciona las siguientes clases en el <ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph> espacio de nombres que se derivan de <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> is a wrapper class for a file handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> es una clase contenedora para un identificador de archivo.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> is a wrapper class for memory-mapped file handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> es una clase contenedora para los identificadores de archivo asignado a memoria.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> is a wrapper class for a pointer to a block of unmanaged memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> es una clase contenedora para un puntero a un bloque de memoria no administrada.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> are wrapper classes for cryptographic handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, y <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> son clases de contenedor para los identificadores del cifrado.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> is a wrapper class for pipe handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> es una clase contenedora para los identificadores de canalización.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> is a wrapper class for a handle to a registry key.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> es una clase contenedora para un identificador de una clave del registro.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> is a wrapper class for a wait handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> es una clase contenedora para un identificador de espera.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> with safe handles instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se usa el <bpt id="p1">[</bpt>patrón de dispose<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> con controladores seguros en lugar de reemplazar el <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It defines a <ph id="ph1">`FileAssociation`</ph> class that wraps registry information about the application that handles files with a particular file extension.</source>
          <target state="translated">Define un <ph id="ph1">`FileAssociation`</ph> clase que contiene información de registro de la aplicación que trata los archivos con una extensión de archivo en particular.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The two registry handles returned as <ph id="ph1">`out`</ph> parameters by Windows <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept> function calls are passed to the <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> constructor.</source>
          <target state="translated">Los identificadores de dos registro formando <ph id="ph1">`out`</ph> parámetros por Windows <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept> llamadas a funciones se pasan a la <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The type's protected <ph id="ph1">`Dispose`</ph> method then calls the <ph id="ph2">`SafeRegistryHandle.Dispose`</ph> method  to free these two handles.</source>
          <target state="translated">El tipo del protege <ph id="ph1">`Dispose`</ph> método, a continuación, llama el <ph id="ph2">`SafeRegistryHandle.Dispose`</ph> método para liberar estos dos puntos de control.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example verifies that the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is called when an object that overrides <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> is destroyed.</source>
          <target state="translated">En el ejemplo siguiente se comprueba que la <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método se llama cuando un objeto que invalida <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> se destruye.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Note that, in a production application, the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method would be overridden to release unmanaged resources held by the object.</source>
          <target state="translated">Tenga en cuenta que, en una aplicación de producción, el <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> se reemplazaría el método para liberar recursos no administrados mantenidos por el objeto.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Also note that the C# example provides a destructor instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Tenga en cuenta también que el ejemplo de C# proporciona un destructor en lugar de reemplazar el <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For an additional example that overrides the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obtener un ejemplo adicional que invalida la <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> método, consulte el <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>Serves as the default hash function.</source>
          <target state="translated">Sirve como la función hash predeterminada.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>A hash code for the current object.</source>
          <target state="translated">Código hash para el objeto actual.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> class, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class, or a type derived from the <ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph> class.</source>
          <target state="translated">Un código hash es un valor numérico que se utiliza para insertar e identificar un objeto de una colección basado en hash como el <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> (clase), el <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> clase o un tipo derivado de la <ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method provides this hash code for algorithms that need quick checks of object equality.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> método proporciona este código hash para los algoritmos que necesitan comprobaciones rápidas de igualdad de objetos.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the <bpt id="p1">[</bpt>Hash Function<ept id="p1">](https://en.wikipedia.org/wiki/Hash_function)</ept> entry in Wikipedia.</source>
          <target state="translated">Para obtener información sobre cómo se utilizan los códigos hash en tablas hash y para algunos algoritmos de código hash adicionales, consulte la <bpt id="p1">[</bpt>función Hash<ept id="p1">](https://en.wikipedia.org/wiki/Hash_function)</ept> entrada de Wikipedia.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two objects that are equal return hash codes that are equal.</source>
          <target state="translated">Dos objetos que son los códigos hash devuelto igual que son iguales.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</source>
          <target state="translated">Sin embargo, lo contrario no es cierto: códigos hash igual no conllevan la igualdad de objetos, porque los objetos (iguales) diferentes pueden tener códigos hash idénticos.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Furthermore, the .NET Framework does not guarantee the default implementation of the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</source>
          <target state="translated">Además, .NET Framework no garantiza la implementación predeterminada de la <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> (método) y el valor de este método devuelve pueden diferir entre versiones de .NET Framework y las plataformas, como las plataformas de 32 bits y 64 bits.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</source>
          <target state="translated">Por estos motivos, no use la implementación predeterminada de este método como un identificador de objeto único para fines de hash.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two consequences follow from this:</source>
          <target state="translated">Siguen dos consecuencias de esto:</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should not assume that equal hash codes imply object equality.</source>
          <target state="translated">No se debe suponer que los códigos hash igual implican igualdad de objetos.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</source>
          <target state="translated">Nunca debería conservar o utilizar un código hash fuera del dominio de aplicación en el que se creó, porque el mismo objeto puede hash entre plataformas, procesos y dominios de aplicación.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</source>
          <target state="translated">Un código hash está destinado a una inserción y búsqueda en las colecciones que se basan en una tabla hash.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is not a permanent value.</source>
          <target state="translated">Un código hash no es un valor permanente.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For this reason:</source>
          <target state="translated">Por esta razón:</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not serialize hash code values or store them in databases.</source>
          <target state="translated">No serializar los valores de código hash o almacenarlos en las bases de datos.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code as the key to retrieve an object from a keyed collection.</source>
          <target state="translated">No utilice el código hash como clave para recuperar un objeto de una colección con clave.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not send hash codes across application domains or processes.</source>
          <target state="translated">No se envían códigos hash a través de procesos o dominios de aplicación.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In some cases, hash codes may be computed on a per-process or per-application domain basis.</source>
          <target state="translated">En algunos casos, se pueden calcular los códigos hash de forma dominio por proceso o por aplicación.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
          <target state="translated">No utilice el código hash en lugar de un valor devuelto por una función hash criptográfica si necesita un hash criptográficamente seguro.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Para valores hash criptográficos, utilice una clase derivada de la <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not test for equality of hash codes to determine whether two objects are equal.</source>
          <target state="translated">No comprobar la igualdad de los códigos hash para determinar si dos objetos son iguales.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>(Unequal objects can have identical hash codes.) To test for equality, call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method.</source>
          <target state="translated">(Objetos distintos pueden tener códigos hash idénticos). Para comprobar la igualdad, llame a la <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method can be overridden by a derived type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> método puede reemplazarse por un tipo derivado.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> is not overridden, hash codes for reference types are computed by calling the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class, which computes a hash code based on an object's reference; for more information, see <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> es no se reemplaza, códigos hash para tipos de referencia se calculan mediante una llamada a la <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> método de la clase base, que calcula un código hash basado en la referencia de un objeto; para obtener más información, consulte <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, two objects for which the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> have identical hash codes.</source>
          <target state="translated">En otras palabras, dos objetos para los que el <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método <ph id="ph2">`true`</ph> tienen códigos hash idénticos.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If value types do not override <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</source>
          <target state="translated">Si los tipos de valor no invalidar <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, el <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> método de la clase base utiliza la reflexión para calcular el código hash basado en los valores de los campos del tipo.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, value types whose fields have equal values have equal hash codes.</source>
          <target state="translated">En otras palabras, cuyos campos tienen los mismos valores de tipos de valor tienen códigos hash igual.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information about overriding <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, see the "Notes to Inheritors" section.</source>
          <target state="translated">Para obtener más información sobre cómo invalidar <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, vea la sección "Notas para los herederos".</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you override the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, you should also override <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>, and vice versa.</source>
          <target state="translated">Si invalida el <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> método, también debe invalidar <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>y viceversa.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If your overridden <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when two objects are tested for equality, your overridden <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method must return the same value for the two objects.</source>
          <target state="translated">Si su invalidado <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> método <ph id="ph2">`true`</ph> cuando dos objetos se comprueban si hay igualdad, su invalidada <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> método debe devolver el mismo valor para los dos objetos.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If an object that is used as a key in a hash table does not provide a useful implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, you can specify a hash code provider by supplying an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> implementation to one of the overloads of the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> class constructor.</source>
          <target state="translated">Si un objeto que se utiliza como clave en una tabla hash no proporciona una implementación útil de <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, puede especificar un proveedor de código hash proporcionando un <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> implementación a una de las sobrecargas de los <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Notas de la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> método en una clase en el <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, proporciona el comportamiento predeterminado para las clases que no se invalidan <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Esto forma parte de la compatibilidad que .NET Framework proporciona para la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (consulte <bpt id="p1">[</bpt>.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement a <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Las clases en el <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> no heredar <ph id="ph2">&lt;xref:System.Object&gt;</ph>y actualmente no se implementa un <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">Sin embargo, parece que tienen <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, y <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> las clases que se escriben en C# o Visual Basic pueden invalidar la <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type is to simply return that value.</source>
          <target state="translated">Una de las maneras más sencillas para calcular un código hash para un valor numérico que tiene la misma o a un intervalo más pequeño que el <ph id="ph1">&lt;xref:System.Int32&gt;</ph> tipo es simplemente devolver ese valor.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows such an implementation for a <ph id="ph1">`Number`</ph> structure.</source>
          <target state="translated">En el ejemplo siguiente se muestra este tipo de implementación para una <ph id="ph1">`Number`</ph> estructura.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Frequently, a type has multiple data fields that can participate in generating the hash code.</source>
          <target state="translated">Con frecuencia, un tipo tiene varios campos de datos que pueden participar en la generación del código hash.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One way to generate a hash code is to combine these fields using an <ph id="ph1">`XOR (eXclusive OR)`</ph> operation, as shown in the following example.</source>
          <target state="translated">Una manera de generar un código hash consiste en combinar estos campos utilizando una <ph id="ph1">`XOR (eXclusive OR)`</ph> operación, tal y como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</source>
          <target state="translated">El ejemplo anterior devuelve el mismo código hash de (n1, n2) y (n2, n1) por lo que puede generar más colisiones de deseable.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A number of solutions are available so that hash codes in these cases are not identical.</source>
          <target state="translated">Un número de soluciones está disponible para que los códigos hash en estos casos no son idénticos.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One is to return the hash code of a <ph id="ph1">`Tuple`</ph> object that reflects the order of each field.</source>
          <target state="translated">Una consiste en devolver el código hash de un <ph id="ph1">`Tuple`</ph> objeto que refleja el orden de cada campo.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows a possible implementation that uses the <ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se muestra una posible implementación que usa el <ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note, though, that the performance overhead of instantiating a <ph id="ph1">`Tuple`</ph> object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</source>
          <target state="translated">Sin embargo, tenga en cuenta que la sobrecarga de rendimiento de una instancia un <ph id="ph1">`Tuple`</ph> objeto puede afectar significativamente al rendimiento general de una aplicación que almacena gran cantidad de objetos en las tablas hash.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</source>
          <target state="translated">Una segunda solución alternativa implica la ponderación de los códigos hash individuales mediante su desplazamiento a la izquierda los códigos hash de campos sucesivas por dos o más bits.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</source>
          <target state="translated">En condiciones óptimas, en lugar de descartarse, bits desplazados más allá de 31 bits se deben ajustar alrededor en lugar de descartar.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</source>
          <target state="translated">Puesto que se descartan los bits por los operadores de desplazamiento a la izquierda en C# y Visual Basic, esto requiere la creación de un método de ajuste de desplazamiento a la izquierda similar al siguiente:</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example then uses this shift-and-wrap method to compute the hash code of the <ph id="ph1">`Point`</ph> structure used in the previous examples.</source>
          <target state="translated">En el ejemplo siguiente se utiliza, a continuación, este método de ajuste de desplazamiento para calcular el código hash de la <ph id="ph1">`Point`</ph> estructura utilizada en los ejemplos anteriores.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</source>
          <target state="translated">Una función hash se utiliza para generar rápidamente un número (código hash) que corresponde al valor de un objeto.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</source>
          <target state="translated">Las funciones hash suelen ser están para cada tipo y, de unicidad, deben utilizar al menos uno de los campos de instancia como entrada.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash codes should not be computed by using the values of static fields.</source>
          <target state="translated">No se deben calcular códigos hash mediante el uso de los valores de los campos estáticos.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For classes derived from <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, the <ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph> method can delegate to the base class <ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> implementation only if the derived class defines equality to be reference equality.</source>
          <target state="translated">Para las clases derivadas de <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, <ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph> puede delegar el método a la clase base <ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> implementación sólo si la clase derivada define la igualdad para que sea la igualdad de referencia.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The default implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for reference types returns a hash code that is equivalent to the one returned by the <ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph> method.</source>
          <target state="translated">La implementación predeterminada de <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> para referencia tipos devuelve un código hash que es equivalente a la devuelta por la <ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for immutable reference types.</source>
          <target state="translated">Puede invalidar <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> para tipos de referencia inmutable.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In general, for mutable reference types, you should override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> only if:</source>
          <target state="translated">En general, para los tipos de referencias mutables, debe invalidar <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> solo si:</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can compute the hash code from fields that are not mutable; or</source>
          <target state="translated">Puede calcular el código hash de los campos que no son mutables; o</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</source>
          <target state="translated">Puede asegurarse de que el código hash de un objeto mutable no cambia y el objeto se encuentra en una colección que se basa en el código hash.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Otherwise, you might think that the mutable object is lost in the hash table.</source>
          <target state="translated">En caso contrario, puede que piense que se ha perdido el objeto mutable en la tabla hash.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you do choose to override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</source>
          <target state="translated">Si elige reemplazar <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> para un tipo de referencia mutable, la documentación debe dejar claro que los usuarios de su tipo no deben modificar los valores de objeto mientras el objeto se almacena en una tabla hash.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For value types, <ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph> provides a default hash code implementation that uses reflection.</source>
          <target state="translated">Para los tipos de valor, <ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph> proporciona una implementación del código hash predeterminado que usa la reflexión.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should consider overriding it for better performance.</source>
          <target state="translated">Considere la posibilidad de reemplazar para mejorar el rendimiento.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information and examples that compute hash codes in a variety of ways, see the Examples section.</source>
          <target state="translated">Para obtener más información y ejemplos que calculan códigos hash en una variedad de formas, vea la sección ejemplos.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function must have the following properties:</source>
          <target state="translated">Una función hash debe tener las siguientes propiedades:</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If two objects compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for each object must return the same value.</source>
          <target state="translated">Si dos objetos comparan como iguales, la <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> método para cada objeto debe devolver el mismo valor.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, if two objects do not compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> methods for the two objects do not have to return different values.</source>
          <target state="translated">Sin embargo, si dos objetos no compararse como iguales, la <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> métodos para los dos objetos no tienen que devolver valores diferentes.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's <bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept> method.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> método para un objeto de forma coherente debe devolver el mismo código hash como no hay ninguna modificación en el estado del objeto que determina el valor devuelto por el objeto <bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept> método.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</source>
          <target state="translated">Tenga en cuenta que esto es cierto solo para la ejecución actual de una aplicación y que se puede devolver un código hash diferente si se vuelve a ejecutar la aplicación.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</source>
          <target state="translated">Para obtener el mejor rendimiento, una función hash debe generar una distribución uniforme para todas las entradas, incluida la entrada que está agrupado con un alto grado.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</source>
          <target state="translated">Una implicación es que deben dar como resultado pequeñas modificaciones en el estado de objetos grandes modificaciones en el código hash resultante para un mejor rendimiento de la tabla de hash.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions should be inexpensive to compute.</source>
          <target state="translated">Las funciones hash deben ser económicas calcular.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method should not throw exceptions.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> método no debe producir excepciones.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For example, the implementation of the <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> method provided by the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> class returns identical hash codes for identical string values.</source>
          <target state="translated">Por ejemplo, la implementación de la <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> método proporcionado por el <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> clase devuelve códigos hash idénticos para valores de cadena idénticos.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Therefore, two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects return the same hash code if they represent the same string value.</source>
          <target state="translated">Por lo tanto, dos <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objetos devuelven el mismo código hash si representan el mismo valor de cadena.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</source>
          <target state="translated">Además, el método utiliza todos los caracteres en la cadena para generar la salida con una distribución aleatoria razonable, incluso cuando la entrada está en clúster en determinados intervalos (por ejemplo, muchos usuarios podrían tener cadenas que contienen sólo los 128 caracteres ASCII inferiores, aunque una cadena puede contener cualquiera de los 65.535 caracteres Unicode).</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</source>
          <target state="translated">Proporciona una función hash adecuada en una clase puede afectar significativamente al rendimiento de la adición de esos objetos en una tabla hash.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</source>
          <target state="translated">En una tabla hash con claves que proporcionan una buena implementación de una función hash, busca un elemento tiene tiempo constante (por ejemplo, una operación o (1)).</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of items in the hash table).</source>
          <target state="translated">En una tabla hash con una implementación inadecuada de una función hash, el rendimiento de una búsqueda depende del número de elementos de la tabla hash (por ejemplo, una O (<ph id="ph1">`n`</ph>) operación, donde <ph id="ph2">`n`</ph> es el número de elementos de la tabla hash).</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</source>
          <target state="translated">Un usuario malintencionado puede escribir datos que aumentan el número de conflictos, que puede reducir significativamente el rendimiento de las aplicaciones que dependen de las tablas hash, en las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When hash functions produce frequent collisions.</source>
          <target state="translated">Cuando las funciones hash producen colisiones frecuentes.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</source>
          <target state="translated">Cuando una gran proporción de objetos en una tabla hash generar códigos hash que son iguales o aproximadamente igual entre sí.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When users input the data from which the hash code is computed.</source>
          <target state="translated">Cuando los usuarios los datos desde el que se calcula el código hash de entrada.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Derived classes that override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> must also override <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> to guarantee that two objects considered equal have the same hash code; otherwise, the <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> type might not work correctly.</source>
          <target state="translated">Las clases derivadas que invalidan <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> también debe invalidar <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> para garantizar que dos objetos considerados iguales tengan el mismo código hash; en caso contrario, el <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> tipo no funcionen correctamente.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the current instance.</source>
          <target state="translated">Obtiene el <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de la instancia actual.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>The exact runtime type of the current instance.</source>
          <target state="translated">El tipo en tiempo de ejecución exacto de la instancia actual.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Because <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> is the base class for all types in the .NET Framework type system, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be used to return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects that represent all .NET Framework types.</source>
          <target state="translated">Dado que <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> es la clase base para todos los tipos en el sistema de tipos de .NET Framework, el <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> método se puede utilizar para devolver <ph id="ph3">&lt;xref:System.Type&gt;</ph> objetos que representan todos los tipos de .NET Framework.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The .NET Framework recognizes the following five categories of types:</source>
          <target state="translated">.NET Framework reconoce las cinco categorías de tipos siguientes:</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Classes, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>,</source>
          <target state="translated">Las clases, que se derivan de <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>,</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Value types, which are derived from <ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Tipos de valor, que derivan de <ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Interfaces, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> starting with the .NET Framework 2.0.</source>
          <target state="translated">Interfaces, que se derivan de <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> a partir de .NET Framework 2.0.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Enumerations, which are derived from <ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Enumeraciones, que se derivan de <ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Delegates, which are derived from <ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Delegados, lo que se derivan de <ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For two objects <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph> that have identical runtime types, <ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Para dos objetos <ph id="ph1">`x`</ph> y <ph id="ph2">`y`</ph> que tienen tipos idénticos en tiempo de ejecución, <ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph> devuelve <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method to determine whether one numeric value is the same type as two other numeric values.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> método con el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método para determinar si un valor numérico es el mismo tipo que los otros dos valores numéricos.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</source>
          <target state="translated">Para determinar si un objeto es un tipo específico, puede usar la palabra clave de comparación de tipo de su lenguaje o construir.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For example, you can use the <ph id="ph1">`TypeOf…Is`</ph> construct in Visual Basic or the <ph id="ph2">`is`</ph> keyword in C#.</source>
          <target state="translated">Por ejemplo, puede usar el <ph id="ph1">`TypeOf…Is`</ph> construir en Visual Basic o <ph id="ph2">`is`</ph> palabra clave de C#.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method is inherited by all types that derive from <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> método es heredado por todos los tipos que derivan de <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>This means that, in addition to using your own language's comparison keyword, you can use the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine the type of a particular object, as the following example shows.</source>
          <target state="translated">Esto significa que, además de utilizar la palabra clave de comparación de su propio lenguaje, puede utilizar el <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> método para determinar el tipo de un objeto determinado, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object exposes the metadata associated with the class of the current <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto expone los metadatos asociados a la clase del elemento actual <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following code example demonstrates that <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> returns the runtime type of the current instance.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra que <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> devuelve el tipo en tiempo de ejecución de la instancia actual.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>Creates a shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Crea una copia superficial del <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>A shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Copia superficial del <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> método crea una copia superficial, cree un nuevo objeto y, a continuación, copiar los campos no estáticos del objeto actual en el nuevo objeto.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">Si un campo es un tipo de valor, se realiza una copia bit a bit del campo.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</source>
          <target state="translated">Si un campo es un tipo de referencia, la referencia se copia, pero el objeto que se hace referencia es no; por lo tanto, el objeto original y su clon hacen referencia al mismo objeto.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</source>
          <target state="translated">Por ejemplo, considere un objeto denominado X que hace referencia a objetos A y B. el objeto B, a su vez, el objeto references C. Una copia superficial de X crea nuevo objeto X2 que también hace referencia a objetos A y B. En contraste, una copia en profundidad de X crea un nuevo objeto X2 que hace referencia a los nuevos objetos A2 y B2, que son copias de A y B. B2, a su vez, hace referencia al nuevo objeto C2, que es una copia de C. En el ejemplo se ilustra la diferencia entre un superficial y una operación de copia en profundidad.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method does not meet your needs.</source>
          <target state="translated">Hay muchas formas para implementar una operación de copia en profundidad si realiza la operación de copia superficial del <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> método no satisfacen sus necesidades.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>These include the following:</source>
          <target state="translated">Entre ellas se incluyen las siguientes:</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</source>
          <target state="translated">Llamar a un constructor de clase del objeto que se va a copiar para crear un segundo objeto con valores de propiedad que se toma del primer objeto.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>This assumes that the values of an object are entirely defined by its class constructor.</source>
          <target state="translated">Se supone que los valores de un objeto completamente se definen mediante su constructor de clase.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> método para crear una copia superficial de un objeto y, a continuación, asignar nuevos objetos cuyos valores son los mismos que el objeto original a las propiedades o campos cuyos valores son tipos de referencia.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">`DeepCopy`</ph> method in the example illustrates this approach.</source>
          <target state="translated">El <ph id="ph1">`DeepCopy`</ph> método en el ejemplo muestra este enfoque.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</source>
          <target state="translated">Serializar el objeto para que sea profundo copiado y, a continuación, restaurar los datos serializados en una variable de objeto diferente.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Use reflection with recursion to perform the deep copy operation.</source>
          <target state="translated">Usar la reflexión con la repetición para realizar la operación de copia en profundidad.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It defines a <ph id="ph1">`ShallowCopy`</ph> method that calls the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to perform a shallow copy operation on a <ph id="ph3">`Person`</ph> object.</source>
          <target state="translated">Define un <ph id="ph1">`ShallowCopy`</ph> método al que llama el <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> método para realizar una operación de copia superficial de un <ph id="ph3">`Person`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It also defines a <ph id="ph1">`DeepCopy`</ph> method that performs a deep copy operation on a <ph id="ph2">`Person`</ph> object.</source>
          <target state="translated">También define un <ph id="ph1">`DeepCopy`</ph> método que realiza una operación de copia en profundidad en un <ph id="ph2">`Person`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>In this example, the <ph id="ph1">`Person.IdInfo`</ph> property returns an <ph id="ph2">`IdInfo`</ph> object.</source>
          <target state="translated">En este ejemplo, el <ph id="ph1">`Person.IdInfo`</ph> propiedad devuelve un <ph id="ph2">`IdInfo`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As the output from the example shows, when a <ph id="ph1">`Person`</ph> object is cloned by calling the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method, the cloned <ph id="ph3">`Person`</ph> object is an independent copy of the original object, except that they share the same <ph id="ph4">`Person.IdInfo`</ph> object reference.</source>
          <target state="translated">Como la salida se muestra en el ejemplo, cuando un <ph id="ph1">`Person`</ph> objeto se clona mediante una llamada a la <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> /método siguiente, clonado <ph id="ph3">`Person`</ph> objeto es una copia independiente del objeto original, salvo que comparten el mismo <ph id="ph4">`Person.IdInfo`</ph> referencia de objeto.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As a result, modifying the clone's <ph id="ph1">`Person.IdInfo`</ph> property changes the original object's <ph id="ph2">`Person.IdInfo`</ph> property.</source>
          <target state="translated">Como resultado, modificar el clon <ph id="ph1">`Person.IdInfo`</ph> cambios en las propiedades del objeto original <ph id="ph2">`Person.IdInfo`</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>On the other hand, when a deep copy operation is performed, the cloned <ph id="ph1">`Person`</ph> object, including its <ph id="ph2">`Person.IdInfo`</ph> property, can be modified without affecting the original object.</source>
          <target state="translated">Por otro lado, cuando se realiza una operación de copia en profundidad, clonado <ph id="ph1">`Person`</ph> objeto, incluido su <ph id="ph2">`Person.IdInfo`</ph> propiedad, se puede modificar sin afectar al objeto original.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">Primer objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The second object  to compare.</source>
          <target state="translated">Segundo objeto que se va a comparar.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are the same instance.</source>
          <target state="translated">Determina si las instancias de <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificadas son la misma instancia.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="objA" /&gt;</ph> is the same instance as <ph id="ph3">&lt;paramref name="objB" /&gt;</ph> or if both are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="objA" /&gt;</ph> es la misma instancia que <ph id="ph3">&lt;paramref name="objB" /&gt;</ph>, o si ambos son <bpt id="p1">**</bpt>null<ept id="p1">**</ept>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method and the equality operator, the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method cannot be overridden.</source>
          <target state="translated">A diferencia de la <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> método y el operador de igualdad, el <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> no se puede invalidar el método.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Because of this, if you want to test two object references for equality and you are unsure about the implementation of the <ph id="ph1">`Equals`</ph> method, you can call the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Por este motivo, si desea probar dos referencias de igualdad de objetos y no está seguro acerca de la implementación de la <ph id="ph1">`Equals`</ph> método, se puede llamar a la <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, the return value of the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method may appear to be anomalous in these two scenarios:</source>
          <target state="translated">Sin embargo, el valor devuelto de la <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método puede aparecer anómalos en los dos escenarios:</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing value types.</source>
          <target state="translated">Al comparar los tipos de valor.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are value types, they are boxed before they are passed to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`objA`</ph> y <ph id="ph2">`objB`</ph> son tipos de valor, se han convertido antes de pasarlos a la <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>This means that if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> represent the same instance of a value type, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method nevertheless returns <ph id="ph4">`false`</ph>, as the following example shows.</source>
          <target state="translated">Esto significa que si ambos <ph id="ph1">`objA`</ph> y <ph id="ph2">`objB`</ph> representan la misma instancia de un tipo de valor, el <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> , sin embargo, devuelve el método <ph id="ph4">`false`</ph>, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For information on boxing value types, see <bpt id="p1">[</bpt>Boxing and Unboxing<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.</source>
          <target state="translated">Para obtener información sobre los tipos de valor de conversión boxing, vea <bpt id="p1">[</bpt>conversión Boxing y Unboxing<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing strings.</source>
          <target state="translated">Cuando se comparan cadenas.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are strings, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph4">`true`</ph> if the string is interned.</source>
          <target state="translated">Si <ph id="ph1">`objA`</ph> y <ph id="ph2">`objB`</ph> son cadenas, la <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> método <ph id="ph4">`true`</ph> si la cadena se aplica el método Intern.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>It does not perform a test for value equality.</source>
          <target state="translated">No lleva a cabo una prueba de igualdad de valores.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>In the following example, <ph id="ph1">`s1`</ph> and <ph id="ph2">`s2`</ph> are equal because they are two instances of a single interned string.</source>
          <target state="translated">En el ejemplo siguiente, <ph id="ph1">`s1`</ph> y <ph id="ph2">`s2`</ph> son iguales porque son dos instancias de una sola cadena aplicado el método Intern.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, <ph id="ph1">`s3`</ph> and <ph id="ph2">`s4`</ph> are not equal, because although they are have identical string values, that string is not interned.</source>
          <target state="translated">Sin embargo, <ph id="ph1">`s3`</ph> y <ph id="ph2">`s4`</ph> no son iguales, porque aunque tienen valores de cadena idéntica, esa cadena no es aplica el método Intern.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For more information about string interning, see <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obtener más información acerca de la asignación al grupo interno de cadena, vea <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> to determine if two objects are the same instance.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> para determinar si dos objetos son la misma instancia.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>Returns a string that represents the current object.</source>
          <target state="translated">Devuelve una cadena que representa el objeto actual.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>A string that represents the current object.</source>
          <target state="translated">Una cadena que representa el objeto actual.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> is the major formatting method in the .NET Framework.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> es el principal formato método en .NET Framework.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It converts an object to its string representation so that it is suitable for display.</source>
          <target state="translated">Convierte un objeto en su representación de cadena para que sea adecuada para su presentación.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>(For information about formatting support in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.) Default implementations of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method return the fully qualified name of the object's type.</source>
          <target state="translated">(Para obtener información acerca del formato de soporte técnico de .NET Framework, vea <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.) Las implementaciones de predeterminadas el <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método devuelve el nombre completo del tipo de objeto.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You may have reached this page by following the link from the member list of another type.</source>
          <target state="translated">Podría haber alcanzado esta página siguiendo el vínculo de la lista de miembros de otro tipo.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>That is because that type does not override <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La razón es que ese tipo no invalidar <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, it inherits the functionality of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En su lugar, hereda la funcionalidad de la <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types frequently override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide a more suitable string representation of a particular type.</source>
          <target state="translated">Los tipos con frecuencia invalidar la <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método para proporcionar una representación de cadena más adecuada de un tipo determinado.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types also frequently overload the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide support for format strings or culture-sensitive formatting.</source>
          <target state="translated">También con frecuencia, los tipos de sobrecargar la <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método para proporcionar compatibilidad con cadenas de formato o el formato dependiente de la referencia cultural.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In this section:</source>
          <target state="translated">En esta sección:</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>The default Object.ToString() method<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>El método predeterminado de Object.ToString)<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overriding the Object.ToString() method<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Invalidación del método Object.ToString)<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overloading the ToString method<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Sobrecarga del método ToString<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Extending the Object.ToString method<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Extender el método Object.ToString<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Notes for the Windows Runtime<ept id="p1">](#WinRT)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Notas para el tiempo de ejecución de Windows<ept id="p1">](#WinRT)</ept></target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default Object.ToString() method</source>
          <target state="translated">El método predeterminado de Object.ToString)</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default implementation of the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the fully qualified name of the type of the <ph id="ph2">&lt;xref:System.Object&gt;</ph>, as the following example shows.</source>
          <target state="translated">La implementación predeterminada de la <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> método devuelve el nombre completo del tipo de la <ph id="ph2">&lt;xref:System.Object&gt;</ph>, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because <ph id="ph1">&lt;xref:System.Object&gt;</ph> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated">Dado que <ph id="ph1">&lt;xref:System.Object&gt;</ph> es la clase base de todos los tipos de referencia en .NET Framework, este comportamiento es heredada por los tipos de referencia que no invalidan los <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example illustrates this.</source>
          <target state="translated">Esto se ilustra en el siguiente ejemplo:</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines a class named <ph id="ph1">`Object1`</ph> that accepts the default implementation of all <ph id="ph2">&lt;xref:System.Object&gt;</ph> members.</source>
          <target state="translated">Se define una clase denominada <ph id="ph1">`Object1`</ph> que acepta la implementación predeterminada de todos los <ph id="ph2">&lt;xref:System.Object&gt;</ph> miembros.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the object's fully qualified type name.</source>
          <target state="translated">Su <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> método devuelve el nombre de tipo completo del objeto.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overriding the Object.ToString() method</source>
          <target state="translated">Invalidación del método Object.ToString)</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types commonly override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return a string that represents the object instance.</source>
          <target state="translated">Los tipos normalmente invalidar la <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método para devolver una cadena que representa la instancia del objeto.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, the base types such as <ph id="ph1">&lt;xref:System.Char&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and <ph id="ph3">&lt;xref:System.String&gt;</ph> provide <ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph> implementations that return the string form of the value that the object represents.</source>
          <target state="translated">Por ejemplo, los tipos base como <ph id="ph1">&lt;xref:System.Char&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, y <ph id="ph3">&lt;xref:System.String&gt;</ph> proporcionar <ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph> las implementaciones que devuelven el formato de cadena del valor que representa el objeto.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a class, <ph id="ph1">`Object2`</ph>, that overrides the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method to return the type name along with its value.</source>
          <target state="translated">En el ejemplo siguiente se define una clase, <ph id="ph1">`Object2`</ph>, que invalida el <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> método para devolver el nombre de tipo junto con su valor.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following table lists the type categories in the .NET Framework and indicates whether or not they override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En la tabla siguiente enumera las categorías de tipos de .NET Framework e indica si se permite o no invalidan los <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Type category</source>
          <target state="translated">Categoría de tipo</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides Object.ToString()</source>
          <target state="translated">Invalida Object.ToString)</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Behavior</source>
          <target state="translated">Comportamiento</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Class</source>
          <target state="translated">Clase</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/D</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/D</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Structure</source>
          <target state="translated">Estructura</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">Sí (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Same as Object.ToString()</source>
          <target state="translated">Igual que Object.ToString)</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Enumeration</source>
          <target state="translated">Enumeración</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">Sí (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The member name</source>
          <target state="translated">El nombre de miembro</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Interface</source>
          <target state="translated">Interfaz</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/D</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/D</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>See the Notes to Inheritors section for additional information on overriding <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">Vea la sección Notas para los herederos para obtener información adicional sobre cómo reemplazar <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overloading the ToString method</source>
          <target state="translated">Sobrecarga del método ToString</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In addition to overriding the parameterless <ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph> method, many types overload the <ph id="ph2">`ToString`</ph> method to provide versions of the method that accept parameters.</source>
          <target state="translated">Además de reemplazar el método sin parámetros <ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph> sobrecarga del método, muchos tipos el <ph id="ph2">`ToString`</ph> método para proporcionar versiones del método que aceptan parámetros.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</source>
          <target state="translated">Normalmente, esto se hace para proporcionar soporte técnico para aplicar formato a variables y formato dependiente de la referencia cultural.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example overloads the <ph id="ph1">`ToString`</ph> method to return a result string that includes the value of various fields of an <ph id="ph2">`Automobile`</ph> class.</source>
          <target state="translated">El ejemplo siguiente se sobrecarga el <ph id="ph1">`ToString`</ph> método para devolver una cadena de resultado que incluye el valor de varios campos de una <ph id="ph2">`Automobile`</ph> clase.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</source>
          <target state="translated">Define cuatro cadenas de formato: G, que devuelve el nombre del modelo y el año; D., que devuelve el nombre del modelo, el año y el número de puertas; C, que devuelve el nombre del modelo, el año y el número de cilindros; y A, que devuelve una cadena con todos los valores de los cuatro campos.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example calls the overloaded <ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method to display culture-sensitive formatting of a currency value.</source>
          <target state="translated">En el ejemplo siguiente se llama sobrecargado <ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> método para mostrar el formato dependiente de la referencia cultural de un valor de moneda.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For more information on format strings and culture-sensitive formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre las cadenas de formato y el formato dependiente de la referencia cultural, consulte <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by numeric values, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Para las cadenas de formato compatibles con valores numéricos, vea <bpt id="p1">[</bpt>cadenas de formato numérico estándar<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> y <bpt id="p2">[</bpt>cadenas de formato numérico personalizado<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
          <target state="translated">Para las cadenas de formato compatibles con valores de fecha y hora, vea <bpt id="p1">[</bpt>cadenas de formato de hora y fecha estándar<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> y <bpt id="p2">[</bpt>cadenas de formato de hora y fecha personalizada<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Extending the Object.ToString method</source>
          <target state="translated">Extender el método Object.ToString</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because a type inherits the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method, you may find its behavior undesirable and want to change it.</source>
          <target state="translated">Puesto que un tipo hereda el valor predeterminado <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método, puede buscar su comportamiento no deseado y desea cambiarla.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is particularly true of arrays and collection classes.</source>
          <target state="translated">Esto es especialmente cierto de matrices y clases de colección.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>While you may expect the <ph id="ph1">`ToString`</ph> method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</source>
          <target state="translated">Mientras que puede esperar el <ph id="ph1">`ToString`</ph> método de una clase de colección o matriz para mostrar los valores de sus miembros, en su lugar, muestra el nombre de tipo completo del tipo, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You have several options to produce the result string that you'd like.</source>
          <target state="translated">Tiene varias opciones para generar la cadena de resultado que le gustaría.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the type is an array, a collection object, or an object that implements the <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interfaces, you can enumerate its elements by using the <ph id="ph3">`foreach`</ph> statement in C# or the <ph id="ph4">`For Each...Next`</ph> construct in Visual Basic.</source>
          <target state="translated">Si el tipo es una matriz, un objeto de colección o un objeto que implementa el <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> o <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interfaces, puede enumerar sus elementos mediante el uso de la <ph id="ph3">`foreach`</ph> instrucción en C# o la <ph id="ph4">`For Each...Next`</ph> construir en Visual Basic.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the class is not <ph id="ph1">`sealed`</ph> (in C#) or <ph id="ph2">`NotInheritable`</ph> (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method you want to customize.</source>
          <target state="translated">Si la clase no es <ph id="ph1">`sealed`</ph> (en C#) o <ph id="ph2">`NotInheritable`</ph> (en Visual Basic), puede desarrollar una clase contenedora que hereda de la clase base cuyo <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método que desee personalizar.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>At a minimum, this requires that you do the following:</source>
          <target state="translated">Como mínimo, para ello haga lo siguiente:</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implement any necessary constructors.</source>
          <target state="translated">Implementar todos los constructores necesarios.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes do not inherit their base class constructors.</source>
          <target state="translated">Las clases derivadas no heredan sus constructores de clase base.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return the result string that you'd like.</source>
          <target state="translated">Invalidar el <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método para devolver la cadena de resultado que le gustaría.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a wrapper class for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se define una clase contenedora para los <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to display the value of each method of the collection rather than the fully qualified type name.</source>
          <target state="translated">Reemplaza el <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método para mostrar el valor de cada método de la colección en lugar de con el nombre de tipo completo.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Develop an <bpt id="p1">[</bpt>extension method<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept> that returns the result string that you want.</source>
          <target state="translated">Desarrollar un <bpt id="p1">[</bpt>método de extensión<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept> que devuelve la cadena de resultado que desea.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that you can't override the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named <ph id="ph2">`ToString`</ph> that is called in place of the original type's <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated">Tenga en cuenta que no se puede invalidar el valor predeterminado <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método de esta manera (es decir, la clase de extensión (en C#) o el módulo (en Visual Basic) no puede tener un método sin parámetros denominado <ph id="ph2">`ToString`</ph> que se llama en lugar del tipo original <ph id="ph3">`ToString`</ph> método.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You'll have to provide some other name for your parameterless <ph id="ph1">`ToString`</ph> replacement.</source>
          <target state="translated">Tendrá que proporcionar otro nombre para su sin parámetros <ph id="ph1">`ToString`</ph> reemplazo.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines two methods that extend the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class: a parameterless <ph id="ph2">`ToString2`</ph> method, and a <ph id="ph3">`ToString`</ph> method with a <ph id="ph4">&lt;xref:System.String&gt;</ph> parameter that represents a format string.</source>
          <target state="translated">El siguiente ejemplo define dos métodos que amplían la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase: una sin parámetros <ph id="ph2">`ToString2`</ph> (método) y un <ph id="ph3">`ToString`</ph> método con un <ph id="ph4">&lt;xref:System.String&gt;</ph> parámetro que representa una cadena de formato.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Notas de la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> método en una clase en el <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, proporciona el comportamiento predeterminado para las clases que no se invalidan <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Esto forma parte de la compatibilidad que .NET Framework proporciona para la <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (consulte <bpt id="p1">[</bpt>.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and don’t always implement a <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">Las clases en el <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> no heredar <ph id="ph2">&lt;xref:System.Object&gt;</ph>y no debe implementar siempre un <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>However, they always appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</source>
          <target state="translated">Sin embargo, siempre parece que tienen <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, y <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona un comportamiento predeterminado para estos métodos.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, the common language runtime will use <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object before falling back to the default implementation of <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, va a utilizar common language runtime <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> en un <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> objeto antes de usar la implementación predeterminada de <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> las clases que se escriben en C# o Visual Basic pueden invalidar la <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> and the IStringable Interface</source>
          <target state="translated">El <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> y la interfaz de IStringable</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with <ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> includes an <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface whose single method, <bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>, provides basic formatting support comparable to that provided by <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">A partir de <ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> incluye un <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interfaz cuyo único método, <bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>, proporciona compatibilidad básica de formato comparable a la que ofrece <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>To prevent ambiguity, you should not implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on managed types.</source>
          <target state="translated">Para evitar la ambigüedad, no debería implementar <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> en tipos administrados.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">Cuando se llama a los objetos administrados por código nativo o código escrito en lenguajes como JavaScript o C++ / CX, que se presentan al implementar <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The common language runtime will automatically route calls from <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> to <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> in the event <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> is not implemented on the managed object.</source>
          <target state="translated">Common language runtime enrutará automáticamente las llamadas de <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> a <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> en el evento <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> no está implementada en el objeto administrado.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because the common language runtime auto-implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> for all managed types in <ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph> apps, we recommend that you do not provide your own <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation.</source>
          <target state="translated">Dado que common language runtime auto-implementa <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> para todos los tipos en administrados <ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph> aplicaciones, se recomienda que no proporciona su propio <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementación.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implementing <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> may result in unintended behavior when calling <ph id="ph1">`ToString`</ph> from the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, C++/CX, or JavaScript.</source>
          <target state="translated">Implementar <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> puede provocar un comportamiento no deseado al llamar a <ph id="ph1">`ToString`</ph> desde el <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, C++ / CX o JavaScript.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If you do choose to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> in a public managed type that is exported in a <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> component, the following restrictions apply:</source>
          <target state="translated">Si decide implementar <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> en un tipo público administrado que se exporte en un <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> componente, se aplican las restricciones siguientes:</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can define the <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface only in a "class implements" relationship, such as</source>
          <target state="translated">Puede definir la <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> sólo en una relación "la clase implementa", como la interfaz</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in C#, or</source>
          <target state="translated">en C# o</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in Visual Basic.</source>
          <target state="translated">en Visual Basic.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on an interface.</source>
          <target state="translated">No se puede implementar <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> en una interfaz.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot declare a parameter to be of type <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">No se puede declarar un parámetro de tipo <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> cannot be the return type of a method, property, or field.</source>
          <target state="translated"><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> no puede ser el tipo de valor devuelto de un método, propiedad o campo.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot hide your <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation from base classes by using a method definition such as the following:</source>
          <target state="translated">No se puede ocultar la <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementación de las clases base mediante una definición de método como el siguiente:</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, the <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation must always override the base class implementation.</source>
          <target state="translated">En su lugar, el <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementación debe invalidar siempre la implementación de la clase base.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can hide a <ph id="ph1">`ToString`</ph> implementation only by invoking it on a strongly typed class instance.</source>
          <target state="translated">Solo puede ocultar una implementación de <ph id="ph1">`ToString`</ph> invocándola en una instancia de clase fuertemente tipada.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that under a variety of conditions, calls from native code to a managed type that implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> or hides its <bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation can produce unexpected behavior.</source>
          <target state="translated">Tenga en cuenta que en determinadas condiciones, las llamadas desde código nativo a un tipo administrado que implemente <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> u oculta su <bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementación puede generar un comportamiento inesperado.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you implement your own types, you should override the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method to return values that are meaningful for those types.</source>
          <target state="translated">Al implementar sus propios tipos, se debe invalidar el <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> método para devolver valores que son significativos para esos tipos.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes that require more control over formatting than <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> provides can implement the <ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">Las clases derivadas que necesitan más control sobre el formato de <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> proporciona puede implementar la <ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph> method enables you to define format strings that control formatting and to use an <ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph> object that can provide for culture-specific formatting.</source>
          <target state="translated">Su <ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph> método le permite definir cadenas de formato que controlan el formato y usar un <ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph> objeto que puede proporcionar para formato específico de la referencia cultural.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides of the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should follow these guidelines:</source>
          <target state="translated">Invalidaciones de la <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> método debe seguir estas directrices:</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be friendly and readable by humans.</source>
          <target state="translated">La cadena devuelta debe ser legible por los seres humanos y descriptiva.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should uniquely identify the value of the object instance.</source>
          <target state="translated">La cadena devuelta debe identificar de forma exclusiva el valor de la instancia del objeto.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be as short as possible so that it is suitable for display by a debugger.</source>
          <target state="translated">La cadena devuelta debe ser lo más corta posible para que sea adecuada para su presentación por un depurador.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not return <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> or a null string.</source>
          <target state="translated">Su <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> invalidación no debería devolver <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> o una cadena nula.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not throw an exception.</source>
          <target state="translated">Su <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> invalidación no debería iniciar una excepción.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">Si la representación de cadena de una instancia de tiene en cuenta la referencia cultural o se puede aplicar formato de varias maneras, implemente el <ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the returned string includes sensitive information, you should first demand an appropriate permission.</source>
          <target state="translated">Si la cadena devuelta incluye información confidencial, primero debería exigir un permiso adecuado.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</source>
          <target state="translated">Si la demanda es correcta, puede devolver la información confidencial; de lo contrario, debe devolver una cadena que excluye la información confidencial.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should have no observable side effects to avoid complications in debugging.</source>
          <target state="translated">Su <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> reemplazo no debe tener efectos deseados de observable para evitar las complicaciones en la depuración.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, a call to the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should not change the value of instance fields.</source>
          <target state="translated">Por ejemplo, una llamada a la <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> método no debería cambiar el valor de los campos de instancia.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If your type implements a parsing method (or <ph id="ph1">&lt;see langword="Parse" /&gt;</ph> or <ph id="ph2">&lt;see langword="TryParse" /&gt;</ph> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method can be converted to an object instance.</source>
          <target state="translated">Si el tipo implementa un método de análisis (o <ph id="ph1">&lt;see langword="Parse" /&gt;</ph> o <ph id="ph2">&lt;see langword="TryParse" /&gt;</ph> método, un constructor o algún otro método estático que crea una instancia del tipo de una cadena), debe asegurarse de que la cadena devuelta por la <ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph> puede ser (método) convertir en una instancia de objeto.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>