<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="15f433904f15b52fc408db54f7fd65e20a71b739" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174254" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="14eb3-101">Admite todas las clases de la jerarquía de clases de .NET Framework y proporciona servicios de bajo nivel a las clases derivadas.</span>
      <span class="sxs-lookup">
        <span data-stu-id="14eb3-101">Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</span>
      </span>
      <span data-ttu-id="14eb3-102">Se trata de la clase base fundamental de todas las clases de .NET Framework; es la raíz de la jerarquía de tipos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="14eb3-102">This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-103">Idiomas no suelen requieran una clase para declarar la herencia de <xref:System.Object> porque la herencia está implícita.</span><span class="sxs-lookup"><span data-stu-id="14eb3-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="14eb3-104">Dado que se derivan todas las clases de .NET Framework <xref:System.Object>, todos los métodos definidos en la <xref:System.Object> clase está disponible en todos los objetos en el sistema.</span><span class="sxs-lookup"><span data-stu-id="14eb3-104">Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="14eb3-105">Las clases derivadas pueden e invalidar algunos de estos métodos, incluyendo:</span><span class="sxs-lookup"><span data-stu-id="14eb3-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="14eb3-106"><xref:System.Object.Equals%2A> -Admite comparaciones entre objetos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="14eb3-107"><xref:System.Object.Finalize%2A> -Realiza operaciones de limpieza antes de que un objeto sea reclamado automáticamente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="14eb3-108"><xref:System.Object.GetHashCode%2A> -Genera un número correspondiente al valor del objeto que admite el uso de una tabla hash.</span><span class="sxs-lookup"><span data-stu-id="14eb3-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="14eb3-109"><xref:System.Object.ToString%2A> -Crea una cadena de texto legible que describe una instancia de la clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="14eb3-110">Consideraciones sobre el rendimiento</span><span class="sxs-lookup"><span data-stu-id="14eb3-110">Performance Considerations</span></span>  
 <span data-ttu-id="14eb3-111">Si está diseñando una clase, como una colección, que debe administrar cualquier tipo de objeto, puede crear miembros de clase que acepten instancias de la <xref:System.Object> clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="14eb3-112">Sin embargo, el proceso de conversión boxing y unboxing a un tipo implica un costo de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="14eb3-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="14eb3-113">Si conoce que la nueva clase controlará con frecuencia ciertos tipos de valor puede utilizar uno de dos tácticas para minimizar el costo de la conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="14eb3-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="14eb3-114">Crear un método general que acepta un <xref:System.Object> tipo y un conjunto de sobrecargas de método específico del tipo que acepten cada tipo de valor que se espera que la clase controle con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="14eb3-115">Si no existe un método específico del tipo que acepta el tipo de parámetro que realiza la llamada, se produce ninguna conversión boxing y se invoca el método específico del tipo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="14eb3-116">Si no hay ningún argumento de método que coincida con el tipo de parámetro que realiza la llamada, el parámetro es una conversión boxing y se invoca el método general.</span><span class="sxs-lookup"><span data-stu-id="14eb3-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="14eb3-117">Diseñar su tipo y sus miembros para que utilicen genéricos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="14eb3-118">Common language runtime crea un tipo genérico cerrado cuando se crea una instancia de la clase y especificar un argumento de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="14eb3-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="14eb3-119">El método genérico es específico del tipo y se puede invocar sin conversión boxing al parámetro de llamada.</span><span class="sxs-lookup"><span data-stu-id="14eb3-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="14eb3-120">Aunque a veces es necesario desarrollar clases de propósito general que aceptan y devuelven <xref:System.Object> tipos, puede mejorar el rendimiento proporcionando también una clase específica del tipo para controlar un tipo de uso frecuente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="14eb3-121">Por ejemplo, si se proporciona una clase que es específica para establecer y obtener valores booleanos, elimina el costo de aplicar conversiones boxing y unboxing valores booleanos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14eb3-122">En el ejemplo siguiente se define un tipo de punto derivado de la <xref:System.Object> clase y se reemplazan muchos de los métodos virtuales de la <xref:System.Object> clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="14eb3-123">Además, en el ejemplo se muestra cómo llamar a muchos de los métodos estático y métodos de la instancia la <xref:System.Object> clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="14eb3-124">Estático público (<see langword="Shared" /> en Visual Basic) miembros de este tipo son seguros para subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="14eb3-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="14eb3-125">No se garantiza que los miembros de instancia sea seguro para subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="14eb3-125">Instance members are not guaranteed to be thread-safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14eb3-126">Inicializa una nueva instancia de la clase <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-127">Este constructor llama a constructores de clases derivadas, pero también se puede utilizar para crear directamente una instancia de la <xref:System.Object> clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="14eb3-128">Determina si dos instancias de objeto son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-128">Determines whether two object instances are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="14eb3-129">Objeto que se va a comparar con el objeto actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-129">The object to compare with the current object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14eb3-130">Determina si el objeto especificado es igual al objeto actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-130">Determines whether the specified object is equal to the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14eb3-131">Es <see langword="true" /> si el objeto especificado es igual al objeto actual; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-131">
              <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-132">El tipo de comparación entre la instancia actual y la `obj` parámetro depende de si la instancia actual es un tipo de referencia o un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="14eb3-133">Si la instancia actual es un tipo de referencia, el <xref:System.Object.Equals%28System.Object%29> método comprueba la igualdad de referencia y una llamada a la <xref:System.Object.Equals%28System.Object%29> método es equivalente a una llamada a la <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="14eb3-134">Igualdad de referencia significa que las variables de objeto que se comparan hacen referencia al mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="14eb3-135">En el ejemplo siguiente se muestra el resultado de una comparación de este tipo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="14eb3-136">Define un `Person` (clase), que es un tipo de referencia, y llama el `Person` constructor de clase para crear dos instancias de nuevo `Person` objetos, `person1a` y `person2`, que tienen el mismo valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="14eb3-137">También asigna `person1a` a otra variable de objeto, `person1b`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="14eb3-138">Como se muestra en el ejemplo, el salida `person1a` y `person1b` son iguales porque hacen referencia al mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="14eb3-139">Sin embargo, `person1a` y `person2` no son iguales, aunque tienen el mismo valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="14eb3-140">Si la instancia actual es un tipo de valor, la <xref:System.Object.Equals%28System.Object%29> método comprueba la igualdad de valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="14eb3-141">Igualdad de valores significa lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="14eb3-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="14eb3-142">Los dos objetos son del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-142">The two objects are of the same type.</span></span> <span data-ttu-id="14eb3-143">Como se muestra en el ejemplo siguiente, un <xref:System.Byte> objeto que tiene un valor de 12 no es igual a un <xref:System.Int32> objeto que tiene un valor de 12, porque los dos objetos tienen distintos tipos de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="14eb3-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="14eb3-144">Los valores de los campos públicos y privados de los dos objetos son iguales.</span><span class="sxs-lookup"><span data-stu-id="14eb3-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="14eb3-145">En el ejemplo siguiente se comprueba la igualdad de valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-145">The following example tests for value equality.</span></span> <span data-ttu-id="14eb3-146">Define un `Person` estructura, que es un tipo de valor, y llama el `Person` constructor de clase para crear dos instancias de nuevo `Person` objetos, `person1` y `person2`, que tienen el mismo valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="14eb3-147">Como se muestra en el resultado del ejemplo, aunque las dos variables de objeto hacen referencia a objetos diferentes, `person1` y `person2` son iguales porque tienen el mismo valor para la privada `personName` campo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="14eb3-148">Dado que la <xref:System.Object> clase es la clase base para todos los tipos de .NET Framework, el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método proporciona la comparación de igualdad predeterminado para todos los demás tipos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="14eb3-149">Sin embargo, los tipos a menudo invalidar la <xref:System.Object.Equals%2A> método para implementar la igualdad de valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="14eb3-150">Para obtener más información, vea las notas para los autores de llamadas y notas de secciones de los herederos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="14eb3-151">Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="14eb3-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="14eb3-152">Cuando se llama a la <xref:System.Object.Equals%28System.Object%29> sobrecarga del método en una clase de la [!INCLUDE[wrt](~/includes/wrt-md.md)], proporciona el comportamiento predeterminado para las clases que no se invalidan <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="14eb3-153">Esto forma parte de la compatibilidad que .NET Framework proporciona para la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="14eb3-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="14eb3-154">Las clases en el [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.Object>y actualmente no se implementa un <xref:System.Object.Equals%28System.Object%29> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="14eb3-155">Sin embargo, parece que tienen <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, y <xref:System.Object.GetHashCode%2A> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="14eb3-156"> las clases que se escriben en C# o Visual Basic pueden invalidar la <xref:System.Object.Equals%28System.Object%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-156"> classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="14eb3-157">Notas para los llamadores</span><span class="sxs-lookup"><span data-stu-id="14eb3-157">Notes for Callers</span></span>  
 <span data-ttu-id="14eb3-158">Las clases derivadas reemplazan con frecuencia el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método para implementar la igualdad de valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="14eb3-159">Además, los tipos también suelen proporcionan una sobrecarga fuertemente tipada adicional a la `Equals` método, normalmente mediante la implementación de la <xref:System.IEquatable%601> interfaz.</span><span class="sxs-lookup"><span data-stu-id="14eb3-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="14eb3-160">Cuando se llama a la `Equals` método para comprobar la igualdad, debe saber si la instancia actual invalida <xref:System.Object.Equals%2A?displayProperty=nameWithType> y entender cómo una determinada llamada a un `Equals` método se ha resuelto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="14eb3-161">En caso contrario, puede estar realizando una prueba de igualdad que es diferente de los previstos, y el método puede devolver un valor inesperado.</span><span class="sxs-lookup"><span data-stu-id="14eb3-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="14eb3-162">Esto se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-162">The following example provides an illustration.</span></span> <span data-ttu-id="14eb3-163">Crea una instancia de tres <xref:System.Text.StringBuilder> objetos con cadenas idénticas y, a continuación, realiza cuatro llamadas a `Equals` métodos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="14eb3-164">La primera llamada al método devuelve `true`y el rendimiento de tres restantes `false`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="14eb3-165">En el primer caso, fuertemente tipado <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> sobrecarga del método, que comprueba la igualdad de valor, se llama.</span><span class="sxs-lookup"><span data-stu-id="14eb3-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="14eb3-166">Dado que las cadenas se asignan a los dos <xref:System.Text.StringBuilder> objetos son iguales, el método devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="14eb3-167">Sin embargo, <xref:System.Text.StringBuilder> no invalida <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="14eb3-168">Por este motivo, cuando la <xref:System.Text.StringBuilder> objeto se convierte en una <xref:System.Object>, cuando un <xref:System.Text.StringBuilder> instancia se asigna a una variable de tipo <xref:System.Object>y cuándo el <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> se pasa al método dos <xref:System.Text.StringBuilder> objetos, el valor predeterminado <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="14eb3-169">Dado que <xref:System.Text.StringBuilder> es un tipo de referencia, es equivalente a pasar los dos <xref:System.Text.StringBuilder> objetos a la <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="14eb3-170">Aunque las tres <xref:System.Text.StringBuilder> objetos contienen cadenas idénticas, hacen referencia a tres objetos distintos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="14eb3-171">Como resultado, estos tres métodos llama devuelto `false`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="14eb3-172">Puede comparar el objeto actual con otro objeto para la igualdad de referencia mediante una llamada a la <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="14eb3-173">En Visual Basic, también puede utilizar el `is` palabra clave (por ejemplo, `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="14eb3-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="14eb3-174">Notas para los herederos</span><span class="sxs-lookup"><span data-stu-id="14eb3-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="14eb3-175">Al definir su propio tipo, ese tipo hereda la funcionalidad definida por el `Equals` método de su tipo base.</span><span class="sxs-lookup"><span data-stu-id="14eb3-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="14eb3-176">La tabla siguiente muestra la implementación predeterminada de la `Equals` método para las categorías principales de tipos en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="14eb3-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="14eb3-177">Categoría de tipo</span><span class="sxs-lookup"><span data-stu-id="14eb3-177">Type category</span></span>|<span data-ttu-id="14eb3-178">Igualdad definida por</span><span class="sxs-lookup"><span data-stu-id="14eb3-178">Equality defined by</span></span>|<span data-ttu-id="14eb3-179">Comentarios</span><span class="sxs-lookup"><span data-stu-id="14eb3-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="14eb3-180">Clase se deriva directamente <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="14eb3-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="14eb3-181">Igualdad de referencia; equivalente a llamar a <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="14eb3-182">Estructura</span><span class="sxs-lookup"><span data-stu-id="14eb3-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="14eb3-183">Igualdad de valor; comparación byte a byte directa o en la comparación de campo a campo mediante la reflexión.</span><span class="sxs-lookup"><span data-stu-id="14eb3-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="14eb3-184">Enumeración</span><span class="sxs-lookup"><span data-stu-id="14eb3-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="14eb3-185">Valores deben tener el mismo tipo de enumeración y el mismo valor subyacente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="14eb3-186">delegado</span><span class="sxs-lookup"><span data-stu-id="14eb3-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="14eb3-187">Delegados deben tener el mismo tipo con listas de invocaciones idénticos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="14eb3-188">Interfaz</span><span class="sxs-lookup"><span data-stu-id="14eb3-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="14eb3-189">Igualdad de referencia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="14eb3-190">Para un tipo de valor, debe invalidar siempre <xref:System.Object.Equals%2A>, ya que comprueba la igualdad que se basan en la reflexión ofrece un rendimiento deficiente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="14eb3-191">También puede invalidar la implementación predeterminada de <xref:System.Object.Equals%2A> para los tipos de referencia para comprobar la igualdad de valores en lugar de la igualdad de referencia y para definir el significado exacto de igualdad de valores.</span><span class="sxs-lookup"><span data-stu-id="14eb3-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="14eb3-192">Este tipo de implementaciones de <xref:System.Object.Equals%2A> devolver `true` si los dos objetos tienen el mismo valor, aunque no sean la misma instancia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="14eb3-193">El implementador de tipos decide qué constituye el valor de un objeto, pero suele ser todos o algunos de los datos almacenados en las variables de instancia del objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="14eb3-194">Por ejemplo, el valor de un <xref:System.String> objeto se basa en los caracteres de la cadena; la <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> reemplazos de método la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método devuelva `true` para cualquiera de dos cadenas instancias que contienen los mismos caracteres en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="14eb3-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="14eb3-195">En el ejemplo siguiente se muestra cómo invalidar el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método para comprobar la igualdad de valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="14eb3-196">Reemplaza el <xref:System.Object.Equals%2A> método para el `Person` clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="14eb3-197">Si `Person` aceptado su implementación de la clase base de la igualdad de los dos `Person` objetos sería iguales sólo si hace referencia a un único objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="14eb3-198">Sin embargo, en este caso, dos `Person` objetos son iguales si tienen el mismo valor para el `Person.Id` propiedad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="14eb3-199">Además de invalidar <xref:System.Object.Equals%2A>, puede implementar la <xref:System.IEquatable%601> interfaz para proporcionar una prueba de igualdad fuertemente tipada.</span><span class="sxs-lookup"><span data-stu-id="14eb3-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="14eb3-200">Las instrucciones siguientes deben ser true para todas las implementaciones de la <xref:System.Object.Equals%28System.Object%29> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="14eb3-201">En la lista, `x`, `y`, y `z` representan referencias a objetos que no son **null**.</span><span class="sxs-lookup"><span data-stu-id="14eb3-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="14eb3-202">`x.Equals(x)` Devuelve `true`, excepto en los casos que implican tipos de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="14eb3-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="14eb3-203">Vea ISO/IEC/IEEE 60559:2011, Information technology--microprocesador sistemas--aritmética de coma flotante.</span><span class="sxs-lookup"><span data-stu-id="14eb3-203">See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</span></span>  
  
-   <span data-ttu-id="14eb3-204">`x.Equals(y)` Devuelve el mismo valor que `y.Equals(x)`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="14eb3-205">`x.Equals(y)` Devuelve `true` si `x` y `y` son `NaN`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="14eb3-206">Si `(x.Equals(y) && y.Equals(z))` devuelve `true`, a continuación, `x.Equals(z)` devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="14eb3-207">Las llamadas sucesivas a `x.Equals(y)` devuelven el mismo valor siempre y cuando los objetos al que hace referencia `x` y `y` no se modifican.</span><span class="sxs-lookup"><span data-stu-id="14eb3-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="14eb3-208">`x.Equals(null)` devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="14eb3-209">Las implementaciones de <xref:System.Object.Equals%2A> no deben producir excepciones; siempre deben devolver un valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="14eb3-210">Por ejemplo, si `obj` es `null`, <xref:System.Object.Equals%2A> método debe devolver `false` en lugar de producir una <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="14eb3-211">Siga estas directrices al reemplazar <xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="14eb3-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="14eb3-212">Los tipos que implementan <xref:System.IComparable> debe invalidar <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="14eb3-213">Tipos que reemplazan <xref:System.Object.Equals%28System.Object%29> también debe invalidar <xref:System.Object.GetHashCode%2A>; en caso contrario, las tablas hash no funcionen correctamente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="14eb3-214">Puede implementar la <xref:System.IEquatable%601> interfaz para admitir fuertemente tipados comprueba la igualdad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="14eb3-215">Su <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementación debe devolver resultados coherentes con <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="14eb3-216">Si su lenguaje de programación admite la sobrecarga de operadores y sobrecargar el operador de igualdad para un tipo determinado, también debe invalidar el <xref:System.Object.Equals%28System.Object%29> método para devolver el mismo resultado que el operador de igualdad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="14eb3-217">Esto ayuda a garantizar que código de biblioteca de clase que usa <xref:System.Object.Equals%2A> (como <xref:System.Collections.ArrayList> y <xref:System.Collections.Hashtable>) se comporta de forma que sea coherente con la manera en que se usa el operador de igualdad por código de aplicación.</span><span class="sxs-lookup"><span data-stu-id="14eb3-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="14eb3-218">Instrucciones para tipos de referencia</span><span class="sxs-lookup"><span data-stu-id="14eb3-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="14eb3-219">Las siguientes directrices se aplican a reemplazar <xref:System.Object.Equals%28System.Object%29> para un tipo de referencia:</span><span class="sxs-lookup"><span data-stu-id="14eb3-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="14eb3-220">Considere la posibilidad de reemplazar <xref:System.Object.Equals%2A> si la semántica del tipo es basada en el hecho de que el tipo representa algunos valores.</span><span class="sxs-lookup"><span data-stu-id="14eb3-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="14eb3-221">La mayoría de los tipos de referencia no deben sobrecargar el operador de igualdad, aunque reemplacen <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="14eb3-222">Sin embargo, si va a implementar un tipo de referencia destinado a tener semántica de valor, como un tipo de número complejo, debe reemplazar el operador de igualdad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="14eb3-223">No se debe reemplazar <xref:System.Object.Equals%2A> en un tipo de referencia mutable.</span><span class="sxs-lookup"><span data-stu-id="14eb3-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="14eb3-224">Esto es porque reemplazar <xref:System.Object.Equals%2A> requiere que también invalidar el <xref:System.Object.GetHashCode%2A> método, como se describe en la sección anterior.</span><span class="sxs-lookup"><span data-stu-id="14eb3-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="14eb3-225">Esto significa que puede cambiar el código hash de una instancia de un tipo de referencia mutable durante su duración, lo que puede producir el objeto que se va a ser perdidos en una tabla hash.</span><span class="sxs-lookup"><span data-stu-id="14eb3-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="14eb3-226">Instrucciones para tipos de valor</span><span class="sxs-lookup"><span data-stu-id="14eb3-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="14eb3-227">Las siguientes directrices se aplican a reemplazar <xref:System.Object.Equals%28System.Object%29> para un tipo de valor:</span><span class="sxs-lookup"><span data-stu-id="14eb3-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="14eb3-228">Si va a definir un tipo de valor que incluye uno o más campos cuyos valores son tipos de referencia, debe invalidar <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="14eb3-229">El <xref:System.Object.Equals%28System.Object%29> implementación proporcionada por <xref:System.ValueType> realiza una comparación byte a byte para los tipos de valor cuyos campos son todos los tipos de valor, pero utiliza la reflexión para realizar una comparación de campo a campo de tipos de valor cuyos campos son tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="14eb3-230">Si invalida <xref:System.Object.Equals%2A> y el lenguaje de programación admite la sobrecarga de operadores, debe sobrecargar el operador de igualdad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="14eb3-231">Debe implementar la <xref:System.IEquatable%601> interfaz.</span><span class="sxs-lookup"><span data-stu-id="14eb3-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="14eb3-232">Al llamar a fuertemente tipado <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método evita la conversión boxing el `obj` argumento.</span><span class="sxs-lookup"><span data-stu-id="14eb3-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14eb3-233">El siguiente ejemplo se muestra un `Point` clase que invalide la <xref:System.Object.Equals%2A> método para proporcionar la igualdad de valor y un `Point3D` clase que se deriva de `Point`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="14eb3-234">Dado que `Point` invalida <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para comprobar la igualdad de valor, la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> no se llama el método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="14eb3-235">Sin embargo, `Point3D.Equals` llamadas `Point.Equals` porque `Point` implementa <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> de forma que se proporciona igualdad de valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="14eb3-236">El `Point.Equals` método comprueba para asegurarse de que el `obj` el argumento no es **null** y que hace referencia a una instancia del mismo tipo que este objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="14eb3-237">Si bien la comprobación da error, el método devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="14eb3-238">El `Point.Equals` llamadas al método el <xref:System.Object.GetType%2A> método para determinar si los tipos de tiempo de ejecución de los dos objetos son idénticos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="14eb3-239">Si el método utilizó una comprobación de la forma `obj is Point` en C# o `TryCast(obj, Point)` en Visual Basic, la comprobación devolverá `true` en casos donde `obj` es una instancia de una clase derivada de `Point`, aunque `obj` y actual instancia no son del mismo tipo de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="14eb3-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="14eb3-240">Una vez comprobado que ambos objetos son del mismo tipo, el método convierte `obj` al tipo `Point` y devuelve el resultado de la comparación de los campos de instancia de los dos objetos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="14eb3-241">En `Point3D.Equals`, los heredados `Point.Equals` método, que invalida <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, se invoca antes de realizar cualquier otra cosa.</span><span class="sxs-lookup"><span data-stu-id="14eb3-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="14eb3-242">Dado que `Point3D` es una clase sealed (`NotInheritable` en Visual Basic), una comprobación en el formulario `obj is Point` en C# o `TryCast(obj, Point)` en Visual Basic es el adecuado para asegurarse de que `obj` es un `Point3D` objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="14eb3-243">Si es un `Point3D` de objeto, se convierte en una `Point` objeto y pasan a la implementación de clase base <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="14eb3-244">Solo cuando los heredados `Point.Equals` método `true` el método de comparación la `z` campos presentados en la clase derivada de la instancia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="14eb3-245">En el ejemplo siguiente se define un `Rectangle` clase que implementa internamente un rectángulo como dos `Point` objetos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="14eb3-246">El `Rectangle` también clase invalidaciones <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para proporcionar la igualdad de valores.</span><span class="sxs-lookup"><span data-stu-id="14eb3-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="14eb3-247">Algunos lenguajes como C# y Visual Basic admiten la sobrecarga de operadores.</span><span class="sxs-lookup"><span data-stu-id="14eb3-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="14eb3-248">Cuando un tipo sobrecarga el operador de igualdad, también debe invalidar el <xref:System.Object.Equals%28System.Object%29> método para proporcionar la misma funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="14eb3-249">Esto se consigue normalmente escribiendo el <xref:System.Object.Equals%28System.Object%29> método en términos del operador de igualdad sobrecargado, como en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="14eb3-250">Dado que `Complex` es un tipo de valor, no puede derivar de.</span><span class="sxs-lookup"><span data-stu-id="14eb3-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="14eb3-251">Por lo tanto, la invalidación para <xref:System.Object.Equals%28System.Object%29> no necesita llamar al método <xref:System.Object.GetType%2A> para determinar el tiempo de ejecución preciso escriba de cada objeto, pero en su lugar, use la `is` operador de C# o la `TypeOf` operador en Visual Basic para comprobar el tipo de la `obj` parámetro.</span><span class="sxs-lookup"><span data-stu-id="14eb3-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="14eb3-252">Primer objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-252">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="14eb3-253">Segundo objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-253">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14eb3-254">Determina si las instancias del objeto especificado se consideran iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-254">Determines whether the specified object instances are considered equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14eb3-255">Es <see langword="true" /> si los dos objetos se consideran iguales; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-255">
              <see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="14eb3-256">Si tanto <paramref name="objA" /> como <paramref name="objB" /> son **null**, el método devuelve <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-257">El método estático <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método indica si dos objetos, `objA` y `objB`, son iguales.</span><span class="sxs-lookup"><span data-stu-id="14eb3-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="14eb3-258">También permite probar los objetos cuyo valor es **null** igualdad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="14eb3-259">Compara `objA` y `objB` para la igualdad como sigue:</span><span class="sxs-lookup"><span data-stu-id="14eb3-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="14eb3-260">Determina si los dos objetos representan la misma referencia de objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="14eb3-261">Si es así, el método devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="14eb3-262">Esta prueba es equivalente a llamar a la <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="14eb3-263">Además, si ambos `objA` y `objB` son **null**, el método devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="14eb3-264">Determina si el `objA` o `objB` es **null**.</span><span class="sxs-lookup"><span data-stu-id="14eb3-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="14eb3-265">Si es así, devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="14eb3-266">Si los dos objetos no representan la misma referencia de objeto y ninguna de ellas es **null**, llama a `objA`.`Equals` (`objB`) y devuelve el resultado.</span><span class="sxs-lookup"><span data-stu-id="14eb3-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="14eb3-267">Esto significa que si `objA` invalida el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> se llama al método, esta invalidación.</span><span class="sxs-lookup"><span data-stu-id="14eb3-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14eb3-268">En el ejemplo siguiente se muestra la <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método y lo compara con el <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14eb3-269">Permite que un objeto intente liberar recursos y realizar otras operaciones de limpieza antes de que sea reclamado por la recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-270">El <xref:System.Object.Finalize%2A> método se usa para realizar operaciones de limpieza en los recursos no administrados mantenidos por el objeto actual antes de que se destruya el objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="14eb3-271">El método está protegido y, por tanto, es accesible sólo a través de esta clase o una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="14eb3-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="14eb3-272">En esta sección:</span><span class="sxs-lookup"><span data-stu-id="14eb3-272">In this section:</span></span>  
  
-   [<span data-ttu-id="14eb3-273">Cómo funciona la finalización</span><span class="sxs-lookup"><span data-stu-id="14eb3-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="14eb3-274">Notas para los implementadores</span><span class="sxs-lookup"><span data-stu-id="14eb3-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="14eb3-275">La alternativa SafeHandle</span><span class="sxs-lookup"><span data-stu-id="14eb3-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="14eb3-276">Cómo funciona la finalización</span><span class="sxs-lookup"><span data-stu-id="14eb3-276">How finalization works</span></span>  
 <span data-ttu-id="14eb3-277">El <xref:System.Object> clase no proporciona una implementación para el <xref:System.Object.Finalize%2A> método y el recolector de elementos no utilizados no marcar tipos derivados de <xref:System.Object> para la finalización, a menos que invalide la <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="14eb3-278">Si un tipo de invalidar el <xref:System.Object.Finalize%2A> método, el recolector de elementos no utilizados agrega una entrada para cada instancia del tipo a una estructura interna denominada cola de finalización.</span><span class="sxs-lookup"><span data-stu-id="14eb3-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="14eb3-279">La cola de finalización contiene entradas para todos los objetos del montón administrado cuyo código de finalización debe ejecutarse antes de que el recolector de elementos no utilizados pueda reclamar su memoria.</span><span class="sxs-lookup"><span data-stu-id="14eb3-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="14eb3-280">El recolector de elementos no utilizados, a continuación, llama el <xref:System.Object.Finalize%2A> método automáticamente en las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="14eb3-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="14eb3-281">Después de que el recolector de elementos no utilizados ha detectado que un objeto es inaccesible, a menos que el objeto haya sido excluido del proceso de finalización mediante una llamada a la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="14eb3-282">Durante el cierre de un dominio de aplicación, a menos que el objeto está exento de finalización.</span><span class="sxs-lookup"><span data-stu-id="14eb3-282">During shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="14eb3-283">Durante el cierre, finalizados incluso objetos que siguen siendo accesibles.</span><span class="sxs-lookup"><span data-stu-id="14eb3-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="14eb3-284"><xref:System.Object.Finalize%2A> se llama automáticamente una sola vez en una instancia determinada, a menos que el objeto se registre de nuevo mediante un mecanismo como <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> y <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método no se ha llamado posteriormente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="14eb3-285"><xref:System.Object.Finalize%2A> las operaciones tienen las siguientes limitaciones:</span><span class="sxs-lookup"><span data-stu-id="14eb3-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="14eb3-286">La hora exacta cuando se ejecuta el finalizador es indefinida.</span><span class="sxs-lookup"><span data-stu-id="14eb3-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="14eb3-287">Para garantizar la liberación determinista de recursos para implementar instancias de la clase, un `Close` método o proporcione un <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación.</span><span class="sxs-lookup"><span data-stu-id="14eb3-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="14eb3-288">No se garantizan que los finalizadores de dos objetos de ejecución en cualquier orden determinado, incluso si un objeto hace referencia a la otra.</span><span class="sxs-lookup"><span data-stu-id="14eb3-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="14eb3-289">Es decir, si un objeto tiene una referencia al objeto B y ambos tienen finalizadores, objeto B podría ya ha finalizado cuando se inicia el finalizador del objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="14eb3-290">El subproceso en el que se ejecuta el finalizador no está especificado.</span><span class="sxs-lookup"><span data-stu-id="14eb3-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="14eb3-291">El <xref:System.Object.Finalize%2A> método podría no ejecutarse hasta su finalización o podría no ejecutarse en absoluto en las siguientes circunstancias excepcionales:</span><span class="sxs-lookup"><span data-stu-id="14eb3-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="14eb3-292">Si otro finalizador se bloquea indefinidamente (queda en un bucle infinito, intenta obtener un bloqueo, nunca puede obtener y así sucesivamente).</span><span class="sxs-lookup"><span data-stu-id="14eb3-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="14eb3-293">Dado el tiempo de ejecución intenta ejecutar los finalizadores hasta su finalización, podrían no se llame a otros finalizadores si un finalizador se bloquea de forma indefinida.</span><span class="sxs-lookup"><span data-stu-id="14eb3-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="14eb3-294">Si el proceso termina sin que el tiempo de ejecución una oportunidad para limpiar.</span><span class="sxs-lookup"><span data-stu-id="14eb3-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="14eb3-295">En este caso, la primera notificación de terminación del proceso de tiempo de ejecución es una notificación DLL_PROCESS_DETACH.</span><span class="sxs-lookup"><span data-stu-id="14eb3-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="14eb3-296">El tiempo de ejecución continúa finalizar los objetos durante el cierre sólo si el número de objetos susceptibles de finalización sigue reduciéndose.</span><span class="sxs-lookup"><span data-stu-id="14eb3-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="14eb3-297">Si <xref:System.Object.Finalize%2A> o un reemplazo de <xref:System.Object.Finalize%2A> inicia una excepción y el tiempo de ejecución no está hospedado por una aplicación que reemplace la directiva predeterminada, el runtime finaliza el proceso y no active `try` / `finally` bloques o los finalizadores se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="14eb3-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="14eb3-298">Este comportamiento garantiza la integridad del proceso si el finalizador no puede liberar ni destruir recursos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="14eb3-299">Invalidación del método Finalize</span><span class="sxs-lookup"><span data-stu-id="14eb3-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="14eb3-300">Debe invalidar <xref:System.Object.Finalize%2A> para una clase que usa recursos no administrados, como identificadores de archivo o las conexiones de base de datos que deben liberarse cuando se descarta el objeto administrado que se usa durante la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="14eb3-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="14eb3-301">No debe implementar un <xref:System.Object.Finalize%2A> método para objetos administrados, porque el recolector de elementos no utilizados libera los recursos administrados automáticamente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="14eb3-302">Si un <xref:System.Runtime.InteropServices.SafeHandle> el objeto está disponible que contiene el recurso no administrado, la alternativa recomendada es implementar el patrón de dispose con un controlador seguro y no reemplazar <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="14eb3-303">Para obtener más información, consulte [alternativa SafeHandle el](#SafeHandle) sección.</span><span class="sxs-lookup"><span data-stu-id="14eb3-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="14eb3-304">El <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método no hace nada de forma predeterminada, pero se debe invalidar <xref:System.Object.Finalize%2A> solo si es necesario y solo para liberar recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="14eb3-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="14eb3-305">Reclamar memoria suele tardar mucho más tiempo si se ejecuta una operación de finalización, porque requiere al menos dos recolecciones de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="14eb3-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="14eb3-306">Además, debe invalidar el <xref:System.Object.Finalize%2A> solo tipos de método como referencia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="14eb3-307">Common language runtime finaliza solo los tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="14eb3-308">Omite los finalizadores en tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="14eb3-309">El ámbito de la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método es `protected`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="14eb3-310">Mantenga este ámbito limitado cuando reemplace el método en su clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="14eb3-311">Manteniendo un <xref:System.Object.Finalize%2A> método protegido, los usuarios de la aplicación de la llamada a un objeto <xref:System.Object.Finalize%2A> método directamente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="14eb3-312">Todas las implementaciones de <xref:System.Object.Finalize%2A> en un tipo derivado debe llamar a la implementación de su tipo base de <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="14eb3-313">Este es el único caso en la aplicación que se puede llamar a código <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="14eb3-314">Un objeto <xref:System.Object.Finalize%2A> método no debe llamar a un método en cualquier objeto que no sean de su clase base.</span><span class="sxs-lookup"><span data-stu-id="14eb3-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="14eb3-315">El motivo es que los otros objetos a los que se llama podrían ser recolectados al mismo tiempo que el objeto que llama, por ejemplo, en el caso de un cierre de Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="14eb3-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="14eb3-316">El compilador de C# no permite invalidar el <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="14eb3-317">En su lugar, proporciona un finalizador implementando un [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) para la clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="14eb3-318">Un destructor de C# llama automáticamente al destructor de su clase base.</span><span class="sxs-lookup"><span data-stu-id="14eb3-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="14eb3-319">Visual C++ también proporciona su propia sintaxis para implementar el <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="14eb3-320">Para obtener más información, vea la sección "Destructores y finalizadores" de [Cómo: definir y utilizar clases y Structs (C++ / CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="14eb3-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="14eb3-321">Dado que la colección de elementos no utilizados es no determinista, no conoce con precisión cuando el recolector de elementos no utilizados realiza finalización.</span><span class="sxs-lookup"><span data-stu-id="14eb3-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="14eb3-322">Para liberar recursos inmediatamente, también puede elegir implementar la [patrón de dispose](~/docs/standard/design-guidelines/dispose-pattern.md) y <xref:System.IDisposable> interfaz.</span><span class="sxs-lookup"><span data-stu-id="14eb3-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="14eb3-323">El <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación se puede llamar a los consumidores de la clase para liberar recursos no administrados, y puede usar el <xref:System.Object.Finalize%2A> método para liberar recursos no administrados en caso de que el <xref:System.IDisposable.Dispose%2A> no se llama el método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="14eb3-324"><xref:System.Object.Finalize%2A> puede realizar casi cualquier acción, como el restablecimiento de un objeto (es decir, hacer que el objeto accesible nuevo) después de que se ha limpiado durante la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="14eb3-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="14eb3-325">Sin embargo, el objeto sólo puede restablecerse una vez; <xref:System.Object.Finalize%2A> no puede llamarse en objetos restablecidos durante la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="14eb3-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span> <span data-ttu-id="14eb3-326">Hay una acción que la implementación de <xref:System.Object.Finalize%2A> nunca debe realizar: jamás deberá producir una excepción.</span><span class="sxs-lookup"><span data-stu-id="14eb3-326">There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.</span></span> <span data-ttu-id="14eb3-327">Si llama a las excepciones producidas por los métodos de la <xref:System.Object.Finalize%2A> son no controlada por el método por el <xref:System.Object.Finalize%2A> método, el tiempo de ejecución supone que la <xref:System.Object.Finalize%2A> método devuelto y continúa llamar a la <xref:System.Object.Finalize%2A> métodos de otros objetos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-327">If any exceptions thrown by methods called from the <xref:System.Object.Finalize%2A> method are unhandled by the <xref:System.Object.Finalize%2A> method, the runtime assumes that the <xref:System.Object.Finalize%2A> method returned and continues to call the <xref:System.Object.Finalize%2A> methods of other objects.</span></span> 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="14eb3-328">La alternativa SafeHandle</span><span class="sxs-lookup"><span data-stu-id="14eb3-328">The SafeHandle alternative</span></span>  
 <span data-ttu-id="14eb3-329">Crear los finalizadores confiables a menudo es difícil, porque no se puede realizar suposiciones sobre el estado de la aplicación y que excepciones no controladas de sistema como <xref:System.OutOfMemoryException> y <xref:System.StackOverflowException> finalizar el finalizador.</span><span class="sxs-lookup"><span data-stu-id="14eb3-329">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="14eb3-330">En lugar de implementar un finalizador de la clase para liberar recursos no administrados, puede usar un objeto que se deriva de la <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> clase para encapsular los recursos no administrados y, a continuación, implementar el patrón de dispose sin un finalizador.</span><span class="sxs-lookup"><span data-stu-id="14eb3-330">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="14eb3-331">.NET Framework proporciona las siguientes clases en el <xref:Microsoft.Win32?displayProperty=nameWithType> espacio de nombres que se derivan de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="14eb3-331">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="14eb3-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> es una clase contenedora para un identificador de archivo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="14eb3-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> es una clase contenedora para los identificadores de archivo asignado a memoria.</span><span class="sxs-lookup"><span data-stu-id="14eb3-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="14eb3-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> es una clase contenedora para un puntero a un bloque de memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="14eb3-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="14eb3-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, y <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> son clases de contenedor para los identificadores del cifrado.</span><span class="sxs-lookup"><span data-stu-id="14eb3-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="14eb3-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> es una clase contenedora para los identificadores de canalización.</span><span class="sxs-lookup"><span data-stu-id="14eb3-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="14eb3-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> es una clase contenedora para un identificador de una clave del registro.</span><span class="sxs-lookup"><span data-stu-id="14eb3-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="14eb3-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> es una clase contenedora para un identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="14eb3-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="14eb3-339">En el ejemplo siguiente se usa el [patrón de dispose](~/docs/standard/design-guidelines/dispose-pattern.md) con controladores seguros en lugar de reemplazar el <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-339">The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="14eb3-340">Define un `FileAssociation` clase que contiene información de registro de la aplicación que trata los archivos con una extensión de archivo en particular.</span><span class="sxs-lookup"><span data-stu-id="14eb3-340">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="14eb3-341">Los identificadores de dos registro formando `out` parámetros por Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) llamadas a funciones se pasan a la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-341">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="14eb3-342">El tipo del protege `Dispose` método, a continuación, llama el `SafeRegistryHandle.Dispose` método para liberar estos dos puntos de control.</span><span class="sxs-lookup"><span data-stu-id="14eb3-342">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="14eb3-343">En el ejemplo siguiente se comprueba que la <xref:System.Object.Finalize%2A> método se llama cuando un objeto que invalida <xref:System.Object.Finalize%2A> se destruye.</span><span class="sxs-lookup"><span data-stu-id="14eb3-343">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="14eb3-344">Tenga en cuenta que, en una aplicación de producción, el <xref:System.Object.Finalize%2A> se reemplazaría el método para liberar recursos no administrados mantenidos por el objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-344">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="14eb3-345">Tenga en cuenta también que el ejemplo de C# proporciona un destructor en lugar de reemplazar el <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-345">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="14eb3-346">Para obtener un ejemplo adicional que invalida la <xref:System.Object.Finalize%2A> método, consulte el <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-346">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14eb3-347">Sirve como la función hash predeterminada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-347">Serves as the default hash function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14eb3-348">Código hash para el objeto actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-348">A hash code for the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-349">Un código hash es un valor numérico que se utiliza para insertar e identificar un objeto de una colección basado en hash como el <xref:System.Collections.Generic.Dictionary%602> (clase), el <xref:System.Collections.Hashtable> clase o un tipo derivado de la <xref:System.Collections.DictionaryBase> clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-349">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="14eb3-350">El <xref:System.Object.GetHashCode%2A> método proporciona este código hash para los algoritmos que necesitan comprobaciones rápidas de igualdad de objetos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-350">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="14eb3-351">Para obtener información sobre cómo se utilizan los códigos hash en tablas hash y para algunos algoritmos de código hash adicionales, consulte la [función Hash](https://en.wikipedia.org/wiki/Hash_function) entrada de Wikipedia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-351">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="14eb3-352">Dos objetos que son los códigos hash devuelto igual que son iguales.</span><span class="sxs-lookup"><span data-stu-id="14eb3-352">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="14eb3-353">Sin embargo, lo contrario no es cierto: códigos hash igual no conllevan la igualdad de objetos, porque los objetos (iguales) diferentes pueden tener códigos hash idénticos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-353">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="14eb3-354">Además, .NET Framework no garantiza la implementación predeterminada de la <xref:System.Object.GetHashCode%2A> (método) y el valor de este método devuelve pueden diferir entre versiones de .NET Framework y las plataformas, como las plataformas de 32 bits y 64 bits.</span><span class="sxs-lookup"><span data-stu-id="14eb3-354">Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="14eb3-355">Por estos motivos, no use la implementación predeterminada de este método como un identificador de objeto único para fines de hash.</span><span class="sxs-lookup"><span data-stu-id="14eb3-355">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="14eb3-356">Siguen dos consecuencias de esto:</span><span class="sxs-lookup"><span data-stu-id="14eb3-356">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="14eb3-357">No se debe suponer que los códigos hash igual implican igualdad de objetos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-357">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="14eb3-358">Nunca debería conservar o utilizar un código hash fuera del dominio de aplicación en el que se creó, porque el mismo objeto puede hash entre plataformas, procesos y dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="14eb3-358">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="14eb3-359">Un código hash está destinado a una inserción y búsqueda en las colecciones que se basan en una tabla hash.</span><span class="sxs-lookup"><span data-stu-id="14eb3-359">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="14eb3-360">Un código hash no es un valor permanente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-360">A hash code is not a permanent value.</span></span> <span data-ttu-id="14eb3-361">Por esta razón:</span><span class="sxs-lookup"><span data-stu-id="14eb3-361">For this reason:</span></span>  
>   
>  -   <span data-ttu-id="14eb3-362">No serializar los valores de código hash o almacenarlos en las bases de datos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-362">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="14eb3-363">No utilice el código hash como clave para recuperar un objeto de una colección con clave.</span><span class="sxs-lookup"><span data-stu-id="14eb3-363">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="14eb3-364">No se envían códigos hash a través de procesos o dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="14eb3-364">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="14eb3-365">En algunos casos, se pueden calcular los códigos hash de forma dominio por proceso o por aplicación.</span><span class="sxs-lookup"><span data-stu-id="14eb3-365">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="14eb3-366">No utilice el código hash en lugar de un valor devuelto por una función hash criptográfica si necesita un hash criptográficamente seguro.</span><span class="sxs-lookup"><span data-stu-id="14eb3-366">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="14eb3-367">Para valores hash criptográficos, utilice una clase derivada de la <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> o <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-367">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="14eb3-368">No comprobar la igualdad de los códigos hash para determinar si dos objetos son iguales.</span><span class="sxs-lookup"><span data-stu-id="14eb3-368">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="14eb3-369">(Objetos distintos pueden tener códigos hash idénticos). Para comprobar la igualdad, llame a la <xref:System.Object.ReferenceEquals%2A> o <xref:System.Object.Equals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-369">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="14eb3-370">El <xref:System.Object.GetHashCode%2A> método puede reemplazarse por un tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="14eb3-370">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="14eb3-371">Si <xref:System.Object.GetHashCode%2A> es no se reemplaza, códigos hash para tipos de referencia se calculan mediante una llamada a la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método de la clase base, que calcula un código hash basado en la referencia de un objeto; para obtener más información, consulte <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-371">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="14eb3-372">En otras palabras, dos objetos para los que el <xref:System.Object.ReferenceEquals%2A> método `true` tienen códigos hash idénticos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-372">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="14eb3-373">Si los tipos de valor no invalidar <xref:System.Object.GetHashCode%2A>, el <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> método de la clase base utiliza la reflexión para calcular el código hash basado en los valores de los campos del tipo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-373">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="14eb3-374">En otras palabras, cuyos campos tienen los mismos valores de tipos de valor tienen códigos hash igual.</span><span class="sxs-lookup"><span data-stu-id="14eb3-374">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="14eb3-375">Para obtener más información sobre cómo invalidar <xref:System.Object.GetHashCode%2A>, vea la sección "Notas para los herederos".</span><span class="sxs-lookup"><span data-stu-id="14eb3-375">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="14eb3-376">Si invalida el <xref:System.Object.GetHashCode%2A> método, también debe invalidar <xref:System.Object.Equals%2A>y viceversa.</span><span class="sxs-lookup"><span data-stu-id="14eb3-376">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="14eb3-377">Si su invalidado <xref:System.Object.Equals%2A> método `true` cuando dos objetos se comprueban si hay igualdad, su invalidada <xref:System.Object.GetHashCode%2A> método debe devolver el mismo valor para los dos objetos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-377">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="14eb3-378">Si un objeto que se utiliza como clave en una tabla hash no proporciona una implementación útil de <xref:System.Object.GetHashCode%2A>, puede especificar un proveedor de código hash proporcionando un <xref:System.Collections.IEqualityComparer> implementación a una de las sobrecargas de los <xref:System.Collections.Hashtable> constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-378">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="14eb3-379">Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="14eb3-379">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="14eb3-380">Cuando se llama a la <xref:System.Object.GetHashCode%2A> método en una clase en el [!INCLUDE[wrt](~/includes/wrt-md.md)], proporciona el comportamiento predeterminado para las clases que no se invalidan <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-380">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="14eb3-381">Esto forma parte de la compatibilidad que .NET Framework proporciona para la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="14eb3-381">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="14eb3-382">Las clases en el [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.Object>y actualmente no se implementa un <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-382">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="14eb3-383">Sin embargo, parece que tienen <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, y <xref:System.Object.GetHashCode%2A> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-383">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="14eb3-384"> las clases que se escriben en C# o Visual Basic pueden invalidar la <xref:System.Object.GetHashCode%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-384"> classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14eb3-385">Una de las maneras más sencillas para calcular un código hash para un valor numérico que tiene la misma o a un intervalo más pequeño que el <xref:System.Int32> tipo es simplemente devolver ese valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-385">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="14eb3-386">En el ejemplo siguiente se muestra este tipo de implementación para una `Number` estructura.</span><span class="sxs-lookup"><span data-stu-id="14eb3-386">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="14eb3-387">Con frecuencia, un tipo tiene varios campos de datos que pueden participar en la generación del código hash.</span><span class="sxs-lookup"><span data-stu-id="14eb3-387">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="14eb3-388">Una manera de generar un código hash consiste en combinar estos campos utilizando una `XOR (eXclusive OR)` operación, tal y como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-388">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="14eb3-389">El ejemplo anterior devuelve el mismo código hash de (n1, n2) y (n2, n1) por lo que puede generar más colisiones de deseable.</span><span class="sxs-lookup"><span data-stu-id="14eb3-389">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="14eb3-390">Un número de soluciones está disponible para que los códigos hash en estos casos no son idénticos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-390">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="14eb3-391">Una consiste en devolver el código hash de un `Tuple` objeto que refleja el orden de cada campo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-391">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="14eb3-392">En el ejemplo siguiente se muestra una posible implementación que usa el <xref:System.Tuple%602> clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-392">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="14eb3-393">Sin embargo, tenga en cuenta que la sobrecarga de rendimiento de una instancia un `Tuple` objeto puede afectar significativamente al rendimiento general de una aplicación que almacena gran cantidad de objetos en las tablas hash.</span><span class="sxs-lookup"><span data-stu-id="14eb3-393">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="14eb3-394">Una segunda solución alternativa implica la ponderación de los códigos hash individuales mediante su desplazamiento a la izquierda los códigos hash de campos sucesivas por dos o más bits.</span><span class="sxs-lookup"><span data-stu-id="14eb3-394">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="14eb3-395">En condiciones óptimas, en lugar de descartarse, bits desplazados más allá de 31 bits se deben ajustar alrededor en lugar de descartar.</span><span class="sxs-lookup"><span data-stu-id="14eb3-395">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="14eb3-396">Puesto que se descartan los bits por los operadores de desplazamiento a la izquierda en C# y Visual Basic, esto requiere la creación de un método de ajuste de desplazamiento a la izquierda similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="14eb3-396">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="14eb3-397">En el ejemplo siguiente se utiliza, a continuación, este método de ajuste de desplazamiento para calcular el código hash de la `Point` estructura utilizada en los ejemplos anteriores.</span><span class="sxs-lookup"><span data-stu-id="14eb3-397">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14eb3-398">
            <para>Una función hash se utiliza para generar rápidamente un número (código hash) que corresponde al valor de un objeto. Las funciones hash suelen ser están para cada tipo y, de unicidad, deben utilizar al menos uno de los campos de instancia como entrada. No se deben calcular códigos hash mediante el uso de los valores de los campos estáticos.  Para las clases derivadas de <see cref="T:System.Object" />, <see langword="GetHashCode" /> puede delegar el método a la clase base <see cref="M:System.Object.GetHashCode" /> implementación sólo si la clase derivada define la igualdad para que sea la igualdad de referencia. La implementación predeterminada de <see cref="M:System.Object.GetHashCode" /> para referencia tipos devuelve un código hash que es equivalente a la devuelta por la <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> método. Puede invalidar <see cref="M:System.Object.GetHashCode" /> para tipos de referencia inmutable. En general, para los tipos de referencias mutables, debe invalidar <see cref="M:System.Object.GetHashCode" /> solo si:: puede calcular el código hash de los campos que no son mutables; o - puede asegurarse de que el código hash de un objeto mutable no cambia y el objeto se encuentra en un collecti en el se basa en el código hash.  En caso contrario, puede que piense que se ha perdido el objeto mutable en la tabla hash. Si elige reemplazar <see cref="M:System.Object.GetHashCode" /> para un tipo de referencia mutable, la documentación debe dejar claro que los usuarios de su tipo no deben modificar los valores de objeto mientras el objeto se almacena en una tabla hash.  Para los tipos de valor, <see cref="M:System.ValueType.GetHashCode" /> proporciona una implementación del código hash predeterminado que usa la reflexión. Considere la posibilidad de reemplazar para mejorar el rendimiento.  <block subset="none" type="note"><para> Para obtener más información y ejemplos que calculan códigos hash en una variedad de formas, vea la sección ejemplos.  </para></block>  Una función hash debe tener las siguientes propiedades: - si dos objetos comparan como iguales, la <see cref="M:System.Object.GetHashCode" /> método para cada objeto debe devolver el mismo valor. Sin embargo, si dos objetos no compararse como iguales, la <see cref="M:System.Object.GetHashCode" /> métodos para los dos objetos no tienen que devolver valores diferentes.  -El <see cref="M:System.Object.GetHashCode" /> método de un objeto constantemente debe devolver el mismo código hash como no hay ninguna modificación en el estado del objeto que determina el valor devuelto por el objeto [System.Object.Equals](xref:System.Object.Equals*) method. Tenga en cuenta que esto es cierto solo para la ejecución actual de una aplicación y que se puede devolver un código hash diferente si se vuelve a ejecutar la aplicación.  -Para un mejor rendimiento, una función hash debe generar una distribución uniforme para todas las entradas, incluida la entrada que está agrupado con un alto grado. Una implicación es que deben dar como resultado pequeñas modificaciones en el estado de objetos grandes modificaciones en el código hash resultante para un mejor rendimiento de la tabla de hash.  -Las funciones hash deben ser económicas calcular.  -El <see cref="M:System.Object.GetHashCode" /> método no debe producir excepciones.  Por ejemplo, la implementación de la <see cref="M:System.String.GetHashCode" /> método proporcionado por el <see cref="T:System.String" /> clase devuelve códigos hash idénticos para valores de cadena idénticos. Por lo tanto, dos <see cref="T:System.String" /> objetos devuelven el mismo código hash si representan el mismo valor de cadena. Además, el método utiliza todos los caracteres en la cadena para generar la salida con una distribución aleatoria razonable, incluso cuando la entrada está en clúster en determinados intervalos (por ejemplo, muchos usuarios podrían tener cadenas que contienen sólo los 128 caracteres ASCII inferiores, aunque una cadena puede contener cualquiera de los 65.535 caracteres Unicode).  Proporciona una función hash adecuada en una clase puede afectar significativamente al rendimiento de la adición de esos objetos en una tabla hash. En una tabla hash con claves que proporcionan una buena implementación de una función hash, busca un elemento tiene tiempo constante (por ejemplo, una operación o (1)). En una tabla hash con una implementación inadecuada de una función hash, el rendimiento de una búsqueda depende del número de elementos de la tabla hash (por ejemplo, una operación de O('n'), donde ' n ' es el número de elementos de la tabla hash). Un usuario malintencionado puede escribir datos que aumentan el número de conflictos, que puede reducir significativamente el rendimiento de las aplicaciones que dependen de las tablas hash, en las siguientes condiciones: - cuando las funciones de hash no generan conflictos frecuentes.  -Cuando una gran proporción de objetos en una tabla hash generar códigos hash que son iguales o aproximadamente igual entre sí.  -Cuando los usuarios los datos desde el que se calcula el código hash de entrada.  Las clases derivadas que invalidan <see cref="M:System.Object.GetHashCode" /> también debe invalidar <see cref="M:System.Object.Equals(System.Object)" /> para garantizar que dos objetos considerados iguales tengan el mismo código hash; en caso contrario, el <see cref="T:System.Collections.Hashtable" /> tipo no funcionen correctamente.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-398">
              <para>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object. Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input. Hash codes should not be computed by using the values of static fields.  For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality. The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method. You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types. In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:  -   You can compute the hash code from fields that are not mutable; or  -   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.  Otherwise, you might think that the mutable object is lost in the hash table. If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.  For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection. You should consider overriding it for better performance.  <block subset="none" type="note"><para> For more information and examples that compute hash codes in a variety of ways, see the Examples section.  </para></block>  A hash function must have the following properties:  -   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value. However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.  -   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method. Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.  -   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered. An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.  -   Hash functions should be inexpensive to compute.  -   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.  For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values. Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value. Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).  Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table. In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation). In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table). A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:  -   When hash functions produce frequent collisions.  -   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.  -   When users input the data from which the hash code is computed.  Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14eb3-399">Obtiene el <see cref="T:System.Type" /> de la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-399">Gets the <see cref="T:System.Type" /> of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14eb3-400">El tipo en tiempo de ejecución exacto de la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-400">The exact runtime type of the current instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-401">Dado que <xref:System.Object?displayProperty=nameWithType> es la clase base para todos los tipos en el sistema de tipos de .NET Framework, el <xref:System.Object.GetType%2A> método se puede utilizar para devolver <xref:System.Type> objetos que representan todos los tipos de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="14eb3-401">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types.</span></span> <span data-ttu-id="14eb3-402">.NET Framework reconoce las cinco categorías de tipos siguientes:</span><span class="sxs-lookup"><span data-stu-id="14eb3-402">The .NET Framework recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="14eb3-403">Las clases, que se derivan de <xref:System.Object?displayProperty=nameWithType>,</span><span class="sxs-lookup"><span data-stu-id="14eb3-403">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="14eb3-404">Tipos de valor, que derivan de <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-404">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="14eb3-405">Interfaces, que se derivan de <xref:System.Object?displayProperty=nameWithType> a partir de .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="14eb3-405">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="14eb3-406">Enumeraciones, que se derivan de <xref:System.Enum?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-406">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="14eb3-407">Delegados, lo que se derivan de <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-407">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="14eb3-408">Para dos objetos `x` y `y` que tienen tipos idénticos en tiempo de ejecución, `Object.ReferenceEquals(x.GetType(),y.GetType())` devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="14eb3-408">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="14eb3-409">En el ejemplo siguiente se usa el <xref:System.Object.GetType%2A> método con el <xref:System.Object.ReferenceEquals%2A> método para determinar si un valor numérico es el mismo tipo que los otros dos valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-409">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="14eb3-410">Para determinar si un objeto es un tipo específico, puede usar la palabra clave de comparación de tipo de su lenguaje o construir.</span><span class="sxs-lookup"><span data-stu-id="14eb3-410">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="14eb3-411">Por ejemplo, puede usar el `TypeOf…Is` construir en Visual Basic o `is` palabra clave de C#.</span><span class="sxs-lookup"><span data-stu-id="14eb3-411">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="14eb3-412">El <xref:System.Object.GetType%2A> método es heredado por todos los tipos que derivan de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-412">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="14eb3-413">Esto significa que, además de utilizar la palabra clave de comparación de su propio lenguaje, puede utilizar el <xref:System.Object.GetType%2A> método para determinar el tipo de un objeto determinado, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-413">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="14eb3-414">El <xref:System.Type> objeto expone los metadatos asociados a la clase del elemento actual <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-414">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14eb3-415">En el ejemplo de código siguiente se muestra que <xref:System.Object.GetType%2A> devuelve el tipo en tiempo de ejecución de la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="14eb3-415">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14eb3-416">Crea una copia superficial del <see cref="T:System.Object" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-416">Creates a shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14eb3-417">Copia superficial del <see cref="T:System.Object" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-417">A shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-418">El <xref:System.Object.MemberwiseClone%2A> método crea una copia superficial, cree un nuevo objeto y, a continuación, copiar los campos no estáticos del objeto actual en el nuevo objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-418">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="14eb3-419">Si un campo es un tipo de valor, se realiza una copia bit a bit del campo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-419">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="14eb3-420">Si un campo es un tipo de referencia, la referencia se copia, pero el objeto que se hace referencia es no; por lo tanto, el objeto original y su clon hacen referencia al mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-420">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="14eb3-421">Por ejemplo, considere un objeto denominado X que hace referencia a objetos A y B. el objeto B, a su vez, el objeto references C. Una copia superficial de X crea nuevo objeto X2 que también hace referencia a objetos A y B. En contraste, una copia en profundidad de X crea un nuevo objeto X2 que hace referencia a los nuevos objetos A2 y B2, que son copias de A y B. B2, a su vez, hace referencia al nuevo objeto C2, que es una copia de C. En el ejemplo se ilustra la diferencia entre un superficial y una operación de copia en profundidad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-421">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="14eb3-422">Hay muchas formas para implementar una operación de copia en profundidad si realiza la operación de copia superficial del <xref:System.Object.MemberwiseClone%2A> método no satisfacen sus necesidades.</span><span class="sxs-lookup"><span data-stu-id="14eb3-422">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="14eb3-423">Entre ellas se incluyen las siguientes:</span><span class="sxs-lookup"><span data-stu-id="14eb3-423">These include the following:</span></span>  
  
-   <span data-ttu-id="14eb3-424">Llamar a un constructor de clase del objeto que se va a copiar para crear un segundo objeto con valores de propiedad que se toma del primer objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-424">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="14eb3-425">Se supone que los valores de un objeto completamente se definen mediante su constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-425">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="14eb3-426">Llame a la <xref:System.Object.MemberwiseClone%2A> método para crear una copia superficial de un objeto y, a continuación, asignar nuevos objetos cuyos valores son los mismos que el objeto original a las propiedades o campos cuyos valores son tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-426">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="14eb3-427">El `DeepCopy` método en el ejemplo muestra este enfoque.</span><span class="sxs-lookup"><span data-stu-id="14eb3-427">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="14eb3-428">Serializar el objeto para que sea profundo copiado y, a continuación, restaurar los datos serializados en una variable de objeto diferente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-428">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="14eb3-429">Usar la reflexión con la repetición para realizar la operación de copia en profundidad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-429">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14eb3-430">En el ejemplo siguiente se muestra el <xref:System.Object.MemberwiseClone%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-430">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="14eb3-431">Define un `ShallowCopy` método al que llama el <xref:System.Object.MemberwiseClone%2A> método para realizar una operación de copia superficial de un `Person` objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-431">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="14eb3-432">También define un `DeepCopy` método que realiza una operación de copia en profundidad en un `Person` objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-432">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="14eb3-433">En este ejemplo, el `Person.IdInfo` propiedad devuelve un `IdInfo` objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-433">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="14eb3-434">Como la salida se muestra en el ejemplo, cuando un `Person` objeto se clona mediante una llamada a la <xref:System.Object.MemberwiseClone%2A> /método siguiente, clonado `Person` objeto es una copia independiente del objeto original, salvo que comparten el mismo `Person.IdInfo` referencia de objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-434">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="14eb3-435">Como resultado, modificar el clon `Person.IdInfo` cambios en las propiedades del objeto original `Person.IdInfo` propiedad.</span><span class="sxs-lookup"><span data-stu-id="14eb3-435">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="14eb3-436">Por otro lado, cuando se realiza una operación de copia en profundidad, clonado `Person` objeto, incluido su `Person.IdInfo` propiedad, se puede modificar sin afectar al objeto original.</span><span class="sxs-lookup"><span data-stu-id="14eb3-436">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="14eb3-437">Primer objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-437">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="14eb3-438">Segundo objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-438">The second object  to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14eb3-439">Determina si las instancias de <see cref="T:System.Object" /> especificadas son la misma instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-439">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14eb3-440">
            <see langword="true" /> si <paramref name="objA" /> es la misma instancia que <paramref name="objB" /> o si ambos son **null**; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-440">
              <see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-441">A diferencia de la <xref:System.Object.Equals%2A> método y el operador de igualdad, el <xref:System.Object.ReferenceEquals%2A> no se puede invalidar el método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-441">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="14eb3-442">Por este motivo, si desea probar dos referencias de igualdad de objetos y no está seguro acerca de la implementación de la `Equals` método, se puede llamar a la <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-442">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="14eb3-443">Sin embargo, el valor devuelto de la <xref:System.Object.ReferenceEquals%2A> método puede aparecer anómalos en los dos escenarios:</span><span class="sxs-lookup"><span data-stu-id="14eb3-443">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="14eb3-444">Al comparar los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-444">When comparing value types.</span></span> <span data-ttu-id="14eb3-445">Si `objA` y `objB` son tipos de valor, se han convertido antes de pasarlos a la <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-445">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="14eb3-446">Esto significa que si ambos `objA` y `objB` representan la misma instancia de un tipo de valor, el <xref:System.Object.ReferenceEquals%2A> , sin embargo, devuelve el método `false`, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-446">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="14eb3-447">Para obtener información sobre los tipos de valor de conversión boxing, vea [conversión Boxing y Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="14eb3-447">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="14eb3-448">Cuando se comparan cadenas.</span><span class="sxs-lookup"><span data-stu-id="14eb3-448">When comparing strings.</span></span> <span data-ttu-id="14eb3-449">Si `objA` y `objB` son cadenas, la <xref:System.Object.ReferenceEquals%2A> método `true` si la cadena se aplica el método Intern.</span><span class="sxs-lookup"><span data-stu-id="14eb3-449">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="14eb3-450">No lleva a cabo una prueba de igualdad de valores.</span><span class="sxs-lookup"><span data-stu-id="14eb3-450">It does not perform a test for value equality.</span></span>  <span data-ttu-id="14eb3-451">En el ejemplo siguiente, `s1` y `s2` son iguales porque son dos instancias de una sola cadena aplicado el método Intern.</span><span class="sxs-lookup"><span data-stu-id="14eb3-451">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="14eb3-452">Sin embargo, `s3` y `s4` no son iguales, porque aunque tienen valores de cadena idéntica, esa cadena no es aplica el método Intern.</span><span class="sxs-lookup"><span data-stu-id="14eb3-452">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="14eb3-453">Para obtener más información acerca de la asignación al grupo interno de cadena, vea <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-453">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14eb3-454">En el ejemplo siguiente se utiliza <xref:System.Object.ReferenceEquals%2A> para determinar si dos objetos son la misma instancia.</span><span class="sxs-lookup"><span data-stu-id="14eb3-454">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14eb3-455">Devuelve una cadena que representa el objeto actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-455">Returns a string that represents the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14eb3-456">Una cadena que representa el objeto actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-456">A string that represents the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14eb3-457"><xref:System.Object.ToString%2A?displayProperty=nameWithType> es el principal formato método en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="14eb3-457"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="14eb3-458">Convierte un objeto en su representación de cadena para que sea adecuada para su presentación.</span><span class="sxs-lookup"><span data-stu-id="14eb3-458">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="14eb3-459">(Para obtener información acerca del formato de soporte técnico de .NET Framework, vea [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Las implementaciones de predeterminadas el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método devuelve el nombre completo del tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-459">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="14eb3-460">Podría haber alcanzado esta página siguiendo el vínculo de la lista de miembros de otro tipo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-460">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="14eb3-461">La razón es que ese tipo no invalidar <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-461">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="14eb3-462">En su lugar, hereda la funcionalidad de la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-462">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="14eb3-463">Los tipos con frecuencia invalidar la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para proporcionar una representación de cadena más adecuada de un tipo determinado.</span><span class="sxs-lookup"><span data-stu-id="14eb3-463">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="14eb3-464">También con frecuencia, los tipos de sobrecargar la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para proporcionar compatibilidad con cadenas de formato o el formato dependiente de la referencia cultural.</span><span class="sxs-lookup"><span data-stu-id="14eb3-464">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="14eb3-465">En esta sección:</span><span class="sxs-lookup"><span data-stu-id="14eb3-465">In this section:</span></span>  
  
 <span data-ttu-id="14eb3-466">[El método predeterminado de Object.ToString)](#Default) </span><span class="sxs-lookup"><span data-stu-id="14eb3-466">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="14eb3-467">[Invalidación del método Object.ToString)](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="14eb3-467">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="14eb3-468">[Sobrecarga del método ToString](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="14eb3-468">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="14eb3-469">[Extender el método Object.ToString](#Extending) </span><span class="sxs-lookup"><span data-stu-id="14eb3-469">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="14eb3-470">Notas para el tiempo de ejecución de Windows</span><span class="sxs-lookup"><span data-stu-id="14eb3-470">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="14eb3-471">El método predeterminado de Object.ToString)</span><span class="sxs-lookup"><span data-stu-id="14eb3-471">The default Object.ToString() method</span></span>  
 <span data-ttu-id="14eb3-472">La implementación predeterminada de la <xref:System.Object.ToString%2A> método devuelve el nombre completo del tipo de la <xref:System.Object>, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-472">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="14eb3-473">Dado que <xref:System.Object> es la clase base de todos los tipos de referencia en .NET Framework, este comportamiento es heredada por los tipos de referencia que no invalidan los <xref:System.Object.ToString%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-473">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="14eb3-474">Esto se ilustra en el siguiente ejemplo:</span><span class="sxs-lookup"><span data-stu-id="14eb3-474">The following example illustrates this.</span></span> <span data-ttu-id="14eb3-475">Se define una clase denominada `Object1` que acepta la implementación predeterminada de todos los <xref:System.Object> miembros.</span><span class="sxs-lookup"><span data-stu-id="14eb3-475">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="14eb3-476">Su <xref:System.Object.ToString%2A> método devuelve el nombre de tipo completo del objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-476">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="14eb3-477">Invalidación del método Object.ToString)</span><span class="sxs-lookup"><span data-stu-id="14eb3-477">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="14eb3-478">Los tipos normalmente invalidar la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para devolver una cadena que representa la instancia del objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-478">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="14eb3-479">Por ejemplo, los tipos base como <xref:System.Char>, <xref:System.Int32>, y <xref:System.String> proporcionar <xref:System.Object.ToString%2A> las implementaciones que devuelven el formato de cadena del valor que representa el objeto.</span><span class="sxs-lookup"><span data-stu-id="14eb3-479">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="14eb3-480">En el ejemplo siguiente se define una clase, `Object2`, que invalida el <xref:System.Object.ToString%2A> método para devolver el nombre de tipo junto con su valor.</span><span class="sxs-lookup"><span data-stu-id="14eb3-480">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="14eb3-481">En la tabla siguiente enumera las categorías de tipos de .NET Framework e indica si se permite o no invalidan los <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-481">The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="14eb3-482">Categoría de tipo</span><span class="sxs-lookup"><span data-stu-id="14eb3-482">Type category</span></span>|<span data-ttu-id="14eb3-483">Invalida Object.ToString)</span><span class="sxs-lookup"><span data-stu-id="14eb3-483">Overrides Object.ToString()</span></span>|<span data-ttu-id="14eb3-484">Comportamiento</span><span class="sxs-lookup"><span data-stu-id="14eb3-484">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="14eb3-485">Clase</span><span class="sxs-lookup"><span data-stu-id="14eb3-485">Class</span></span>|<span data-ttu-id="14eb3-486">N/D</span><span class="sxs-lookup"><span data-stu-id="14eb3-486">n/a</span></span>|<span data-ttu-id="14eb3-487">N/D</span><span class="sxs-lookup"><span data-stu-id="14eb3-487">n/a</span></span>|  
|<span data-ttu-id="14eb3-488">Estructura</span><span class="sxs-lookup"><span data-stu-id="14eb3-488">Structure</span></span>|<span data-ttu-id="14eb3-489">Sí (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="14eb3-489">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="14eb3-490">Igual que Object.ToString)</span><span class="sxs-lookup"><span data-stu-id="14eb3-490">Same as Object.ToString()</span></span>|  
|<span data-ttu-id="14eb3-491">Enumeración</span><span class="sxs-lookup"><span data-stu-id="14eb3-491">Enumeration</span></span>|<span data-ttu-id="14eb3-492">Sí (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="14eb3-492">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="14eb3-493">El nombre de miembro</span><span class="sxs-lookup"><span data-stu-id="14eb3-493">The member name</span></span>|  
|<span data-ttu-id="14eb3-494">Interfaz</span><span class="sxs-lookup"><span data-stu-id="14eb3-494">Interface</span></span>|<span data-ttu-id="14eb3-495">No</span><span class="sxs-lookup"><span data-stu-id="14eb3-495">No</span></span>|<span data-ttu-id="14eb3-496">N/D</span><span class="sxs-lookup"><span data-stu-id="14eb3-496">n/a</span></span>|  
|<span data-ttu-id="14eb3-497">delegado</span><span class="sxs-lookup"><span data-stu-id="14eb3-497">Delegate</span></span>|<span data-ttu-id="14eb3-498">No</span><span class="sxs-lookup"><span data-stu-id="14eb3-498">No</span></span>|<span data-ttu-id="14eb3-499">N/D</span><span class="sxs-lookup"><span data-stu-id="14eb3-499">n/a</span></span>|  
  
 <span data-ttu-id="14eb3-500">Vea la sección Notas para los herederos para obtener información adicional sobre cómo reemplazar <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-500">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="14eb3-501">Sobrecarga del método ToString</span><span class="sxs-lookup"><span data-stu-id="14eb3-501">Overloading the ToString method</span></span>  
 <span data-ttu-id="14eb3-502">Además de reemplazar el método sin parámetros <xref:System.Object.ToString?displayProperty=nameWithType> sobrecarga del método, muchos tipos el `ToString` método para proporcionar versiones del método que aceptan parámetros.</span><span class="sxs-lookup"><span data-stu-id="14eb3-502">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="14eb3-503">Normalmente, esto se hace para proporcionar soporte técnico para aplicar formato a variables y formato dependiente de la referencia cultural.</span><span class="sxs-lookup"><span data-stu-id="14eb3-503">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="14eb3-504">El ejemplo siguiente se sobrecarga el `ToString` método para devolver una cadena de resultado que incluye el valor de varios campos de una `Automobile` clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-504">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="14eb3-505">Define cuatro cadenas de formato: G, que devuelve el nombre del modelo y el año; D., que devuelve el nombre del modelo, el año y el número de puertas; C, que devuelve el nombre del modelo, el año y el número de cilindros; y A, que devuelve una cadena con todos los valores de los cuatro campos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-505">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="14eb3-506">En el ejemplo siguiente se llama sobrecargado <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método para mostrar el formato dependiente de la referencia cultural de un valor de moneda.</span><span class="sxs-lookup"><span data-stu-id="14eb3-506">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="14eb3-507">Para obtener más información sobre las cadenas de formato y el formato dependiente de la referencia cultural, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="14eb3-507">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="14eb3-508">Para las cadenas de formato compatibles con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="14eb3-508">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="14eb3-509">Para las cadenas de formato compatibles con valores de fecha y hora, vea [cadenas de formato de hora y fecha estándar](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [cadenas de formato de hora y fecha personalizada](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="14eb3-509">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="14eb3-510">Extender el método Object.ToString</span><span class="sxs-lookup"><span data-stu-id="14eb3-510">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="14eb3-511">Puesto que un tipo hereda el valor predeterminado <xref:System.Object.ToString%2A?displayProperty=nameWithType> método, puede buscar su comportamiento no deseado y desea cambiarla.</span><span class="sxs-lookup"><span data-stu-id="14eb3-511">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="14eb3-512">Esto es especialmente cierto de matrices y clases de colección.</span><span class="sxs-lookup"><span data-stu-id="14eb3-512">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="14eb3-513">Mientras que puede esperar el `ToString` método de una clase de colección o matriz para mostrar los valores de sus miembros, en su lugar, muestra el nombre de tipo completo del tipo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="14eb3-513">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="14eb3-514">Tiene varias opciones para generar la cadena de resultado que le gustaría.</span><span class="sxs-lookup"><span data-stu-id="14eb3-514">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="14eb3-515">Si el tipo es una matriz, un objeto de colección o un objeto que implementa el <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601> interfaces, puede enumerar sus elementos mediante el uso de la `foreach` instrucción en C# o la `For Each...Next` construir en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="14eb3-515">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="14eb3-516">Si la clase no es `sealed` (en C#) o `NotInheritable` (en Visual Basic), puede desarrollar una clase contenedora que hereda de la clase base cuyo <xref:System.Object.ToString%2A?displayProperty=nameWithType> método que desee personalizar.</span><span class="sxs-lookup"><span data-stu-id="14eb3-516">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="14eb3-517">Como mínimo, para ello haga lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="14eb3-517">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="14eb3-518">Implementar todos los constructores necesarios.</span><span class="sxs-lookup"><span data-stu-id="14eb3-518">Implement any necessary constructors.</span></span> <span data-ttu-id="14eb3-519">Las clases derivadas no heredan sus constructores de clase base.</span><span class="sxs-lookup"><span data-stu-id="14eb3-519">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="14eb3-520">Invalidar el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para devolver la cadena de resultado que le gustaría.</span><span class="sxs-lookup"><span data-stu-id="14eb3-520">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="14eb3-521">En el ejemplo siguiente se define una clase contenedora para los <xref:System.Collections.Generic.List%601> clase.</span><span class="sxs-lookup"><span data-stu-id="14eb3-521">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="14eb3-522">Reemplaza el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para mostrar el valor de cada método de la colección en lugar de con el nombre de tipo completo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-522">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="14eb3-523">Desarrollar un [método de extensión](~/docs/standard/design-guidelines/extension-methods.md) que devuelve la cadena de resultado que desea.</span><span class="sxs-lookup"><span data-stu-id="14eb3-523">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="14eb3-524">Tenga en cuenta que no se puede invalidar el valor predeterminado <xref:System.Object.ToString%2A?displayProperty=nameWithType> método de esta manera (es decir, la clase de extensión (en C#) o el módulo (en Visual Basic) no puede tener un método sin parámetros denominado `ToString` que se llama en lugar del tipo original `ToString` método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-524">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="14eb3-525">Tendrá que proporcionar otro nombre para su sin parámetros `ToString` reemplazo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-525">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="14eb3-526">El siguiente ejemplo define dos métodos que amplían la <xref:System.Collections.Generic.List%601> clase: una sin parámetros `ToString2` (método) y un `ToString` método con un <xref:System.String> parámetro que representa una cadena de formato.</span><span class="sxs-lookup"><span data-stu-id="14eb3-526">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="14eb3-527">Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="14eb3-527">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="14eb3-528">Cuando se llama a la <xref:System.Object.ToString%2A> método en una clase en el [!INCLUDE[wrt](~/includes/wrt-md.md)], proporciona el comportamiento predeterminado para las clases que no se invalidan <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-528">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="14eb3-529">Esto forma parte de la compatibilidad que .NET Framework proporciona para la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="14eb3-529">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="14eb3-530">Las clases en el [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.Object>y no debe implementar siempre un <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-530">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and don’t always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="14eb3-531">Sin embargo, siempre parece que tienen <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, y <xref:System.Object.GetHashCode%2A> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona un comportamiento predeterminado para estos métodos.</span><span class="sxs-lookup"><span data-stu-id="14eb3-531">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="14eb3-532">A partir de la [!INCLUDE[net_v451](~/includes/net-v451-md.md)], va a utilizar common language runtime [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) en un [!INCLUDE[wrt](~/includes/wrt-md.md)] objeto antes de usar la implementación predeterminada de <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-532">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="14eb3-533"> las clases que se escriben en C# o Visual Basic pueden invalidar la <xref:System.Object.ToString%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14eb3-533"> classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="14eb3-534">El [!INCLUDE[wrt](~/includes/wrt-md.md)] y la interfaz de IStringable</span><span class="sxs-lookup"><span data-stu-id="14eb3-534">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="14eb3-535">A partir de [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] incluye un [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfaz cuyo único método, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), proporciona compatibilidad básica de formato comparable a la que ofrece <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14eb3-535">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="14eb3-536">Para evitar la ambigüedad, no debería implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) en tipos administrados.</span><span class="sxs-lookup"><span data-stu-id="14eb3-536">To prevent ambiguity, you should not implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="14eb3-537">Cuando se llama a los objetos administrados por código nativo o código escrito en lenguajes como JavaScript o C++ / CX, que se presentan al implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="14eb3-537">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="14eb3-538">Common language runtime enrutará automáticamente las llamadas de [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) a <xref:System.Object.ToString%2A?displayProperty=nameWithType> en el evento [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) no está implementada en el objeto administrado.</span><span class="sxs-lookup"><span data-stu-id="14eb3-538">The common language runtime will automatically route calls from [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="14eb3-539">Dado que common language runtime auto-implementa [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) para todos los tipos en administrados [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicaciones, se recomienda que no proporciona su propio [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementación.</span><span class="sxs-lookup"><span data-stu-id="14eb3-539">Because the common language runtime auto-implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="14eb3-540">Implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) puede provocar un comportamiento no deseado al llamar a `ToString` desde el [!INCLUDE[wrt](~/includes/wrt-md.md)], C++ / CX o JavaScript.</span><span class="sxs-lookup"><span data-stu-id="14eb3-540">Implementing [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="14eb3-541">Si decide implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) en un tipo público administrado que se exporte en un [!INCLUDE[wrt](~/includes/wrt-md.md)] componente, se aplican las restricciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="14eb3-541">If you do choose to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="14eb3-542">Puede definir la [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) sólo en una relación "la clase implementa", como la interfaz</span><span class="sxs-lookup"><span data-stu-id="14eb3-542">You can define the [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="14eb3-543">en C# o</span><span class="sxs-lookup"><span data-stu-id="14eb3-543">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="14eb3-544">en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="14eb3-544">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="14eb3-545">No se puede implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) en una interfaz.</span><span class="sxs-lookup"><span data-stu-id="14eb3-545">You cannot implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="14eb3-546">No se puede declarar un parámetro de tipo [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="14eb3-546">You cannot declare a parameter to be of type [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="14eb3-547">[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) no puede ser el tipo de valor devuelto de un método, propiedad o campo.</span><span class="sxs-lookup"><span data-stu-id="14eb3-547">[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="14eb3-548">No se puede ocultar la [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementación de las clases base mediante una definición de método como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="14eb3-548">You cannot hide your [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="14eb3-549">En su lugar, el [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementación debe invalidar siempre la implementación de la clase base.</span><span class="sxs-lookup"><span data-stu-id="14eb3-549">Instead, the [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="14eb3-550">Solo puede ocultar una implementación de `ToString` invocándola en una instancia de clase fuertemente tipada.</span><span class="sxs-lookup"><span data-stu-id="14eb3-550">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="14eb3-551">Tenga en cuenta que en determinadas condiciones, las llamadas desde código nativo a un tipo administrado que implemente [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) u oculta su [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementación puede generar un comportamiento inesperado.</span><span class="sxs-lookup"><span data-stu-id="14eb3-551">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14eb3-552">
            <para>Al implementar sus propios tipos, se debe invalidar el <see cref="M:System.Object.ToString" /> método para devolver valores que son significativos para esos tipos. Las clases derivadas que necesitan más control sobre el formato de <see cref="M:System.Object.ToString" /> proporciona puede implementar la <see cref="T:System.IFormattable" /> interfaz. Su <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> método le permite definir cadenas de formato que controlan el formato y usar un <see cref="T:System.IFormatProvider" /> objeto que puede proporcionar para formato específico de la referencia cultural.  Invalidaciones de la <see cref="M:System.Object.ToString" /> método debe seguir estas directrices:-la cadena devuelta debe ser descriptivo y legibles por los seres humanos.  -La cadena devuelta debe identificar de forma exclusiva el valor de la instancia del objeto.  -La cadena devuelta debe ser lo más corta posible para que sea adecuada para su presentación por un depurador.  -El <see cref="M:System.Object.ToString" /> invalidación no debería devolver <see cref="F:System.String.Empty" /> o una cadena nula.  -El <see cref="M:System.Object.ToString" /> invalidación no debería iniciar una excepción.  -Si la representación de cadena de una instancia de tiene en cuenta la referencia cultural o se puede aplicar formato de varias maneras, implemente el <see cref="T:System.IFormattable" /> interfaz.  -Si la cadena devuelta incluye la información confidencial, primero debería exigir un permiso adecuado. Si la demanda es correcta, puede devolver la información confidencial; de lo contrario, debe devolver una cadena que excluye la información confidencial.  -El <see cref="M:System.Object.ToString" /> reemplazo no debe tener efectos deseados de observable para evitar las complicaciones en la depuración. Por ejemplo, una llamada a la <see cref="M:System.Object.ToString" /> método no debería cambiar el valor de los campos de instancia.  -Si el tipo implementa un método de análisis (o <see langword="Parse" /> o <see langword="TryParse" /> método, un constructor o algún otro método estático que crea una instancia del tipo de una cadena), debe asegurarse de que la cadena devuelta por la <see cref="M:System.Object.ToString" /> puede ser (método) convertir en una instancia de objeto.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14eb3-552">
              <para>When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types. Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface. Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.  Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:  -   The returned string should be friendly and readable by humans.  -   The returned string should uniquely identify the value of the object instance.  -   The returned string should be as short as possible so that it is suitable for display by a debugger.  -   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.  -   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.  -   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.  -   If the returned string includes sensitive information, you should first demand an appropriate permission. If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.  -   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging. For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.  -   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>