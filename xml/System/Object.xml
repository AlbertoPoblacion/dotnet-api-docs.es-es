<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="795aa213f55320afb69e8ac92a851b4700704644" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52734513" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Admite todas las clases de la jerarquía de clases de .NET Framework y proporciona servicios de bajo nivel a las clases derivadas. Se trata de la clase base fundamental de todas las clases de .NET Framework; es la raíz de la jerarquía de tipos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Idiomas normalmente no requieren una clase para declarar la herencia de <xref:System.Object> porque la herencia está implícita.  
  
 Dado que se derivan todas las clases de .NET Framework <xref:System.Object>, cada método definido en el <xref:System.Object> clase está disponible en todos los objetos en el sistema. Las clases derivadas pueden e invalidar algunos de estos métodos, incluidos:  
  
-   <xref:System.Object.Equals%2A> -Admite comparaciones entre objetos.  
  
-   <xref:System.Object.Finalize%2A> -Realiza operaciones de limpieza antes de que un objeto se reclama automáticamente.  
  
-   <xref:System.Object.GetHashCode%2A> -Genera un número que corresponde al valor del objeto para admitir el uso de una tabla hash.  
  
-   <xref:System.Object.ToString%2A> -Crea una cadena de texto legible que describe una instancia de la clase.  
  
## <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 Si está diseñando una clase, como una colección, que debe controlar cualquier tipo de objeto, puede crear miembros de clase que acepten instancias de la <xref:System.Object> clase. Sin embargo, el proceso de conversión boxing y unboxing a un tipo implica un costo de rendimiento. Si conoce que la nueva clase controlará con frecuencia ciertos tipos de valor puede utilizar uno de dos tácticas para minimizar el costo de la conversión boxing.  
  
-   Crear un método general que acepta un <xref:System.Object> tipo y un conjunto de sobrecargas del método específico del tipo que acepte cada tipo de valor que se espera que la clase controle con frecuencia. Si no existe un método específico del tipo que acepta el tipo de parámetro que realiza la llamada, se produce ninguna conversión boxing y se invoca el método específico del tipo. Si no hay ningún argumento de método que coincida con el tipo de parámetro que realiza la llamada, se aplica el parámetro y se invoca el método general.  
  
-   Diseñe su tipo y sus miembros para utilizar genéricos. Common language runtime crea un tipo genérico cerrado cuando se crea una instancia de la clase y especificar un argumento de tipo genérico. El método genérico es específico del tipo y se puede invocar sin conversión boxing al parámetro de llamada.  
  
 Aunque a veces es necesario desarrollar clases de propósito general que aceptan y devuelven <xref:System.Object> tipos, puede mejorar el rendimiento al proporcionar también una clase específica del tipo para controlar un tipo de uso frecuente. Por ejemplo, elimina el costo de conversión boxing y unboxing valores booleanos que proporciona una clase que es específica para establecer y obtener los valores booleanos.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un tipo de punto que se deriva el <xref:System.Object> clase e invalida muchos de los métodos virtuales de la <xref:System.Object> clase. Además, el ejemplo muestra cómo llamar a muchos de los métodos estático y los métodos de la instancia la <xref:System.Object> clase.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Estáticos públicos (<see langword="Shared" /> en Visual Basic) los miembros de este tipo son seguros para subprocesos. Los miembros de instancia no se garantiza que sea seguro para subprocesos.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor llama a constructores de clases derivadas, pero también puede usarse para crear directamente una instancia de la <xref:System.Object> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si dos instancias de objeto son iguales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con el objeto actual.</param>
        <summary>Determina si el objeto especificado es igual al objeto actual.</summary>
        <returns>Es <see langword="true" /> si el objeto especificado es igual al objeto actual; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo de comparación entre la instancia actual y el `obj` parámetro depende de si la instancia actual es un tipo de referencia o un tipo de valor.  
  
-   Si la instancia actual es un tipo de referencia, el <xref:System.Object.Equals%28System.Object%29> método comprueba la igualdad de referencia y una llamada a la <xref:System.Object.Equals%28System.Object%29> es equivalente a una llamada al método el <xref:System.Object.ReferenceEquals%2A> método. Igualdad de referencia significa que las variables de objeto que se comparan hacen referencia al mismo objeto. El ejemplo siguiente muestra el resultado de una comparación de este tipo. Define un `Person` (clase), que es un tipo de referencia, y llama a la `Person` constructor de clase para crear dos instancias nuevo `Person` objetos, `person1a` y `person2`, que tienen el mismo valor. También asigna `person1a` a otra variable de objeto, `person1b`. Como se muestra en el ejemplo, la salida `person1a` y `person1b` son iguales porque hacen referencia al mismo objeto. Sin embargo, `person1a` y `person2` no son iguales, aunque tienen el mismo valor.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Si la instancia actual es un tipo de valor, el <xref:System.Object.Equals%28System.Object%29> método comprueba la igualdad de valor. Igualdad de valores significa lo siguiente:  
  
    -   Los dos objetos son del mismo tipo. Como se muestra en el ejemplo siguiente, un <xref:System.Byte> no es igual que el objeto que tiene un valor de 12 una <xref:System.Int32> objeto que tiene un valor de 12, porque los dos objetos tienen distintos tipos de tiempo de ejecución.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Los valores de los campos públicos y privados de los dos objetos son iguales. El ejemplo siguiente se comprueba la igualdad de valor. Define un `Person` estructura, que es un tipo de valor, y llama a la `Person` constructor de clase para crear dos instancias nuevo `Person` objetos, `person1` y `person2`, que tienen el mismo valor. Como se muestra el resultado del ejemplo, aunque las dos variables de objeto hacen referencia a objetos diferentes, `person1` y `person2` son iguales porque tienen el mismo valor para la privada `personName` campo.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Dado que el <xref:System.Object> clase es la clase base para todos los tipos en .NET Framework, el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método proporciona la comparación de igualdad predeterminado para todos los demás tipos. Sin embargo, los tipos a menudo invalidar el <xref:System.Object.Equals%2A> método para implementar la igualdad de valores. Para obtener más información, vea las notas para los autores de llamadas y notas de las secciones de los herederos.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Cuando se llama a la <xref:System.Object.Equals%28System.Object%29> sobrecarga del método en una clase de la [!INCLUDE[wrt](~/includes/wrt-md.md)], proporciona el comportamiento predeterminado para las clases que no se invalidan <xref:System.Object.Equals%28System.Object%29>. Esto forma parte de la compatibilidad que .NET Framework proporciona para el [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [soporte técnico para Windows Store aplicaciones de .NET Framework y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Las clases en el [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.Object>y actualmente no se implementa un <xref:System.Object.Equals%28System.Object%29> método. Sin embargo, parece que tienen <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, y <xref:System.Object.GetHashCode%2A> métodos al usarlos en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado de estos métodos.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] las clases que se escriben en C# o Visual Basic pueden reemplazar el <xref:System.Object.Equals%28System.Object%29> sobrecarga del método.  
  
## <a name="notes-for-callers"></a>Notas para los llamadores  
 Las clases derivadas reemplazan con frecuencia el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método para implementar la igualdad de valores. Además, los tipos también suelen ofrecen una sobrecarga adicional fuertemente tipada para el `Equals` método, normalmente mediante la implementación de la <xref:System.IEquatable%601> interfaz. Cuando se llama a la `Equals` método para comprobar la igualdad, debe saber si se reemplaza la instancia actual <xref:System.Object.Equals%2A?displayProperty=nameWithType> y entender cómo una determinada llamada a un `Equals` método se ha resuelto. En caso contrario, es posible que se realice una prueba de igualdad que es diferente de los previstos, y el método puede devolver un valor inesperado.  
  
 Esto se muestra en el ejemplo siguiente. Crea una instancia de tres <xref:System.Text.StringBuilder> objetos con cadenas idénticas y, a continuación, realiza cuatro llamadas a `Equals` métodos. La primera llamada al método devuelve `true`y la devolución de tres restantes `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 En el primer caso, fuertemente tipado <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> sobrecarga del método, que comprueba la igualdad de valor, se llama. Dado que las cadenas se asigna a los dos <xref:System.Text.StringBuilder> objetos son iguales, el método devuelve `true`. Sin embargo, <xref:System.Text.StringBuilder> no invalida <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. Por este motivo, cuando el <xref:System.Text.StringBuilder> objeto se convierte en un <xref:System.Object>, cuando un <xref:System.Text.StringBuilder> instancia se asigna a una variable de tipo <xref:System.Object>y cuándo el <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> se pasa al método dos <xref:System.Text.StringBuilder> objetos, el valor predeterminado <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>se llama al método. Dado que <xref:System.Text.StringBuilder> es un tipo de referencia, esto es equivalente a pasar los dos <xref:System.Text.StringBuilder> objetos a la <xref:System.Object.ReferenceEquals%2A> método. Aunque las tres <xref:System.Text.StringBuilder> objetos contienen cadenas idénticas, hacen referencia a tres objetos diferenciados. Como resultado, estos tres métodos llama devuelto `false`.  
  
 Puede comparar el objeto actual con otro objeto para la igualdad de referencia mediante una llamada a la <xref:System.Object.ReferenceEquals%2A> método. En Visual Basic, también puede usar el `is` palabra clave (por ejemplo, `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Notas para los herederos  
 Al definir su propio tipo, ese tipo hereda la funcionalidad definida por el `Equals` método de su tipo base. La tabla siguiente muestra la implementación predeterminada de la `Equals` método para las principales categorías de tipos en .NET Framework.  
  
|Categoría de tipo|Igualdad definido por|Comentarios|  
|-------------------|-------------------------|--------------|  
|Clase se deriva directamente <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Igualdad de referencia; equivalente a llamar a <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Estructura|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Igualdad de valor; comparación byte a byte directa o bien mediante la reflexión de comparación de campo por campo.|  
|Enumeración|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Valores deben tener el mismo tipo de enumeración y el mismo valor subyacente.|  
|Delegado|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Los delegados deben tener el mismo tipo con listas de invocación idénticos.|  
|Interfaz|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Igualdad de referencia.|  
  
 Para un tipo de valor, debe invalidar siempre <xref:System.Object.Equals%2A>, ya que comprueba la igualdad que se basan en la reflexión ofrece un rendimiento deficiente. También puede invalidar la implementación predeterminada de <xref:System.Object.Equals%2A> para tipos de referencia para comprobar la igualdad de valor en lugar de igualdad de referencia y para definir el significado exacto de la igualdad de valores. Este tipo de implementaciones de <xref:System.Object.Equals%2A> devolver `true` si los dos objetos tienen el mismo valor, aunque no sean la misma instancia. El implementador de tipos decide lo que constituye el valor de un objeto, pero suele ser algunos o todos los datos almacenados en las variables de instancia del objeto. Por ejemplo, el valor de un <xref:System.String> objeto se basa en los caracteres de la cadena; la <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> reemplazos de método la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método devuelva `true` para cualquier dos instancias que contienen los mismos caracteres en el mismo orden de cadena.  
  
 El ejemplo siguiente muestra cómo invalidar el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método para comprobar la igualdad de valores. Invalida el <xref:System.Object.Equals%2A> método para el `Person` clase. Si `Person` aceptado su implementación de la clase base de la igualdad de dos `Person` objetos serían iguales solo si hace referencia a un único objeto. Sin embargo, en este caso, dos `Person` objetos son iguales si tienen el mismo valor para el `Person.Id` propiedad.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Además de invalidar <xref:System.Object.Equals%2A>, puede implementar el <xref:System.IEquatable%601> interfaz para proporcionar una prueba de igualdad fuertemente tipada.  
  
 Deben cumplirse las siguientes instrucciones para todas las implementaciones de la <xref:System.Object.Equals%28System.Object%29> método. En la lista, `x`, `y`, y `z` representan las referencias de objeto que no sean **null**.  
  
-   `x.Equals(x)` Devuelve `true`, excepto en los casos que implican tipos de punto flotante. Vea ISO/IEC/IEEE 60559:2011, tecnología de la información--microprocesador sistemas--aritmética de punto flotante.  
  
-   `x.Equals(y)` devuelve el mismo valor que `y.Equals(x)`.  
  
-   `x.Equals(y)` Devuelve `true` si ambos `x` y `y` son `NaN`.  
  
-   Si `(x.Equals(y) && y.Equals(z))` devuelve `true`, a continuación, `x.Equals(z)` devuelve `true`.  
  
-   Las llamadas sucesivas a `x.Equals(y)` devuelven el mismo valor siempre y cuando los objetos al que hace referencia `x` y `y` no se modifican.  
  
-   `x.Equals(null)` devuelve `false`.  
  
 Las implementaciones de <xref:System.Object.Equals%2A> no deben producir excepciones; siempre debe devolver un valor. Por ejemplo, si `obj` es `null`, <xref:System.Object.Equals%2A> método debe devolver `false` en lugar de producir una <xref:System.ArgumentNullException>.  
  
 Siga estas instrucciones cuando se reemplaza <xref:System.Object.Equals%28System.Object%29>:  
  
-   Los tipos que implementan <xref:System.IComparable> debe invalidar <xref:System.Object.Equals%28System.Object%29>.  
  
-   Los tipos que reemplazan <xref:System.Object.Equals%28System.Object%29> también debe invalidar <xref:System.Object.GetHashCode%2A>; de lo contrario, las tablas hash no funcionen correctamente.  
  
-   Debe considerar implementar la <xref:System.IEquatable%601> interfaz para admitir fuertemente tipados comprueba la igualdad. Su <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementación debería devolver los resultados que sean coherentes con <xref:System.Object.Equals%2A>.  
  
-   Si su lenguaje de programación admite la sobrecarga de operadores y sobrecargar el operador de igualdad para un tipo determinado, también debe invalidar el <xref:System.Object.Equals%28System.Object%29> método para devolver el mismo resultado que el operador de igualdad. Esto ayuda a garantizar ese código de biblioteca de clases que utiliza <xref:System.Object.Equals%2A> (como <xref:System.Collections.ArrayList> y <xref:System.Collections.Hashtable>) se comporta de forma que sea coherente con la manera en que se usa el operador de igualdad por código de aplicación.  
  
### <a name="guidelines-for-reference-types"></a>Directrices para los tipos de referencia  
 Las siguientes directrices se aplican a reemplazar <xref:System.Object.Equals%28System.Object%29> para un tipo de referencia:  
  
-   Considere la posibilidad de invalidar <xref:System.Object.Equals%2A> si la semántica del tipo se basa en el hecho de que el tipo representa algunos valores.  
  
-   La mayoría de los tipos de referencia no deben sobrecargar el operador de igualdad, aunque reemplacen <xref:System.Object.Equals%2A>. Sin embargo, si está implementando un tipo de referencia que pretende tener semántica de valor, como un tipo de número complejo, debe reemplazar el operador de igualdad.  
  
-   No se debe reemplazar <xref:System.Object.Equals%2A> en un tipo de referencia mutable. Esto es porque reemplazar <xref:System.Object.Equals%2A> requiere que invalide también el <xref:System.Object.GetHashCode%2A> método, como se describe en la sección anterior. Esto significa que puede cambiar el código hash de una instancia de un tipo de referencia mutable durante su vigencia, lo que puede producir el objeto se perderá en una tabla hash.  
  
### <a name="guidelines-for-value-types"></a>Directrices para los tipos de valor  
 Las siguientes directrices se aplican a reemplazar <xref:System.Object.Equals%28System.Object%29> para un tipo de valor:  
  
-   Si va a definir un tipo de valor que incluye uno o más campos cuyos valores son tipos de referencia, debe reemplazar <xref:System.Object.Equals%28System.Object%29>. El <xref:System.Object.Equals%28System.Object%29> implementación proporcionada por <xref:System.ValueType> realiza una comparación byte a byte para tipos de valor cuyos campos son todos los tipos de valor, pero usa la reflexión para realizar una comparación de campo por campo de tipos de valor cuyos campos incluyen tipos de referencia.  
  
-   Si invalida <xref:System.Object.Equals%2A> y el lenguaje de programación admite la sobrecarga de operadores, debe sobrecargar el operador de igualdad.  
  
-   Debe implementar la <xref:System.IEquatable%601> interfaz. Una llamada a fuertemente tipado <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método impide la conversión boxing el `obj` argumento.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra un `Point` clase que invalide la <xref:System.Object.Equals%2A> método para proporcionar la igualdad de valores y un `Point3D` clase que se deriva de `Point`. Dado que `Point` invalida <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para comprobar la igualdad de valores, el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> no se llama al método. Sin embargo, `Point3D.Equals` llamadas `Point.Equals` porque `Point` implementa <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> en un modo que ofrezca igualdad de valores.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 El `Point.Equals` método comprueba para asegurarse de que el `obj` argumento no es **null** que hace referencia a una instancia del mismo tipo que este objeto. Si hay alguna comprobación se produce un error, el método devuelve `false`.  
  
 El `Point.Equals` llamadas al método el <xref:System.Object.GetType%2A> método para determinar si los tipos de tiempo de ejecución de los dos objetos son idénticos. Si el método utiliza una comprobación del formulario `obj is Point` en C# o `TryCast(obj, Point)` en Visual Basic, la comprobación devolverá `true` en casos donde `obj` es una instancia de una clase derivada de `Point`, aunque `obj` y actual instancia no son del mismo tipo de tiempo de ejecución. Después de comprobar que ambos objetos son del mismo tipo, el método convierte `obj` escriba `Point` y devuelve el resultado de la comparación de los campos de instancia de los dos objetos.  
  
 En `Point3D.Equals`, heredadas `Point.Equals` método, lo que invalida <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, se invoca antes de realiza cualquier otra cosa. Dado que `Point3D` es una clase sealed (`NotInheritable` en Visual Basic), una comprobación en el formulario `obj is Point` en C# o `TryCast(obj, Point)` en Visual Basic es la adecuada para asegurarse de que `obj` es un `Point3D` objeto. Si es un `Point3D` objeto, se convierte en un `Point` de objetos y pasa a la implementación de clase base <xref:System.Object.Equals%2A>. Solo cuando el heredado `Point.Equals` devuelve del método `true` el método de comparación la `z` introducidos en la clase derivada de campos de instancia.  
  
 En el ejemplo siguiente se define un `Rectangle` clase que implementa internamente un rectángulo como dos `Point` objetos. El `Rectangle` también clase invalidaciones <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para proporcionar la igualdad de valores.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Algunos lenguajes como C# y Visual Basic admiten la sobrecarga de operadores. Cuando un tipo sobrecarga el operador de igualdad, también debe invalidar el <xref:System.Object.Equals%28System.Object%29> método para proporcionar la misma funcionalidad. Normalmente, esto se logra escribiendo el <xref:System.Object.Equals%28System.Object%29> método en términos del operador de igualdad sobrecargado, como en el ejemplo siguiente.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Dado que `Complex` es un tipo de valor, no se pueden derivar.  Por lo tanto, la invalidación <xref:System.Object.Equals%28System.Object%29> no necesita llamar al método <xref:System.Object.GetType%2A> para determinar el tiempo de ejecución preciso escriba de cada objeto, pero en su lugar, use el `is` operador en C# o la `TypeOf` operador en Visual Basic para comprobar el tipo de la `obj` parámetro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Primer objeto que se va a comparar.</param>
        <param name="objB">Segundo objeto que se va a comparar.</param>
        <summary>Determina si las instancias del objeto especificado se consideran iguales.</summary>
        <returns>Es <see langword="true" /> si los dos objetos se consideran iguales; en caso contrario, es <see langword="false" />. Si tanto <paramref name="objA" /> como <paramref name="objB" /> son **null**, el método devuelve <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método indica si dos objetos, `objA` y `objB`, son iguales. También permite probar los objetos cuyo valor es **null** igualdad. Compara `objA` y `objB` igualdad como sigue:  
  
-   Determina si los dos objetos representan la misma referencia de objeto. Si es así, el método devuelve `true`. Esta prueba es equivalente a llamar a la <xref:System.Object.ReferenceEquals%2A> método. Además, si ambos `objA` y `objB` son **null**, el método devuelve `true`.  
  
-   Determina si ya sea `objA` o `objB` es **null**. Si es así, devuelve `false`.  
  
-   Si los dos objetos no representan la misma referencia de objeto y ninguna de ellas es **null**, llama a `objA`.`Equals` (`objB`) y devuelve el resultado. Esto significa que si `objA` invalida la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , esta invalidación se llama al método.  
  
   
  
## Examples  
 El ejemplo siguiente ilustra la <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método y lo compara con el <xref:System.Object.ReferenceEquals%2A> método.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que un objeto intente liberar recursos y realizar otras operaciones de limpieza antes de que sea reclamado por la recolección de elementos no utilizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Object.Finalize%2A> método se usa para realizar operaciones de limpieza en los recursos no administrados mantenidos por el objeto actual antes de que se destruya el objeto. El método está protegido y, por tanto, es accesible sólo a través de esta clase o una clase derivada.  
  
 En esta sección:  
  
-   [Cómo funciona la finalización](#How)  
  
-   [Notas para los implementadores](#Notes)  
  
-   [La alternativa SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Cómo funciona la finalización  
 El <xref:System.Object> clase no proporciona ninguna implementación para el <xref:System.Object.Finalize%2A> método y el recolector de elementos no utilizados no marcar los tipos derivados de <xref:System.Object> para la finalización, a menos que invalide la <xref:System.Object.Finalize%2A> método.  
  
 Si un tipo de invalidar el <xref:System.Object.Finalize%2A> método, el recolector de elementos no utilizados agrega una entrada para cada instancia del tipo a una estructura interna denominada cola de finalización. La cola de finalización contiene entradas para todos los objetos del montón administrado cuyo código de finalización se debe ejecutar antes de que el recolector de elementos no utilizados pueda reclamar su memoria. El recolector de elementos no utilizados, a continuación, llama a la <xref:System.Object.Finalize%2A> método automáticamente en las siguientes condiciones:  
  
-   Después de que el recolector de elementos no utilizados ha detectado que un objeto es inaccesible, a menos que el objeto se ha excluido de la finalización mediante una llamada a la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.  
  
-   **En .NET Framework solo**, durante el cierre de un dominio de aplicación, a menos que el objeto está exento de la finalización. Durante el cierre, incluso los objetos que siguen siendo accesibles se finalizan.  
  
 <xref:System.Object.Finalize%2A> se llama automáticamente una sola vez en una instancia determinada, a menos que el objeto es volver a registrar mediante un mecanismo como <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> y <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método no se ha llamado posteriormente.  
  
 <xref:System.Object.Finalize%2A> las operaciones tienen las siguientes limitaciones:  
  
-   El tiempo exacto cuando se ejecuta el finalizador es indefinido. Para garantizar la liberación determinista de recursos para implementar las instancias de la clase, un `Close` método o proporcione un <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación.  
  
-   Los finalizadores de dos objetos no se garantiza que se ejecuten en un orden determinado, incluso si un objeto hace referencia a otro. Es decir, si un objeto tiene una referencia al objeto B, y ambos tienen finalizadores, objeto B es posible que ya ha finalizado cuando se inicia el finalizador del objeto.  
  
-   El subproceso en el que se ejecuta el finalizador no está especificado.  
  
 El <xref:System.Object.Finalize%2A> método podría no ejecutarse hasta su finalización o podría no ejecutarse en absoluto en las siguientes circunstancias excepcionales:  
  
-   Si otro finalizador se bloquea indefinidamente (entrarán en un bucle infinito, intenta obtener un bloqueo, nunca puede obtener y así sucesivamente). Dado que el tiempo de ejecución intenta ejecutar los finalizadores hasta su finalización, es posible que no se llame a otros finalizadores si un finalizador se bloquea de forma indefinida.  
  
-   Si el proceso finaliza sin tener que proporcionar el tiempo de ejecución de una oportunidad para limpiar. En este caso, la primera notificación de finalización del proceso del tiempo de ejecución es una notificación DLL_PROCESS_DETACH.  
  
 El tiempo de ejecución sigue finalizar los objetos durante el apagado sólo mientras continúa disminuyendo el número de objetos susceptibles de finalización.  
  
 Si <xref:System.Object.Finalize%2A> o un reemplazo de <xref:System.Object.Finalize%2A> inicia una excepción y el tiempo de ejecución no está hospedado por una aplicación que reemplace la directiva predeterminada, el runtime finaliza el proceso y no activa `try` / `finally` bloques o se ejecutan los finalizadores. Este comportamiento garantiza la integridad del proceso si el finalizador no puede liberar o destruir recursos.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Invalidación del método Finalize 
 Se debe reemplazar <xref:System.Object.Finalize%2A> para una clase que usa recursos no administrados, como identificadores de archivos o las conexiones de base de datos que deben liberarse cuando se descarta el objeto administrado que se usa durante la recolección de elementos no utilizados. No debe implementar un <xref:System.Object.Finalize%2A> método para objetos administrados, porque el recolector de elementos no utilizados libera los recursos administrados automáticamente.  
  
> [!IMPORTANT]
>  Si un <xref:System.Runtime.InteropServices.SafeHandle> hay un objeto que contiene el recurso no administrado, la alternativa recomendada es implementar el patrón de dispose con un identificador seguro y no reemplazar <xref:System.Object.Finalize%2A>. Para obtener más información, consulte [alternativa SafeHandle The](#SafeHandle) sección.  
  
 El <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método no hace nada de forma predeterminada, pero se debe invalidar <xref:System.Object.Finalize%2A> solo si es necesario y solo para liberar recursos no administrados. Reclamar memoria suele tardar mucho más tiempo si se ejecuta una operación de finalización, porque requiere al menos dos recolecciones de elementos no utilizados. Además, se debe reemplazar el <xref:System.Object.Finalize%2A> solo los tipos de método como referencia. Common language runtime finaliza solo los tipos de referencia. Omite los finalizadores en tipos de valor.  

El ámbito de la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método es `protected`. Mantenga este ámbito limitado cuando reemplace el método en su clase. Si se mantiene un <xref:System.Object.Finalize%2A> método protegido, evitar que los usuarios de la aplicación de la llamada a un objeto <xref:System.Object.Finalize%2A> método directamente.
  
 Todas las implementaciones de <xref:System.Object.Finalize%2A> en un tipo derivado debe llamar a implementación de su tipo base de <xref:System.Object.Finalize%2A>. Este es el único caso en la aplicación que se puede llamar a código <xref:System.Object.Finalize%2A>. Un objeto <xref:System.Object.Finalize%2A> método no debería llamar a un método en todos los objetos que no sean de su clase base. El motivo es que los otros objetos a los que se llama podrían ser recolectados al mismo tiempo que el objeto que llama, por ejemplo, en el caso de un cierre de Common Language Runtime. 
  
> [!NOTE]
>  El compilador de C# no permite invalidar el <xref:System.Object.Finalize%2A> método. En su lugar, proporciona un finalizador implementando un [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) para la clase. Un destructor de C# llama automáticamente al destructor de su clase base.  
>   
>  Visual C++ también proporciona su propia sintaxis para implementar el <xref:System.Object.Finalize%2A> método. Para obtener más información, vea la sección "Destructores y finalizadores" de [Cómo: definir y utilizar clases y Structs (C++ / c++ / CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Porque la recolección de elementos no es determinista, no sabe exactamente cuando el recolector de elementos no utilizados realiza finalización. Para liberar recursos inmediatamente, también puede implementar la [patrón de dispose](~/docs/standard/design-guidelines/dispose-pattern.md) y <xref:System.IDisposable> interfaz. El <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación se puede llamar a los consumidores de la clase para liberar recursos no administrados, y puede usar el <xref:System.Object.Finalize%2A> método para liberar recursos no administrados en caso de que el <xref:System.IDisposable.Dispose%2A> no se llama al método.  
  
 <xref:System.Object.Finalize%2A> puede tomar casi cualquier acción, como el restablecimiento de un objeto (es decir, hacer que el objeto accesible nuevo) una vez que se ha limpiado durante la recolección de elementos no utilizados. Sin embargo, el objeto sólo puede restablecerse una vez; <xref:System.Object.Finalize%2A> no puede llamarse en objetos restablecidos durante la recolección de elementos no utilizados. Hay una acción que la implementación de <xref:System.Object.Finalize%2A> nunca debe tomar: nunca debe producir una excepción. Si las excepciones producidas por los métodos que se llama desde el <xref:System.Object.Finalize%2A> método no se controla mediante el <xref:System.Object.Finalize%2A> método, el tiempo de ejecución supone que el <xref:System.Object.Finalize%2A> devuelto de método y sigue llamando al <xref:System.Object.Finalize%2A> métodos de otros objetos. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>La alternativa SafeHandle  
 Creación de los finalizadores confiables a menudo es difícil, dado que no puede realizar suposiciones sobre el estado de la aplicación así como excepciones no controladas de sistema, como <xref:System.OutOfMemoryException> y <xref:System.StackOverflowException> terminar el finalizador. En lugar de implementar un finalizador para la clase para liberar recursos no administrados, puede usar un objeto que se deriva el <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> clase para encapsular los recursos no administrados y, a continuación, implementar el patrón de dispose sin un finalizador. .NET Framework proporciona las siguientes clases en el <xref:Microsoft.Win32?displayProperty=nameWithType> espacio de nombres que se derivan de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> es una clase contenedora para un identificador de archivo.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> es una clase contenedora para los identificadores de archivo asignado a memoria.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> es una clase contenedora para un puntero a un bloque de memoria no administrada.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, y <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> son clases contenedoras para los identificadores cifrados.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> es una clase contenedora para los identificadores de canalización.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> es una clase contenedora para un identificador de una clave del registro.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> es una clase contenedora para un identificador de espera.  
  
 En el ejemplo siguiente se usa el [patrón de dispose](~/docs/standard/design-guidelines/dispose-pattern.md) con identificadores seguros en lugar de reemplazar el <xref:System.Object.Finalize%2A> método. Define un `FileAssociation` clase que encapsula la información del registro acerca de la aplicación que controla los archivos con una extensión de archivo determinada. Los identificadores de dos registro devueltos como `out` parámetros por Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) las llamadas de función se pasan a la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor. Protegido el tipo `Dispose` método, a continuación, llama a la `SafeRegistryHandle.Dispose` método para liberar estos dos identificadores.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 En el ejemplo siguiente se comprueba que el <xref:System.Object.Finalize%2A> método se llama cuando un objeto que reemplaza <xref:System.Object.Finalize%2A> se destruye. Tenga en cuenta que, en una aplicación de producción, el <xref:System.Object.Finalize%2A> se reemplazaría el método para liberar recursos no administrados mantenidos por el objeto. Tenga en cuenta también que el ejemplo de C# proporciona un destructor en lugar de reemplazar el <xref:System.Object.Finalize%2A> método.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Para obtener un ejemplo adicional que reemplaza el <xref:System.Object.Finalize%2A> método, consulte el <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sirve como la función hash predeterminada.</summary>
        <returns>Código hash para el objeto actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un código hash es un valor numérico que se usa para insertar e identificar un objeto en una colección basada en hash, como el <xref:System.Collections.Generic.Dictionary%602> (clase), el <xref:System.Collections.Hashtable> clase o un tipo derivado de la <xref:System.Collections.DictionaryBase> clase. El <xref:System.Object.GetHashCode%2A> método proporciona este código hash para los algoritmos que necesitan comprobaciones rápidas de igualdad de objetos.  
  
> [!NOTE]
>  Para obtener información sobre cómo se usan códigos hash en tablas hash y algunos algoritmos de código hash adicionales, consulte el [función Hash](https://en.wikipedia.org/wiki/Hash_function) entrada en Wikipedia.  
  
 Dos objetos que son los códigos hash devuelto igual que son iguales. Sin embargo, lo contrario no es cierto: códigos hash iguales implica la igualdad de objetos, dado que diferentes objetos (iguales) pueden tener los códigos hash idénticos. Además, .NET Framework no garantiza la implementación predeterminada de la <xref:System.Object.GetHashCode%2A> método y el valor que devuelve este método puede diferir entre las versiones de .NET Framework y plataformas, como plataformas de 32 bits y 64 bits. Por estas razones, no use la implementación predeterminada de este método como un identificador de objeto único para fines de hash. Siguen dos consecuencias de esto:  
  
-   No debe suponer que los códigos hash iguales impliquen igualdad de objetos.  
  
-   Nunca debe conservar o usar un código hash fuera del dominio de aplicación en el que se creó, porque puede hash al mismo objeto a través de plataformas, procesos y dominios de aplicación.  
  
> [!WARNING]
>  Un código hash está destinado a una inserción y la búsqueda en las colecciones que se basan en una tabla hash. Un código hash no es un valor permanente. Por este motivo:  
>   
> -   No serializar los valores de código hash o almacenarlos en las bases de datos.  
> -   No utilice el código hash como clave para recuperar un objeto de una colección con clave.  
> -   No envíe los códigos hash entre dominios de aplicación o procesos. En algunos casos, es posible que se puede calcular códigos hash según el dominio por proceso o por aplicación.  
> -   No use el código hash en lugar de un valor devuelto por una función hash criptográfica si necesita un hash criptográficamente sólidos. Para algoritmos hash criptográficos, use una clase derivada de la <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> o <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> clase.  
> -   No comprobar la igualdad de los códigos hash para determinar si dos objetos son iguales. (Objetos distintos pueden tener los códigos hash idénticos). Para comprobar la igualdad, llame a la <xref:System.Object.ReferenceEquals%2A> o <xref:System.Object.Equals%2A> método.  
  
 El <xref:System.Object.GetHashCode%2A> método puede reemplazarse por un tipo derivado. Si <xref:System.Object.GetHashCode%2A> es no reemplaza los códigos hash para los tipos de referencia se calculan mediante una llamada a la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método de la clase base, que calcula un código hash basado en la referencia de un objeto; para obtener más información, consulte <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. En otras palabras, dos objetos para los que el <xref:System.Object.ReferenceEquals%2A> devuelve del método `true` tienen códigos hash idénticos. Si los tipos de valor no reemplazan <xref:System.Object.GetHashCode%2A>, el <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> método de la clase base utiliza la reflexión para calcular el código hash basado en los valores de los campos del tipo. En otras palabras, cuyos campos tienen los mismos valores de tipos de valor tienen códigos hash iguales. Para obtener más información sobre cómo invalidar <xref:System.Object.GetHashCode%2A>, consulte la sección "Notas para los herederos".  
  
> [!WARNING]
>  Si invalida el <xref:System.Object.GetHashCode%2A> método, también debe invalidar <xref:System.Object.Equals%2A>y viceversa. Si su invalidado <xref:System.Object.Equals%2A> devuelve del método `true` cuando dos objetos se comprueban si son iguales, anulado <xref:System.Object.GetHashCode%2A> método debe devolver el mismo valor para los dos objetos.  
  
 Si un objeto que se utiliza como clave en una tabla hash no proporciona una implementación útil de <xref:System.Object.GetHashCode%2A>, puede especificar un proveedor de código hash proporcionando un <xref:System.Collections.IEqualityComparer> implementación a una de las sobrecargas de los <xref:System.Collections.Hashtable> constructor de clase.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Cuando se llama a la <xref:System.Object.GetHashCode%2A> método en una clase en el [!INCLUDE[wrt](~/includes/wrt-md.md)], proporciona el comportamiento predeterminado para las clases que no se invalidan <xref:System.Object.GetHashCode%2A>. Esto forma parte de la compatibilidad que .NET Framework proporciona para el [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [soporte técnico para Windows Store aplicaciones de .NET Framework y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Las clases en el [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.Object>y actualmente no se implementa un <xref:System.Object.GetHashCode%2A>. Sin embargo, parece que tienen <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, y <xref:System.Object.GetHashCode%2A> métodos al usarlos en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado de estos métodos.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] las clases que se escriben en C# o Visual Basic pueden reemplazar el <xref:System.Object.GetHashCode%2A> método.  
  
   
  
## Examples  
 Una de las maneras más sencillas para calcular un código hash para un valor numérico que tiene el mismo o un intervalo más pequeño que el <xref:System.Int32> tipo es simplemente devolver ese valor. El ejemplo siguiente muestra este tipo de implementación para un `Number` estructura.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Con frecuencia, un tipo tiene varios campos de datos que pueden participar en la generación de código hash. Una manera de generar un código hash consiste en combinar estos campos utilizando un `XOR (eXclusive OR)` operación, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 El ejemplo anterior devuelve el mismo código hash de (n1, n2) y (n2 n1) por lo que puede generar más colisiones que son deseables. Una serie de soluciones está disponible para que los códigos hash en estos casos no son idénticos. Una consiste en devolver el código hash de un `Tuple` objeto que refleja el orden de cada campo. El ejemplo siguiente muestra una posible implementación que usa el <xref:System.Tuple%602> clase. Sin embargo, tenga en cuenta que la sobrecarga de rendimiento de crear instancias de un `Tuple` objeto puede afectar significativamente al rendimiento general de una aplicación que almacena grandes cantidades de objetos en las tablas hash.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Una segunda solución alternativa implica la ponderación de los códigos hash individuales por desplazamiento hacia la izquierda los códigos hash de campos sucesivos por dos o más bits. De forma óptima, en lugar de descartarlas, bits desplazados más allá de 31 bits deben ajustarse en lugar de descartarse. Puesto que se descartan los bits por los operadores de desplazamiento a la izquierda en C# y Visual Basic, esto requiere la creación de un método de encapsulado de MAYÚS izquierdo similar al siguiente:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 El ejemplo siguiente utiliza, a continuación, este método de ajuste de desplazamiento para calcular el código hash de la `Point` estructura utilizada en los ejemplos anteriores.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Una función hash se utiliza para generar rápidamente un número (código hash) que corresponde al valor de un objeto. Las funciones hash suelen ser están para cada tipo y, para la unicidad, deben utilizar al menos uno de los campos de instancia como entrada. No se deben calcular códigos hash mediante el uso de los valores de los campos estáticos.  
  
Para las clases derivadas de <see cref="T:System.Object" />, <see langword="GetHashCode" /> método puede delegar a la clase base <see cref="M:System.Object.GetHashCode" /> implementación sólo si la clase derivada define la igualdad para que sea la igualdad de referencia. La implementación predeterminada de <see cref="M:System.Object.GetHashCode" /> para referencia tipos devuelve un código hash que es equivalente a la devuelta por la <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> método. Puede invalidar <see cref="M:System.Object.GetHashCode" /> para tipos de referencia inmutable. En general, para los tipos de referencia mutable, debe invalidar <see cref="M:System.Object.GetHashCode" /> solo si: 
-Se puede calcular el código hash de campos que no son mutables; o 
-Puede asegurarse de que el código hash de un objeto mutable no cambia y el objeto se encuentra en una colección que se basa en su código hash.  
  
En caso contrario, podría pensar que el objeto mutable se pierde en la tabla hash. Si opta por reemplazar <see cref="M:System.Object.GetHashCode" /> para un tipo de referencia mutable, la documentación debe dejar claro que los usuarios de su tipo no deben modificar los valores de objeto, mientras que el objeto se almacena en una tabla hash.  
  
Para los tipos de valor, <see cref="M:System.ValueType.GetHashCode" /> proporciona una implementación de código hash de forma predeterminada que usa la reflexión. Considere la posibilidad de reemplazarlo para mejorar el rendimiento.  
  
 <block subset="none" type="note"><para>  
 Para obtener más información y ejemplos que calculan códigos hash en una variedad de formas, vea la sección ejemplos.  
  
</para></block>  
  
 Una función hash debe tener las siguientes propiedades: 
-Si dos objetos se consideran iguales, la <see cref="M:System.Object.GetHashCode" /> método para cada objeto debe devolver el mismo valor. Sin embargo, si no se pueden comparar dos objetos como iguales, la <see cref="M:System.Object.GetHashCode" /> métodos para los dos objetos no tienen que devolver valores diferentes.  
  
-El <see cref="M:System.Object.GetHashCode" /> método para un objeto constantemente debe devolver el mismo código hash siempre y cuando no hay ninguna modificación en el estado del objeto que determina el valor devuelto por el objeto [System.Object.Equals](xref:System.Object.Equals*) método. Tenga en cuenta que esto es cierto solo para la ejecución actual de una aplicación y que se puede devolver un código hash diferente si se vuelve a ejecutar la aplicación.  
  
-Para un rendimiento óptimo, una función hash debe generar una distribución uniforme para todas las entradas, incluidas la entrada que está agrupado mucho. Una implicación es que realizar grandes modificaciones en el código hash resultante para un mejor rendimiento de la tabla de hash deberían producir pequeñas modificaciones en el estado del objeto.  
  
-Las funciones hash deben ser económicas calcular.  
  
-El <see cref="M:System.Object.GetHashCode" /> método no debería producir excepciones.  
  
Por ejemplo, la implementación de la <see cref="M:System.String.GetHashCode" /> método proporcionado por el <see cref="T:System.String" /> clase devuelve los códigos hash idénticos para los valores de cadena idénticos. Por lo tanto, dos <see cref="T:System.String" /> objetos devuelven el mismo código hash si representan el mismo valor de cadena. Además, el método utiliza todos los caracteres en la cadena para generar la salida de distribución aleatoria razonable, incluso cuando la entrada está en clúster en determinados intervalos (por ejemplo, muchos usuarios podrían tener cadenas que contienen solo los 128 caracteres ASCII inferiores, aunque un cadena puede contener ninguno de los 65.535 caracteres Unicode).  
  
Proporcionar una función hash adecuada en una clase significativamente puede afectar al rendimiento de la adición de esos objetos en una tabla hash. En una tabla hash con claves que proporcionan una buena implementación de una función hash, la búsqueda de un elemento toma tiempo constante (por ejemplo, una operación o (1)). En una tabla hash con una mala implementación de una función hash, el rendimiento de una búsqueda depende del número de elementos de la tabla hash (por ejemplo, una E/s (`n`) operación, donde `n` es el número de elementos de la tabla hash). Un usuario malintencionado puede escribir datos que aumenta el número de colisiones, lo que puede degradar significativamente el rendimiento de las aplicaciones que dependen las tablas hash, en las siguientes condiciones: 
-Cuando las funciones hash producen colisiones frecuentes.  
  
-Cuando una gran proporción de objetos en una tabla hash genera códigos hash son iguales o aproximadamente igual a uno del otro.  
  
-Cuando los usuarios introducir los datos desde el que se calcula el código hash.  
  
Las clases derivadas que invalidarán <see cref="M:System.Object.GetHashCode" /> también debe invalidar <see cref="M:System.Object.Equals(System.Object)" /> para garantizar que dos objetos que se consideran iguales tengan el mismo código hash; en caso contrario, el <see cref="T:System.Collections.Hashtable" /> tipo podría no funcionar correctamente.</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el <see cref="T:System.Type" /> de la instancia actual.</summary>
        <returns>El tipo en tiempo de ejecución exacto de la instancia actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que <xref:System.Object?displayProperty=nameWithType> es la clase base para todos los tipos en el sistema de tipos de .NET Framework, el <xref:System.Object.GetType%2A> método puede utilizarse para devolver <xref:System.Type> objetos que representan todos los tipos de .NET Framework. .NET Framework reconoce las cinco categorías de tipos siguientes:  
  
-   Las clases, que se derivan de <xref:System.Object?displayProperty=nameWithType>,  
  
-   Tipos de valor, que se derivan de <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Las interfaces, que se derivan de <xref:System.Object?displayProperty=nameWithType> a partir de .NET Framework 2.0.  
  
-   Enumeraciones, que se derivan de <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Delegados, lo que se derivan de <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Para dos objetos `x` y `y` que tienen tipos idénticos en tiempo de ejecución, `Object.ReferenceEquals(x.GetType(),y.GetType())` devuelve `true`. En el ejemplo siguiente se usa el <xref:System.Object.GetType%2A> método con el <xref:System.Object.ReferenceEquals%2A> método para determinar si un valor numérico es el mismo tipo que los otros dos valores numéricos.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Para determinar si un objeto es un tipo específico, puede usar la palabra clave de comparación de tipo de su lenguaje o construir. Por ejemplo, puede usar el `TypeOf…Is` construir en Visual Basic o `is` palabra clave en C#.  
  
 El <xref:System.Object.GetType%2A> método es heredado por todos los tipos que derivan de <xref:System.Object>. Esto significa que, además de utilizar la palabra clave de comparación de su propio lenguaje, se puede utilizar el <xref:System.Object.GetType%2A> método para determinar el tipo de un objeto determinado, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 El <xref:System.Type> objeto expone los metadatos asociados con la clase del elemento actual <xref:System.Object>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que <xref:System.Object.GetType%2A> devuelve el tipo en tiempo de ejecución de la instancia actual.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficial del <see cref="T:System.Object" /> actual.</summary>
        <returns>Copia superficial del <see cref="T:System.Object" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Object.MemberwiseClone%2A> método crea una copia superficial creando un nuevo objeto y, a continuación, copiar los campos no estáticos del objeto actual en el nuevo objeto. Si un campo es un tipo de valor, se realiza una copia bit a bit del campo. Si un campo es un tipo de referencia, se copia la referencia, pero el objeto que se hace referencia no; es por lo tanto, el objeto original y su clon hacen referencia al mismo objeto.  
  
 Por ejemplo, considere la posibilidad de un objeto denominado X que hace referencia a objetos A y B. objeto B, a su vez, el objeto references C. Una copia superficial de X crea el nuevo objeto X2 que también hace referencia a objetos A y B. En cambio, una copia en profundidad de X crea un nuevo objeto X2 que hace referencia a los nuevos objetos A2 y B2, que son copias de la A y B. B2, a su vez, hace referencia al objeto nuevo C2, que es una copia de C. En el ejemplo se muestra la diferencia entre una operación de copia en profundidad y un poco.  
  
 Hay muchas formas para implementar una operación de copia en profundidad si realiza la operación de copia superficial del <xref:System.Object.MemberwiseClone%2A> método no satisfacen sus necesidades. Entre ellas se incluyen las siguientes:  
  
-   Llamar a un constructor de clase del objeto que se va a copiar para crear un segundo objeto con valores de propiedad tomados del primer objeto. Se supone que los valores de un objeto completamente se definen mediante su constructor de clase.  
  
-   Llame a la <xref:System.Object.MemberwiseClone%2A> método para crear una copia superficial de un objeto y, a continuación, asignar nuevos objetos cuyos valores son los mismos que el objeto original para las propiedades o campos cuyos valores son tipos de referencia. El `DeepCopy` método en el ejemplo muestra este enfoque.  
  
-   Serializar el objeto como deep copiado y, a continuación, restaurar los datos serializados en una variable de objeto diferente.  
  
-   Usar la reflexión para realizar la operación de copia en profundidad con la recursión.  
  
   
  
## Examples  
 El ejemplo siguiente ilustra la <xref:System.Object.MemberwiseClone%2A> método. Define un `ShallowCopy` método al que llama el <xref:System.Object.MemberwiseClone%2A> método para realizar una operación de copia superficial de un `Person` objeto. También define un `DeepCopy` método que realiza una operación de copia en profundidad en un `Person` objeto.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 En este ejemplo, el `Person.IdInfo` propiedad devuelve un `IdInfo` objeto. Como la salida muestra el ejemplo, cuando un `Person` se clona el objeto mediante una llamada a la <xref:System.Object.MemberwiseClone%2A> método, clonado `Person` objeto es una copia independiente del objeto original, excepto que comparten el mismo `Person.IdInfo` referencia de objeto. Como resultado, modificar el clon `Person.IdInfo` propiedad cambia el objeto original `Person.IdInfo` propiedad. Por otro lado, cuando se realiza una operación de copia en profundidad, clonado `Person` objeto, incluida su `Person.IdInfo` propiedad, puede modificarse sin alterar el objeto original.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Primer objeto que se va a comparar.</param>
        <param name="objB">Segundo objeto que se va a comparar.</param>
        <summary>Determina si las instancias de <see cref="T:System.Object" /> especificadas son la misma instancia.</summary>
        <returns>Es <see langword="true" /> si <paramref name="objA" /> es la misma instancia que <paramref name="objB" />, o si ambos son **null**; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la <xref:System.Object.Equals%2A> método y el operador de igualdad, la <xref:System.Object.ReferenceEquals%2A> no se puede reemplazar el método. Por este motivo, si desea probar dos referencias de igualdad de objetos y no está seguro acerca de la implementación de la `Equals` método, puede llamar a la <xref:System.Object.ReferenceEquals%2A> método.  
  
 Sin embargo, el valor devuelto de la <xref:System.Object.ReferenceEquals%2A> método puede parecer anómalos en estos dos escenarios:  
  
-   Al comparar los tipos de valor. Si `objA` y `objB` son tipos de valor, se han convertido antes de pasarlos a la <xref:System.Object.ReferenceEquals%2A> método. Esto significa que si ambos `objA` y `objB` representan la misma instancia de un tipo de valor, el <xref:System.Object.ReferenceEquals%2A> , sin embargo, devuelve el método `false`, tal y como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Para obtener información sobre los tipos de valor de conversión boxing, vea [conversión Boxing y Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Cuando se comparan cadenas. Si `objA` y `objB` son cadenas, la <xref:System.Object.ReferenceEquals%2A> devuelve del método `true` si la cadena se aplica el método Intern. No se realiza una prueba de igualdad de valores.  En el ejemplo siguiente, `s1` y `s2` son iguales porque son las dos instancias de una sola cadena internada. Sin embargo, `s3` y `s4` no son iguales, porque aunque tienen valores de cadena idénticas, esa cadena no esté internada.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Para obtener más información sobre el internamiento de cadenas, vea <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Object.ReferenceEquals%2A> para determinar si dos objetos son la misma instancia.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una cadena que representa el objeto actual.</summary>
        <returns>Cadena que representa el objeto actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> es el principal formato método en .NET Framework. Convierte un objeto en su representación de cadena para que sea apropiada para mostrarla. (Para obtener información acerca del formato de soporte técnico de .NET Framework, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).) Las implementaciones de predeterminadas el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método devuelve el nombre completo del tipo de objeto.  
  
> [!IMPORTANT]
>  Podría haber alcanzado esta página siguiendo el vínculo de la lista de miembros de otro tipo. Eso es porque ese tipo no invalida <xref:System.Object.ToString%2A?displayProperty=nameWithType>. En su lugar, hereda la funcionalidad de la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.  
  
 Tipos se reemplazan con frecuencia el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para proporcionar una representación de cadena más adecuada de un tipo determinado. Tipos también suelen sobrecargar el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para proporcionar compatibilidad con cadenas de formato o el formato dependiente de la referencia cultural.  
  
 En esta sección:  
  
 [El método predeterminado de Object.ToString)](#Default)   
 [Invalidación del método Object.ToString)](#Overriding)   
 [Sobrecarga del método ToString](#Overloading)   
 [Extender el método Object.ToString](#Extending)   
 [Notas para el tiempo de ejecución de Windows](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>El método predeterminado de Object.ToString)  
 La implementación predeterminada de la <xref:System.Object.ToString%2A> método devuelve el nombre completo del tipo de la <xref:System.Object>, tal y como se muestra en el ejemplo siguiente.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Dado que <xref:System.Object> es la clase base de todos los tipos de referencia en .NET Framework, este comportamiento se hereda por tipos de referencia que no invalidan el <xref:System.Object.ToString%2A> método. Esto se ilustra en el siguiente ejemplo: Define una clase denominada `Object1` que acepta la implementación predeterminada de todos los <xref:System.Object> miembros. Su <xref:System.Object.ToString%2A> método devuelve el nombre de tipo completo del objeto.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Invalidación del método Object.ToString)  
 Los tipos comúnmente invalidar el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para devolver una cadena que representa la instancia del objeto. Por ejemplo, los tipos base como <xref:System.Char>, <xref:System.Int32>, y <xref:System.String> proporcionar <xref:System.Object.ToString%2A> implementaciones que devuelven el formato de cadena del valor que representa el objeto. En el ejemplo siguiente se define una clase, `Object2`, que reemplaza el <xref:System.Object.ToString%2A> método para devolver el nombre de tipo junto con su valor.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 En la tabla siguiente se enumeran las categorías de tipos en .NET Framework e indica si invalidan el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.  
  
|Categoría de tipo|Invalida Object.ToString)|Comportamiento|  
|-------------------|-----------------------------------|--------------|  
|Clase|N/D|N/D|  
|Estructura|Sí (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Igual a Object.ToString)|  
|Enumeración|Sí (<xref:System.Enum.ToString?displayProperty=nameWithType>)|El nombre de miembro|  
|Interfaz|No|N/D|  
|Delegado|No|N/D|  
  
 Vea la sección Notas para los herederos para obtener más información sobre cómo reemplazar <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Sobrecarga del método ToString  
 Además de invalidar sin parámetros <xref:System.Object.ToString?displayProperty=nameWithType> sobrecarga del método, muchos tipos el `ToString` método para proporcionar versiones del método que aceptan parámetros. Normalmente, esto se hace para proporcionar compatibilidad para aplicar formato a variables y el formato de la referencia cultural.  
  
 El ejemplo siguiente se sobrecarga la `ToString` método para devolver una cadena de resultado que incluye el valor de varios campos de un `Automobile` clase. Define cuatro cadenas de formato: G, que devuelve el nombre del modelo y el año; D., que devuelve el nombre del modelo, el año y el número de puertas; C, que devuelve el nombre del modelo, el año y el número de cilindros; y A, que devuelve una cadena con todos los valores de los cuatro campos.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 En el ejemplo siguiente se llama sobrecargado <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método para mostrar el formato de la referencia cultural de un valor de moneda.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Para obtener más información sobre las cadenas de formato y el formato de la referencia cultural, consulte [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md). Para las cadenas de formato admitidas por los valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato compatibles con los valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Extender el método Object.ToString  
 Dado que un tipo hereda el valor predeterminado <xref:System.Object.ToString%2A?displayProperty=nameWithType> método, es posible que encuentre su comportamiento no deseado y desea cambiarlo. Esto es especialmente cierto para las matrices y las clases de colección. Mientras que puede esperar el `ToString` método de una clase de matriz o colección para mostrar los valores de sus miembros, en su lugar, muestra el nombre de tipo completo del tipo, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Tiene varias opciones para generar la cadena de resultado que le gustaría.  
  
-   Si el tipo es una matriz, un objeto de colección o un objeto que implementa el <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601> interfaces, puede enumerar sus elementos mediante el `foreach` instrucción en C# o la `For Each...Next` construir en Visual Basic.  
  
-   Si la clase no es `sealed` (en C#) o `NotInheritable` (en Visual Basic), puede desarrollar una clase contenedora que hereda de la clase base cuyo <xref:System.Object.ToString%2A?displayProperty=nameWithType> método que desee personalizar. Como mínimo, esto requiere que haga lo siguiente:  
  
    1.  Implementar todos los constructores necesarios. Las clases derivadas no heredan sus constructores de clase base.  
  
    2.  Invalidar el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para devolver la cadena de resultado que le gustaría.  
  
     En el ejemplo siguiente se define una clase contenedora para el <xref:System.Collections.Generic.List%601> clase. Invalida el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para mostrar el valor de cada método de la colección en lugar de con el nombre de tipo completo.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Desarrollar un [método de extensión](~/docs/standard/design-guidelines/extension-methods.md) que devuelve la cadena de resultado que desee. Tenga en cuenta que no se puede invalidar el valor predeterminado <xref:System.Object.ToString%2A?displayProperty=nameWithType> método de esta manera (es decir, la clase de extensión (en C#) o el módulo (en Visual Basic) no puede tener un método sin parámetros denominado `ToString` que se llama en lugar del tipo original `ToString` (método) . Tendrá que proporcionar otro nombre para su sin parámetros `ToString` reemplazo.  
  
     El siguiente ejemplo define dos métodos que extienden la <xref:System.Collections.Generic.List%601> clase: una sin parámetros `ToString2` método y un `ToString` método con un <xref:System.String> parámetro que representa una cadena de formato.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Cuando se llama a la <xref:System.Object.ToString%2A> método en una clase en el [!INCLUDE[wrt](~/includes/wrt-md.md)], proporciona el comportamiento predeterminado para las clases que no se invalidan <xref:System.Object.ToString%2A>. Esto forma parte de la compatibilidad que .NET Framework proporciona para el [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [soporte técnico para Windows Store aplicaciones de .NET Framework y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Las clases en el [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.Object>y no siempre se implementa un <xref:System.Object.ToString%2A>. Sin embargo, siempre parecen tener <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, y <xref:System.Object.GetHashCode%2A> métodos al usarlos en el código de C# o Visual Basic y .NET Framework proporciona un comportamiento predeterminado para estos métodos.  
  
 A partir de la [!INCLUDE[net_v451](~/includes/net-v451-md.md)], common language runtime usará [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) en un [!INCLUDE[wrt](~/includes/wrt-md.md)] objeto antes de recurrir a la implementación predeterminada de <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] las clases que se escriben en C# o Visual Basic pueden reemplazar el <xref:System.Object.ToString%2A> método.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>El [!INCLUDE[wrt](~/includes/wrt-md.md)] y la interfaz IStringable  
 A partir de [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] incluye un [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfaz cuyo único método, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), proporciona compatibilidad básica de formato comparable a la proporcionado por <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Para evitar la ambigüedad, debe implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) en tipos administrados.  
  
 Cuando se llama a los objetos administrados por el código nativo o el código escrito en lenguajes como JavaScript o C++ / c++ / CX, aparecen implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Common language runtime enrutará automáticamente las llamadas de [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) a <xref:System.Object.ToString%2A?displayProperty=nameWithType> en el evento [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) no está implementada en el objeto administrado.  
  
> [!WARNING]
>  Dado que common language runtime auto-implementa [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) para todos los tipos en administrados [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicaciones, se recomienda que no proporcione sus propios [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementación. Implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) puede provocar un comportamiento no deseado al llamar a `ToString` desde el [!INCLUDE[wrt](~/includes/wrt-md.md)], C++ / c++ / CX o JavaScript.  
  
 Si decide implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) en un tipo público administrado que se exporte en un [!INCLUDE[wrt](~/includes/wrt-md.md)] componente, se aplican las restricciones siguientes:  
  
-   Puede definir la [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) sólo en una relación "la clase implementa", como la interfaz  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     en C# o  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     en Visual Basic.  
  
-   No se puede implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) en una interfaz.  
  
-   No se puede declarar un parámetro de tipo [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) no puede ser el tipo de valor devuelto de un método, propiedad o campo.  
  
-   No se pueden ocultar su [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementación de las clases base mediante una definición de método como la siguiente:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     En su lugar, el [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) siempre debe invalidar la implementación de clase base. Solo puede ocultar una implementación de `ToString` invocándola en una instancia de clase fuertemente tipada.  
  
 Tenga en cuenta que en determinadas condiciones, las llamadas desde código nativo a un tipo administrado que implementa [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) u oculta su [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementación puede generar un comportamiento inesperado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Al implementar sus propios tipos, se debe reemplazar el <see cref="M:System.Object.ToString" /> que devuelva valores que son significativos para esos tipos. Las clases derivadas que necesitan más control sobre el formato que <see cref="M:System.Object.ToString" /> proporciona puede implementar el <see cref="T:System.IFormattable" /> interfaz. Su <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> método le permite definir cadenas de formato que controlan el formato y usar un <see cref="T:System.IFormatProvider" /> objeto que puede proporcionar para el formato específico de la referencia cultural.  
  
Invalidaciones de la <see cref="M:System.Object.ToString" /> método debe seguir estas directrices: 
-La cadena devuelta debe ser descriptivo y que puede leer los humanos.  
  
-La cadena devuelta debe identificar el valor de la instancia del objeto.  
  
-La cadena devuelta debe ser tan breve como sea posible para que sea adecuado para su presentación por un depurador.  
  
-El <see cref="M:System.Object.ToString" /> invalidación no debe devolver <see cref="F:System.String.Empty" /> o una cadena nula.  
  
-El <see cref="M:System.Object.ToString" /> invalidación no debe producir una excepción.  
  
-Si la representación de cadena de una instancia de la referencia cultural o se puede aplicar formato de varias maneras, implemente el <see cref="T:System.IFormattable" /> interfaz.  
  
-Si la cadena devuelta incluye información confidencial, primero debe solicitar un permiso adecuado. Si se realiza correctamente la demanda, puede devolver la información confidencial; en caso contrario, debe devolver una cadena que excluye la información confidencial.  
  
-El <see cref="M:System.Object.ToString" /> reemplazo no debe tener ningún efecto secundario observable para evitar complicaciones en la depuración. Por ejemplo, una llamada a la <see cref="M:System.Object.ToString" /> método no debería cambiar el valor de campos de instancia.  
  
-Si el tipo implementa un método de análisis (o <see langword="Parse" /> o <see langword="TryParse" /> método, un constructor o algún otro método estático que crea una instancia del tipo de una cadena), debe asegurarse de que la cadena devuelta por la <see cref="M:System.Object.ToString" /> método puede ser convertir en una instancia de objeto.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>