<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0499b9ab8b5160fa80acdb83902087541206252e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429238" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Admite todas las clases de la jerarquía de clases de .NET Framework y proporciona servicios de bajo nivel a las clases derivadas. Se trata de la clase base fundamental de todas las clases de .NET Framework; es la raíz de la jerarquía de tipos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Idiomas no suelen requieran una clase para declarar la herencia de <xref:System.Object> porque la herencia está implícita.  
  
 Dado que se derivan todas las clases de .NET Framework <xref:System.Object>, todos los métodos definidos en la <xref:System.Object> clase está disponible en todos los objetos en el sistema. Las clases derivadas pueden e invalidar algunos de estos métodos, incluyendo:  
  
-   <xref:System.Object.Equals%2A> -Admite comparaciones entre objetos.  
  
-   <xref:System.Object.Finalize%2A> -Realiza operaciones de limpieza antes de que un objeto sea reclamado automáticamente.  
  
-   <xref:System.Object.GetHashCode%2A> -Genera un número correspondiente al valor del objeto que admite el uso de una tabla hash.  
  
-   <xref:System.Object.ToString%2A> -Crea una cadena de texto legible que describe una instancia de la clase.  
  
## <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 Si está diseñando una clase, como una colección, que debe administrar cualquier tipo de objeto, puede crear miembros de clase que acepten instancias de la <xref:System.Object> clase. Sin embargo, el proceso de conversión boxing y unboxing a un tipo implica un costo de rendimiento. Si conoce que la nueva clase controlará con frecuencia ciertos tipos de valor puede utilizar uno de dos tácticas para minimizar el costo de la conversión boxing.  
  
-   Crear un método general que acepta un <xref:System.Object> tipo y un conjunto de sobrecargas de método específico del tipo que acepten cada tipo de valor que se espera que la clase controle con frecuencia. Si no existe un método específico del tipo que acepta el tipo de parámetro que realiza la llamada, se produce ninguna conversión boxing y se invoca el método específico del tipo. Si no hay ningún argumento de método que coincida con el tipo de parámetro que realiza la llamada, el parámetro es una conversión boxing y se invoca el método general.  
  
-   Diseñar su tipo y sus miembros para que utilicen genéricos. Common language runtime crea un tipo genérico cerrado cuando se crea una instancia de la clase y especificar un argumento de tipo genérico. El método genérico es específico del tipo y se puede invocar sin conversión boxing al parámetro de llamada.  
  
 Aunque a veces es necesario desarrollar clases de propósito general que aceptan y devuelven <xref:System.Object> tipos, puede mejorar el rendimiento proporcionando también una clase específica del tipo para controlar un tipo de uso frecuente. Por ejemplo, si se proporciona una clase que es específica para establecer y obtener valores booleanos, elimina el costo de aplicar conversiones boxing y unboxing valores booleanos.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un tipo de punto derivado de la <xref:System.Object> clase y se reemplazan muchos de los métodos virtuales de la <xref:System.Object> clase. Además, en el ejemplo se muestra cómo llamar a muchos de los métodos estático y métodos de la instancia la <xref:System.Object> clase.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Estático público (<see langword="Shared" /> en Visual Basic) miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancia sea seguro para subprocesos.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor llama a constructores de clases derivadas, pero también se puede utilizar para crear directamente una instancia de la <xref:System.Object> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si dos instancias de un objeto son iguales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con el objeto actual.</param>
        <summary>Determina si el objeto especificado es igual al objeto actual.</summary>
        <returns>Es <see langword="true" /> si el objeto especificado es igual al objeto actual; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo de comparación entre la instancia actual y la `obj` parámetro depende de si la instancia actual es un tipo de referencia o un tipo de valor.  
  
-   Si la instancia actual es un tipo de referencia, el <xref:System.Object.Equals%28System.Object%29> método comprueba la igualdad de referencia y una llamada a la <xref:System.Object.Equals%28System.Object%29> método es equivalente a una llamada a la <xref:System.Object.ReferenceEquals%2A> método. Igualdad de referencia significa que las variables de objeto que se comparan hacen referencia al mismo objeto. En el ejemplo siguiente se muestra el resultado de una comparación de este tipo. Define un `Person` (clase), que es un tipo de referencia, y llama el `Person` constructor de clase para crear dos instancias de nuevo `Person` objetos, `person1a` y `person2`, que tienen el mismo valor. También asigna `person1a` a otra variable de objeto, `person1b`. Como se muestra en el ejemplo, el salida `person1a` y `person1b` son iguales porque hacen referencia al mismo objeto. Sin embargo, `person1a` y `person2` no son iguales, aunque tienen el mismo valor.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Si la instancia actual es un tipo de valor, la <xref:System.Object.Equals%28System.Object%29> método comprueba la igualdad de valor. Igualdad de valores significa lo siguiente:  
  
    -   Los dos objetos son del mismo tipo. Como se muestra en el ejemplo siguiente, un <xref:System.Byte> objeto que tiene un valor de 12 no es igual a un <xref:System.Int32> objeto que tiene un valor de 12, porque los dos objetos tienen distintos tipos de tiempo de ejecución.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Los valores de los campos públicos y privados de los dos objetos son iguales. En el ejemplo siguiente se comprueba la igualdad de valor. Define un `Person` estructura, que es un tipo de valor, y llama el `Person` constructor de clase para crear dos instancias de nuevo `Person` objetos, `person1` y `person2`, que tienen el mismo valor. Como se muestra en el resultado del ejemplo, aunque las dos variables de objeto hacen referencia a objetos diferentes, `person1` y `person2` son iguales porque tienen el mismo valor para la privada `personName` campo.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Dado que la <xref:System.Object> clase es la clase base para todos los tipos de .NET Framework, el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método proporciona la comparación de igualdad predeterminado para todos los demás tipos. Sin embargo, los tipos a menudo invalidar la <xref:System.Object.Equals%2A> método para implementar la igualdad de valor. Para obtener más información, vea las notas para los autores de llamadas y notas de secciones de los herederos.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Cuando se llama a la <xref:System.Object.Equals%28System.Object%29> sobrecarga del método en una clase de la [!INCLUDE[wrt](~/includes/wrt-md.md)], proporciona el comportamiento predeterminado para las clases que no se invalidan <xref:System.Object.Equals%28System.Object%29>. Esto forma parte de la compatibilidad que .NET Framework proporciona para la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Las clases en el [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.Object>y actualmente no se implementa un <xref:System.Object.Equals%28System.Object%29> método. Sin embargo, parece que tienen <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, y <xref:System.Object.GetHashCode%2A> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] las clases que se escriben en C# o Visual Basic pueden invalidar la <xref:System.Object.Equals%28System.Object%29> sobrecarga del método.  
  
## <a name="notes-for-callers"></a>Notas para los llamadores  
 Las clases derivadas reemplazan con frecuencia el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método para implementar la igualdad de valor. Además, los tipos también suelen proporcionan una sobrecarga fuertemente tipada adicional a la `Equals` método, normalmente mediante la implementación de la <xref:System.IEquatable%601> interfaz. Cuando se llama a la `Equals` método para comprobar la igualdad, debe saber si la instancia actual invalida <xref:System.Object.Equals%2A?displayProperty=nameWithType> y entender cómo una determinada llamada a un `Equals` método se ha resuelto. En caso contrario, puede estar realizando una prueba de igualdad que es diferente de los previstos, y el método puede devolver un valor inesperado.  
  
 Esto se muestra en el ejemplo siguiente. Crea una instancia de tres <xref:System.Text.StringBuilder> objetos con cadenas idénticas y, a continuación, realiza cuatro llamadas a `Equals` métodos. La primera llamada al método devuelve `true`y el rendimiento de tres restantes `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 En el primer caso, fuertemente tipado <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> sobrecarga del método, que comprueba la igualdad de valor, se llama. Dado que las cadenas se asignan a los dos <xref:System.Text.StringBuilder> objetos son iguales, el método devuelve `true`. Sin embargo, <xref:System.Text.StringBuilder> no invalida <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. Por este motivo, cuando la <xref:System.Text.StringBuilder> objeto se convierte en una <xref:System.Object>, cuando un <xref:System.Text.StringBuilder> instancia se asigna a una variable de tipo <xref:System.Object>y cuándo el <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> se pasa al método dos <xref:System.Text.StringBuilder> objetos, el valor predeterminado <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>se llama al método. Dado que <xref:System.Text.StringBuilder> es un tipo de referencia, es equivalente a pasar los dos <xref:System.Text.StringBuilder> objetos a la <xref:System.Object.ReferenceEquals%2A> método. Aunque las tres <xref:System.Text.StringBuilder> objetos contienen cadenas idénticas, hacen referencia a tres objetos distintos. Como resultado, estos tres métodos llama devuelto `false`.  
  
 Puede comparar el objeto actual con otro objeto para la igualdad de referencia mediante una llamada a la <xref:System.Object.ReferenceEquals%2A> método. En Visual Basic, también puede utilizar el `is` palabra clave (por ejemplo, `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Notas para los herederos  
 Al definir su propio tipo, ese tipo hereda la funcionalidad definida por el `Equals` método de su tipo base. La tabla siguiente muestra la implementación predeterminada de la `Equals` método para las categorías principales de tipos en .NET Framework.  
  
|Categoría de tipo|Igualdad definida por|Comentarios|  
|-------------------|-------------------------|--------------|  
|Clase se deriva directamente <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Igualdad de referencia; equivalente a llamar a <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Estructura|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Igualdad de valor; comparación byte a byte directa o en la comparación de campo a campo mediante la reflexión.|  
|Enumeración|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Valores deben tener el mismo tipo de enumeración y el mismo valor subyacente.|  
|Delegado|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Delegados deben tener el mismo tipo con listas de invocaciones idénticos.|  
|Interfaz|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Igualdad de referencia.|  
  
 Para un tipo de valor, debe invalidar siempre <xref:System.Object.Equals%2A>, ya que comprueba la igualdad que se basan en la reflexión ofrece un rendimiento deficiente. También puede invalidar la implementación predeterminada de <xref:System.Object.Equals%2A> para los tipos de referencia para comprobar la igualdad de valores en lugar de la igualdad de referencia y para definir el significado exacto de igualdad de valores. Este tipo de implementaciones de <xref:System.Object.Equals%2A> devolver `true` si los dos objetos tienen el mismo valor, aunque no sean la misma instancia. El implementador de tipos decide qué constituye el valor de un objeto, pero suele ser todos o algunos de los datos almacenados en las variables de instancia del objeto. Por ejemplo, el valor de un <xref:System.String> objeto se basa en los caracteres de la cadena; la <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> reemplazos de método la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método devuelva `true` para cualquiera de dos cadenas instancias que contienen los mismos caracteres en el mismo orden.  
  
 En el ejemplo siguiente se muestra cómo invalidar el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método para comprobar la igualdad de valor. Reemplaza el <xref:System.Object.Equals%2A> método para el `Person` clase. Si `Person` aceptado su implementación de la clase base de la igualdad de los dos `Person` objetos sería iguales sólo si hace referencia a un único objeto. Sin embargo, en este caso, dos `Person` objetos son iguales si tienen el mismo valor para el `Person.Id` propiedad.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Además de invalidar <xref:System.Object.Equals%2A>, puede implementar la <xref:System.IEquatable%601> interfaz para proporcionar una prueba de igualdad fuertemente tipada.  
  
 Las instrucciones siguientes deben ser true para todas las implementaciones de la <xref:System.Object.Equals%28System.Object%29> método. En la lista, `x`, `y`, y `z` representan referencias a objetos que no son **null**.  
  
-   `x.Equals(x)` Devuelve `true`, excepto en los casos que implican tipos de punto flotante. Vea ISO/IEC/IEEE 60559:2011, Information technology--microprocesador sistemas--aritmética de coma flotante.  
  
-   `x.Equals(y)` Devuelve el mismo valor que `y.Equals(x)`.  
  
-   `x.Equals(y)` Devuelve `true` si `x` y `y` son `NaN`.  
  
-   Si `(x.Equals(y) && y.Equals(z))` devuelve `true`, a continuación, `x.Equals(z)` devuelve `true`.  
  
-   Las llamadas sucesivas a `x.Equals(y)` devuelven el mismo valor siempre y cuando los objetos al que hace referencia `x` y `y` no se modifican.  
  
-   `x.Equals(null)` devuelve `false`.  
  
 Las implementaciones de <xref:System.Object.Equals%2A> no deben producir excepciones; siempre deben devolver un valor. Por ejemplo, si `obj` es `null`, <xref:System.Object.Equals%2A> método debe devolver `false` en lugar de producir una <xref:System.ArgumentNullException>.  
  
 Siga estas directrices al reemplazar <xref:System.Object.Equals%28System.Object%29>:  
  
-   Los tipos que implementan <xref:System.IComparable> debe invalidar <xref:System.Object.Equals%28System.Object%29>.  
  
-   Tipos que reemplazan <xref:System.Object.Equals%28System.Object%29> también debe invalidar <xref:System.Object.GetHashCode%2A>; en caso contrario, las tablas hash no funcionen correctamente.  
  
-   Puede implementar la <xref:System.IEquatable%601> interfaz para admitir fuertemente tipados comprueba la igualdad. Su <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementación debe devolver resultados coherentes con <xref:System.Object.Equals%2A>.  
  
-   Si su lenguaje de programación admite la sobrecarga de operadores y sobrecargar el operador de igualdad para un tipo determinado, también debe invalidar el <xref:System.Object.Equals%28System.Object%29> método para devolver el mismo resultado que el operador de igualdad. Esto ayuda a garantizar que código de biblioteca de clase que usa <xref:System.Object.Equals%2A> (como <xref:System.Collections.ArrayList> y <xref:System.Collections.Hashtable>) se comporta de forma que sea coherente con la manera en que se usa el operador de igualdad por código de aplicación.  
  
### <a name="guidelines-for-reference-types"></a>Instrucciones para tipos de referencia  
 Las siguientes directrices se aplican a reemplazar <xref:System.Object.Equals%28System.Object%29> para un tipo de referencia:  
  
-   Considere la posibilidad de reemplazar <xref:System.Object.Equals%2A> si la semántica del tipo es basada en el hecho de que el tipo representa algunos valores.  
  
-   La mayoría de los tipos de referencia no deben sobrecargar el operador de igualdad, aunque reemplacen <xref:System.Object.Equals%2A>. Sin embargo, si va a implementar un tipo de referencia destinado a tener semántica de valor, como un tipo de número complejo, debe reemplazar el operador de igualdad.  
  
-   No se debe reemplazar <xref:System.Object.Equals%2A> en un tipo de referencia mutable. Esto es porque reemplazar <xref:System.Object.Equals%2A> requiere que también invalidar el <xref:System.Object.GetHashCode%2A> método, como se describe en la sección anterior. Esto significa que puede cambiar el código hash de una instancia de un tipo de referencia mutable durante su duración, lo que puede producir el objeto que se va a ser perdidos en una tabla hash.  
  
### <a name="guidelines-for-value-types"></a>Instrucciones para tipos de valor  
 Las siguientes directrices se aplican a reemplazar <xref:System.Object.Equals%28System.Object%29> para un tipo de valor:  
  
-   Si va a definir un tipo de valor que incluye uno o más campos cuyos valores son tipos de referencia, debe invalidar <xref:System.Object.Equals%28System.Object%29>. El <xref:System.Object.Equals%28System.Object%29> implementación proporcionada por <xref:System.ValueType> realiza una comparación byte a byte para los tipos de valor cuyos campos son todos los tipos de valor, pero utiliza la reflexión para realizar una comparación de campo a campo de tipos de valor cuyos campos son tipos de referencia.  
  
-   Si invalida <xref:System.Object.Equals%2A> y el lenguaje de programación admite la sobrecarga de operadores, debe sobrecargar el operador de igualdad.  
  
-   Debe implementar la <xref:System.IEquatable%601> interfaz. Al llamar a fuertemente tipado <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método evita la conversión boxing el `obj` argumento.  
  
   
  
## Examples  
 El siguiente ejemplo se muestra un `Point` clase que invalide la <xref:System.Object.Equals%2A> método para proporcionar la igualdad de valor y un `Point3D` clase que se deriva de `Point`. Dado que `Point` invalida <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para comprobar la igualdad de valor, la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> no se llama el método. Sin embargo, `Point3D.Equals` llamadas `Point.Equals` porque `Point` implementa <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> de forma que se proporciona igualdad de valor.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 El `Point.Equals` método comprueba para asegurarse de que el `obj` el argumento no es **null** y que hace referencia a una instancia del mismo tipo que este objeto. Si bien la comprobación da error, el método devuelve `false`.  
  
 El `Point.Equals` llamadas al método el <xref:System.Object.GetType%2A> método para determinar si los tipos de tiempo de ejecución de los dos objetos son idénticos. Si el método utilizó una comprobación de la forma `obj is Point` en C# o `TryCast(obj, Point)` en Visual Basic, la comprobación devolverá `true` en casos donde `obj` es una instancia de una clase derivada de `Point`, aunque `obj` y actual instancia no son del mismo tipo de tiempo de ejecución. Una vez comprobado que ambos objetos son del mismo tipo, el método convierte `obj` al tipo `Point` y devuelve el resultado de la comparación de los campos de instancia de los dos objetos.  
  
 En `Point3D.Equals`, los heredados `Point.Equals` método, que invalida <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, se invoca antes de realizar cualquier otra cosa. Dado que `Point3D` es una clase sealed (`NotInheritable` en Visual Basic), una comprobación en el formulario `obj is Point` en C# o `TryCast(obj, Point)` en Visual Basic es el adecuado para asegurarse de que `obj` es un `Point3D` objeto. Si es un `Point3D` de objeto, se convierte en una `Point` objeto y pasan a la implementación de clase base <xref:System.Object.Equals%2A>. Solo cuando los heredados `Point.Equals` método `true` el método de comparación la `z` campos presentados en la clase derivada de la instancia.  
  
 En el ejemplo siguiente se define un `Rectangle` clase que implementa internamente un rectángulo como dos `Point` objetos. El `Rectangle` también clase invalidaciones <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para proporcionar la igualdad de valores.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Algunos lenguajes como C# y Visual Basic admiten la sobrecarga de operadores. Cuando un tipo sobrecarga el operador de igualdad, también debe invalidar el <xref:System.Object.Equals%28System.Object%29> método para proporcionar la misma funcionalidad. Esto se consigue normalmente escribiendo el <xref:System.Object.Equals%28System.Object%29> método en términos del operador de igualdad sobrecargado, como en el ejemplo siguiente.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Dado que `Complex` es un tipo de valor, no puede derivar de.  Por lo tanto, la invalidación para <xref:System.Object.Equals%28System.Object%29> no necesita llamar al método <xref:System.Object.GetType%2A> para determinar el tiempo de ejecución preciso escriba de cada objeto, pero en su lugar, use la `is` operador de C# o la `TypeOf` operador en Visual Basic para comprobar el tipo de la `obj` parámetro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Primer objeto que se va a comparar.</param>
        <param name="objB">Segundo objeto que se va a comparar.</param>
        <summary>Determina si las instancias del objeto especificado se consideran iguales.</summary>
        <returns>
          <see langword="true" /> si los dos objetos se consideran iguales; en caso contrario, <see langword="false" />. Si tanto <paramref name="objA" /> como <paramref name="objB" /> son **null**, el método devuelve <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método estático <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método indica si dos objetos, `objA` y `objB`, son iguales. También permite probar los objetos cuyo valor es **null** igualdad. Compara `objA` y `objB` para la igualdad como sigue:  
  
-   Determina si los dos objetos representan la misma referencia de objeto. Si es así, el método devuelve `true`. Esta prueba es equivalente a llamar a la <xref:System.Object.ReferenceEquals%2A> método. Además, si ambos `objA` y `objB` son **null**, el método devuelve `true`.  
  
-   Determina si el `objA` o `objB` es **null**. Si es así, devuelve `false`.  
  
-   Si los dos objetos no representan la misma referencia de objeto y ninguna de ellas es **null**, llama a `objA`.`Equals` (`objB`) y devuelve el resultado. Esto significa que si `objA` invalida el <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> se llama al método, esta invalidación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método y lo compara con el <xref:System.Object.ReferenceEquals%2A> método.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que un objeto intente liberar recursos y realizar otras operaciones de limpieza antes de ser reclamado por la recolección de elementos no utilizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Object.Finalize%2A> método se usa para realizar operaciones de limpieza en los recursos no administrados mantenidos por el objeto actual antes de que se destruya el objeto. El método está protegido y, por tanto, es accesible sólo a través de esta clase o una clase derivada.  
  
 En esta sección:  
  
-   [Cómo funciona la finalización](#How)  
  
-   [Notas para los implementadores](#Notes)  
  
-   [La alternativa SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Cómo funciona la finalización  
 El <xref:System.Object> clase no proporciona una implementación para el <xref:System.Object.Finalize%2A> método y el recolector de elementos no utilizados no marcar tipos derivados de <xref:System.Object> para la finalización, a menos que invalide la <xref:System.Object.Finalize%2A> método.  
  
 Si un tipo de invalidar el <xref:System.Object.Finalize%2A> método, el recolector de elementos no utilizados agrega una entrada para cada instancia del tipo a una estructura interna denominada cola de finalización. La cola de finalización contiene entradas para todos los objetos del montón administrado cuyo código de finalización debe ejecutarse antes de que el recolector de elementos no utilizados pueda reclamar su memoria. El recolector de elementos no utilizados, a continuación, llama el <xref:System.Object.Finalize%2A> método automáticamente en las siguientes condiciones:  
  
-   Después de que el recolector de elementos no utilizados ha detectado que un objeto es inaccesible, a menos que el objeto haya sido excluido del proceso de finalización mediante una llamada a la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.  
  
-   Durante el cierre de un dominio de aplicación, a menos que el objeto está exento de finalización. Durante el cierre, finalizados incluso objetos que siguen siendo accesibles.  
  
 <xref:System.Object.Finalize%2A> se llama automáticamente una sola vez en una instancia determinada, a menos que el objeto se registre de nuevo mediante un mecanismo como <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> y <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método no se ha llamado posteriormente.  
  
 <xref:System.Object.Finalize%2A> las operaciones tienen las siguientes limitaciones:  
  
-   La hora exacta cuando se ejecuta el finalizador es indefinida. Para garantizar la liberación determinista de recursos para implementar instancias de la clase, un `Close` método o proporcione un <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación.  
  
-   No se garantizan que los finalizadores de dos objetos de ejecución en cualquier orden determinado, incluso si un objeto hace referencia a la otra. Es decir, si un objeto tiene una referencia al objeto B y ambos tienen finalizadores, objeto B podría ya ha finalizado cuando se inicia el finalizador del objeto.  
  
-   El subproceso en el que se ejecuta el finalizador no está especificado.  
  
 El <xref:System.Object.Finalize%2A> método podría no ejecutarse hasta su finalización o podría no ejecutarse en absoluto en las siguientes circunstancias excepcionales:  
  
-   Si otro finalizador se bloquea indefinidamente (queda en un bucle infinito, intenta obtener un bloqueo, nunca puede obtener y así sucesivamente). Dado el tiempo de ejecución intenta ejecutar los finalizadores hasta su finalización, podrían no se llame a otros finalizadores si un finalizador se bloquea de forma indefinida.  
  
-   Si el proceso termina sin que el tiempo de ejecución una oportunidad para limpiar. En este caso, la primera notificación de terminación del proceso de tiempo de ejecución es una notificación DLL_PROCESS_DETACH.  
  
 El tiempo de ejecución continúa finalizar los objetos durante el cierre sólo si el número de objetos susceptibles de finalización sigue reduciéndose.  
  
 Si <xref:System.Object.Finalize%2A> o un reemplazo de <xref:System.Object.Finalize%2A> inicia una excepción y el tiempo de ejecución no está hospedado por una aplicación que reemplace la directiva predeterminada, el runtime finaliza el proceso y no active `try` / `finally` bloques o los finalizadores se ejecutan. Este comportamiento garantiza la integridad del proceso si el finalizador no puede liberar ni destruir recursos.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Invalidación del método Finalize 
 Debe invalidar <xref:System.Object.Finalize%2A> para una clase que usa recursos no administrados, como identificadores de archivo o las conexiones de base de datos que deben liberarse cuando se descarta el objeto administrado que se usa durante la recolección de elementos no utilizados. No debe implementar un <xref:System.Object.Finalize%2A> método para objetos administrados, porque el recolector de elementos no utilizados libera los recursos administrados automáticamente.  
  
> [!IMPORTANT]
>  Si un <xref:System.Runtime.InteropServices.SafeHandle> el objeto está disponible que contiene el recurso no administrado, la alternativa recomendada es implementar el patrón de dispose con un controlador seguro y no reemplazar <xref:System.Object.Finalize%2A>. Para obtener más información, consulte [alternativa SafeHandle el](#SafeHandle) sección.  
  
 El <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método no hace nada de forma predeterminada, pero se debe invalidar <xref:System.Object.Finalize%2A> solo si es necesario y solo para liberar recursos no administrados. Reclamar memoria suele tardar mucho más tiempo si se ejecuta una operación de finalización, porque requiere al menos dos recolecciones de elementos no utilizados. Además, debe invalidar el <xref:System.Object.Finalize%2A> solo tipos de método como referencia. Common language runtime finaliza solo los tipos de referencia. Omite los finalizadores en tipos de valor.  

El ámbito de la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método es `protected`. Mantenga este ámbito limitado cuando reemplace el método en su clase. Manteniendo un <xref:System.Object.Finalize%2A> método protegido, los usuarios de la aplicación de la llamada a un objeto <xref:System.Object.Finalize%2A> método directamente.
  
 Todas las implementaciones de <xref:System.Object.Finalize%2A> en un tipo derivado debe llamar a la implementación de su tipo base de <xref:System.Object.Finalize%2A>. Este es el único caso en la aplicación que se puede llamar a código <xref:System.Object.Finalize%2A>. Un objeto <xref:System.Object.Finalize%2A> método no debe llamar a un método en cualquier objeto que no sean de su clase base. El motivo es que los otros objetos a los que se llama podrían ser recolectados al mismo tiempo que el objeto que llama, por ejemplo, en el caso de un cierre de Common Language Runtime. 
  
> [!NOTE]
>  El compilador de C# no permite invalidar el <xref:System.Object.Finalize%2A> método. En su lugar, proporciona un finalizador implementando un [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) para la clase. Un destructor de C# llama automáticamente al destructor de su clase base.  
>   
>  Visual C++ también proporciona su propia sintaxis para implementar el <xref:System.Object.Finalize%2A> método. Para obtener más información, vea la sección "Destructores y finalizadores" de [Cómo: definir y utilizar clases y Structs (C++ / CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Dado que la colección de elementos no utilizados es no determinista, no conoce con precisión cuando el recolector de elementos no utilizados realiza finalización. Para liberar recursos inmediatamente, también puede elegir implementar la [patrón de dispose](~/docs/standard/design-guidelines/dispose-pattern.md) y <xref:System.IDisposable> interfaz. El <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación se puede llamar a los consumidores de la clase para liberar recursos no administrados, y puede usar el <xref:System.Object.Finalize%2A> método para liberar recursos no administrados en caso de que el <xref:System.IDisposable.Dispose%2A> no se llama el método.  
  
 <xref:System.Object.Finalize%2A> puede realizar casi cualquier acción, como el restablecimiento de un objeto (es decir, hacer que el objeto accesible nuevo) después de que se ha limpiado durante la recolección de elementos no utilizados. Sin embargo, el objeto sólo puede restablecerse una vez; <xref:System.Object.Finalize%2A> no puede llamarse en objetos restablecidos durante la recolección de elementos no utilizados. Hay una acción que la implementación de <xref:System.Object.Finalize%2A> nunca debe realizar: jamás deberá producir una excepción. Si llama a las excepciones producidas por los métodos de la <xref:System.Object.Finalize%2A> son no controlada por el método por el <xref:System.Object.Finalize%2A> método, el tiempo de ejecución supone que la <xref:System.Object.Finalize%2A> método devuelto y continúa llamar a la <xref:System.Object.Finalize%2A> métodos de otros objetos. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>La alternativa SafeHandle  
 Crear los finalizadores confiables a menudo es difícil, porque no se puede realizar suposiciones sobre el estado de la aplicación y que excepciones no controladas de sistema como <xref:System.OutOfMemoryException> y <xref:System.StackOverflowException> finalizar el finalizador. En lugar de implementar un finalizador de la clase para liberar recursos no administrados, puede usar un objeto que se deriva de la <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> clase para encapsular los recursos no administrados y, a continuación, implementar el patrón de dispose sin un finalizador. .NET Framework proporciona las siguientes clases en el <xref:Microsoft.Win32?displayProperty=nameWithType> espacio de nombres que se derivan de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> es una clase contenedora para un identificador de archivo.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> es una clase contenedora para los identificadores de archivo asignado a memoria.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> es una clase contenedora para un puntero a un bloque de memoria no administrada.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, y <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> son clases de contenedor para los identificadores del cifrado.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> es una clase contenedora para los identificadores de canalización.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> es una clase contenedora para un identificador de una clave del registro.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> es una clase contenedora para un identificador de espera.  
  
 En el ejemplo siguiente se usa el [patrón de dispose](~/docs/standard/design-guidelines/dispose-pattern.md) con controladores seguros en lugar de reemplazar el <xref:System.Object.Finalize%2A> método. Define un `FileAssociation` clase que contiene información de registro de la aplicación que trata los archivos con una extensión de archivo en particular. Los identificadores de dos registro formando `out` parámetros por Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) llamadas a funciones se pasan a la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor. El tipo del protege `Dispose` método, a continuación, llama el `SafeRegistryHandle.Dispose` método para liberar estos dos puntos de control.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 En el ejemplo siguiente se comprueba que la <xref:System.Object.Finalize%2A> método se llama cuando un objeto que invalida <xref:System.Object.Finalize%2A> se destruye. Tenga en cuenta que, en una aplicación de producción, el <xref:System.Object.Finalize%2A> se reemplazaría el método para liberar recursos no administrados mantenidos por el objeto. Tenga en cuenta también que el ejemplo de C# proporciona un destructor en lugar de reemplazar el <xref:System.Object.Finalize%2A> método.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Para obtener un ejemplo adicional que invalida la <xref:System.Object.Finalize%2A> método, consulte el <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sirve como la función hash predeterminada.</summary>
        <returns>Código hash para el objeto actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un código hash es un valor numérico que se utiliza para insertar e identificar un objeto de una colección basado en hash como el <xref:System.Collections.Generic.Dictionary%602> (clase), el <xref:System.Collections.Hashtable> clase o un tipo derivado de la <xref:System.Collections.DictionaryBase> clase. El <xref:System.Object.GetHashCode%2A> método proporciona este código hash para los algoritmos que necesitan comprobaciones rápidas de igualdad de objetos.  
  
> [!NOTE]
>  Para obtener información sobre cómo se utilizan los códigos hash en tablas hash y para algunos algoritmos de código hash adicionales, consulte la [función Hash](https://en.wikipedia.org/wiki/Hash_function) entrada de Wikipedia.  
  
 Dos objetos que son los códigos hash devuelto igual que son iguales. Sin embargo, lo contrario no es cierto: códigos hash igual no conllevan la igualdad de objetos, porque los objetos (iguales) diferentes pueden tener códigos hash idénticos. Además, .NET Framework no garantiza la implementación predeterminada de la <xref:System.Object.GetHashCode%2A> (método) y el valor de este método devuelve pueden diferir entre versiones de .NET Framework y las plataformas, como las plataformas de 32 bits y 64 bits. Por estos motivos, no use la implementación predeterminada de este método como un identificador de objeto único para fines de hash. Siguen dos consecuencias de esto:  
  
-   No se debe suponer que los códigos hash igual implican igualdad de objetos.  
  
-   Nunca debería conservar o utilizar un código hash fuera del dominio de aplicación en el que se creó, porque el mismo objeto puede hash entre plataformas, procesos y dominios de aplicación.  
  
> [!WARNING]
>  Un código hash está destinado a una inserción y búsqueda en las colecciones que se basan en una tabla hash. Un código hash no es un valor permanente. Por esta razón:  
>   
>  -   No serializar los valores de código hash o almacenarlos en las bases de datos.  
> -   No utilice el código hash como clave para recuperar un objeto de una colección con clave.  
> -   No se envían códigos hash a través de procesos o dominios de aplicación. En algunos casos, se pueden calcular los códigos hash de forma dominio por proceso o por aplicación.  
> -   No utilice el código hash en lugar de un valor devuelto por una función hash criptográfica si necesita un hash criptográficamente seguro. Para valores hash criptográficos, utilice una clase derivada de la <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> o <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> clase.  
> -   No comprobar la igualdad de los códigos hash para determinar si dos objetos son iguales. (Objetos distintos pueden tener códigos hash idénticos). Para comprobar la igualdad, llame a la <xref:System.Object.ReferenceEquals%2A> o <xref:System.Object.Equals%2A> método.  
  
 El <xref:System.Object.GetHashCode%2A> método puede reemplazarse por un tipo derivado. Si <xref:System.Object.GetHashCode%2A> es no se reemplaza, códigos hash para tipos de referencia se calculan mediante una llamada a la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método de la clase base, que calcula un código hash basado en la referencia de un objeto; para obtener más información, consulte <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. En otras palabras, dos objetos para los que el <xref:System.Object.ReferenceEquals%2A> método `true` tienen códigos hash idénticos. Si los tipos de valor no invalidar <xref:System.Object.GetHashCode%2A>, el <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> método de la clase base utiliza la reflexión para calcular el código hash basado en los valores de los campos del tipo. En otras palabras, cuyos campos tienen los mismos valores de tipos de valor tienen códigos hash igual. Para obtener más información sobre cómo invalidar <xref:System.Object.GetHashCode%2A>, vea la sección "Notas para los herederos".  
  
> [!WARNING]
>  Si invalida el <xref:System.Object.GetHashCode%2A> método, también debe invalidar <xref:System.Object.Equals%2A>y viceversa. Si su invalidado <xref:System.Object.Equals%2A> método `true` cuando dos objetos se comprueban si hay igualdad, su invalidada <xref:System.Object.GetHashCode%2A> método debe devolver el mismo valor para los dos objetos.  
  
 Si un objeto que se utiliza como clave en una tabla hash no proporciona una implementación útil de <xref:System.Object.GetHashCode%2A>, puede especificar un proveedor de código hash proporcionando un <xref:System.Collections.IEqualityComparer> implementación a una de las sobrecargas de los <xref:System.Collections.Hashtable> constructor de clase.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Cuando se llama a la <xref:System.Object.GetHashCode%2A> método en una clase en el [!INCLUDE[wrt](~/includes/wrt-md.md)], proporciona el comportamiento predeterminado para las clases que no se invalidan <xref:System.Object.GetHashCode%2A>. Esto forma parte de la compatibilidad que .NET Framework proporciona para la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Las clases en el [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.Object>y actualmente no se implementa un <xref:System.Object.GetHashCode%2A>. Sin embargo, parece que tienen <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, y <xref:System.Object.GetHashCode%2A> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona el comportamiento predeterminado para estos métodos.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] las clases que se escriben en C# o Visual Basic pueden invalidar la <xref:System.Object.GetHashCode%2A> método.  
  
   
  
## Examples  
 Una de las maneras más sencillas para calcular un código hash para un valor numérico que tiene la misma o a un intervalo más pequeño que el <xref:System.Int32> tipo es simplemente devolver ese valor. En el ejemplo siguiente se muestra este tipo de implementación para una `Number` estructura.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Con frecuencia, un tipo tiene varios campos de datos que pueden participar en la generación del código hash. Una manera de generar un código hash consiste en combinar estos campos utilizando una `XOR (eXclusive OR)` operación, tal y como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 El ejemplo anterior devuelve el mismo código hash de (n1, n2) y (n2, n1) por lo que puede generar más colisiones de deseable. Un número de soluciones está disponible para que los códigos hash en estos casos no son idénticos. Una consiste en devolver el código hash de un `Tuple` objeto que refleja el orden de cada campo. En el ejemplo siguiente se muestra una posible implementación que usa el <xref:System.Tuple%602> clase. Sin embargo, tenga en cuenta que la sobrecarga de rendimiento de una instancia un `Tuple` objeto puede afectar significativamente al rendimiento general de una aplicación que almacena gran cantidad de objetos en las tablas hash.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Una segunda solución alternativa implica la ponderación de los códigos hash individuales mediante su desplazamiento a la izquierda los códigos hash de campos sucesivas por dos o más bits. En condiciones óptimas, en lugar de descartarse, bits desplazados más allá de 31 bits se deben ajustar alrededor en lugar de descartar. Puesto que se descartan los bits por los operadores de desplazamiento a la izquierda en C# y Visual Basic, esto requiere la creación de un método de ajuste de desplazamiento a la izquierda similar al siguiente:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 En el ejemplo siguiente se utiliza, a continuación, este método de ajuste de desplazamiento para calcular el código hash de la `Point` estructura utilizada en los ejemplos anteriores.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Una función hash se utiliza para generar rápidamente un número (código hash) que corresponde al valor de un objeto. Las funciones hash suelen ser están para cada tipo y, de unicidad, deben utilizar al menos uno de los campos de instancia como entrada. No se deben calcular códigos hash mediante el uso de los valores de los campos estáticos.  Para las clases derivadas de <see cref="T:System.Object" />, <see langword="GetHashCode" /> puede delegar el método a la clase base <see cref="M:System.Object.GetHashCode" /> implementación sólo si la clase derivada define la igualdad para que sea la igualdad de referencia. La implementación predeterminada de <see cref="M:System.Object.GetHashCode" /> para referencia tipos devuelve un código hash que es equivalente a la devuelta por la <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> método. Puede invalidar <see cref="M:System.Object.GetHashCode" /> para tipos de referencia inmutable. En general, para los tipos de referencias mutables, debe invalidar <see cref="M:System.Object.GetHashCode" /> solo si:: puede calcular el código hash de los campos que no son mutables; o - puede asegurarse de que el código hash de un objeto mutable no cambia y el objeto se encuentra en un collecti en el se basa en el código hash.  En caso contrario, puede que piense que se ha perdido el objeto mutable en la tabla hash. Si elige reemplazar <see cref="M:System.Object.GetHashCode" /> para un tipo de referencia mutable, la documentación debe dejar claro que los usuarios de su tipo no deben modificar los valores de objeto mientras el objeto se almacena en una tabla hash.  Para los tipos de valor, <see cref="M:System.ValueType.GetHashCode" /> proporciona una implementación del código hash predeterminado que usa la reflexión. Considere la posibilidad de reemplazar para mejorar el rendimiento.  <block subset="none" type="note"><para> Para obtener más información y ejemplos que calculan códigos hash en una variedad de formas, vea la sección ejemplos.  </para></block>  Una función hash debe tener las siguientes propiedades: - si dos objetos comparan como iguales, la <see cref="M:System.Object.GetHashCode" /> método para cada objeto debe devolver el mismo valor. Sin embargo, si dos objetos no compararse como iguales, la <see cref="M:System.Object.GetHashCode" /> métodos para los dos objetos no tienen que devolver valores diferentes.  -El <see cref="M:System.Object.GetHashCode" /> método de un objeto constantemente debe devolver el mismo código hash como no hay ninguna modificación en el estado del objeto que determina el valor devuelto por el objeto [System.Object.Equals](xref:System.Object.Equals*) method. Tenga en cuenta que esto es cierto solo para la ejecución actual de una aplicación y que se puede devolver un código hash diferente si se vuelve a ejecutar la aplicación.  -Para un mejor rendimiento, una función hash debe generar una distribución uniforme para todas las entradas, incluida la entrada que está agrupado con un alto grado. Una implicación es que deben dar como resultado pequeñas modificaciones en el estado de objetos grandes modificaciones en el código hash resultante para un mejor rendimiento de la tabla de hash.  -Las funciones hash deben ser económicas calcular.  -El <see cref="M:System.Object.GetHashCode" /> método no debe producir excepciones.  Por ejemplo, la implementación de la <see cref="M:System.String.GetHashCode" /> método proporcionado por el <see cref="T:System.String" /> clase devuelve códigos hash idénticos para valores de cadena idénticos. Por lo tanto, dos <see cref="T:System.String" /> objetos devuelven el mismo código hash si representan el mismo valor de cadena. Además, el método utiliza todos los caracteres en la cadena para generar la salida con una distribución aleatoria razonable, incluso cuando la entrada está en clúster en determinados intervalos (por ejemplo, muchos usuarios podrían tener cadenas que contienen sólo los 128 caracteres ASCII inferiores, aunque una cadena puede contener cualquiera de los 65.535 caracteres Unicode).  Proporciona una función hash adecuada en una clase puede afectar significativamente al rendimiento de la adición de esos objetos en una tabla hash. En una tabla hash con claves que proporcionan una buena implementación de una función hash, busca un elemento tiene tiempo constante (por ejemplo, una operación o (1)). En una tabla hash con una implementación inadecuada de una función hash, el rendimiento de una búsqueda depende del número de elementos de la tabla hash (por ejemplo, una operación de O('n'), donde ' n ' es el número de elementos de la tabla hash). Un usuario malintencionado puede escribir datos que aumentan el número de conflictos, que puede reducir significativamente el rendimiento de las aplicaciones que dependen de las tablas hash, en las siguientes condiciones: - cuando las funciones de hash no generan conflictos frecuentes.  -Cuando una gran proporción de objetos en una tabla hash generar códigos hash que son iguales o aproximadamente igual entre sí.  -Cuando los usuarios los datos desde el que se calcula el código hash de entrada.  Las clases derivadas que invalidan <see cref="M:System.Object.GetHashCode" /> también debe invalidar <see cref="M:System.Object.Equals(System.Object)" /> para garantizar que dos objetos considerados iguales tengan el mismo código hash; en caso contrario, el <see cref="T:System.Collections.Hashtable" /> tipo no funcionen correctamente.</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Type" /> de la instancia actual.</summary>
        <returns>Tipo en tiempo de ejecución de la instancia actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que <xref:System.Object?displayProperty=nameWithType> es la clase base para todos los tipos en el sistema de tipos de .NET Framework, el <xref:System.Object.GetType%2A> método se puede utilizar para devolver <xref:System.Type> objetos que representan todos los tipos de .NET Framework. .NET Framework reconoce las cinco categorías de tipos siguientes:  
  
-   Las clases, que se derivan de <xref:System.Object?displayProperty=nameWithType>,  
  
-   Tipos de valor, que derivan de <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Interfaces, que se derivan de <xref:System.Object?displayProperty=nameWithType> a partir de .NET Framework 2.0.  
  
-   Enumeraciones, que se derivan de <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Delegados, lo que se derivan de <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Para dos objetos `x` y `y` que tienen tipos idénticos en tiempo de ejecución, `Object.ReferenceEquals(x.GetType(),y.GetType())` devuelve `true`. En el ejemplo siguiente se usa el <xref:System.Object.GetType%2A> método con el <xref:System.Object.ReferenceEquals%2A> método para determinar si un valor numérico es el mismo tipo que los otros dos valores numéricos.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Para determinar si un objeto es un tipo específico, puede usar la palabra clave de comparación de tipo de su lenguaje o construir. Por ejemplo, puede usar el `TypeOf…Is` construir en Visual Basic o `is` palabra clave de C#.  
  
 El <xref:System.Object.GetType%2A> método es heredado por todos los tipos que derivan de <xref:System.Object>. Esto significa que, además de utilizar la palabra clave de comparación de su propio lenguaje, puede utilizar el <xref:System.Object.GetType%2A> método para determinar el tipo de un objeto determinado, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 El <xref:System.Type> objeto expone los metadatos asociados a la clase del elemento actual <xref:System.Object>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que <xref:System.Object.GetType%2A> devuelve el tipo en tiempo de ejecución de la instancia actual.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficial del objeto <see cref="T:System.Object" /> actual.</summary>
        <returns>Copia superficial del objeto <see cref="T:System.Object" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Object.MemberwiseClone%2A> método crea una copia superficial, cree un nuevo objeto y, a continuación, copiar los campos no estáticos del objeto actual en el nuevo objeto. Si un campo es un tipo de valor, se realiza una copia bit a bit del campo. Si un campo es un tipo de referencia, la referencia se copia, pero el objeto que se hace referencia es no; por lo tanto, el objeto original y su clon hacen referencia al mismo objeto.  
  
 Por ejemplo, considere un objeto denominado X que hace referencia a objetos A y B. el objeto B, a su vez, el objeto references C. Una copia superficial de X crea nuevo objeto X2 que también hace referencia a objetos A y B. En contraste, una copia en profundidad de X crea un nuevo objeto X2 que hace referencia a los nuevos objetos A2 y B2, que son copias de A y B. B2, a su vez, hace referencia al nuevo objeto C2, que es una copia de C. En el ejemplo se ilustra la diferencia entre un superficial y una operación de copia en profundidad.  
  
 Hay muchas formas para implementar una operación de copia en profundidad si realiza la operación de copia superficial del <xref:System.Object.MemberwiseClone%2A> método no satisfacen sus necesidades. Se incluyen las siguientes:  
  
-   Llamar a un constructor de clase del objeto que se va a copiar para crear un segundo objeto con valores de propiedad que se toma del primer objeto. Se supone que los valores de un objeto completamente se definen mediante su constructor de clase.  
  
-   Llame a la <xref:System.Object.MemberwiseClone%2A> método para crear una copia superficial de un objeto y, a continuación, asignar nuevos objetos cuyos valores son los mismos que el objeto original a las propiedades o campos cuyos valores son tipos de referencia. El `DeepCopy` método en el ejemplo muestra este enfoque.  
  
-   Serializar el objeto para que sea profundo copiado y, a continuación, restaurar los datos serializados en una variable de objeto diferente.  
  
-   Usar la reflexión con la repetición para realizar la operación de copia en profundidad.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Object.MemberwiseClone%2A> método. Define un `ShallowCopy` método al que llama el <xref:System.Object.MemberwiseClone%2A> método para realizar una operación de copia superficial de un `Person` objeto. También define un `DeepCopy` método que realiza una operación de copia en profundidad en un `Person` objeto.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 En este ejemplo, el `Person.IdInfo` propiedad devuelve un `IdInfo` objeto. Como la salida se muestra en el ejemplo, cuando un `Person` objeto se clona mediante una llamada a la <xref:System.Object.MemberwiseClone%2A> /método siguiente, clonado `Person` objeto es una copia independiente del objeto original, salvo que comparten el mismo `Person.IdInfo` referencia de objeto. Como resultado, modificar el clon `Person.IdInfo` cambios en las propiedades del objeto original `Person.IdInfo` propiedad. Por otro lado, cuando se realiza una operación de copia en profundidad, clonado `Person` objeto, incluido su `Person.IdInfo` propiedad, se puede modificar sin afectar al objeto original.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Primer objeto que se va a comparar.</param>
        <param name="objB">Segundo objeto que se va a comparar.</param>
        <summary>Determina si las instancias de <see cref="T:System.Object" /> especificadas son la misma instancia.</summary>
        <returns>
          <see langword="true" /> si <paramref name="objA" /> es la misma instancia que <paramref name="objB" /> o si ambos son **null**; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la <xref:System.Object.Equals%2A> método y el operador de igualdad, el <xref:System.Object.ReferenceEquals%2A> no se puede invalidar el método. Por este motivo, si desea probar dos referencias de igualdad de objetos y no está seguro acerca de la implementación de la `Equals` método, se puede llamar a la <xref:System.Object.ReferenceEquals%2A> método.  
  
 Sin embargo, el valor devuelto de la <xref:System.Object.ReferenceEquals%2A> método puede aparecer anómalos en los dos escenarios:  
  
-   Al comparar los tipos de valor. Si `objA` y `objB` son tipos de valor, se han convertido antes de pasarlos a la <xref:System.Object.ReferenceEquals%2A> método. Esto significa que si ambos `objA` y `objB` representan la misma instancia de un tipo de valor, el <xref:System.Object.ReferenceEquals%2A> , sin embargo, devuelve el método `false`, como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Para obtener información sobre los tipos de valor de conversión boxing, vea [conversión Boxing y Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Cuando se comparan cadenas. Si `objA` y `objB` son cadenas, la <xref:System.Object.ReferenceEquals%2A> método `true` si la cadena se aplica el método Intern. No lleva a cabo una prueba de igualdad de valores.  En el ejemplo siguiente, `s1` y `s2` son iguales porque son dos instancias de una sola cadena aplicado el método Intern. Sin embargo, `s3` y `s4` no son iguales, porque aunque tienen valores de cadena idéntica, esa cadena no es aplica el método Intern.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Para obtener más información acerca de la asignación al grupo interno de cadena, vea <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Object.ReferenceEquals%2A> para determinar si dos objetos son la misma instancia.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una cadena que representa el objeto actual.</summary>
        <returns>Cadena que representa el objeto actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> es el principal formato método en .NET Framework. Convierte un objeto en su representación de cadena para que sea adecuada para su presentación. (Para obtener información acerca del formato de soporte técnico de .NET Framework, vea [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Las implementaciones de predeterminadas el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método devuelve el nombre completo del tipo de objeto.  
  
> [!IMPORTANT]
>  Podría haber alcanzado esta página siguiendo el vínculo de la lista de miembros de otro tipo. La razón es que ese tipo no invalidar <xref:System.Object.ToString%2A?displayProperty=nameWithType>. En su lugar, hereda la funcionalidad de la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.  
  
 Los tipos con frecuencia invalidar la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para proporcionar una representación de cadena más adecuada de un tipo determinado. También con frecuencia, los tipos de sobrecargar la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para proporcionar compatibilidad con cadenas de formato o el formato dependiente de la referencia cultural.  
  
 En esta sección:  
  
 [El método predeterminado de Object.ToString)](#Default)   
 [Invalidación del método Object.ToString)](#Overriding)   
 [Sobrecarga del método ToString](#Overloading)   
 [Extender el método Object.ToString](#Extending)   
 [Notas para el tiempo de ejecución de Windows](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>El método predeterminado de Object.ToString)  
 La implementación predeterminada de la <xref:System.Object.ToString%2A> método devuelve el nombre completo del tipo de la <xref:System.Object>, como se muestra en el ejemplo siguiente.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Dado que <xref:System.Object> es la clase base de todos los tipos de referencia en .NET Framework, este comportamiento es heredada por los tipos de referencia que no invalidan los <xref:System.Object.ToString%2A> método. Esto se ilustra en el siguiente ejemplo: Se define una clase denominada `Object1` que acepta la implementación predeterminada de todos los <xref:System.Object> miembros. Su <xref:System.Object.ToString%2A> método devuelve el nombre de tipo completo del objeto.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Invalidación del método Object.ToString)  
 Los tipos normalmente invalidar la <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para devolver una cadena que representa la instancia del objeto. Por ejemplo, los tipos base como <xref:System.Char>, <xref:System.Int32>, y <xref:System.String> proporcionar <xref:System.Object.ToString%2A> las implementaciones que devuelven el formato de cadena del valor que representa el objeto. En el ejemplo siguiente se define una clase, `Object2`, que invalida el <xref:System.Object.ToString%2A> método para devolver el nombre de tipo junto con su valor.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 En la tabla siguiente enumera las categorías de tipos de .NET Framework e indica si se permite o no invalidan los <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.  
  
|Categoría de tipo|Invalida Object.ToString)|Comportamiento|  
|-------------------|-----------------------------------|--------------|  
|Clase|no disponible|no disponible|  
|Estructura|Sí (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Igual que Object.ToString)|  
|Enumeración|Sí (<xref:System.Enum.ToString?displayProperty=nameWithType>)|El nombre de miembro|  
|Interfaz|No|no disponible|  
|Delegado|No|no disponible|  
  
 Vea la sección Notas para los herederos para obtener información adicional sobre cómo reemplazar <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Sobrecarga del método ToString  
 Además de reemplazar el método sin parámetros <xref:System.Object.ToString?displayProperty=nameWithType> sobrecarga del método, muchos tipos el `ToString` método para proporcionar versiones del método que aceptan parámetros. Normalmente, esto se hace para proporcionar soporte técnico para aplicar formato a variables y formato dependiente de la referencia cultural.  
  
 El ejemplo siguiente se sobrecarga el `ToString` método para devolver una cadena de resultado que incluye el valor de varios campos de una `Automobile` clase. Define cuatro cadenas de formato: G, que devuelve el nombre del modelo y el año; D., que devuelve el nombre del modelo, el año y el número de puertas; C, que devuelve el nombre del modelo, el año y el número de cilindros; y A, que devuelve una cadena con todos los valores de los cuatro campos.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 En el ejemplo siguiente se llama sobrecargado <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método para mostrar el formato dependiente de la referencia cultural de un valor de moneda.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Para obtener más información sobre las cadenas de formato y el formato dependiente de la referencia cultural, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md). Para las cadenas de formato compatibles con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato compatibles con valores de fecha y hora, vea [cadenas de formato de hora y fecha estándar](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [cadenas de formato de hora y fecha personalizada](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Extender el método Object.ToString  
 Puesto que un tipo hereda el valor predeterminado <xref:System.Object.ToString%2A?displayProperty=nameWithType> método, puede buscar su comportamiento no deseado y desea cambiarla. Esto es especialmente cierto de matrices y clases de colección. Mientras que puede esperar el `ToString` método de una clase de colección o matriz para mostrar los valores de sus miembros, en su lugar, muestra el nombre de tipo completo del tipo, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Tiene varias opciones para generar la cadena de resultado que le gustaría.  
  
-   Si el tipo es una matriz, un objeto de colección o un objeto que implementa el <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601> interfaces, puede enumerar sus elementos mediante el uso de la `foreach` instrucción en C# o la `For Each...Next` construir en Visual Basic.  
  
-   Si la clase no es `sealed` (en C#) o `NotInheritable` (en Visual Basic), puede desarrollar una clase contenedora que hereda de la clase base cuyo <xref:System.Object.ToString%2A?displayProperty=nameWithType> método que desee personalizar. Como mínimo, para ello haga lo siguiente:  
  
    1.  Implementar todos los constructores necesarios. Las clases derivadas no heredan sus constructores de clase base.  
  
    2.  Invalidar el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para devolver la cadena de resultado que le gustaría.  
  
     En el ejemplo siguiente se define una clase contenedora para los <xref:System.Collections.Generic.List%601> clase. Reemplaza el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para mostrar el valor de cada método de la colección en lugar de con el nombre de tipo completo.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Desarrollar un [método de extensión](~/docs/standard/design-guidelines/extension-methods.md) que devuelve la cadena de resultado que desea. Tenga en cuenta que no se puede invalidar el valor predeterminado <xref:System.Object.ToString%2A?displayProperty=nameWithType> método de esta manera (es decir, la clase de extensión (en C#) o el módulo (en Visual Basic) no puede tener un método sin parámetros denominado `ToString` que se llama en lugar del tipo original `ToString` (método) . Tendrá que proporcionar otro nombre para su sin parámetros `ToString` reemplazo.  
  
     El siguiente ejemplo define dos métodos que amplían la <xref:System.Collections.Generic.List%601> clase: una sin parámetros `ToString2` (método) y un `ToString` método con un <xref:System.String> parámetro que representa una cadena de formato.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notas de la [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Cuando se llama a la <xref:System.Object.ToString%2A> método en una clase en el [!INCLUDE[wrt](~/includes/wrt-md.md)], proporciona el comportamiento predeterminado para las clases que no se invalidan <xref:System.Object.ToString%2A>. Esto forma parte de la compatibilidad que .NET Framework proporciona para la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [.NET Framework admiten almacén de aplicaciones de Windows y Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Las clases en el [!INCLUDE[wrt](~/includes/wrt-md.md)] no heredar <xref:System.Object>y no debe implementar siempre un <xref:System.Object.ToString%2A>. Sin embargo, siempre parece que tienen <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, y <xref:System.Object.GetHashCode%2A> métodos cuando se usa en el código de C# o Visual Basic y .NET Framework proporciona un comportamiento predeterminado para estos métodos.  
  
 A partir de la [!INCLUDE[net_v451](~/includes/net-v451-md.md)], va a utilizar common language runtime [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) en un [!INCLUDE[wrt](~/includes/wrt-md.md)] objeto antes de usar la implementación predeterminada de <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] las clases que se escriben en C# o Visual Basic pueden invalidar la <xref:System.Object.ToString%2A> método.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>El [!INCLUDE[wrt](~/includes/wrt-md.md)] y la interfaz de IStringable  
 A partir de [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] incluye un [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfaz cuyo único método, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), proporciona compatibilidad básica de formato comparable a la proporcionado por <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Para evitar la ambigüedad, no debería implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) en tipos administrados.  
  
 Cuando se llama a los objetos administrados por código nativo o código escrito en lenguajes como JavaScript o C++ / CX, que se presentan al implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Common language runtime enrutará automáticamente las llamadas de [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) a <xref:System.Object.ToString%2A?displayProperty=nameWithType> en el evento [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) no está implementada en el objeto administrado.  
  
> [!WARNING]
>  Dado que common language runtime auto-implementa [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) para todos los tipos en administrados [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicaciones, se recomienda que no proporciona su propio [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementación. Implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) puede provocar un comportamiento no deseado al llamar a `ToString` desde el [!INCLUDE[wrt](~/includes/wrt-md.md)], C++ / CX o JavaScript.  
  
 Si decide implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) en un tipo público administrado que se exporte en un [!INCLUDE[wrt](~/includes/wrt-md.md)] componente, se aplican las restricciones siguientes:  
  
-   Puede definir la [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) sólo en una relación "la clase implementa", como la interfaz  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     en C# o  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     en Visual Basic.  
  
-   No se puede implementar [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) en una interfaz.  
  
-   No se puede declarar un parámetro de tipo [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) no puede ser el tipo de valor devuelto de un método, propiedad o campo.  
  
-   No se puede ocultar la [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementación de las clases base mediante una definición de método como el siguiente:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     En su lugar, el [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementación debe invalidar siempre la implementación de la clase base. Solo puede ocultar una implementación de `ToString` invocándola en una instancia de clase fuertemente tipada.  
  
 Tenga en cuenta que en determinadas condiciones, las llamadas desde código nativo a un tipo administrado que implemente [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) u oculta su [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementación puede generar un comportamiento inesperado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al implementar sus propios tipos, se debe invalidar el <see cref="M:System.Object.ToString" /> método para devolver valores que son significativos para esos tipos. Las clases derivadas que necesitan más control sobre el formato de <see cref="M:System.Object.ToString" /> proporciona puede implementar la <see cref="T:System.IFormattable" /> interfaz. Su <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> método le permite definir cadenas de formato que controlan el formato y usar un <see cref="T:System.IFormatProvider" /> objeto que puede proporcionar para formato específico de la referencia cultural.  Invalidaciones de la <see cref="M:System.Object.ToString" /> método debe seguir estas directrices:-la cadena devuelta debe ser descriptivo y legibles por los seres humanos.  -La cadena devuelta debe identificar de forma exclusiva el valor de la instancia del objeto.  -La cadena devuelta debe ser lo más corta posible para que sea adecuada para su presentación por un depurador.  -El <see cref="M:System.Object.ToString" /> invalidación no debería devolver <see cref="F:System.String.Empty" /> o una cadena nula.  -El <see cref="M:System.Object.ToString" /> invalidación no debería iniciar una excepción.  -Si la representación de cadena de una instancia de tiene en cuenta la referencia cultural o se puede aplicar formato de varias maneras, implemente el <see cref="T:System.IFormattable" /> interfaz.  -Si la cadena devuelta incluye la información confidencial, primero debería exigir un permiso adecuado. Si la demanda es correcta, puede devolver la información confidencial; de lo contrario, debe devolver una cadena que excluye la información confidencial.  -El <see cref="M:System.Object.ToString" /> reemplazo no debe tener efectos deseados de observable para evitar las complicaciones en la depuración. Por ejemplo, una llamada a la <see cref="M:System.Object.ToString" /> método no debería cambiar el valor de los campos de instancia.  -Si el tipo implementa un método de análisis (o <see langword="Parse" /> o <see langword="TryParse" /> método, un constructor o algún otro método estático que crea una instancia del tipo de una cadena), debe asegurarse de que la cadena devuelta por la <see cref="M:System.Object.ToString" /> puede ser (método) convertir en una instancia de objeto.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>