<Type Name="Double" FullName="System.Double">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4bb51935ed74b1ef60e7451850bf1def79a76574" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431932" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un número de punto flotante de precisión doble.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double> tipo de valor representa un número de 64 bits de precisión doble con valores comprendidos entre negativo 1. 79769313486232e308 al positivo 1. 79769313486232e308, así como cero positivo o negativo, <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>y no es un número (<xref:System.Double.NaN>). Está diseñado para representar los valores que no sean extremadamente grande (por ejemplo, las distancias entre planetas o galaxias) o muy pequeño (masa molecular de una sustancia en kilogramos) y que a menudo son precisos (como la distancia desde la tierra en otro sistema solar), el <xref:System.Double> tipo cumple la IEC 60559: 1989 (IEEE 754) estándar para aritmética binaria de punto flotante.  
  
 Este tema consta de las siguientes secciones:  
  
-   [Precisión y la representación de punto flotante](#Precision)  
  
-   [Comprobación de igualdad](#Equality)  
  
-   [Excepciones y valores de punto flotante](#Exceptions)  
  
-   [Conversiones de tipos y la estructura doble](#Conversions)  
  
-   [Funcionalidad de punto flotante](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Precisión y la representación de punto flotante  
 El <xref:System.Double> tipo de datos almacena valores de punto flotante de precisión doble en un formato binario de 64 bits, tal como se muestra en la tabla siguiente:  
  
|Parte|Bits|  
|----------|----------|  
|Mantisa o mantisa|0-51|  
|Exponente|52-62|  
|Inicio de sesión (0 = positivos, 1 = negativo)|63|  
  
 Tal y como fracciones decimales son no se puede representar con precisión algunos valores fraccionarios (por ejemplo, 1/3 o <xref:System.Math.PI?displayProperty=nameWithType>), fracciones binarias son no se puede representar algunos valores fraccionarios. Por ejemplo, 1/10, que se representa con precisión,.1 como una fracción decimal, se representa mediante.001100110011 como una fracción binaria, con el patrón "0011" de repetición hasta el infinito. En este caso, el valor de punto flotante proporciona una representación imprecisa del número que representa. Realizar operaciones matemáticas adicionales en el valor de punto flotante original a menudo tiende a aumentar su falta de precisión. Por ejemplo, si se compara el resultado de multiplicar.1 por 10 y agregar.1 a.1 nueve veces, vemos que suma, porque ha implicado ocho más operaciones, ha generado el resultado menos preciso. Tenga en cuenta que esta disparidad es evidente sólo si se muestran los dos <xref:System.Double> valores mediante el uso de la "R" [cadena de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md), que si es necesario muestra todos los 17 dígitos de precisión admitida por el <xref:System.Double> tipo.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Puesto que algunos números no se puede representar exactamente como valores binarios fracciones, números de punto flotante pueden solo los números reales aproximados.  
  
 Todos los números de punto flotante también tienen un número limitado de dígitos significativos, que también determina la precisión con un valor de punto flotante se aproxima a un número real.   Un <xref:System.Double> valor tiene hasta 15 dígitos decimales de precisión, aunque internamente se conserva 17 dígitos como máximo. Esto significa que algunas operaciones de punto flotante podrán carecer de la precisión para cambiar un flotante valor de punto. Esto se muestra en el ejemplo siguiente. Define un valor de punto flotante muy grande y, a continuación, agrega el producto de <xref:System.Double.Epsilon?displayProperty=nameWithType> y un trillón a él. El producto, sin embargo, es demasiado pequeño para modificar el valor de punto flotante original. Sus dígitos menos significativos es milésimas, mientras que el dígito más significativo en el producto es 1<sup>-312</sup>.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 La precisión limitada de un número de punto flotante tiene varias consecuencias:  
  
-   Dos números de punto flotante que parecen iguales para una precisión determinada podrían no son iguales porque sus dígitos menos significativos son diferentes. En el ejemplo siguiente, se suman una serie de números y el total se compara con su total esperado. Aunque los dos valores parecen iguales, una llamada a la `Equals` método indica que no se encuentran.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Si cambia los elementos de formato en el <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> instrucción desde `{0}` y `{1}` a `{0:R}` y `{1:R}` para mostrar todos los dígitos significativos de los dos <xref:System.Double> valores, está claro que los dos valores son iguales porque de una pérdida de precisión durante las operaciones de adición. En este caso, el problema puede solucionarse mediante una llamada a la <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> método para redondear el <xref:System.Double> valores a la precisión deseado antes de realizar la comparación.  
  
-   Una operación matemática o de comparación que utiliza un número de punto flotante podría no producir el mismo resultado si se usa un número decimal, porque el número de punto flotante binario no puede ser igual al número decimal. Un ejemplo anterior ilustra esto mostrando el resultado de multiplicar.1 por 10 y agregar.1 veces.  
  
     Cuando la precisión en operaciones numéricas con valores fraccionarios es importante, puede usar el <xref:System.Decimal> en lugar del <xref:System.Double> tipo. Cuando la precisión en operaciones numéricas con valores enteros más allá del intervalo de la <xref:System.Int64> o <xref:System.UInt64> tipos es importante, use la <xref:System.Numerics.BigInteger> tipo.  
  
-   Un valor podría no ida y vuelta si está implicado un número de punto flotante. Se dice que un valor de ida y vuelta si una operación convierte a un número de punto flotante original a otra forma, una operación inversa transforma el formato convertido a un número de punto flotante y el número de punto flotante final no es igual a la versión original número de punto flotante. Puede producir un error en la ida y vuelta porque uno o más dígitos menos significativos se pierden o cambian en una conversión. En el ejemplo siguiente, tres <xref:System.Double> valores se convierten en cadenas y se guardan en un archivo. Como muestra el resultado, sin embargo, aunque los valores parezcan idénticas, los valores restaurados no son iguales a los valores originales.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     En este caso, los valores pueden ser la ida y vuelta correctamente mediante el uso de "G17" [cadena de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) para conservar la precisión completa de <xref:System.Double> valores, como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  Cuando se usa con un <xref:System.Double> valor, el especificador de formato "R" en algunos casos se produce un error en la ida y vuelta correctamente el valor original. Para asegurarse de que <xref:System.Double> valores de ida y vuelta correctamente, use el especificador de formato "G17".

-   <xref:System.Single> valores tienen menor precisión que <xref:System.Double> valores. A <xref:System.Single> valor que se convierte en un equivalente aparentemente <xref:System.Double> a menudo no es igual a la <xref:System.Double> valor debido a diferencias en la precisión. En el ejemplo siguiente, se asigna el resultado de las operaciones de división idéntica a una <xref:System.Double> y un <xref:System.Single> valor. Después de la <xref:System.Single> valor se convierte en un <xref:System.Double>, se muestra una comparación de los dos valores que no son iguales.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Para evitar este problema, use el <xref:System.Double> en lugar de la <xref:System.Single> tipo de datos o use el <xref:System.Math.Round%2A> método para que ambos valores tienen la misma precisión.  
  
 Además, el resultado de las operaciones aritméticas y de asignación con <xref:System.Double> valores pueden diferir ligeramente según la plataforma debido a la pérdida de precisión de la <xref:System.Double> tipo. Por ejemplo, el resultado de la asignación de un literal <xref:System.Double> valor puede ser diferente de las versiones de 32 bits y 64 bits de .NET Framework. Esto ilustra en el ejemplo siguiente se diferencia cuando el literal value - 4.42330604244772E-305 y una variable cuyo valor es - 4.42330604244772E-305 se asignan a un <xref:System.Double> variable. Tenga en cuenta que el resultado de la <xref:System.Double.Parse%28System.String%29> método en este caso no sufren una pérdida de precisión.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Comprobación de igualdad  
 Para considerarse iguales, dos <xref:System.Double> valores deben representar valores idénticos. Sin embargo, debido a diferencias en la precisión entre valores, o debido a una pérdida de precisión por uno o ambos valores, valores de punto flotante que se esperan que sean idénticos a menudo resultan para ser desigual debido a diferencias en sus dígitos menos significativos. Como resultado, las llamadas a la <xref:System.Double.Equals%2A> método para determinar si dos valores son iguales, o llamadas a la <xref:System.Double.CompareTo%2A> método para determinar la relación entre dos <xref:System.Double> valores, a menudo producen resultados inesperados. Esto es evidente en el ejemplo siguiente, donde dos aparentemente sea <xref:System.Double> valores resultan para ser iguales porque la primera tiene 15 dígitos de precisión, mientras que el segundo tiene 17.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Valores calculados que siguen diferentes rutas de código y que se ha manipulado de maneras diferentes a menudo siendo iguales. En el ejemplo siguiente, un <xref:System.Double> se eleva al cuadrado el valor y, a continuación, se calcula la raíz cuadrada para restaurar el valor original. Un segundo <xref:System.Double> se multiplica por 3.51 y al cuadrado antes de que la raíz cuadrada del resultado se divide por 3.51 para restaurar el valor original. Aunque los dos valores parezcan idénticas, una llamada a la <xref:System.Double.Equals%28System.Double%29> método indica que no son iguales. Usar la cadena de formato estándar "R" para devolver una cadena de resultado que muestra todos los dígitos significativos de cada valor de tipo Double muestra que el segundo valor es.0000000000001 menor que el primero.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 En casos donde es probable que afecta al resultado de una comparación de una pérdida de precisión, puede adoptar cualquiera de las siguientes alternativas a llamar a la <xref:System.Double.Equals%2A> o <xref:System.Double.CompareTo%2A> método:  
  
-   Llame a la <xref:System.Math.Round%2A?displayProperty=nameWithType> método para asegurarse de que ambos valores tienen la misma precisión. En el ejemplo siguiente se modifica un ejemplo anterior para usar este enfoque para que dos valores fraccionarios son equivalentes.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Sin embargo, tenga en cuenta que el problema de precisión sigue siendo aplicable al redondeo de valores de punto medio. Para obtener más información, vea el método <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Probar la igualdad aproximado en lugar de igualdad. Esto requiere que se defina cualquier absoluto cantidad por la que los dos valores pueden diferir pero sigue ser igual o que definen una cantidad relativa por el que el valor más pequeño puede diferir del valor mayor.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> a veces se utiliza como una medida absoluta de la distancia entre dos <xref:System.Double> valores al probar la igualdad.  Sin embargo, <xref:System.Double.Epsilon?displayProperty=nameWithType> mide el menor valor posible que se puede agregar a o restar, un <xref:System.Double> cuyo valor es cero. Para la mayoría de valores positivos y negativos <xref:System.Double> valores, el valor de <xref:System.Double.Epsilon?displayProperty=nameWithType> es demasiado pequeño para que lo detecte. Por lo tanto, salvo por los valores que son iguales a cero, no se recomienda su uso en las pruebas de igualdad.  
  
     En el ejemplo siguiente se usa el último enfoque para definir un `IsApproximatelyEqual` método comprueba la diferencia relativa entre dos valores. También se contrasta el resultado de las llamadas a la `IsApproximatelyEqual` método y <xref:System.Double.Equals%28System.Double%29> método.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Excepciones y valores de punto flotante  
 A diferencia de las operaciones con los tipos enteros, que producen excepciones en casos de desbordamiento o de operaciones ilegales como la división por cero, las operaciones con valores de punto flotante no producen excepciones. En su lugar, en situaciones excepcionales, el resultado de una operación de punto flotante es cero, infinito positivo, infinito negativo o no es un número (NaN):  
  
-   Si el resultado de una operación de punto flotante es demasiado pequeño para el formato de destino, el resultado es cero. Esto puede ocurrir cuando se multiplican dos números muy pequeños, como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Si la magnitud del resultado de una operación de punto flotante supera el intervalo del formato de destino, el resultado de la operación es <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>, según corresponda para el signo del resultado. El resultado de una operación que se desborda <xref:System.Double.MaxValue?displayProperty=nameWithType> es <xref:System.Double.PositiveInfinity>y el resultado de una operación que se desborda <xref:System.Double.MinValue?displayProperty=nameWithType> es <xref:System.Double.NegativeInfinity>, como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> También se produce de una división por cero con un dividendo positivo, y <xref:System.Double.NegativeInfinity> da como resultado de una división por cero con un dividendo negativo.  
  
-   Si una operación de punto flotante no es válida, el resultado de la operación es <xref:System.Double.NaN>. Por ejemplo, <xref:System.Double.NaN> resultante de las siguientes operaciones:  
  
    -   División por cero con un dividendo de cero. Tenga en cuenta que los demás casos de división por cero en la vista de resultados <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>.  
  
-   Cualquier operación de punto flotante con una entrada no válida. Por ejemplo, al llamar a la <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> método con un valor negativo devuelve <xref:System.Double.NaN>, igual que llamar a la <xref:System.Math.Acos%2A?displayProperty=nameWithType> método con un valor que es mayor que uno o menor que un valor negativo.  
  
-   Cualquier operación con un argumento cuyo valor es <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Conversiones de tipos y la estructura doble  
 El <xref:System.Double> estructura no define ningún operador de conversión explícita o implícita; en su lugar, las conversiones se implementan por el compilador.  
  
 La conversión del valor de cualquier tipo numérico primitivo a un <xref:System.Double> es una conversión de ampliación y, por tanto, no requiere un operador de conversión explícita ni llamar a un método de conversión a menos que un compilador explícitamente lo requiere. Por ejemplo, el compilador de C# requiere un operador de conversión para las conversiones de <xref:System.Decimal> a <xref:System.Double>, mientras que el compilador de Visual Basic no lo hace. En el ejemplo siguiente se convierte el valor mínimo o máximo de los otros tipos numéricos primitivos a una <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 Además, el <xref:System.Single> valores <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, y <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> convertir a <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, y <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 Tenga en cuenta que la conversión del valor de algunos tipos numéricos a una <xref:System.Double> valor puede conllevar una pérdida de precisión. Como se muestra en el ejemplo, una pérdida de precisión es posible al convertir <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, y <xref:System.UInt64> valores <xref:System.Double> valores.  
  
 La conversión de un <xref:System.Double> valor en un valor de cualquier otro tipo de datos numérico primitivo es una conversión de restricción y requiere un operador de conversión (en C#), un método de conversión (en Visual Basic) o una llamada a un <xref:System.Convert> método. Valores que están fuera del intervalo del tipo de datos de destino, que se definen mediante el tipo de destino `MinValue` y `MaxValue` propiedades, se comportan como se muestra en la tabla siguiente.  
  
|Tipo de destino|Resultado|  
|-----------------|------------|  
|Cualquier tipo entero|Un <xref:System.OverflowException> excepción si la conversión se realiza en un contexto comprobado.<br /><br /> Si la conversión se produce en un contexto no comprobado (el valor predeterminado en C#), la operación de conversión se realiza correctamente, pero el valor se desborda.|  
|<xref:System.Decimal>|Excepción <xref:System.OverflowException>.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> para los valores negativos.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> para los valores positivos.|  
  
 Además, <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, y <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> producir una <xref:System.OverflowException> para las conversiones de enteros en un contexto protegido, pero estos desbordamiento valores cuando se convierten en enteros en un contexto no comprobado. Para las conversiones a <xref:System.Decimal>, siempre producen un <xref:System.OverflowException>. Para las conversiones a <xref:System.Single>, se convierten a <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, y <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 Tenga en cuenta que puede dar lugar a una pérdida de precisión en la conversión de un <xref:System.Double> valor a otro tipo numérico. En el caso de conversión no entero <xref:System.Double> valores, como se muestra en el resultado del ejemplo, el componente de fracción se pierde cuando el <xref:System.Double> valor se redondea (como en Visual Basic) o se truncan (como en C#). Para las conversiones a <xref:System.Decimal> y <xref:System.Single> valores, el <xref:System.Double> valor no puede tener una representación precisa en el tipo de datos de destino.  
  
 En el ejemplo siguiente se convierte un número de <xref:System.Double> valores a varios otros tipos numéricos. Las conversiones se producen en un contexto comprobado en Visual Basic (el valor predeterminado) y en C# (porque el [comprueban](~/docs/csharp/language-reference/keywords/checked.md) palabra clave). El resultado del ejemplo muestra el resultado para las conversiones en ambos un comprobado un contexto no comprobado. Puede realizar conversiones en un contexto no comprobado en Visual Basic a la compilación con el `/removeintchecks+` modificador de compilador y en C# marcando como comentario el `checked` instrucción.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Para obtener más información sobre la conversión de tipos numéricos, vea [conversión de tipos en .NET Framework](~/docs/standard/base-types/type-conversion.md) y [tablas de conversión de tipo](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Funcionalidad de punto flotante  
 El <xref:System.Double> estructura y los tipos relacionados proporcionan métodos para realizar operaciones en las áreas siguientes:  
  
-   **Comparación de valores**. Puede llamar a la <xref:System.Double.Equals%2A> método para determinar si dos <xref:System.Double> valores son iguales, o la <xref:System.Double.CompareTo%2A> método para determinar la relación entre dos valores.  
  
     El <xref:System.Double> estructura también admite un conjunto completo de operadores de comparación. Por ejemplo, puede comprobar la igualdad o desigualdad o determinar si un valor es mayor o igual que otro. Si uno de los operandos es un tipo numérico distinto de un <xref:System.Double>, se convierte en un <xref:System.Double> antes de realizar la comparación.  
  
    > [!WARNING]
    >  Debido a diferencias en precisión, dos <xref:System.Double> podrán resultar valores que se esperan que sea igual a distinguir, lo que afecta al resultado de la comparación. Consulte la [comprobación de igualdad](#Equality) sección para obtener más información acerca de cómo comparar dos <xref:System.Double> valores.  
  
     También puede llamar a la <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, y <xref:System.Double.IsNegativeInfinity%2A> métodos para comprobar estos valores especiales.  
  
-   **Operaciones matemáticas**. Operaciones aritméticas comunes, como suma, resta, multiplicación y división, se implementan mediante los compiladores de lenguaje y las instrucciones de Common Intermediate Language (CIL), en lugar de <xref:System.Double> métodos. Si uno de los operandos de una operación matemática es un tipo numérico distinto de un <xref:System.Double>, se convierte en un <xref:System.Double> antes de realizar la operación. El resultado de la operación es también un <xref:System.Double> valor.  
  
     Se pueden realizar otras operaciones matemáticas mediante una llamada a `static` (`Shared` en Visual Basic) métodos en la <xref:System.Math?displayProperty=nameWithType> clase. Incluye métodos adicionales utilizados habitualmente para aritmética (como <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, y <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), geometría (como <xref:System.Math.Cos%2A?displayProperty=nameWithType> y <xref:System.Math.Sin%2A?displayProperty=nameWithType>) y el cálculo (como <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     También se pueden manipular los bits individuales en un <xref:System.Double> valor. El <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> método conserva un <xref:System.Double> valor del patrón de bits en un entero de 64 bits. El <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> método devuelve su patrón de bits en una matriz de bytes.  
  
-   **Redondeo**. Redondeo a menudo se usa como una técnica para reducir el impacto de las diferencias entre los valores que se deben a problemas de representación de punto flotante y precisión. Se puede redondear un <xref:System.Double> valor mediante una llamada a la <xref:System.Math.Round%2A?displayProperty=nameWithType> método.  
  
-   **Formato**. Puede convertir un <xref:System.Double> valor en su representación de cadena mediante una llamada a la <xref:System.Double.ToString%2A> método o mediante la característica de formato compuesto. Para obtener información sobre la forma en que las cadenas de formato controlan la representación de cadena de valores de punto flotante, consulte el [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md) temas.  
  
-   **Analizar cadenas**. Puede convertir la representación de cadena de un valor de punto flotante a un <xref:System.Double> valor por una llamada a la <xref:System.Double.Parse%2A> o <xref:System.Double.TryParse%2A> método. Si se produce un error en la operación de análisis, el <xref:System.Double.Parse%2A> método produce una excepción, mientras que la <xref:System.Double.TryParse%2A> método `false`.  
  
-   **Conversión de tipos de**. El <xref:System.Double> estructura proporciona una implementación de interfaz explícita para la <xref:System.IConvertible> interfaz, que admite la conversión entre los dos tipos de datos estándares de .NET Framework. Los compiladores de lenguajes también admiten la conversión implícita de valores de todos los demás tipos numéricos estándares para <xref:System.Double> valores. Conversión de un valor de cualquier tipo numérico estándar para una <xref:System.Double> es una conversión de ampliación y no requiere que el usuario de un método de operador o conversión de conversión,  
  
     Sin embargo, la conversión de <xref:System.Int64> y <xref:System.Single> valores pueden conllevar una pérdida de precisión. En la tabla siguiente se enumera las diferencias de precisión para cada uno de estos tipos:  
  
    |Tipo|Precisión máxima|Precisión interna|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 dígitos decimales|19 dígitos decimales|  
    |<xref:System.Single>|7 dígitos decimales|9 dígitos decimales|  
  
     El problema de precisión con más frecuencia afecta a <xref:System.Single> valores que se convierten en <xref:System.Double> valores. En el ejemplo siguiente, dos valores que se producen las operaciones de división idénticos no son iguales porque uno de los valores es un valor de punto flotante de precisión sencilla convertido en un <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros de este tipo son seguros para subprocesos. Los miembros que aparecen modificar el estado de instancia realmente devuelven una nueva instancia inicializada con el nuevo valor. Como con cualquier otro tipo, leer y escribir en una variable compartida que contiene una instancia de este tipo deben protegerse mediante un bloqueo para garantizar la seguridad para subprocesos.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara esta instancia con un objeto especificado o un objeto <see cref="T:System.Double" /> y devuelve un entero que indica si el valor de esta instancia es menor, igual o mayor que el valor del objeto especificado o el objeto <see cref="T:System.Double" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Número de punto flotante de precisión doble que se va a comparar.</param>
        <summary>Compara esta instancia con un número de punto flotante de precisión doble especificado y devuelve un entero que indica si el valor de esta instancia es mayor, menor o igual que el valor del número de punto flotante de precisión doble especificado.</summary>
        <returns>Número con signo que indica los valores relativos de esta instancia y <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valor devuelto </term><description> Descripción </description></listheader><item><term> Menor que cero </term><description> Esta instancia es menor que <paramref name="value" />. -o bien- Esta instancia no es un número (<see cref="F:System.Double.NaN" />) y <paramref name="value" /> es un número.  </description></item><item><term> Cero </term><description> Esta instancia es igual a <paramref name="value" />. -o bien- Esta instancia y <paramref name="value" /> no son un número (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" />.  </description></item><item><term> Mayor que cero </term><description> Esta instancia es mayor que <paramref name="value" />. -o bien- Esta instancia es un número y <paramref name="value" /> no es un número (<see cref="F:System.Double.NaN" />). </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores deben ser idénticos para que se consideran iguales. Especialmente cuando los valores de punto flotante dependen de varias operaciones matemáticas, es común para perder precisión y para los valores que son prácticamente idénticas excepto sus dígitos menos significativos. Por este motivo, el valor devuelto de la <xref:System.Double.CompareTo%2A> método a veces puede parecer sorprendente. Por ejemplo, la multiplicación por un valor determinado seguido de división por el mismo valor debe generar el valor original. En el ejemplo siguiente, sin embargo, el valor calculado resulta para ser mayor que el valor original. Mostrar todos los dígitos significativos de los dos valores con la "R" [cadena de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) indica que el valor calculado difiere del valor original en sus dígitos menos significativos. Para obtener información sobre cómo administrar estas comparaciones, vea la sección Comentarios de la <xref:System.Double.Equals%28System.Double%29> método.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Este método implementa el <xref:System.IComparable%601?displayProperty=nameWithType> interfaz y realiza ligeramente mejor que la <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> método porque no tiene que convertir el `value` parámetro a un objeto.  
  
 Tenga en cuenta que, aunque un objeto cuyo valor es <xref:System.Double.NaN> no se considera igual a otro objeto cuyo valor es <xref:System.Double.NaN> (incluso él mismo), el <xref:System.IComparable%601> interfaz requiere que `A.CompareTo(A)` devolver cero.  
  
## <a name="widening-conversions"></a>conversiones de ampliación  
 Dependiendo del lenguaje de programación, es posible al código un <xref:System.Double.CompareTo%2A> método donde el tipo de parámetro tiene menos bits (es más estrecho) que el tipo de instancia. Esto es posible porque algunos lenguajes de programación realizan una conversión de ampliación implícita que representa el parámetro como un tipo con tantos bits como la instancia.  
  
 Por ejemplo, suponga que el tipo de instancia es <xref:System.Double> y el tipo de parámetro es <xref:System.Int32>. El compilador de Microsoft C# genera instrucciones para representar el valor del parámetro como un <xref:System.Double> objeto, a continuación, genera un <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> método que compara los valores de la instancia y la representación ampliada del parámetro.  
  
 Consulte la documentación de su lenguaje de programación para determinar si el compilador realiza las conversiones de ampliación implícitas de tipos numéricos. Para obtener más información, consulte el [tablas de conversión de tipo](~/docs/standard/base-types/conversion-tables.md) tema.  
  
## <a name="precision-in-comparisons"></a>Precisión en las comparaciones  
 La precisión de números de punto flotante más allá de la precisión documentada es específica de la implementación y la versión de .NET Framework. Por lo tanto, una comparación de dos números concretos podría cambiar entre las versiones de .NET Framework, ya que podría cambiar la precisión de la representación interna de los números.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra versiones genéricas y de la <xref:System.Double.CompareTo%2A> método para varios tipos de valor y de referencia.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a comparar o <see langword="null" />.</param>
        <summary>Compara esta instancia con un objeto especificado y devuelve un entero que indica si el valor de esta instancia es mayor, igual o menor que el valor del objeto especificado.</summary>
        <returns>Número con signo que indica los valores relativos de esta instancia y <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valor </term><description> Descripción </description></listheader><item><term> Un entero negativo </term><description> Esta instancia es menor que <paramref name="value" />. -o bien- Esta instancia no es un número (<see cref="F:System.Double.NaN" />) y <paramref name="value" /> es un número.  </description></item><item><term> Cero </term><description> Esta instancia es igual a <paramref name="value" />. -o bien- Esta instancia y <paramref name="value" /> son <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Un entero positivo </term><description> Esta instancia es mayor que <paramref name="value" />. -o bien- Esta instancia es un número y <paramref name="value" /> no es un número (<see cref="F:System.Double.NaN" />). -o bien- <paramref name="value" /> es <see langword="null" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro debe ser `null` o una instancia de `Double`; en caso contrario, se produce una excepción. Cualquier instancia de <xref:System.Double>, independientemente de su valor, se considera mayor que `null`.  
  
 Los valores deben ser idénticos para que se consideran iguales. Especialmente cuando los valores de punto flotante dependen de varias operaciones matemáticas, es común para perder precisión y para los valores que son prácticamente idénticas excepto sus dígitos menos significativos. Por este motivo, el valor devuelto de la <xref:System.Double.CompareTo%2A> método a veces puede parecer sorprendente. Por ejemplo, la multiplicación por un valor determinado seguido de división por el mismo valor debe generar el valor original. En el ejemplo siguiente, sin embargo, el valor calculado resulta para ser mayor que el valor original. Mostrar todos los dígitos significativos de los dos valores con la "R" [cadena de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) indica que el valor calculado difiere del valor original en sus dígitos menos significativos. Para obtener información sobre cómo administrar estas comparaciones, vea la sección Comentarios de la <xref:System.Double.Equals%28System.Double%29> método.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Este método se implementa para admitir el <xref:System.IComparable> interfaz. Tenga en cuenta que, aunque un <xref:System.Double.NaN> no se considera igual que otro <xref:System.Double.NaN> (incluso él mismo), el <xref:System.IComparable> interfaz requiere que `A.CompareTo(A)` devolver cero.  
  
## <a name="precision-in-comparisons"></a>Precisión en las comparaciones  
 La precisión de números de punto flotante más allá de la precisión documentada es específica de la implementación y la versión de .NET Framework. Por lo tanto, una comparación de dos números concretos podría cambiar entre las versiones de .NET Framework, ya que podría cambiar la precisión de la representación interna de los números.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de `CompareTo` en el contexto de `Double`.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no es un <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Representa el menor valor <see cref="T:System.Double" /> positivo mayor que cero. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.Double.Epsilon> propiedad refleja el valor positivo más pequeño <xref:System.Double> valor que es importante en operaciones numéricas o comparaciones cuando el valor de la <xref:System.Double> instancia es cero. Por ejemplo, el código siguiente muestra que cero y <xref:System.Double.Epsilon> se consideran valores desiguales, mientras que cero y la mitad del valor de <xref:System.Double.Epsilon> se consideran iguales.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Más concretamente, el flotante punto formato consta de un inicio de sesión, una mantisa de 52 bits o mantisa y un exponente de 11 bits. Como se muestra en el ejemplo siguiente, cero tiene un exponente de -1022 y una mantisa de 0. <xref:System.Double.Epsilon> tiene un exponente de -1022 y una mantisa de 1. Esto significa que <xref:System.Double.Epsilon> es el menor valor positivo <xref:System.Double> valor mayor que cero y representa el menor valor posible y el incremento más pequeño posible para un <xref:System.Double> cuyo exponente es -1022.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 Sin embargo, el <xref:System.Double.Epsilon> propiedad no es una medida general de precisión de la <xref:System.Double> escriba; solo se aplica a <xref:System.Double> instancias que tienen un valor de cero o un exponente de -1022.  
  
> [!NOTE]
>  El valor de la <xref:System.Double.Epsilon> propiedad no es equivalente a epsilon máquina, que representa el límite superior del error relativo debido al redondeo en aritmética de coma flotante.  
  
 El valor de esta constante es 4, 94065645841247E-324.  
  
 Dos números de punto flotante aparentemente equivalentes podrían no son iguales debido a diferencias en sus dígitos menos significativos. Por ejemplo, la expresión de C# `(double)1/3 == (double)0.33333`, no son iguales porque la operación de división del lado izquierdo tiene precisión máxima, mientras que la constante del lado derecho sólo es precisa en los dígitos especificados. Si crea un algoritmo personalizado que determina si dos números de punto flotante pueden considerarse iguales, no se recomienda que base su algoritmo en el valor de la <xref:System.Double.Epsilon> constante para establecer el margen absoluto aceptable de diferencia para los dos valores que se consideran iguales.  (Normalmente, ese margen de diferencia es muchas veces mayor que <xref:System.Double.Epsilon>.) Para obtener información acerca de cómo comparar dos valores de punto flotante de precisión doble, consulte <xref:System.Double> y <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Notas de la plataforma  
 En sistemas ARM, el valor de la <xref:System.Double.Epsilon> constante es demasiado pequeño para ser detectado, por lo que equivale a cero. Puede definir un valor de epsilon alternativo que sea igual a 2, 2250738585072014E-308 en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si dos instancias de <see cref="T:System.Double" /> representan el mismo valor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto <see cref="T:System.Double" /> que se va a comparar con esta instancia.</param>
        <summary>Devuelve un valor que indica si esta instancia y un objeto <see cref="T:System.Double" /> especificado representan el mismo valor.</summary>
        <returns>Es <see langword="true" /> si <paramref name="obj" /> es igual a esta instancia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el <xref:System.IEquatable%601?displayProperty=nameWithType> interfaz y se ejecuta ligeramente mejor que <xref:System.Double.Equals%2A> porque no tiene que convertir el `obj` parámetro a un objeto.  
  
## <a name="widening-conversions"></a>conversiones de ampliación  
 Dependiendo del lenguaje de programación, es posible al código un <xref:System.Double.Equals%2A> método donde el tipo de parámetro tiene menos bits (es más estrecho) que el tipo de instancia. Esto es posible porque algunos lenguajes de programación realizan una conversión de ampliación implícita que representa el parámetro como un tipo con tantos bits como la instancia.  
  
 Por ejemplo, suponga que el tipo de instancia es <xref:System.Double> y el tipo de parámetro es <xref:System.Int32>. El compilador de Microsoft C# genera instrucciones para representar el valor del parámetro como un <xref:System.Double> objeto, a continuación, genera un <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> método que compara los valores de la instancia y la representación ampliada del parámetro.  
  
 Consulte la documentación de su lenguaje de programación para determinar si el compilador realiza las conversiones de ampliación implícitas de tipos numéricos. Para obtener más información, consulte el [tablas de conversión de tipo](~/docs/standard/base-types/conversion-tables.md) tema.  
  
## <a name="precision-in-comparisons"></a>Precisión en las comparaciones  
 El <xref:System.Double.Equals%2A> método debe utilizarse con precaución, porque dos valores aparentemente equivalentes pueden ser distintos debido a la precisión de los dos valores que no son iguales. En el ejemplo siguiente se notifica que el <xref:System.Double> valor.333333 y <xref:System.Double> valor devuelto dividiendo 1 por 3 no son iguales.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 En lugar de comparación de igualdad, una técnica implica definir un margen aceptable relativo de la diferencia entre dos valores (como. 001% de uno de los valores). Si el valor absoluto de la diferencia entre los dos valores es menor o igual que el margen, la diferencia es probable que sea debido a diferencias en la precisión y, por lo tanto, los valores suelen ser iguales. En el ejemplo siguiente se utiliza esta técnica para comparar, 33333 y 1/3, los dos <xref:System.Double> valores que en el ejemplo de código anterior se encuentra como iguales. En este caso, los valores son iguales.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Dado que <xref:System.Double.Epsilon> define la expresión mínima de un valor positivo cuyo intervalo está cerca de cero, el margen de la diferencia entre dos valores similares debe ser mayor que <xref:System.Double.Epsilon>. Normalmente, es muchas veces mayor que <xref:System.Double.Epsilon>. Por este motivo, se recomienda que no utilice <xref:System.Double.Epsilon> al comparar <xref:System.Double> valores son iguales.  
  
 Una segunda técnica consiste en comparar la diferencia entre dos números de punto flotante con algún valor absoluto. Si la diferencia es menor o igual a ese valor absoluto, los números son iguales. Si es mayor, los números no son iguales. Una alternativa consiste en Seleccionar arbitrariamente un valor absoluto. Esto es problemático, sin embargo, dado que un margen aceptable de diferencia depende de la magnitud de la <xref:System.Double> valores. Una segunda alternativa aprovecha las ventajas de una característica de diseño del formato de punto flotante: la diferencia entre la representación de entero de dos valores de punto flotante indica el número de posibles valores de punto flotante que separa. Por ejemplo, la diferencia entre 0,0 y <xref:System.Double.Epsilon> es 1, porque <xref:System.Double.Epsilon> es el valor más pequeño representable cuando se trabaja con un <xref:System.Double> cuyo valor es cero. En el ejemplo siguiente se utiliza esta técnica para comparar, 33333 y 1/3, que son los dos <xref:System.Double> valores que el ejemplo de código anterior con la <xref:System.Double.Equals%28System.Double%29> no se encontró que acentuadas. Tenga en cuenta que el ejemplo se utiliza la <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> método para convertir un valor de punto flotante de precisión doble en su representación de entero.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 La precisión de números de punto flotante más allá de la precisión documentada es específica de la implementación y la versión de .NET Framework. Por lo tanto, una comparación de dos números concretos podría cambiar entre las versiones de .NET Framework, ya que podría cambiar la precisión de la representación interna de los números.  
  
 Si dos <xref:System.Double.NaN?displayProperty=nameWithType> valores se comprueban si hay igualdad mediante una llamada a la <xref:System.Double.Equals%2A> método, el método devuelve `true`. Sin embargo, si dos <xref:System.Double.NaN> valores se comprueban si hay igualdad mediante el operador de igualdad, el operador devuelve `false`. Si desea determinar si el valor de un <xref:System.Double> no es un número (NaN), una alternativa consiste en llamar a la <xref:System.Double.IsNaN%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>La resolución de sobrecarga de compilador puede representar una diferencia aparente en el comportamiento de los dos <see cref="M:System.Double.Equals(System.Object)" /> sobrecargas del método. Si una conversión implícita entre el <paramref name="obj" /> argumento y un <see cref="T:System.Double" /> se define y el argumento no se ha escrito como una <see cref="T:System.Object" />, compiladores pueden realizar una conversión implícita y la llamada la <see cref="M:System.Double.Equals(System.Double)" /> método. De lo contrario, llame a la <see cref="M:System.Double.Equals(System.Object)" /> método, que siempre devuelve <see langword="false" /> si su <paramref name="obj" /> el argumento no es un <see cref="T:System.Double" /> valor. En el ejemplo siguiente se ilustra la diferencia de comportamiento entre las sobrecargas del dos método. En el caso de todos los tipos numéricos primitivos excepto <see cref="T:System.Decimal" /> y en C#, se devuelve la primera comparación <see langword="true" /> porque el compilador realiza automáticamente una conversión de ampliación y llama el <see cref="M:System.Double.Equals(System.Double)" /> método, mientras que la segunda comparación Devuelve <see langword="false" /> porque el compilador llama el <see cref="M:System.Double.Equals(System.Object)" /> método.  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con esta instancia.</param>
        <summary>Devuelve un valor que indica si esta instancia equivale a un objeto especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="obj" /> es una instancia de <see cref="T:System.Double" /> y es igual al valor de esta instancia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.Equals%2A> método debe utilizarse con precaución, porque dos valores aparentemente equivalentes pueden ser distintos debido a la precisión de los dos valores que no son iguales. En el ejemplo siguiente se notifica que el <xref:System.Double> valor.3333 y la <xref:System.Double> devuelto por dividir 1 entre 3 son distintos.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Para consultar otras alternativas a llamar a la <xref:System.Double.Equals%2A> método, consulte la documentación de la <xref:System.Double.Equals%28System.Double%29> sobrecarga.  
  
> [!NOTE]
>  Dado que <xref:System.Double.Epsilon> define la expresión mínima de un valor positivo cuyo intervalo está cerca de cero, el margen de la diferencia entre dos valores similares debe ser mayor que <xref:System.Double.Epsilon>. Normalmente, es muchas veces mayor que <xref:System.Double.Epsilon>.  
  
 La precisión de números de punto flotante más allá de la precisión documentada es específica de la implementación y la versión de .NET Framework. Por lo tanto, una comparación de dos números concretos podría cambiar entre las versiones de .NET Framework, ya que podría cambiar la precisión de la representación interna de los números.  
  
 Si dos <xref:System.Double.NaN?displayProperty=nameWithType> valores se comprueban si hay igualdad mediante una llamada a la <xref:System.Double.Equals%2A> método, el método devuelve `true`. Sin embargo, si dos <xref:System.Double.NaN> valores se comprueban si hay igualdad mediante el operador de igualdad, el operador devuelve `false`. Si desea determinar si el valor de un <xref:System.Double> no es un número (NaN), una alternativa consiste en llamar a la <xref:System.Double.IsNaN%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>La resolución de sobrecarga de compilador puede representar una diferencia aparente en el comportamiento de los dos <see cref="M:System.Double.Equals(System.Object)" /> sobrecargas del método. Si una conversión implícita entre el <paramref name="obj" /> argumento y un <see cref="T:System.Double" /> se define y el argumento no se ha escrito como una <see cref="T:System.Object" />, compiladores pueden realizar una conversión implícita y la llamada la <see cref="M:System.Double.Equals(System.Double)" /> método. De lo contrario, llame a la <see cref="M:System.Double.Equals(System.Object)" /> método, que siempre devuelve <see langword="false" /> si su <paramref name="obj" /> el argumento no es un <see cref="T:System.Double" /> valor. En el ejemplo siguiente se ilustra la diferencia de comportamiento entre las sobrecargas del dos método. En el caso de todos los tipos numéricos primitivos excepto <see cref="T:System.Decimal" /> y en C#, se devuelve la primera comparación <see langword="true" /> porque el compilador realiza automáticamente una conversión de ampliación y llama el <see cref="M:System.Double.Equals(System.Double)" /> método, mientras que la segunda comparación Devuelve <see langword="false" /> porque el compilador llama el <see cref="M:System.Double.Equals(System.Object)" /> método.  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de esta instancia.</summary>
        <returns>Código hash de un entero de 32 bits con signo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el <see cref="T:System.TypeCode" /> para el tipo de valor <see cref="T:System.Double" />.</summary>
        <returns>Constante enumerada, <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Número de punto flotante de precisión doble.</param>
        <summary>Devuelve un valor que indica si el número especificado se evalúa como infinito negativo o positivo.</summary>
        <returns>Es <see langword="true" /> si <paramref name="d" /> se evalúa en <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las operaciones de punto flotante devuelven <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity> para señalar una condición de desbordamiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Número de punto flotante de precisión doble.</param>
        <summary>Devuelve un valor que indica si el valor especificado no es un número (<see cref="F:System.Double.NaN" />).</summary>
        <returns>Es <see langword="true" /> si <paramref name="d" /> se evalúa en <see cref="F:System.Double.NaN" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las operaciones de punto flotante devuelven <xref:System.Double.NaN> para señalar que ese resultado de la operación es indefinido. Por ejemplo, al dividir 0,0 por 0,0 el resultado en <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> Devuelve `false` si un <xref:System.Double> valor sea <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>. Para comprobar estos valores, utilice la <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, y <xref:System.Double.IsNegativeInfinity%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Número de punto flotante de precisión doble.</param>
        <summary>Devuelve un valor que indica si el número especificado se evalúa como infinito negativo.</summary>
        <returns>Es <see langword="true" /> si <paramref name="d" /> se evalúa en <see cref="F:System.Double.NegativeInfinity" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las operaciones de punto flotante devuelven <xref:System.Double.NegativeInfinity> para señalar una condición de desbordamiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Número de punto flotante de precisión doble.</param>
        <summary>Devuelve un valor que indica si el número especificado se evalúa como infinito positivo.</summary>
        <returns>Es <see langword="true" /> si <paramref name="d" /> se evalúa en <see cref="F:System.Double.PositiveInfinity" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las operaciones de punto flotante devuelven <xref:System.Double.PositiveInfinity> para señalar una condición de desbordamiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Representa el mayor valor posible de un <see cref="T:System.Double" />. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es 1. 7976931348623157E + 308 positivo.  
  
 El resultado de una operación que supera <xref:System.Double.MaxValue?displayProperty=nameWithType> es <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. En el ejemplo siguiente, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> da como resultado de las operaciones de suma, multiplicación y exponenciación cuando el resultado supera <xref:System.Double.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Representa el menor valor posible de un <see cref="T:System.Double" />. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es 1. 7976931348623157E + 308 negativo.  
  
 El resultado de una operación que es menor que <xref:System.Double.MinValue?displayProperty=nameWithType> es <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. En el ejemplo siguiente, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> resultante de las operaciones de resta y multiplicación cuando el resultado es menor que <xref:System.Double.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Representa un valor no numérico (<see langword="NaN" />). Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Devuelve un método u operador <xref:System.Double.NaN> cuando el resultado de una operación es indefinido. Por ejemplo, es el resultado de dividir cero por cero <xref:System.Double.NaN>, como se muestra en el ejemplo siguiente. (Pero tenga en cuenta que al dividir un número distinto de cero por cero devuelve <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>, según el inicio de sesión del divisor.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 Además, llamar un método con un <xref:System.Double.NaN> valor o una operación en un <xref:System.Double.NaN> valor devuelve <xref:System.Double.NaN>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Use la <xref:System.Double.IsNaN%2A> método para determinar si un valor no es un número. El <xref:System.Double.op_Equality%2A> operador considera que dos <xref:System.Double.NaN> valores sean iguales entre sí. En general, <xref:System.Double> operadores no se puede usar para comparar <xref:System.Double.NaN?displayProperty=nameWithType> Sí <xref:System.Double> valores, aunque los métodos de comparación (como <xref:System.Double.Equals%2A> y <xref:System.Double.CompareTo%2A>) can. En el ejemplo siguiente se muestra la diferencia de comportamiento entre <xref:System.Double> métodos y operadores de comparación.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 En el siguiente ejemplo se describe el uso de <xref:System.Double.NaN>.  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Representa infinito negativo. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es el resultado de dividir un número negativo por cero.  
  
 Esta constante se devuelve cuando el resultado de una operación es menor que <xref:System.Double.MinValue>.  
  
 Utilice <xref:System.Double.IsNegativeInfinity%2A> para determinar si un valor se evalúa como infinito negativo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si dos valores <see cref="T:System.Double" /> especificados son iguales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.op_Equality%2A> método define el operador de igualdad para <xref:System.Double> valores.  
  
 Si dos <xref:System.Double.NaN?displayProperty=nameWithType> valores se comprueban si hay igualdad mediante el operador de igualdad, el resultado es `false`; dos <xref:System.Double.NaN?displayProperty=nameWithType> valores no se consideran iguales. Si se comprueban si hay igualdad mediante una llamada a la <xref:System.Double.Equals%2A> método, el resultado es `true`.  Si desea determinar si el valor de un <xref:System.Double> no es un número (NaN), una alternativa consiste en llamar a la <xref:System.Double.IsNaN%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Double" /> especificado es mayor que otro valor <see cref="T:System.Double" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.op_GreaterThan%2A> método define el funcionamiento de la mayor-que el operador para <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Double" /> especificado es mayor o igual que otro valor <see cref="T:System.Double" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> es mayor o igual que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.op_GreaterThanOrEqual%2A> método define el funcionamiento del operador mayor o igual de <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si dos valores <see cref="T:System.Double" /> especificados no son iguales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.op_Inequality%2A> método define el operador de desigualdad para <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Double" /> especificado es menor que otro valor <see cref="T:System.Double" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> es menor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.op_LessThan%2A> método define la operación de la menor-que el operador para <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Double" /> especificado es menor o igual que otro valor <see cref="T:System.Double" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> es menor o igual que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.op_LessThanOrEqual%2A> método define el funcionamiento del operador menor o igual de <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la representación en forma de cadena de un número en el número de punto flotante de precisión doble equivalente.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <summary>Convierte la representación en forma de cadena de un número en el número de punto flotante de precisión doble equivalente.</summary>
        <returns>Número de punto flotante de precisión doble equivalente al valor numérico o símbolo especificado en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `s` parámetro puede contener la referencia cultural actual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, o una cadena del formulario:  
  
 [*ws*] [*inicio de sesión*] [*dígitos enteros*[*,*]]*dígitos enteros*[*.* [*dígitos fraccionarios*]] [E [*inicio de sesión*]*dígitos exponenciales*] [*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Una serie de caracteres de espacio en blanco.|  
|*sign*|Símbolos de un signo menos (-) o un signo positivo (+) de símbolos. Se puede utilizar solo un signo inicial.|  
|*dígitos enteros*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte entera del número. Se ejecuta de *dígitos enteros* pueden estar divididas por un símbolo de separador de grupos. Por ejemplo, en algunas referencias culturales una coma (,) separa los millares. El *dígitos enteros* puede ser el elemento está ausente if la cadena contiene la *dígitos fraccionarios* elemento.|  
|,|Específicas de referencias culturales miles símbolo de separador.|  
|.|Un símbolo de separador decimal de referencias culturales específicas.|  
|*dígitos fraccionarios*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte fraccionaria del número.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en notación exponencial (científica).|  
|*dígitos exponenciales*|Una serie de dígitos que comprende del 0 al 9 que especifican a un exponente.|  
  
 El `s` parámetro se interpreta mediante una combinación de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marcas. Esto significa que el espacio en blanco y miles se permiten separadores, por ejemplo, si bien los símbolos de divisa no son. Para obtener un mayor control sobre qué estilo elementos están permitidos en `s` para que la operación de análisis se realice correctamente, llame a la <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> o <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 El `s` parámetro se interpreta usando la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto que se inicializa para la referencia cultural del subproceso actual. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Para analizar una cadena usando la información de formato de alguna otra referencia cultural, llame a la <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> o <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 Por lo general, si se pasa el <xref:System.Double.Parse%2A?displayProperty=nameWithType> método es una cadena que se crea mediante una llamada a la <xref:System.Double.ToString%2A?displayProperty=nameWithType> /método siguiente, la versión original <xref:System.Double> se devuelve el valor. Sin embargo, debido a una pérdida de precisión, los valores pueden no ser iguales. Además, al intentar analizar la representación de cadena de <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> produce una <xref:System.OverflowException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método <xref:System.Double.Parse%28System.String%29>.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> no representa un número con un formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa un número menor que <see cref="F:System.Double.MinValue" /> o mayor que <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <param name="style">Combinación bit a bit de los valores de enumeración que indica los elementos de estilo que pueden estar presentes en <c>s</c>. Un valor que se especifica de forma habitual es una combinación de <see cref="F:System.Globalization.NumberStyles.Float" /> combinado con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Convierte la representación en forma de cadena de un número con un estilo especificado en el número de punto flotante de precisión doble equivalente.</summary>
        <returns>Número de punto flotante de precisión doble equivalente al valor numérico o símbolo especificado en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `style` parámetro define los elementos de estilo (como espacios en blanco, miles separadores y símbolos de moneda) que se permiten en la `s` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración. El siguiente <xref:System.Globalization.NumberStyles> miembros no son compatibles:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 El `s` parámetro puede contener la referencia cultural actual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>. Dependiendo del valor de `style`, también puede tener el formato:  
  
 [*ws*] [*$*] [*inicio de sesión*] [*dígitos enteros*[*,*]]* dígitos enteros*[*.* [*dígitos fraccionarios*]] [E [*inicio de sesión*]*dígitos exponenciales*] [*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Una serie de caracteres de espacio en blanco. Espacio en blanco puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca y pueden aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|$|Un símbolo de moneda específico de la referencia cultural. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual. Símbolo de divisa de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Símbolos de un signo menos (-) o un signo positivo (+) de símbolos. El signo puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y pueden aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `s` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*dígitos enteros*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte entera del número. El *dígitos enteros* puede ser el elemento está ausente if la cadena contiene la *dígitos fraccionarios* elemento.|  
|,|Separador de grupos de referencias culturales específicas. Símbolo de separador de grupos de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca|  
|.|Un símbolo de separador decimal de referencias culturales específicas. Símbolo de separador decimal de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*dígitos fraccionarios*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte fraccionaria del número. Pueden aparecer dígitos fraccionarios en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en notación exponencial (científica). El `s` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
|*dígitos exponenciales*|Una serie de dígitos que comprende del 0 al 9 que especifican a un exponente.|  
  
 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> estilo) siempre se analiza correctamente. El resto <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> miembros controlan los elementos que pueden estar presentes, pero no tienen que estar presentes en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> marcas afectan a los elementos que pueden estar presentes en `s`.  
  
|Valor NumberStyles|Elementos permitidos en `s` además de dígitos|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos enteros* solo el elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El separador decimal (*.*) y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o el carácter "E", que indica notación exponencial. Este marcador por sí solo admite valores en el formulario *dígitos*E*dígitos*; adicionales se necesitan marcadores para analizar correctamente cadenas con esos elementos como signos positivos o negativos y los símbolos de separador decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *inicio de sesión* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *inicio de sesión* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *inicio de sesión* elemento en forma de paréntesis delimitando el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Los miles elemento separador (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El elemento de moneda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos los elementos. Sin embargo, `s` no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `s`, *inicio de sesión* al principio de `s`y el símbolo de separador decimal (.). El `s` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, miles separador (,) y los elementos de punto decimal (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los elementos. Sin embargo, `s` no puede representar un número hexadecimal.|  
  
 El `s` parámetro se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto que se inicializa para la referencia cultural del sistema actual. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Por lo general, si se pasa el <xref:System.Double.Parse%2A?displayProperty=nameWithType> método es una cadena que se crea mediante una llamada a la <xref:System.Double.ToString%2A?displayProperty=nameWithType> /método siguiente, la versión original <xref:System.Double> se devuelve el valor. Sin embargo, debido a una pérdida de precisión, los valores pueden no ser iguales. Además, al intentar analizar la representación de cadena de <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> produce una <xref:System.OverflowException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método para analizar las representaciones de cadena de <xref:System.Double> valores mediante la referencia cultural en-US.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> no representa un número con un formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa un número menor que <see cref="F:System.Double.MinValue" /> o mayor que <see cref="F:System.Double.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> no es un valor <see cref="T:System.Globalization.NumberStyles" />.  -o bien- <paramref name="style" /> incluye el valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural sobre <c>s</c>.</param>
        <summary>Convierte la representación en forma de cadena de un número con un formato específico de la referencia cultural especificado en el número de punto flotante de precisión doble equivalente.</summary>
        <returns>Número de punto flotante de precisión doble equivalente al valor numérico o símbolo especificado en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de la <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> método se utiliza normalmente para convertir texto al que se puede aplicar formato en una variedad de formas de un <xref:System.Double> valor. Por ejemplo, se puede utilizar para convertir el texto escrito por un usuario en un cuadro de texto HTML a un valor numérico.  
  
 El `s` parámetro se interpreta mediante una combinación de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marcas. El `s` parámetro puede contener <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para la referencia cultural especificada por `provider`, o puede contener una cadena del formulario:  
  
 [*ws*] [*inicio de sesión*]*dígitos enteros*[*.* [*dígitos fraccionarios*]] [E [*inicio de sesión*]*dígitos exponenciales*] [*ws*]  
  
 Elementos opcionales están entre corchetes ([y]). Elementos que contienen el término "dígitos" constan de una serie de caracteres numéricos comprendidos entre 0 y 9.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Una serie de caracteres de espacio en blanco.|  
|*sign*|Símbolos de un signo menos (-) o un signo positivo (+) de símbolos.|  
|*dígitos enteros*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte entera del número. Se ejecuta de *dígitos enteros* pueden estar divididas por un símbolo de separador de grupos. Por ejemplo, en algunas referencias culturales una coma (,) separa los millares. El *dígitos enteros* puede ser el elemento está ausente if la cadena contiene la *dígitos fraccionarios* elemento.|  
|.|Un símbolo de separador decimal de referencias culturales específicas.|  
|*dígitos fraccionarios*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte fraccionaria del número.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en notación exponencial (científica).|  
|*dígitos exponenciales*|Una serie de dígitos que comprende del 0 al 9 que especifican a un exponente.|  
  
 Para obtener más información acerca de formatos numéricos, vea el [Formatting Types](~/docs/standard/base-types/formatting-types.md) tema.  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que aporta información específica de la referencia cultural usada para interpretar el formato de `s`. Normalmente, es un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> objeto. Si `provider` es `null` o <xref:System.Globalization.NumberFormatInfo> no se puede obtener, la información de formato se usa la referencia cultural del sistema actual.  
  
 Por lo general, si se pasa el <xref:System.Double.Parse%2A?displayProperty=nameWithType> método es una cadena que se crea mediante una llamada a la <xref:System.Double.ToString%2A?displayProperty=nameWithType> /método siguiente, la versión original <xref:System.Double> se devuelve el valor. Sin embargo, debido a una pérdida de precisión, los valores pueden no ser iguales. Además, al intentar analizar la representación de cadena de <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> produce una <xref:System.OverflowException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente es el botón, haga clic en el controlador de eventos de un formulario Web Forms. Utiliza la matriz devuelta por la <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> propiedad para determinar la configuración regional del usuario. A continuación, crea una instancia de un <xref:System.Globalization.CultureInfo> objeto que corresponde a esa configuración regional. El <xref:System.Globalization.NumberFormatInfo> objeto al que pertenece a la <xref:System.Globalization.CultureInfo> , a continuación, se pasa el objeto a la <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> para convertir el usuario de entrada del método a un <xref:System.Double> valor.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> no representa un número con un formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa un número menor que <see cref="F:System.Double.MinValue" /> o mayor que <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <param name="style">Combinación bit a bit de los valores de enumeración que indica los elementos de estilo que pueden estar presentes en <c>s</c>. Un valor que se especifica de forma habitual es <see cref="F:System.Globalization.NumberStyles.Float" /> combinado con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural sobre <c>s</c>.</param>
        <summary>Convierte la representación en forma de cadena de un número con un estilo y un formato específico de la referencia cultural especificados en el número de punto flotante de precisión doble equivalente.</summary>
        <returns>Número de punto flotante de precisión doble equivalente al valor numérico o símbolo especificado en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `style` parámetro define los elementos de estilo (como espacios en blanco, miles separadores y símbolos de moneda) que se permiten en la `s` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración. El siguiente <xref:System.Globalization.NumberStyles> miembros no son compatibles:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 El `s` parámetro puede contener <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para la referencia cultural especificada por `provider`. Dependiendo del valor de `style`, también puede tener el formato:  
  
 [*ws*] [*$*] [*inicio de sesión*] [*dígitos enteros*,]*dígitos enteros*[. [ *dígitos fraccionarios*]] [E [*inicio de sesión*]*dígitos exponenciales*] [*ws*]  
  
 Elementos que aparecen entre corchetes ([y]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Una serie de caracteres de espacio en blanco. Espacio en blanco puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca y pueden aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|$|Un símbolo de moneda específico de la referencia cultural. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual. Símbolo de divisa de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Símbolos de un signo menos (-) o un signo positivo (+) de símbolos. El signo puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y pueden aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `s` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*dígitos enteros*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte entera del número. El *dígitos enteros* puede ser el elemento está ausente if la cadena contiene la *dígitos fraccionarios* elemento.|  
|,|Separador de grupos de referencias culturales específicas. Símbolo de separador de grupos de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca|  
|.|Un símbolo de separador decimal de referencias culturales específicas. Símbolo de separador decimal de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*dígitos fraccionarios*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte fraccionaria del número. Pueden aparecer dígitos fraccionarios en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en notación exponencial (científica). El `s` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
|*dígitos exponenciales*|Una serie de dígitos que comprende del 0 al 9 que especifican a un exponente.|  
  
 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> estilo) siempre se analiza correctamente. El resto <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> miembros controlan los elementos que pueden estar presentes, pero no tienen que estar presentes en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> marcas afectan a los elementos que pueden estar presentes en `s`.  
  
|Valor NumberStyles|Elementos permitidos en `s` además de dígitos|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos enteros* solo el elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El separador decimal (*.*) y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o el carácter "E", que indica notación exponencial. Este marcador por sí solo admite valores en el formulario *dígitos*E*dígitos*; adicionales se necesitan marcadores para analizar correctamente cadenas con esos elementos como signos positivos o negativos y los símbolos de separador decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *inicio de sesión* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *inicio de sesión* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *inicio de sesión* elemento en forma de paréntesis delimitando el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Los miles elemento separador (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El elemento de moneda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos los elementos. Sin embargo, `s` no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `s`, *inicio de sesión* al principio de `s`y el símbolo de separador decimal (.). El `s` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, miles separador (,) y los elementos de punto decimal (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los elementos. Sin embargo, `s` no puede representar un número hexadecimal.|  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que aporta información específica de la referencia cultural usada para interpretar el formato de `s`. Normalmente, es un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> objeto. Si `provider` es `null` o <xref:System.Globalization.NumberFormatInfo> no se puede obtener, la información de formato se usa la referencia cultural del sistema actual.  
  
 Por lo general, si se pasa el <xref:System.Double.Parse%2A?displayProperty=nameWithType> método es una cadena que se crea mediante una llamada a la <xref:System.Double.ToString%2A?displayProperty=nameWithType> /método siguiente, la versión original <xref:System.Double> se devuelve el valor. Sin embargo, debido a una pérdida de precisión, los valores pueden no ser iguales. Además, al intentar analizar la representación de cadena de <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> produce una <xref:System.OverflowException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método para asignar varias representaciones de cadena de valores de temperatura a un `Temperature` objeto.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> no representa un valor numérico.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> no es un valor <see cref="T:System.Globalization.NumberStyles" />.  -o bien- <paramref name="style" /> es el valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa un número menor que <see cref="F:System.Double.MinValue" /> o mayor que <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Representa infinito positivo. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es el resultado de dividir un número positivo por cero.  
  
 Esta constante se devuelve cuando el resultado de una operación es mayor que <xref:System.Double.MaxValue>.  
  
 Utilice <xref:System.Double.IsPositiveInfinity%2A> para determinar si un valor se evalúa como infinito positivo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>Es <see langword="true" /> si el valor de la instancia actual no es cero; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>No se admite esta conversión. Cualquier intento de usar este método produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No se admite esta conversión. No se devuelve ningún valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>No se admite esta conversión. Cualquier intento de usar este método produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No se admite esta conversión. No se devuelve ningún valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, sin ningún tipo de modificación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo al que se va a convertir este valor <see cref="T:System.Double" />.</param>
        <param name="provider">Implementación de <see cref="T:System.IFormatProvider" /> que proporciona información específica de la referencia cultural sobre el formato del valor devuelto.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la `static` (`Shared` en Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Double> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente.</summary>
        <returns>Representación de cadena del valor de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.ToString> método formatos un <xref:System.Double> valor en el valor predeterminado ("G" o general), formato de la referencia cultural actual. Si desea especificar un formato diferente, la precisión o la referencia cultural, use las otras sobrecargas de la <xref:System.Double.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Una referencia cultural específica|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato concreto o la precisión|Referencia cultural predeterminada de (actual).|<xref:System.Double.ToString%28System.String%29>|  
|Un formato concreto o la precisión|Una referencia cultural específica|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 El valor devuelto puede ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una cadena del formulario:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 Elementos opcionales están entre corchetes ([y]). Elementos que contienen el término "dígitos" constan de una serie de caracteres numéricos comprendidos entre 0 y 9. Se admiten los elementos enumerados en la tabla siguiente.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*sign*|Un signo negativo o el símbolo de signo positivo.|  
|*dígitos enteros*|Una serie de dígitos que especifican la parte entera del número. Dígitos enteros pueden no estar presentes si hay dígitos fraccionarios.|  
|'*.*'|Un símbolo de separador decimal de referencias culturales específicas.|  
|*dígitos fraccionarios*|Una serie de dígitos que especifican la parte fraccionaria del número.|  
|'*e*'|Un carácter en minúscula 'e', que indica una notación exponencial (científica).|  
|*dígitos exponenciales*|Una serie de dígitos que especifican a un exponente.|  
  
 Algunos ejemplos del valor devuelto son "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" y "-Infinity".  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre cómo dar formato, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza el valor predeterminado <xref:System.Double.ToString?displayProperty=nameWithType> método para mostrar las representaciones de cadena de un número de <xref:System.Double> valores.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 En el ejemplo siguiente se muestra el uso de <xref:System.Double.ToString%2A>.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente usando la información de formato específica de la referencia cultural especificada.</summary>
        <returns>Representación en forma de cadena del valor de esta instancia, tal y como especifica <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.ToString%28System.IFormatProvider%29> método formatos un <xref:System.Double> valor en el valor predeterminado ("G" o general), formato de una referencia cultural especificada. Si desea especificar un formato diferente o la referencia cultural, use las otras sobrecargas de la <xref:System.Double.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Predeterminado (actual).|<xref:System.Double.ToString>|  
|Un formato concreto o la precisión|Referencia cultural predeterminada de (actual).|<xref:System.Double.ToString%28System.String%29>|  
|Un formato concreto o la precisión|Una referencia cultural específica|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 El valor devuelto puede ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una cadena del formulario:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 Elementos opcionales están entre corchetes ([y]). Elementos que contienen el término "dígitos" constan de una serie de caracteres numéricos comprendidos entre 0 y 9. Se admiten los elementos enumerados en la tabla siguiente.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*sign*|Un signo negativo o el símbolo de signo positivo.|  
|*dígitos enteros*|Una serie de dígitos que especifican la parte entera del número. Dígitos enteros pueden no estar presentes si hay dígitos fraccionarios.|  
|'*.*'|Un símbolo de separador decimal de referencias culturales específicas.|  
|*dígitos fraccionarios*|Una serie de dígitos que especifican la parte fraccionaria del número.|  
|'*e*'|Un carácter en minúscula 'e', que indica una notación exponencial (científica).|  
|*dígitos exponenciales*|Una serie de dígitos que especifican a un exponente.|  
  
 Algunos ejemplos del valor devuelto son "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" y "-Infinity".  
  
 Esta instancia está formateada con el especificador de formato numérico general ("G").  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre cómo dar formato, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto. Por lo general, `provider` es un <xref:System.Globalization.CultureInfo> objeto o un <xref:System.Globalization.NumberFormatInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural utilizada para dar formato. Si `provider` es `null`, el valor devuelto se representa con la <xref:System.Globalization.NumberFormatInfo> objeto para la referencia cultural actual.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la representación de cadena de dos <xref:System.Double> valores mediante <xref:System.Globalization.CultureInfo> objetos que representan varias referencias culturales diferentes.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 En el ejemplo siguiente se muestra el uso de <xref:System.Double.ToString%2A>, teniendo un <xref:System.String> y un <xref:System.IFormatProvider> como parámetros.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato numérico.</param>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente usando el formato especificado.</summary>
        <returns>Representación en forma de cadena del valor de esta instancia, tal y como especifica <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.ToString%28System.String%29> método formatos un <xref:System.Double> valor en un formato especificado usando las convenciones de la referencia cultural actual. Si desea especificar un formato diferente o la referencia cultural, use las otras sobrecargas de la <xref:System.Double.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Referencia cultural predeterminada de (actual).|<xref:System.Double.ToString>|  
|Formato predeterminado ("G")|Una referencia cultural específica|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato concreto o la precisión|Una referencia cultural específica|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 El valor devuelto puede ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la representación de cadena de un número, tal y como especifica `format`.  
  
 El `format` parámetro puede ser cualquier especificador de formato numérico estándar válido salvo D y X, así como cualquier combinación de especificadores de formato numérico personalizado. Si `format` es `null` o una cadena vacía, el valor devuelto se le aplica formato con el especificador de formato numérico general ("G").  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre cómo dar formato, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
 De forma predeterminada, el valor devuelto solo contiene 15 dígitos de precisión, aunque internamente se conserva 17 dígitos como máximo. Si el valor de esta instancia tiene más de 15 dígitos, <xref:System.Double.ToString%2A> devuelve <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> en lugar del número esperado. Si se requiere mayor precisión, especifique `format` con la especificación de formato "G17", que siempre devuelve 17 dígitos de precisión, o "R", que devuelve 15 dígitos si el número se puede representar con esa precisión o 17 dígitos si el número sólo puede ser representa con precisión máxima.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un valor numérico y formatea como un valor de moneda mediante la cadena de formato numérico estándar "C" y como un valor numérico con tres posiciones decimales mediante el uso de la cadena de formato numérico estándar "N". Se da formato a las cadenas de resultado usando las convenciones de la referencia cultural en-US. Para obtener más información sobre cadenas de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 El ejemplo siguiente muestra varios <xref:System.Double> valores mediante los especificadores de formato numérico estándar compatibles junto con tres cadenas de formato numérico personalizado. Una de esas cadenas de formato personalizado muestra cómo rellenar un <xref:System.Single> valor con ceros a la izquierda. Además, el ejemplo utiliza los especificadores de precisión con cada especificador de formato estándar excepto "R". Los valores de precisión especificadores entre 0 y 3. Para convertir los valores numéricos en cadenas, el ejemplo utiliza las convenciones de formato de la referencia cultural en-US.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> no es válido.</exception>
        <block subset="none" type="usage">
          <para>En algunos casos, <see cref="T:System.Double" /> aplicar formato a valores con los no de cadena de formato numérico estándar "R" ida no correctamente si se compilan con la <see langword="/platform:x64" /> o <see langword="/platform:anycpu" /> conmutadores y se ejecutan en sistemas de 64 bits. Para evitar este problema, puede dar formato a los valores <see cref="T:System.Double" /> usando la cadena de formato numérico estándar "G17". En el ejemplo siguiente se usa la cadena de formato "R" con un <see cref="T:System.Double" /> valor que no no ida y vuelta correctamente, y también usa "G17" cadena de formato para ida y vuelta correctamente el valor original.  [! código csharp [System.Double.ToString#6] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. Double.ToString/cs/roundtripex2.cs#6)] [! código de vb [System.Double.ToString#6] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. Double.ToString/vb/roundtripex2.vb#6)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato numérico.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor numérico de esta instancia en su representación de cadena equivalente mediante el formato y la información de formato específica de la referencia cultural que se especificaran.</summary>
        <returns>Representación de cadena del valor de esta instancia, tal y como especifican <paramref name="format" /> y <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> método formatos un <xref:System.Double> valor en un formato específico de la referencia cultural especificada. Si desea especificar un formato diferente o la referencia cultural, use las otras sobrecargas de la <xref:System.Double.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Referencia cultural predeterminada de (actual).|<xref:System.Double.ToString>|  
|Formato predeterminado ("G")|Una referencia cultural específica|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato concreto o la precisión|Referencia cultural predeterminada de (actual).|<xref:System.Double.ToString%28System.String%29>|  
  
 El valor devuelto puede ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la representación de cadena de un número, tal y como especifica `format`.  
  
 El `format` parámetro puede ser cualquier especificador de formato numérico estándar válido salvo D y X, así como cualquier combinación de especificadores de formato numérico personalizado. Si `format` es `null` o una cadena vacía, el valor devuelto de esta instancia está formateada con el especificador de formato numérico general ("G").  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre cómo dar formato, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto. Por lo general, `provider` es un <xref:System.Globalization.CultureInfo> objeto o un <xref:System.Globalization.NumberFormatInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural utilizada para dar formato. Si `provider` es `null`, el valor devuelto se representa con la <xref:System.Globalization.NumberFormatInfo> objeto para la referencia cultural actual.  
  
 De forma predeterminada, el valor devuelto solo contiene 15 dígitos de precisión, aunque internamente se conserva 17 dígitos como máximo. Si el valor de esta instancia tiene más de 15 dígitos, <xref:System.Double.ToString%2A> devuelve <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> en lugar del número esperado. Si se requiere mayor precisión, especifique `format` con la especificación de formato "G17", que siempre devuelve 17 dígitos de precisión, o "R", que devuelve 15 dígitos si el número se puede representar con esa precisión o 17 dígitos si el número sólo puede ser representa con precisión máxima.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un <xref:System.Double> valor con cada uno de los especificadores de formato numérico estándar compatibles para varias referencias culturales diferentes.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 En el ejemplo siguiente se muestra el uso de <xref:System.Double.ToString%2A>, teniendo un <xref:System.String> y un <xref:System.IFormatProvider> como parámetros.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>En algunos casos, <see cref="T:System.Double" /> aplicar formato a valores con los no de cadena de formato numérico estándar "R" ida no correctamente si se compilan con la <see langword="/platform:x64" /> o <see langword="/platform:anycpu" /> conmutadores y se ejecutan en sistemas de 64 bits. Para evitar este problema, puede dar formato a los valores <see cref="T:System.Double" /> usando la cadena de formato numérico estándar "G17". En el ejemplo siguiente se usa la cadena de formato "R" con un <see cref="T:System.Double" /> valor que no no ida y vuelta correctamente, y también usa "G17" cadena de formato para ida y vuelta correctamente el valor original.  [! código csharp [System.Double.ToString#5] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. Double.ToString/cs/roundtripex1.cs#5)] [! código de vb [System.Double.ToString#5] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. Double.ToString/vb/roundtripex1.vb#5)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la representación en forma de cadena de un número en el número de punto flotante de precisión doble equivalente. Un valor devuelto indica si la conversión se realizó correctamente o si se produjeron errores.</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <param name="result">Cuando este método devuelve un resultado, contiene el número de punto flotante de precisión doble equivalente al parámetro <c>s</c> si la conversión se ha producido correctamente o cero en caso de error. La conversión no se produce correctamente si el parámetro <c>s</c> es <see langword="null" /> o <see cref="F:System.String.Empty" />, no es un número con formato válido o representa un número menor que <see cref="F:System.Double.MinValue" /> o mayor que <see cref="F:System.Double.MaxValue" />. Este parámetro se pasa sin inicializar; se sobrescribirán todos los valores proporcionados originalmente en <c>result</c>.</param>
        <summary>Convierte la representación en forma de cadena de un número en el número de punto flotante de precisión doble equivalente. Un valor devuelto indica si la conversión se realizó correctamente o si se produjeron errores.</summary>
        <returns>
          <see langword="true" /> si <paramref name="s" /> se convirtió correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga difiere de la <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> método devolviendo un valor booleano que indica si la operación de análisis se realizó correctamente en lugar de devolver el valor numérico analizado. Elimina la necesidad de utilizar el control de excepciones para probar una <xref:System.FormatException> en caso de que `s` no es válido y no se puede analizar correctamente.  
  
 El `s` parámetro puede contener la referencia cultural actual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (la comparación de cadenas distingue mayúsculas de minúsculas), o una cadena del formulario:  
  
 [ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Una serie de caracteres de espacio en blanco.|  
|*sign*|Un signo negativo o el símbolo de signo positivo.|  
|*dígitos enteros*|Una serie de caracteres numéricos comprendidos entre 0 y 9 y que especifican la parte entera del número. Dígitos enteros pueden no estar presentes si hay dígitos fraccionarios.|  
|*,*|Un símbolo de separador de grupo específicas de referencias culturales.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas.|  
|*dígitos fraccionarios*|Una serie de caracteres numéricos comprendidos entre 0 y 9 y que especifican la parte fraccionaria del número.|  
|*E*|Un letra mayúscula o minúscula carácter 'e', que indica una notación exponencial (científica).|  
|*dígitos exponenciales*|Una serie de caracteres numéricos comprendidos entre 0 y 9 y que especifican a un exponente.|  
  
 Para obtener más información acerca de formatos numéricos, vea [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
 El `s` parámetro se interpreta mediante una combinación de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marcas. Esto significa que el espacio en blanco y miles se permiten separadores pero no los símbolos de divisa. Para definir explícitamente los elementos (como símbolos de moneda, miles separadores y espacios en blanco) que pueden estar presentes en `s`, use el <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> sobrecarga del método.  
  
 El `s` parámetro se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto que se inicializa para la referencia cultural del sistema actual. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Para analizar una cadena usando la información de formato de alguna otra especifica la referencia cultural, use el <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> sobrecarga del método.  
  
 Por lo general, si se pasa el <xref:System.Double.TryParse%2A?displayProperty=nameWithType> método es una cadena que se crea mediante una llamada a la <xref:System.Double.ToString%2A?displayProperty=nameWithType> /método siguiente, la versión original <xref:System.Double> se devuelve el valor. Sin embargo, debido a una pérdida de precisión, los valores pueden no ser iguales. Además, al intentar analizar la representación de cadena de <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> produce una <xref:System.OverflowException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y los separadores decimales y de grupo son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un separador de grupos. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> método para convertir las representaciones de cadena de valores numéricos a <xref:System.Double> valores. Se supone que en-US es la referencia cultural actual.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <param name="style">Combinación bit a bit de valores <see cref="T:System.Globalization.NumberStyles" /> que indica el formato permitido de <c>s</c>. Un valor que se especifica de forma habitual es <see cref="F:System.Globalization.NumberStyles.Float" /> combinado con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> que proporciona información de formato específica de la referencia cultural sobre <c>s</c>.</param>
        <param name="result">Cuando este método devuelve un resultado, contiene el número de punto flotante de precisión doble equivalente al valor numérico o al símbolo contenido en <c>s</c> si la conversión se ha producido correctamente o cero en caso de error. Se produce un error en la conversión si el parámetro <c>s</c> es <see langword="null" /> o <see cref="F:System.String.Empty" />, no tiene un formato compatible con <c>style</c>, representa un número menor que <see cref="F:System.SByte.MinValue" /> o mayor que <see cref="F:System.SByte.MaxValue" />, o bien si <c>style</c> no es una combinación válida de constantes enumeradas de <see cref="T:System.Globalization.NumberStyles" />. Este parámetro se pasa sin inicializar; se sobrescribirán todos los valores proporcionados originalmente en <c>result</c>.</param>
        <summary>Convierte la representación en forma de cadena de un número con un estilo y un formato específico de la referencia cultural especificados en el número de punto flotante de precisión doble equivalente. Un valor devuelto indica si la conversión se realizó correctamente o si se produjeron errores.</summary>
        <returns>
          <see langword="true" /> si <paramref name="s" /> se convirtió correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.TryParse%2A> método es similar a la <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método, salvo que este método no produce una excepción si se produce un error en la conversión. Si la conversión se realiza correctamente, el valor devuelto es `true` y `result` parámetro se establece en el resultado de la conversión. Si se produce un error en la conversión, el valor devuelto es `false` y `result` parámetro se establece en cero. Esto elimina la necesidad de utilizar el control de excepciones para probar una <xref:System.FormatException> en caso de que `s` no es válido y no se puede analizar correctamente.  
  
 El `style` parámetro define el formato permitido de la `s` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración. El siguiente <xref:System.Globalization.NumberStyles> miembros no son compatibles:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 El `s` parámetro puede contener <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para la referencia cultural indicada por `provider`. Además, dependiendo del valor de `style`, el `s` parámetro puede incluir los siguientes elementos:  
  
 [ws] [$] [inicio de sesión] [dígitos enteros,] dígitos enteros [. dígitos fraccionarios] [e [signo] dígitos exponenciales] [eb]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional. Espacio en blanco puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca. Puede aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|*$*|Un símbolo de moneda específico de la referencia cultural. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> o <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la <xref:System.Globalization.NumberFormatInfo> objeto devuelto por la <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> método de la `provider` parámetro. El símbolo de moneda puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Un signo opcional. El signo puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y pueden aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `s` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*dígitos enteros*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte entera del número. Dígitos enteros pueden no estar presentes si hay dígitos fraccionarios.|  
|*,*|Específicas de referencias culturales miles símbolo de separador. Miles de la referencia cultural actual puede aparecer el símbolo del separador en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas. Símbolo de separador decimal de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*dígitos fraccionarios*|Una serie de dígitos que comprende del 0 al 9 y que especifican la parte fraccionaria del número. Pueden aparecer dígitos fraccionarios en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*e*|El carácter e o E, que indica que `s` puede representar un número mediante notación exponencial. El `s` parámetro puede representar un número en notación exponencial si el estilo incluye el <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
|*dígitos exponenciales*|Una serie de dígitos que comprende del 0 al 9 que especifican a un exponente.|  
  
 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> estilo) siempre se analiza correctamente. El resto <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> miembros controlan los elementos que pueden ser pero no tienen que estar presentes en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> marcas afectan a los elementos que pueden estar presentes en `s`.  
  
|Valor NumberStyles|Elementos permitidos en s además de dígitos|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos enteros* solo el elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El elemento de lenguaje *.* y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|El `s` parámetro también puede utilizar la notación exponencial. Este marcador por sí solo admite valores en el formulario *dígitos enteros*E*dígitos exponenciales*; adicionales se necesitan marcadores para analizar correctamente cadenas en notación exponencial con esos elementos como signos positivos o negativos y los símbolos de separador decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *inicio de sesión* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *inicio de sesión* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *inicio de sesión* elemento en forma de paréntesis delimitando el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|El *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El * $ * elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos. El `s` parámetro no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `s`, *inicio de sesión* al principio de `s`y el *.* símbolo. El `s` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, miles separador (*,),* y punto decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los estilos excepto `s` no puede representar un número hexadecimal.|  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación, como un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural utilizada en el análisis. Si `provider` es `null` o <xref:System.Globalization.NumberFormatInfo> no se puede obtener el objeto, se utiliza la información de formato para la referencia cultural actual.  
  
 Se produce un error en la conversión si el `s` parámetro es `null` o un valor no numérico, el `provider` parámetro no produce un <xref:System.Globalization.NumberFormatInfo> objeto, o el `style` parámetro no es una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración.  
  
 Por lo general, si se pasa el <xref:System.Double.TryParse%2A?displayProperty=nameWithType> método es una cadena que se crea mediante una llamada a la <xref:System.Double.ToString%2A?displayProperty=nameWithType> /método siguiente, la versión original <xref:System.Double> se devuelve el valor. Sin embargo, debido a una pérdida de precisión, los valores pueden no ser iguales. Además, al intentar analizar la representación de cadena de <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> produce una <xref:System.OverflowException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> método para analizar la representación de cadena de números que tienen un estilo determinado y se da formato usando las convenciones de una referencia cultural determinada.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> no es un valor <see cref="T:System.Globalization.NumberStyles" />.  -o bien- <paramref name="style" /> incluye el valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>