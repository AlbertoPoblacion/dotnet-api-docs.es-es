<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2c88c30ffa35750968f7aaa452806739fc48db98" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59355194" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa texto como una secuencia de unidades de código UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Una cadena es una colección secuencial de caracteres que se utiliza para representar texto. Un <xref:System.String> objeto es una colección secuencial de <xref:System.Char?displayProperty=nameWithType> objetos que representan una cadena; un <xref:System.Char?displayProperty=nameWithType> objeto corresponde a una unidad de código UTF-16. El valor de la <xref:System.String> objeto es el contenido de la colección secuencial de <xref:System.Char?displayProperty=nameWithType> objetos, y que el valor es inmutable (es decir, es de solo lectura). Para obtener más información acerca de la inmutabilidad de cadenas, vea el [inmutabilidad y la clase StringBuilder](#Immutability) sección más adelante en este tema. El tamaño máximo de un <xref:System.String> objeto en memoria es 2 GB, o aproximadamente 1 millones de caracteres.  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 En esta sección:  
  
 [Instancias de un objeto de cadena](#Instantiation)   
 [Los caracteres Unicode y objetos Char](#Characters)   
 [Las cadenas y el estándar Unicode](#Unicode)   
 [Las cadenas y caracteres nulos incrustados](#EmbeddedNulls)   
 [Las cadenas e índices](#Indexes)   
 [Cadenas nulas y cadenas vacías](#Nulls)   
 [La inmutabilidad y la clase StringBuilder](#Immutability)   
 [Ordinal frente a operaciones sensibles a la referencia cultural](#CultureSensitive)   
 [Normalización](#Normalization)   
 [Operaciones de cadenas por categoría](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Instancias de un objeto de cadena  
 Puede crear instancias de un <xref:System.String> objeto de las maneras siguientes:  
  
-   Mediante la asignación de un literal de cadena a un <xref:System.String> variable. Este es el método más usado para crear una cadena. El ejemplo siguiente utiliza la asignación para crear varias cadenas. Tenga en cuenta que en C#, ya que la barra diagonal inversa (\\) es un carácter de escape, se debe escapar barra diagonal literal en una cadena o la cadena completa debe ser @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Mediante una llamada a un <xref:System.String> constructor de clase. El ejemplo siguiente se crea una instancia de cadenas mediante una llamada a varios constructores de clase. Tenga en cuenta que algunos de los constructores son punteros a matrices de caracteres o matrices de bytes con signo como parámetros. Visual Basic no admite llamadas a estos constructores. Para obtener información detallada sobre <xref:System.String> constructores, vea el <xref:System.String.%23ctor%2A> resumen del constructor.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp-interactive[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Utilizando el operador de concatenación (+ en C# y & o + en Visual Basic) para crear una sola cadena de cualquier combinación de <xref:System.String> instancias y literales de cadena. El ejemplo siguiente muestra el uso del operador de concatenación de cadena.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Recuperar una propiedad o llamar a un método que devuelve una cadena. El ejemplo siguiente utiliza los métodos de la <xref:System.String> clase para extraer una subcadena de una cadena mayor.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Mediante una llamada a un método para convertir un valor u objeto en su representación de cadena de formato. En el ejemplo siguiente se usa el [formatos compuestos](~/docs/standard/base-types/composite-formatting.md) característica para incrustar la representación de cadena de dos objetos en una cadena.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp-interactive[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Los caracteres Unicode y objetos Char  
 Cada carácter de una cadena se define mediante un valor escalar Unicode, también denominado punto de código Unicode o el valor ordinal (numérico) del carácter Unicode. Cada punto de código se codifica utilizando la codificación UTF-16, y el valor numérico de cada elemento de la codificación se representa mediante un <xref:System.Char> objeto.  
  
> [!NOTE]
>  Tenga en cuenta que, dado un <xref:System.String> instancia se compone de una colección secuencial de unidades de código UTF-16, es posible crear un <xref:System.String> objeto que no es una cadena Unicode con formato correcto. Por ejemplo, es posible crear una cadena que tenga un suplente bajo sin un suplente alto correspondiente. Aunque algunos métodos, como los métodos de codificación y descodificación de objetos en el <xref:System.Text> espacio de nombres, es posible que realiza comprobaciones para asegurarse de que las cadenas están bien formadas, <xref:System.String> los miembros de clase no garantizan que una cadena es correcta.  
  
 Una sola <xref:System.Char> objeto normalmente representa un único punto de código; es decir, el valor numérico de la <xref:System.Char> es igual al punto de código. Por ejemplo, el punto de código para el carácter "a" es u+0061. Sin embargo, un punto de código podría requerir más de un elemento codificado (más de un <xref:System.Char> objeto). El estándar Unicode define dos tipos de caracteres que corresponden a varios <xref:System.Char> objetos: graphemes y puntos de código adicionales que se corresponden con los caracteres de los aviones con Unicode.  
  
-   Un grafemas está representado por un carácter base seguido de uno o más caracteres de combinación. Por ejemplo, el carácter Unicote se representa mediante un <xref:System.Char> objeto cuyo punto de código está seguido por un u+0061 <xref:System.Char> objeto cuyo punto de código es + u+0308. Este carácter también puede definirse mediante una sola <xref:System.Char> objeto que tiene un punto de código de 00E4 U +. Como se muestra en el ejemplo siguiente, una comparación de referencias culturales de igualdad indica que estas dos representaciones son iguales, aunque no lo hace una comparación ordinal normal. Sin embargo, si se normalizan las dos cadenas, una comparación ordinal también indica si son iguales. (Para obtener más información sobre la normalización de cadenas, vea el [normalización](#Normalization) sección.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode (un par suplente) del punto de código adicional se representa mediante un <xref:System.Char> objeto cuyo punto de código es un suplente alto seguido por un <xref:System.Char> objeto cuyo punto de código es un suplente bajo. Las unidades de código suplentes altos del intervalo de u+D800 a U+DBFF. Las unidades de código suplentes bajo del intervalo de u+DC00 a U+DFFF. Los pares suplentes se utilizan para representar los caracteres de los aviones con 16 de Unicode. El ejemplo siguiente se crea un carácter suplente y lo pasa a la <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> método para determinar si se trata de un par suplente.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Las cadenas y el estándar Unicode  
 Caracteres de una cadena se representan mediante unidades de código con codificación UTF-16, que corresponden a <xref:System.Char> valores.  
  
 Cada carácter de una cadena tiene una categoría de caracteres Unicode asociada, que se representa en .NET mediante el <xref:System.Globalization.UnicodeCategory> enumeración. La categoría de un carácter o un par suplente se puede determinar mediante una llamada a la <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> método.  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 Además, .NET admite la comparación de cadenas y ordenar según el estándar Unicode. En las versiones de .NET Framework a través de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework mantiene su propia tabla de datos de cadena. También es el caso de las versiones de .NET Framework a partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)] que se ejecutan en Windows 7. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)] que se ejecutan en Windows 8 y versiones posteriores del sistema operativo Windows, la cadena de los delegados en tiempo de ejecución de comparaciones y ordenaciones de las operaciones en el sistema operativo. Comparación de cadenas en .NET Core, y ordenar la información proporcionada por [International Components for Unicode](http://site.icu-project.org/) bibliotecas. En la tabla siguiente se enumera las versiones de .NET y las versiones del estándar Unicode en caracteres que se basan las comparaciones y ordenaciones.  
  
|Versión de .NET|Versión del estándar Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Estándar Unicode, versión 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Estándar Unicode, versión 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Estándar Unicode, versión 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Estándar Unicode, versión 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] y versiones posteriores en Windows 7|[Estándar Unicode, versión 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] y versiones posteriores en Windows 8 y los sistemas operativos de Windows posteriores|[Estándar Unicode, versión 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (todas las versiones)|Depende de la versión del estándar Unicode compatible con el sistema operativo subyacente.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Las cadenas y caracteres nulos incrustados  
 En. NET, un <xref:System.String> objeto puede incluir caracteres nulos incrustados, que cuentan como parte de la longitud de cadena. Sin embargo, en algunos lenguajes como C y C++, un carácter null indica el final de una cadena; no se considera parte de la cadena y no se cuentan como parte de la longitud de cadena. Esto significa que las suposiciones siguientes comunes que podrían hacer que los programadores de C y C++ o bibliotecas escritas en C o C++ acerca de las cadenas no son necesariamente válidas cuando se aplica a <xref:System.String> objetos:  
  
-   El valor devuelto por la `strlen` o `wcslen` funciones no es necesariamente igual <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   La cadena creada por el `strcpy_s` o `wcscpy_s` funciones no es necesariamente idéntica a la cadena creada por el <xref:System.String.Copy%2A?displayProperty=nameWithType> método.  
  
 Debe asegurarse de ese código de C y C++ nativo que crea una instancia de <xref:System.String> objetos y el código que se pasa <xref:System.String> objetos a través de la plataforma de invocación, no suponga que un carácter nulo incrustado marca el final de la cadena.  
  
 Caracteres nulos incrustados en una cadena también se tratan de forma diferente cuando una cadena se ordenan (o en comparación con) y cuando se busca una cadena. Caracteres null se omiten al realizar comparaciones entre dos cadenas, incluyendo las comparaciones con la referencia cultural invariable. Se consideran sólo para las comparaciones ordinales ordinales o mayúsculas y minúsculas. Por otro lado, siempre se consideran caracteres nulos incrustados al buscar una cadena con métodos como <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, y <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Las cadenas e índices  
 Un índice es la posición de un <xref:System.Char> objeto (no un carácter Unicode) en un <xref:System.String>. Un índice es un número no negativo de base cero que se inicia desde la primera posición en la cadena, que es la posición de índice cero. Un número de métodos de búsqueda, como <xref:System.String.IndexOf%2A> y <xref:System.String.LastIndexOf%2A>, devolver el índice de un carácter o subcadena en la instancia de cadena.  
  
 El <xref:System.String.Chars%2A> propiedad le permite tener acceso a individuales <xref:System.Char> objetos por su posición de índice en la cadena. Dado que el <xref:System.String.Chars%2A> propiedad es la propiedad predeterminada (en Visual Basic) o el indizador (en C#), puede tener acceso a la persona <xref:System.Char> objetos en una cadena mediante código como el siguiente. Este código busca un espacio en blanco o caracteres de puntuación en una cadena para determinar el número de palabras contiene la cadena.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Porque el <xref:System.String> la clase implementa la <xref:System.Collections.IEnumerable> interfaz, también puede iterar por la <xref:System.Char> objetos en una cadena mediante un `foreach` construcción, como se muestra en el ejemplo siguiente.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Valores de índice consecutivos no pueden corresponderse con caracteres Unicode consecutivos, porque podría ser el carácter Unicode codificado como más de un <xref:System.Char> objeto. En concreto, una cadena puede contener varios caracteres unidades de texto que están formadas por un carácter base seguido por uno o más caracteres de combinación o por pares suplentes. Para trabajar con caracteres Unicode en lugar de <xref:System.Char> objetos, utilice el <xref:System.Globalization.StringInfo?displayProperty=nameWithType> y <xref:System.Globalization.TextElementEnumerator> clases. El ejemplo siguiente muestra la diferencia entre el código que funciona con <xref:System.Char> objetos y el código que funciona con los caracteres Unicode. Compara el número de caracteres o elementos de texto de cada palabra de una frase. La cadena incluye dos secuencias de un carácter base seguido por un carácter de combinación.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 En este ejemplo funciona con elementos de texto mediante el <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> método y el <xref:System.Globalization.TextElementEnumerator> clase para enumerar todos los elementos de texto en una cadena. También puede recuperar una matriz que contiene el índice inicial de cada elemento de texto mediante una llamada a la <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> método.  
  
 Para obtener más información sobre cómo trabajar con unidades de texto en lugar de persona <xref:System.Char> valores, vea el <xref:System.Globalization.StringInfo> clase.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Cadenas nulas y cadenas vacías  
 Es una cadena que se ha declarado pero no se ha asignado un valor `null`. Al intentar llamar a métodos en esa cadena produce una <xref:System.NullReferenceException>. Una cadena null es diferente de una cadena vacía, que es una cadena cuyo valor es "" o <xref:System.String.Empty?displayProperty=nameWithType>. En algunos casos, pasando una cadena nula o una cadena vacía como argumento en una llamada al método produce una excepción. Por ejemplo, al pasar una cadena nula para la <xref:System.Int32.Parse%2A?displayProperty=nameWithType> método produce una <xref:System.ArgumentNullException>y pasar una cadena vacía produce un <xref:System.FormatException>. En otros casos, un argumento de método puede ser una cadena nula o una cadena vacía. Por ejemplo, si va a proporcionar un <xref:System.IFormattable> implementación para una clase, desea equivalen a una cadena nula y una cadena vacía con el especificador de formato general ("G").  
  
 El <xref:System.String> clase incluye los siguientes métodos de dos conveniencia que permiten probar si una cadena es `null` o está vacío:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, que indica si una cadena es `null` o es igual a <xref:System.String.Empty?displayProperty=nameWithType>. Este método elimina la necesidad de usar código como el siguiente:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, que indica si una cadena es `null`, es igual a <xref:System.String.Empty?displayProperty=nameWithType>, o consta únicamente de caracteres de espacio en blanco. Este método elimina la necesidad de usar código como el siguiente:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 En el ejemplo siguiente se usa el <xref:System.String.IsNullOrEmpty%2A> método en el <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementación de un personalizado `Temperature` clase. El método es compatible con las cadenas de formato "G", "C", "F" y "K". Si una cadena de formato vacío o un formato de cadena cuyo valor es `null` se pasa al método, se cambia su valor a la cadena de formato "G".  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>La inmutabilidad y la clase StringBuilder  
 Un <xref:System.String> objeto se denomina inmutable (de solo lectura), porque su valor no puede modificarse una vez que se ha creado. Los métodos que parecen modificar una <xref:System.String> objeto realmente se devuelven en un nuevo <xref:System.String> objeto que contiene la modificación.  
  
 Dado que las cadenas son inmutables, rutinas de manipulación de cadena que llevan a cabo repiten adiciones o eliminaciones en lo que parece ser que una sola cadena puede suponer una reducción del rendimiento significativa. Por ejemplo, el código siguiente utiliza un generador de números aleatorios para crear una cadena con 1000 caracteres en el intervalo 0 x 0001 a 0x052F. Aunque el código parece que utiliza la concatenación de cadenas para anexar un carácter de nueva a la cadena existente denominada `str`, realmente crea una nueva <xref:System.String> objeto para cada operación de concatenación.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Puede usar el <xref:System.Text.StringBuilder> clase en lugar de la <xref:System.String> clase para las operaciones que realizan varios cambios en el valor de una cadena. A diferencia de las instancias de la <xref:System.String> (clase), <xref:System.Text.StringBuilder> objetos son mutables; al concatenar, anexar o eliminar subcadenas de una cadena, las operaciones se realizan en una sola cadena. Cuando haya terminado de modificar el valor de un <xref:System.Text.StringBuilder> objeto, puede llamar a su <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método para convertirlo en una cadena. En el ejemplo siguiente se sustituye el <xref:System.String> usado en el ejemplo anterior para concatenar los 1000 caracteres aleatorios en el intervalo de 0 x 0001 a 0x052F con un <xref:System.Text.StringBuilder> objeto.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Ordinal frente a operaciones sensibles a la referencia cultural  
 Los miembros de la <xref:System.String> clase operaciones ordinal o la referencia cultural (lingüístico) en un <xref:System.String> objeto. Una operación ordinal actúa sobre el valor numérico de cada <xref:System.Char> objeto. Una operación de la referencia cultural actúa sobre el valor de la <xref:System.String> objeto y mayúsculas y minúsculas específicas de referencias culturales de toma, ordenación, formato y las reglas de análisis en la cuenta. Operaciones sensibles a la referencia cultural que se ejecutan en el contexto de una referencia cultural declarada explícitamente o la referencia cultural implícita. Los dos tipos de operaciones pueden producir resultados muy diferentes cuando se llevan a cabo en la misma cadena.  
  
.NET también admite operaciones de cadena lingüístico culturales mediante el uso de la referencia cultural (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), que se basa generalmente en la configuración de la referencia cultural del idioma inglés independiente de la región. A diferencia de otras <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> se garantiza que la siguen siendo coherentes en un único equipo del sistema al sistema y en las versiones de .NET de configuración, la configuración de la referencia cultural invariable. La referencia cultural puede ser considerada como una especie de caja negra que garantiza la estabilidad de las comparaciones de cadenas y ordenación entre todas las referencias culturales.  
  
> [!IMPORTANT]
>  Si la aplicación toma una decisión de seguridad sobre un identificador simbólico, como un nombre de archivo o canalización con nombre, o sobre los datos persistentes, como los datos basados en texto en un archivo XML, la operación debe utilizar una comparación ordinal en lugar de una comparación dependiente de la referencia cultural. Esto es porque una comparación dependiente de la referencia cultural puede producir resultados diferentes en función de la referencia cultural en vigor, mientras que una comparación ordinal depende únicamente el valor binario de los caracteres comparados.  
  
> [!IMPORTANT]
>  Mayoría de los métodos que realizan operaciones de cadenas que incluye una sobrecarga que tenga un parámetro de tipo <xref:System.StringComparison>, que le permite especificar si el método realiza una operación ordinal o la referencia cultural. En general, debe llamar a esta sobrecarga para aclarar la intención del método de llamada al. Para obtener procedimientos recomendados y orientación para el uso de ordinales y culturales operaciones en cadenas, vea [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md).  
  
 Operaciones para [mayúsculas y minúsculas](#casing), [análisis y formato](#parsing), [comparación y ordenación](#comparison), y [probar la igualdad](#equality) puede ser cualquier ordinal o referencia cultural. Las secciones siguientes tratan cada categoría de la operación.  
  
> [!TIP]
>  Siempre debe llamar una sobrecarga del método que realiza la intención del método de llamada no cifrado. Por ejemplo, en lugar de llamar el <xref:System.String.Compare%28System.String%2CSystem.String%29> método para realizar una comparación de referencias culturales de dos cadenas mediante las convenciones de la referencia cultural actual, debe llamar a la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método con un valor de <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> para el `comparisonType` argumento. Para obtener más información, consulte [Procedimientos recomendados para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md).  

Puede descargar las [tablas de pesos de ordenación](https://www.microsoft.com/en-us/download/details.aspx?id=10921), un conjunto de archivos de texto que contienen información sobre los pesos de caracteres que se usan en las operaciones de ordenación y comparación para los sistemas operativos Windows, además de la [tabla de elementos de intercalación Unicode predeterminada](https://www.unicode.org/Public/UCA/latest/allkeys.txt), que se trata de la tabla de pesos de ordenación para Linux y macOS.

<a name="casing"></a>   
### <a name="casing"></a>Mayúsculas y minúsculas  
 Las reglas de mayúsculas y minúsculas determinan cómo cambiar las mayúsculas y minúsculas de un carácter Unicode; Por ejemplo, de minúsculas a mayúsculas. A menudo, se realiza una operación de mayúsculas y minúsculas antes de una comparación de cadenas. Por ejemplo, se puede convertir una cadena a mayúsculas para que se puede comparar con otra cadena en mayúsculas. Puede convertir los caracteres de una cadena a minúsculas mediante una llamada a la <xref:System.String.ToLower%2A> o <xref:System.String.ToLowerInvariant%2A> método y se pueden convertir a mayúsculas mediante una llamada a la <xref:System.String.ToUpper%2A> o <xref:System.String.ToUpperInvariant%2A> método. Además, puede usar el <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> método para convertir una cadena a mayúsculas.  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 Las operaciones de mayúsculas y minúsculas pueden basarse en las reglas de la referencia cultural actual, una referencia cultural especificada o la referencia cultural invariable. Como asignaciones mayúsculas y minúsculas pueden variar según la referencia cultural utilizada, el resultado de las operaciones de mayúsculas y minúsculas puede variar en función de la referencia cultural. Las diferencias de mayúsculas y minúsculas reales son de tres tipos:  
  
-   Las diferencias en la asignación de mayúsculas del alfabeto LATINO letra mayúscula I (u+0049) LATINO pequeña letra I (u+0069) LATINO letra mayúscula I con punto superior (0130) y LATIN pequeña letra DOTLESS I (0131). En las referencias culturales de az-Latn-AZ (latino, Azerbaiyán) y el tr-TR (turco (Turquía)) y en el tr, az y referencias culturales neutras de az-Latn, es el equivalente en minúsculas de la letra mayúscula LATÍN I LATÍN pequeña letra DOTLESS I y es el equivalente en mayúsculas del LATÍN pequeña letra I LETRA MAYÚSCULA LATÍN I CON UN PUNTO ANTERIOR. En todas las otras referencias culturales, incluida la referencia cultural invariable, LATINO pequeña letra I y LATIN CAPITAL letra I son equivalentes en mayúsculas y minúsculas.  
  
     El ejemplo siguiente se muestra cómo una comparación de cadenas que se ha diseñado impedir el acceso de archivo del sistema puede producir un error si se basa en una comparación de mayúsculas y minúsculas de la referencia cultural. (Las convenciones de mayúsculas y minúsculas de la referencia cultural invariable deben haberse utilizadas.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Diferencias entre la referencia cultural invariable y todas las demás referencias culturales en asignaciones de mayúsculas. En estos casos, aplicando las reglas de mayúsculas y minúsculas de la referencia cultural invariable para cambiar un carácter en mayúsculas o minúsculas, devuelve el mismo carácter. Para todas las otras culturas y devuelve un carácter diferente. En la tabla siguiente se enumeran algunos de los caracteres afectados.  
  
    |Carácter|Si cambia a|Valores devueltos|  
    |---------------|-------------------|-------------|  
    |INICIO DE SESIÓN DE MICRAS (00B5)|Mayúsculas|LETRA MAYÚSCULA GRIEGA MU (U +-39C)|  
    |LETRA LATINA MAYÚSCULA I CON UN PUNTO ANTERIOR (0130)|Minúsculas|LETRA MINÚSCULA LATÍN I (U+0069)|  
    |LETRA MINÚSCULA LATINA DOTLESS ME (0131)|Mayúsculas|LETRA MAYÚSCULA LATÍN I (U+0049)|  
    |LETRA LATINA MINÚSCULA S LARGA (017F)|Mayúsculas|LATIN CAPITAL LETTER S (0053)|  
    |D. LETRA LATINA MAYÚSCULA CON LA LETRA MINÚSCULA Z CON ACENTO CIRCUNFLEJO (U + 01C 5)|Minúsculas|LETRA LATINA MINÚSCULA DZ CON ACENTO CIRCUNFLEJO (U + 01C 6)|  
    |YPOGEGRAMMENI GRIEGO DE COMBINACIÓN (0345)|Mayúsculas|LETRA MAYÚSCULA GRIEGA IOTA (0399)|  
  
-   Diferencias en las asignaciones de casos de pares de dos letras mayúsculas y minúsculas mezcladas en el intervalo de caracteres ASCII. En la mayoría de las referencias culturales, un par de dos letras mayúsculas y minúsculas mezcladas es igual que el par equivalente de dos letras en mayúscula o minúscula. Esto no es cierto para los siguientes pares de dos letras en las siguientes referencias culturales, porque en cada caso se comparan para un dígrafo:  
  
    -   "lJ" y "nJ" en la referencia cultural hr-HR (croata (Croacia)).  
  
    -   "cH" en el cs-CZ (checo (República Checa)) y referencias culturales sk-SK (eslovaco (Eslovaquia)).  
  
    -   "aA" en la referencia cultural da-DK (danés (Dinamarca)).  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY" y "zS" en la referencia cultural hu-HU (húngaro (Hungría)).  
  
    -   "cH" y "lL" en la referencia cultural es-ES_tradnl (español (España, alfabetización tradicional)).  
  
    -   "cH", "2gi", "kH", "nG" "nH", "pH", "qU", "tH" y "tR" en la referencia cultural vi-VN (vietnamita (Vietnam)).  
  
     Sin embargo, es habitual encontrar una situación en la que una comparación de la referencia cultural de estos pares crea problemas, ya que son habituales en cadenas fijas o identificadores de estos pares.  
  
 El ejemplo siguiente muestra algunas de las diferencias en las reglas de mayúsculas y minúsculas entre referencias culturales al convertir cadenas a mayúsculas.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Análisis y formato  
 Formato y análisis son operaciones inversas. Reglas de formato determinan cómo convertir un valor, como una fecha y hora o un número, en su representación de cadena, mientras que las reglas de análisis determinan cómo convertir una representación de cadena en un valor como una fecha y hora. Las reglas de análisis y formato dependen de las convenciones culturales. El ejemplo siguiente muestra las ambigüedades que pueden surgir al interpretar una cadena de fecha específica de la referencia cultural. Sin conocer las convenciones de la referencia cultural que se usó para generar una cadena de fecha, no es posible saber si el 01/03/2011, 03/01/2011 y 3/1/2011 representan el 3 de enero de 2011 o 1 de marzo de 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 De forma similar, como se muestra en el ejemplo siguiente, una sola cadena puede producir diferentes fechas según la referencia cultural cuyas convenciones se usan en la operación de análisis.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Comparación de cadenas y ordenación  
 Convenciones para comparar y ordenar cadenas varían culturales. Por ejemplo, el criterio de ordenación puede basarse en la fonética o en la representación visual de caracteres. En los idiomas de Asia oriental, los caracteres se ordenan teniendo en cuenta los trazos y el radical de los ideogramas. El criterio de ordenación también depende del orden que se emplea en los distintos idiomas y referencias culturales para el alfabeto. Por ejemplo, el idioma danés tiene un carácter "Æ" que se ordena después de la "Z" en el alfabeto. Además, se pueden realizar comparaciones entre mayúsculas y minúsculas o mayúsculas y minúsculas, y en algunos casos también difieren las reglas de mayúsculas y minúsculas según la referencia cultural. Comparación ordinal, por otro lado, usa los puntos de código Unicode de caracteres individuales en una cadena al comparar y ordenar cadenas.  
  
 Las reglas de ordenación determinan que el orden alfabético de caracteres Unicode y cómo dos cadenas se comparan entre sí. Por ejemplo, el <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método compara dos cadenas según la <xref:System.StringComparison> parámetro. Si el valor del parámetro es <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, el método realiza una comparación lingüística que usa las convenciones de la referencia cultural actual; si el valor del parámetro es <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, el método realiza una comparación ordinal. Por lo tanto, como muestra el siguiente ejemplo, si la referencia cultural actual es inglés Inglés, la primera llamada a la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método (mediante la comparación dependiente de la referencia cultural) considera "a" menor que "A", pero se considera que la segunda llamada al mismo método (mediante la comparación ordinal) "a" mayor que "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET es compatible con la palabra, cadena y las reglas de ordenación ordinal:  
  
-   Una operación de ordenación de palabras realiza una comparación de cadenas donde se tiene en cuenta la referencia cultural y donde ciertos caracteres Unicode no alfanuméricos pueden tener asignados pesos especiales. Por ejemplo, el guión (-) podría tener un peso muy pequeño asignado para que "coop" y "Co-op" aparecerían juntos en una lista ordenada. Para obtener una lista de los <xref:System.String> métodos que se comparan dos cadenas utilizando reglas de ordenación de palabras, vea el [operaciones de cadena por categoría](#ByCategory) sección.  
  
-   Una ordenación por cadena también realiza una comparación dependiente de la referencia cultural. Es similar a la ordenación por palabra, salvo que no hay casos especiales, y todos los símbolos alfanuméricos van antes todos los caracteres Unicode alfanuméricos. Se pueden comparar dos cadenas utilizando reglas de ordenación de cadenas mediante una llamada a la <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> sobrecargas del método que tienen un `options` parámetro que proporciona un valor de <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Tenga en cuenta que esto es el único método que proporciona .NET para comparar dos cadenas utilizando reglas de ordenación de cadenas.  
  
-   Una ordenación ordinal compara las cadenas basadas en el valor numérico de cada objeto <xref:System.Char> en la cadena. Una comparación ordinal es automáticamente entre mayúsculas y minúsculas, porque las versiones en mayúsculas y minúsculas de un carácter tienen distintos puntos de código. Sin embargo, si el caso no es importante, puede especificar una comparación ordinal que no distingue entre mayúsculas. Esto es equivalente a convertir la cadena a mayúsculas mediante la referencia cultural invariable y, a continuación, realizar una comparación ordinal en el resultado. Para obtener una lista de los <xref:System.String> métodos que comparan dos cadenas utilizando reglas de ordenación ordinal, vea el [operaciones de cadena por categoría](#ByCategory) sección.  
  
 Una comparación dependiente de la referencia cultural es cualquier comparación que utiliza explícita o implícitamente un <xref:System.Globalization.CultureInfo> objeto, incluida la referencia cultural especificada por el <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> propiedad. La referencia cultural implícita es la referencia cultural actual, que se especifica mediante el <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> y <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propiedades. Hay una variación considerable en el criterio de ordenación de caracteres alfabéticos (es decir, los caracteres para el que el <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> propiedad devuelve `true`) entre distintas referencias culturales. Puede especificar una comparación de la referencia cultural que utiliza las convenciones de una referencia cultural concreta al suministrar un <xref:System.Globalization.CultureInfo> de objeto a un método de comparación de cadenas como <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Puede especificar una comparación de la referencia cultural que utiliza las convenciones de la referencia cultural actual proporcionando <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, o cualquier miembro de la <xref:System.Globalization.CompareOptions> enumeración distinto <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> o <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> un adecuado sobrecarga de la <xref:System.String.Compare%2A> método. Una comparación dependiente de la referencia cultural generalmente resulta adecuada para la ordenación, mientras que una comparación ordinal no es. Una comparación ordinal generalmente resulta adecuada para determinar si dos cadenas son iguales (es decir, para determinar la identidad), mientras que una comparación de referencias culturales no lo es.  
  
 El ejemplo siguiente muestra la diferencia entre la comparación ordinal y las referencias culturales. Este ejemplo devuelve tres cadenas, "Apple", "Primer lugar" y "AEble", mediante la comparación ordinal y las convenciones de las referencias culturales da-DK y en-US (cada uno de los cuales es la referencia cultural predeterminada en el momento del <xref:System.String.Compare%2A> se llama al método). Dado que el idioma danés el carácter "Æ" trata como carácter individual y ordena después de la "Z" en el alfabeto, la cadena "Æble" es mayor que "Apple". Sin embargo, "Primer lugar" no se considera equivalente a "AEble", por lo que también es mayor que "AEble" "primer lugar". La referencia cultural en-US no incluye la letra "Æ", pero lo trata como equivalente a "AE", que explica por qué "Primer lugar" es menor que "Apple", pero igual a "AEble". Comparación ordinal, por otro lado, considera "Apple" para ser menor que "Primer lugar" y "Primer lugar" sea mayor que "AEble".  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Utilice las siguientes directrices generales para elegir un método de comparación de ordenación o de cadena apropiado:  
  
-   Si desea que las cadenas se ordene en función de la referencia cultural del usuario, debe ordénelas según las convenciones de la referencia cultural actual. Si cambia la referencia cultural del usuario, el orden de las cadenas ordenadas también cambiará en consecuencia. Por ejemplo, una aplicación de diccionario de sinónimos siempre debe ordenar palabras en función de la referencia cultural del usuario.  
  
-   Si desea que las cadenas se ordenen según las convenciones de una referencia cultural concreta, debe solicitarlos proporcionando un <xref:System.Globalization.CultureInfo> objeto que representa esa referencia cultural a un método de comparación. Por ejemplo, en una aplicación diseñada para enseñar a los alumnos un idioma concreto, desea que las cadenas se ordenen según las convenciones de una de las referencias culturales que habla ese idioma.  
  
-   Si desea que el orden de las cadenas que permanecen sin cambios en distintas referencias culturales, debería ordénelas según las convenciones de la referencia cultural invariable o utilice una comparación ordinal. Por ejemplo, se usaría a una ordenación ordinal para organizar los nombres de archivos, procesos, exclusiones mutuas o canalizaciones con nombre.  
  
-   Para obtener una comparación que implica una decisión de seguridad (por ejemplo, si un nombre de usuario es válido), siempre debe realizar una prueba de igualdad ordinal mediante una llamada a una sobrecarga de la <xref:System.String.Equals%2A> método.  
  
> [!NOTE]
>  La versión de .NET dependen de la ordenación de referencias culturales y las mayúsculas y minúsculas de las reglas utilizadas en la comparación de cadenas. En .NET Framework 4.5 y versiones posteriores que se ejecutan en el [!INCLUDE[win8](~/includes/win8-md.md)] sistema operativo, ordenación, mayúsculas y minúsculas, normalización y obtener información de carácter Unicode se ajusta al estándar Unicode 6.0. En otros sistemas operativos Windows, cumple el estándar Unicode 5.0. En .NET Core, depende de la versión del estándar Unicode compatibles con el sistema operativo subyacente. 
  
 Para obtener más información acerca de palabra, cadena y las reglas de ordenación ordinal, vea el <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> tema. Para obtener más recomendaciones sobre cuándo usar cada regla, vea [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md).  
  
 Normalmente, no llamar a cadena de los métodos de comparación como <xref:System.String.Compare%2A> directamente para determinar el criterio de ordenación de cadenas. En su lugar, se llama a métodos de comparación, como los métodos de ordenación <xref:System.Array.Sort%2A?displayProperty=nameWithType> o <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. El ejemplo siguiente realiza cuatro diferentes operaciones de ordenación (ordenación por palabra utilizando la referencia cultural actual, utilizando la referencia cultural de ordenación de palabras, ordenación ordinal y ordenación por cadena usando la referencia cultural invariable) sin llamar explícitamente a un método de comparación de cadenas Aunque especifique el tipo de comparación que se va a usar. Tenga en cuenta que cada tipo de ordenación genera una única ordenación de cadenas de su matriz.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Internamente, .NET usa claves de ordenación para admitir la comparación de cadenas cultural. A cada carácter de una cadena se le otorgan varias categorías de prioridad de ordenación, entre las que se incluyen el orden alfabético, el uso de mayúsculas y minúsculas y los signos diacríticos. Un criterio de ordenación, representado por la <xref:System.Globalization.SortKey> clase, proporciona un repositorio de estas categorías para una cadena determinada. Si la aplicación realiza un gran número de búsqueda o clasificación de las operaciones en el mismo conjunto de cadenas, puede mejorar su rendimiento generando y almacenando las claves de ordenación para todas las cadenas que utiliza. Cuando se requiere una operación de ordenación o de comparación, usar las claves de ordenación en lugar de las cadenas. Para obtener más información, vea la clase <xref:System.Globalization.SortKey>.  
  
 Si no se especifica una convención de comparación de cadenas, métodos de ordenación como <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> realizar una ordenación culturales, distingue mayúsculas de minúsculas en las cadenas. El ejemplo siguiente muestra cómo cambiar la referencia cultural actual afecta al orden de las cadenas ordenadas en una matriz. Crea una matriz de tres cadenas. En primer lugar, se establece la propiedad `System.Threading.Thread.CurrentThread.CurrentCulture` en en-US y se llama al método <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>. El criterio de ordenación resultante se basa en las convenciones de ordenación de la referencia cultural Inglés (Estados Unidos). A continuación, el ejemplo establece la propiedad `System.Threading.Thread.CurrentThread.CurrentCulture` en da-DK y llama de nuevo al método <xref:System.Array.Sort%2A?displayProperty=nameWithType>. Observe que el criterio de ordenación resultante difiere del resultado de en-US porque usa las convenciones de ordenación correspondientes a la referencia cultural Danés (Dinamarca).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Si su objetivo principal en la comparación de cadenas es determinar si son iguales, se debe llamar a la <xref:System.String.Equals%2A?displayProperty=nameWithType> método. Normalmente, debe utilizar <xref:System.String.Equals%2A> para realizar una comparación ordinal. El <xref:System.String.Compare%2A?displayProperty=nameWithType> método está pensado principalmente para ordenar cadenas.  
  
 Los métodos de búsqueda de cadena como <xref:System.String.StartsWith%2A?displayProperty=nameWithType> y <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, también puede realizar comparaciones de cadenas de referencias culturales u ordinal. El ejemplo siguiente muestra las diferencias entre las comparaciones ordinales y culturales utilizando el <xref:System.String.IndexOf%2A> método. Una búsqueda de la referencia cultural en la que la referencia cultural actual es inglés (Estados Unidos), considera que la subcadena "oe" para que coincida con la ligadura "œ". Dado que un guion (00AD) es un carácter de ancho cero, la búsqueda trata el guion como equivalente a <xref:System.String.Empty> y encuentra una coincidencia al principio de la cadena. Por otro lado, una búsqueda ordinal, no encuentra a una coincidencia en cualquier caso.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Buscar cadenas  
 Los métodos de búsqueda de cadena como <xref:System.String.StartsWith%2A?displayProperty=nameWithType> y <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, también puede llevar a cabo la referencia cultural o comparaciones de cadenas ordinales para determinar si un carácter o subcadena se encuentra en una cadena especificada.  
  
 Los métodos de búsqueda en el <xref:System.String> clase que buscar un carácter individual, como el <xref:System.String.IndexOf%2A> método o un conjunto de caracteres, como el <xref:System.String.IndexOfAny%2A> método, todas realizan una búsqueda ordinal. Para llevar a cabo una búsqueda de la referencia cultural de un carácter, debe llamar a un <xref:System.Globalization.CompareInfo> método como <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> o <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Tenga en cuenta que los resultados de buscar un carácter mediante la comparación ordinal y la referencia cultural pueden ser muy diferentes. Por ejemplo, una búsqueda de un carácter Unicode compuesto como la ligadura "Æ" (U + 00 C 6) podría coincidir con cualquier aparición de sus componentes en la secuencia correcta, como "AE" (U + 041U + 0045), dependiendo de la referencia cultural. El ejemplo siguiente muestra la diferencia entre el <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> y <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> métodos cuando se busca un carácter individual. La ligadura "æ" (00E6) se encuentra en la cadena "aérea" al usar las convenciones de la referencia cultural en-US, pero no cuando se utilizan las convenciones de la referencia cultural da-DK o al realizar una comparación ordinal.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 Por otro lado, <xref:System.String> métodos que busquen una cadena en lugar de un carácter de realiza una búsqueda de la referencia cultural, si las opciones de búsqueda no se especifican explícitamente a un parámetro de tipo de la clase <xref:System.StringComparison>. La única excepción es <xref:System.String.Contains%2A>, que realiza una búsqueda ordinal.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Probar la igualdad  
 Use el <xref:System.String.Compare%2A?displayProperty=nameWithType> método para determinar la relación de dos cadenas en el criterio de ordenación. Normalmente, esto es una operación de la referencia cultural. En cambio, llame a la <xref:System.String.Equals%2A?displayProperty=nameWithType> método para comprobar la igualdad. Dado que la prueba de igualdad normalmente compara la entrada del usuario con alguna cadena conocido, como un nombre de usuario válida, una contraseña o una ruta de acceso del sistema de archivos, normalmente es una operación ordinal.  
  
> [!WARNING]
>  Es posible comprobar la igualdad llamando el <xref:System.String.Compare%2A?displayProperty=nameWithType> método y determinar si el valor devuelto es cero. Sin embargo, no se recomienda esta práctica. Para determinar si dos cadenas son iguales, debe llamar a una de las sobrecargas de los <xref:System.String.Equals%2A?displayProperty=nameWithType> método. La sobrecarga preferida para llamar a es la instancia <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> estático o método <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, porque ambos métodos incluyen un <xref:System.StringComparison?displayProperty=nameWithType> parámetro que especifique explícitamente el tipo de comparación.  
  
 El ejemplo siguiente muestra el peligro de llevar a cabo una comparación dependiente de la referencia cultural para la igualdad cuando un ordinal que se debería utilizar en su lugar. En este caso, la intención del código es prohibir el acceso al sistema de archivos de las direcciones URL que comienzan con "FILE://" o "file://" mediante la realización de una comparación entre mayúsculas y minúsculas del principio de una dirección URL con la cadena "FILE://". Sin embargo, si se realiza una comparación de la referencia cultural utilizando la referencia cultural de turco (Turquía) en una dirección URL que comienza con "file://", la comparación de igualdad produce un error, porque el turco equivalente en mayúsculas de minúsculas "i" es "İ" en lugar de "I". Como resultado, por accidente se permite el acceso al sistema de archivos. Por otro lado, si se realiza una comparación ordinal, la comparación de igualdad se realiza correctamente y se deniega el acceso al sistema de archivos.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalización  
 Algunos caracteres Unicode tienen varias representaciones. Por ejemplo, cualquiera de los puntos de código siguiente puede representar la letra "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Varias representaciones de un único carácter complican la búsqueda, ordenación, coincidencia y otras operaciones de cadena.  
  
 El estándar Unicode define un proceso denominado normalización, que devuelve una representación binaria de un carácter Unicode para cualquiera de sus representaciones binarias equivalentes. La normalización puede utilizar varios algoritmos, denominados formas de normalización, que siguen reglas distintas. .NET es compatible con formas de normalización Unicode C, D, KC y KD. Cuando se han normalizado las cadenas a la misma forma de normalización, pueden compararse por medio de una comparación ordinal.  
  
 Una comparación ordinal es una comparación binaria del valor escalar Unicode de correspondiente <xref:System.Char> objetos de cada cadena. La <xref:System.String> clase incluye una serie de métodos que puede realizar una comparación ordinal, incluido lo siguiente:  
  
-   Ninguna sobrecarga de la <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, y <xref:System.String.LastIndexOf%2A> métodos que incluye un <xref:System.StringComparison> parámetro. El método realiza una comparación ordinal si proporciona un valor de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o <xref:System.StringComparison.OrdinalIgnoreCase> para este parámetro.  
  
-   Las sobrecargas de los <xref:System.String.CompareOrdinal%2A> método.  
  
-   Los métodos que usan la comparación ordinal de forma predeterminada, como <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, y <xref:System.String.Split%2A>.  
  
-   Los métodos que buscan un <xref:System.Char> valor o los elementos de un <xref:System.Char> matriz en una instancia de cadena. Estos métodos incluyen <xref:System.String.IndexOf%28System.Char%29> y <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Puede determinar si una cadena se normaliza a la forma de normalización C mediante una llamada a la <xref:System.String.IsNormalized?displayProperty=nameWithType> puede llamar al método, o bien el <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> método para determinar si se normaliza una cadena a una forma de normalización especificada. También puede llamar a la <xref:System.String.Normalize?displayProperty=nameWithType> puede llamar al método para convertir una cadena en forma de normalización C, o bien el <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> método para convertir una cadena en una forma de normalización especificada. Para obtener información detallada sobre la normalización y comparar cadenas, vea el <xref:System.String.Normalize> y <xref:System.String.Normalize%28System.Text.NormalizationForm%29> métodos.  
  
 El siguiente ejemplo muestra la normalización de cadenas. Define la letra "ố" de tres maneras diferentes en tres cadenas diferentes y utiliza una comparación ordinal de igualdad para determinar que cada cadena difiere de las dos cadenas. A continuación, convierte cada cadena en las formas de normalización admitidas y vuelva a realiza una comparación ordinal de cada cadena en una forma de normalización especificada. En cada caso, la segunda prueba de igualdad muestra que las cadenas son iguales.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Para obtener más información sobre la normalización y formas de normalización, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, así como [Unicode Standard Annex #15: Formas de normalización Unicode](https://unicode.org/reports/tr15/) y [preguntas más frecuentes de normalización](https://www.unicode.org/faq/normalization.html) en el sitio Web de unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Operaciones de cadenas por categoría  
 El <xref:System.String> clase proporciona miembros para comparar cadenas, las pruebas de las cadenas de igualdad, búsqueda de subcadenas en una cadena, modificar una cadena, extraer subcadenas de una cadena, combinar cadenas, dar formato a valores, copiar una cadena, o caracteres y la normalización de una cadena.  
  
### <a name="comparing-strings"></a>Comparar cadenas  
 Puede comparar cadenas para determinar su posición relativa en el criterio de ordenación mediante el siguiente <xref:System.String> métodos:  
  
-   <xref:System.String.Compare%2A> Devuelve un entero que indica la relación de una cadena en una segunda cadena en el criterio de ordenación.  
  
-   <xref:System.String.CompareOrdinal%2A> Devuelve un entero que indica la relación de una cadena en una segunda cadena que se basa en una comparación de sus puntos de código.  
  
-   <xref:System.String.CompareTo%2A> Devuelve un entero que indica la relación de la instancia de cadena actual con otra cadena en el criterio de ordenación. El <xref:System.String.CompareTo%28System.String%29> método proporciona la <xref:System.IComparable> y <xref:System.IComparable%601> implementaciones para el <xref:System.String> clase.  
  
### <a name="testing-strings-for-equality"></a>Cadenas de pruebas de igualdad  
 Se llama a la <xref:System.String.Equals%2A> método para determinar si dos cadenas son iguales. La instancia <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> y estático <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> sobrecargas permiten especificar si la comparación es ordinal o de la referencia cultural, y si es considerar caso o a omitirse. Mayoría de las pruebas de igualdad es ordinal y las comparaciones de igualdad que determinan el acceso a un recurso del sistema (por ejemplo, un objeto del sistema de archivos) siempre deben ser ordinales.  
  
### <a name="finding-characters-in-a-string"></a>Buscar caracteres en una cadena  
 La <xref:System.String> clase incluye dos tipos de métodos de búsqueda:  
  
-   Los métodos que devuelven un <xref:System.Boolean> valor para indicar si una subcadena determinada está presente en una instancia de cadena. Estos incluyen el <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, y <xref:System.String.StartsWith%2A> métodos.  
  
-   Métodos que indican la posición inicial de una subcadena en una instancia de cadena. Estos incluyen el <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, y <xref:System.String.LastIndexOfAny%2A> métodos.  
  
> [!WARNING]
>  Si desea buscar una cadena para un modelo concreto en lugar de una subcadena concreta, debe usar expresiones regulares. Para obtener más información, consulte [expresiones regulares de .NET](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modificación de una cadena  
 La <xref:System.String> clase incluye los siguientes métodos que parecen modificar el valor de una cadena:  
  
-   <xref:System.String.Insert%2A> Inserta una cadena en el actual <xref:System.String> instancia.  
  
-   <xref:System.String.PadLeft%2A> una o más apariciones de un carácter especificado se inserta al principio de una cadena.  
  
-   <xref:System.String.PadRight%2A> Inserta una o más apariciones de un carácter especificado al final de una cadena.  
  
-   <xref:System.String.Remove%2A> elimina una subcadena de la actual <xref:System.String> instancia.  
  
-   <xref:System.String.Replace%2A> reemplaza una subcadena por otra subcadena actual <xref:System.String> instancia.  
  
-   <xref:System.String.ToLower%2A> y <xref:System.String.ToLowerInvariant%2A> convertir todos los caracteres de una cadena a minúsculas.  
  
-   <xref:System.String.ToUpper%2A> y <xref:System.String.ToUpperInvariant%2A> convertir todos los caracteres de una cadena a mayúsculas.  
  
-   <xref:System.String.Trim%2A> Quita todas las apariciones de un carácter de principio y al final de una cadena.  
  
-   <xref:System.String.TrimEnd%2A> Quita todas las apariciones de un carácter de final de una cadena.  
  
-   <xref:System.String.TrimStart%2A> Quita todas las apariciones de un carácter desde el principio de una cadena.  
  
> [!IMPORTANT]
>  Todos los métodos de modificación de cadenas que devuelven un nuevo <xref:System.String> objeto. No modifican el valor de la instancia actual.  
  
### <a name="extracting-substrings-from-a-string"></a>Extraer subcadenas de una cadena  
 El <xref:System.String.Split%2A?displayProperty=nameWithType> método separa una cadena única en varias cadenas. Las sobrecargas del método le permiten especificar varios delimitadores, para determinar el número máximo de subcadenas que se extrae el método y para determinar si las cadenas vacías (que se producen cuando los delimitadores son adyacentes) se incluyen entre las cadenas devueltas.  
  
### <a name="combining-strings"></a>Cadenas de combinación  
 La siguiente <xref:System.String> métodos se pueden usar para la concatenación de cadenas:  
  
-   <xref:System.String.Concat%2A> combina una o varias subcadenas en una sola cadena.  
  
-   <xref:System.String.Join%2A> Concatena una o varias subcadenas en un solo elemento y agrega un separador entre cada subcadena.  
  
### <a name="formatting-values"></a>Dar formato a valores  
 El <xref:System.String.Format%2A?displayProperty=nameWithType> método usa la característica de formato compuesto para reemplazar uno o más marcadores de posición en una cadena con la representación de cadena de algún objeto o valor. El <xref:System.String.Format%2A> método se suele usar para hacer lo siguiente:  
  
-   Para incrustar la representación de cadena de un valor numérico en una cadena.  
  
-   Para incrustar la representación de cadena de un valor de fecha y hora en una cadena.  
  
-   Para incrustar la representación de cadena de un valor de enumeración en una cadena.  
  
-   Para incrustar la representación de cadena de un objeto que admite el <xref:System.IFormattable> interfaz en una cadena.  
  
-   Justificar a la derecha o justificar a la izquierda una subcadena en un campo dentro de una cadena mayor.  
  
 Para obtener información detallada acerca del formato de las operaciones y ejemplos, vea el <xref:System.String.Format%2A> sobrecargar el resumen.  
  
### <a name="copying-a-string"></a>Copiar una cadena  
 Puede llamar a la siguiente <xref:System.String> métodos para realizar una copia de una cadena:  
  
-   <xref:System.String.Clone%2A> Devuelve una referencia a una existente <xref:System.String> objeto.  
  
-   <xref:System.String.Copy%2A> crea una copia de una cadena existente.  
  
-   <xref:System.String.CopyTo%2A> copia una parte de una cadena en una matriz de caracteres.  
  
### <a name="normalizing-a-string"></a>La normalización de una cadena  
 En Unicode, un solo carácter puede tener varios puntos de código. Normalización convierte estos caracteres equivalentes en la misma representación binaria. El <xref:System.String.Normalize%2A?displayProperty=nameWithType> método realiza la normalización y el <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> método determina si se normaliza una cadena.  
  
 Para obtener más información y un ejemplo, vea el [normalización](#Normalization) anteriormente en este tema.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">Ordenación de los sistemas operativos de las tablas de peso para Windows</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Tabla de elemento de intercalación de predeterminado Unicode, para Linux y macOS</related>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Procedimientos recomendados para el uso de cadenas en .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En esta sección:  
  
 [Sintaxis de constructor sobrecargado](#Syntax)   
 [Parámetros](#Params)   
 [Excepciones](#Exceptions)   
 [¿Qué método se debe llamar?](#Tasks)   
 [Creación de cadenas](#Creating_Strings)   
 [Controlar cadenas repetitivas](#Repetitive)   
 Ejemplos de crear instancias de cadenas:   
 [Uso de la asignación de cadena](#Ctor1_Example)  
 [Uso de una matriz de caracteres](#Ctor2_Example)  
 [Con una parte de una matriz de caracteres y un único carácter de repetición](#Ctor3_Example)  
 [Mediante un puntero a una matriz de caracteres](#Ctor4_Example)  
 [Uso de un puntero y un intervalo de una matriz](#Ctor5_Example)  
 [Mediante un puntero a una matriz de bytes con signo](#Ctor6_Example)  
[Información de versión](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Sintaxis de constructor sobrecargado  
 Constructores de cadena se dividen en dos categorías: las que no tienen parámetros de puntero y aquellos con los parámetros de puntero. Los constructores que utilizan punteros no son conformes a CLS. Además, Visual Basic no admite el uso de punteros y C# requiere que el código que utiliza punteros para ejecutarse en un contexto no seguro. Para obtener más información, vea [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 ¿Para obtener orientación adicional acerca de cómo elegir una sobrecarga, vea [qué método se debe llamar?](#Tasks)  
  
 `String(Char[] value)`  
 Inicializa la nueva instancia con el valor indicado por una matriz de caracteres Unicode. Este constructor copia caracteres Unicode ([ejemplo](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Inicializa la nueva instancia con el valor indicado por una matriz de caracteres Unicode, una posición de carácter inicial dentro de dicha matriz y una longitud ([ejemplo](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Inicializa la nueva instancia en el valor indicada por un carácter Unicode especificado repite un número determinado de veces ([ejemplo](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(No conforme a CLS)**  Inicializa la nueva instancia con el valor indicado por un puntero a una matriz de caracteres Unicode que termina con un carácter nulo (u+0000 o '\0'). ([ejemplo](#Ctor4_Example)).  
  
 Permiso: <xref:System.Security.SecurityCriticalAttribute>, requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(No conforme a CLS)**  Inicializa la nueva instancia con el valor indicado por un puntero a una matriz de caracteres Unicode, una posición de carácter inicial dentro de dicha matriz y una longitud. El constructor copia los caracteres Unicode desde `value` empezando por índice `startIndex` y terminando en índice `startIndex`  +  `length` - 1 ([ejemplo](#Ctor5_Example)).  
  
 Permiso: <xref:System.Security.SecurityCriticalAttribute>, requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.  
  
 `String(SByte* value)`  
 **(No conforme a CLS)**  Inicializa la nueva instancia con el valor indicado por un puntero a una matriz de enteros de 8 bits con signo. La matriz se supone que representa una cadena codificada mediante la página de códigos del sistema actual (es decir, la codificación especificada por <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). El constructor procesa los caracteres de `value` a partir de la ubicación especificada por el puntero hasta que se alcanza un carácter nulo (0 x 00) ([ejemplo](#Ctor6_Example)).  
  
 Permiso: <xref:System.Security.SecurityCriticalAttribute>, requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(No conforme a CLS)**  Inicializa la nueva instancia con el valor indicado por un puntero a una matriz de enteros de 8 bits con signo, una posición inicial dentro de dicha matriz y una longitud.  La matriz se supone que representa una cadena codificada mediante la página de códigos del sistema actual (es decir, la codificación especificada por <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). El constructor procesa los caracteres de valor a partir `startIndex` hasta `startIndex`  +  `length` - 1 ([ejemplo](#Ctor6_Example)).  
  
 Permiso: <xref:System.Security.SecurityCriticalAttribute>, requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(No conforme a CLS)**  Inicializa la nueva instancia con el valor indicado por un puntero a una matriz de enteros de 8 bits con signo, una posición inicial dentro de dicha matriz, una longitud y un <xref:System.Text.Encoding> objeto.  
  
 Permiso: <xref:System.Security.SecurityCriticalAttribute>, requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parámetros  
 Esta es una lista completa de parámetros utilizada por <xref:System.String> constructores que no incluyen un parámetro de puntero. Para los parámetros utilizados por cada sobrecarga, vea la sintaxis de sobrecarga anterior.  
  
|Parámetro|Tipo|Descripción|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Matriz de caracteres Unicode.|  
|`c`|<xref:System.Char>|Carácter Unicode.|  
|`startIndex`|<xref:System.Int32>|La posición inicial en `value` del primer carácter en la nueva cadena.<br /><br /> Valor predeterminado: 0|  
|`length`|<xref:System.Int32>|El número de caracteres en `value` para incluir en la nueva cadena.<br /><br /> Valor predeterminado: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|El número de veces que el carácter `c` se repite en la nueva cadena. Si `count` es cero, el valor del nuevo objeto es <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Esta es una lista completa de parámetros utilizada por <xref:System.String> constructores que incluyen un parámetro de puntero. Para los parámetros utilizados por cada sobrecarga, vea la sintaxis de sobrecarga anterior.  
  
|Parámetro|Tipo|Descripción|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> O bien<br /><br /> <xref:System.SByte>\*|Un puntero a una matriz terminada en null de caracteres Unicode o una matriz de enteros de 8 bits con signo. Si `value` es `null` o una matriz vacía, el valor de la nueva cadena es <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|El índice del elemento de matriz que define el primer carácter en la nueva cadena.<br /><br /> Valor predeterminado: 0|  
|`length`|<xref:System.Int32>|El número de elementos de la matriz se usa para crear la nueva cadena. Si la longitud es cero, el constructor crea una cadena cuyo valor es <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Valor predeterminado: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Objeto que especifica cómo el `value` se codifica la matriz.<br /><br /> Valor predeterminado: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, o la página de códigos ANSI actual del sistema|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Excepciones  
 Presentamos una lista de excepciones producidas por los constructores que no incluyen los parámetros de puntero.  
  
|Excepción|Condición|Iniciada por|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` es `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, o `count` es menor que cero.<br /><br /> O bien<br /><br /> La suma de `startIndex` y `length` es mayor que el número de elementos de `value`.<br /><br /> O bien<br /><br /> `count` es menor que cero.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Presentamos una lista de excepciones producidas por los constructores que incluyen los parámetros de puntero.  
  
|Excepción|Condición|Iniciada por|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Especifica una matriz que contiene un carácter Unicode no válido.<br /><br /> O bien<br /><br /> `value` o `value`  +  `startIndex` especifica una dirección que es menor que 64 KB.<br /><br /> O bien<br /><br /> Un nuevo <xref:System.String> no se pudo inicializar la instancia de la `value` matriz de bytes porque `value` no utiliza la codificación de página de código de forma predeterminada.|Todos los constructores con punteros.|  
|<xref:System.ArgumentNullException>|`value` es null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|El proceso actual no tiene acceso de lectura a todos los caracteres tratados.<br /><br /> O bien<br /><br /> `startIndex` o `length` es menor que cero, `value` + `startIndex` produce un desbordamiento de puntero o el proceso actual no tiene acceso de lectura a todos los caracteres tratados.<br /><br /> O bien<br /><br /> La longitud de la nueva cadena es demasiado grande para asignar.|Todos los constructores con punteros.|  
|<xref:System.AccessViolationException>|`value`, o `value`  +  `startIndex`  +  `length` -1, especifica una dirección no válida.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>¿Qué método se debe llamar?  
  
|En|Llamada o use|  
|--------|-----------------|  
|Crear una cadena.|Asignación de un literal de cadena o una cadena existente ([ejemplo](#Ctor1_Example))|  
|Crear una cadena de una matriz de caracteres completa.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([ejemplo](#Ctor2_Example))|  
|Crear una cadena de una parte de una matriz de caracteres.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([ejemplo](#Ctor3_Example))|  
|Crear una cadena que se repite el mismo carácter varias veces.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([ejemplo](#Ctor3_Example))|  
|Cree una cadena de un puntero a una matriz de caracteres anchos o Unicode.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Crear una cadena de una parte de una matriz de caracteres anchos o Unicode mediante su puntero.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Crear una cadena de C++ `char` matriz.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> O bien<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Crear una cadena de caracteres ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Creación de cadenas  
 Las más usadas técnica para crear cadenas mediante programación es una asignación simple, como se muestra en [en este ejemplo](#Ctor1_Example). La <xref:System.String> clase también incluye cuatro tipos de sobrecargas del constructor que le permite crear cadenas a partir de los valores siguientes:  
  
-   Desde una matriz de caracteres (una matriz de caracteres con codificación UTF-16). Puede crear un nuevo <xref:System.String> objeto a partir de los caracteres en toda la matriz o una parte de ella. El <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor copia todos los caracteres de la matriz a la nueva cadena. El <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor copia los caracteres de índice `startIndex` al índice `startIndex`  +  `length` -1 a la nueva cadena. Si `length` es cero, el valor de la nueva cadena es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Si el código varias veces crea instancias de cadenas que tienen el mismo valor, puede mejorar el rendimiento de la aplicación mediante el uso de medios alternativos para creación de cadenas. Para obtener más información, consulte [controlar cadenas repetitivas](#Repetitive).  
  
-   Desde un único carácter que es duplicado cero, uno, o más veces, mediante el uso de la <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructor. Si `count` es cero, el valor de la nueva cadena es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   De un puntero a una matriz de caracteres terminada en null, usando la <xref:System.String.%23ctor%28System.Char%2A%29> o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor. Toda la matriz o un intervalo especificado se puede usar para inicializar la cadena. El constructor copia una secuencia de caracteres Unicode a partir del puntero especificado o desde el puntero especificado más `startIndex` y continuando hasta el final de la matriz o para `length` caracteres. Si `value` es un puntero nulo o `length` es cero, el constructor crea una cadena cuyo valor es <xref:System.String.Empty?displayProperty=nameWithType>. Si la operación de copia se ejecuta hasta el final de la matriz y la matriz no está terminada en null, el comportamiento del constructor es dependiente del sistema. Esta condición podría provocar una infracción de acceso.  
  
     Si la matriz contiene los caracteres nulos incrustados (u+0000 o '\0') y el <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> es llamar a la sobrecarga, la instancia de cadena contiene `length` las incluidas de caracteres nulos incrustados. El ejemplo siguiente muestra lo que sucede cuando se pasa un puntero a una matriz de 10 elementos que incluye dos caracteres null a la <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> método. Dado que la dirección es el principio de la matriz y todos los elementos de la matriz son que se agregarán a la cadena, el constructor crea una instancia de una cadena con diez caracteres, incluidos los dos valores null incrustados. Por otro lado, si la misma matriz se pasa a la <xref:System.String.%23ctor%28System.Char%2A%29> constructor, el resultado es una cadena de cuatro caracteres que no incluye el primer carácter nulo.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     La matriz debe contener caracteres Unicode. En C++, esto significa que la matriz de caracteres debe estar definida como el administrado <xref:System.Char>tipo [] o no administrado`wchar_t`tipo [].  
  
     Si el <xref:System.String.%23ctor%28System.Char%2A%29> es llamar a la sobrecarga y la matriz no está terminada en null, o si el <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> es llamar a la sobrecarga y `startIndex`  +  `length`-1 incluye un intervalo que lo fuera de la memoria asignada para la secuencia de caracteres, el comportamiento del constructor depende del sistema y puede producirse una infracción de acceso. Además, en el procesador Intel Itanium, las llamadas a la <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor puede producir un <xref:System.DataMisalignedException> excepción. Si esto ocurre, llame a la <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> en su lugar.  
  
-   De un puntero a una matriz de bytes con signo. Toda la matriz o un intervalo especificado se puede usar para inicializar la cadena. Se puede interpretar la secuencia de bytes mediante el uso de la página de códigos predeterminada de codificación o una codificación puede especificarse en la llamada al constructor. Si el constructor intenta crear una instancia de una cadena a partir de toda una matriz que no está terminada en null, o si el intervalo de la matriz de `value`  +  `startIndex` a `value`  +  `startIndex`  +  `length` -1 está fuera de la memoria asignada para la matriz, el comportamiento de este constructor es dependiente del sistema y puede producirse una infracción de acceso.  
  
     Los tres constructores que incluyen una matriz de bytes con signo como un parámetro están diseñados principalmente para convertir un C++ `char` de matriz en una cadena, como se muestra en este ejemplo:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Si la matriz contiene caracteres nulos ('\0') o bytes cuyo valor es 0 y el <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> es llamar a la sobrecarga, la instancia de cadena contiene `length` las incluidas de caracteres nulos incrustados. El ejemplo siguiente muestra lo que sucede cuando se pasa un puntero a una matriz de 10 elementos que incluye dos caracteres null a la <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> método. Dado que la dirección es el principio de la matriz y todos los elementos de la matriz son que se agregarán a la cadena, el constructor crea una instancia de una cadena con diez caracteres, incluidos los dos valores null incrustados. Por otro lado, si la misma matriz se pasa a la <xref:System.String.%23ctor%28System.SByte%2A%29> constructor, el resultado es una cadena de cuatro caracteres que no incluye el primer carácter nulo.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Dado que el <xref:System.String.%23ctor%28System.SByte%2A%29> y <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructores interpretan `value` mediante el uso de la página de códigos ANSI predeterminada, una llamada a estos constructores con matrices de bytes idéntica puede crear las cadenas que tienen valores diferentes en distintos sistemas.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Controlar cadenas repetitivas  
 Las aplicaciones que analizan o descodifican secuencias de texto a menudo usan el <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor o <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para convertir las secuencias de caracteres en una cadena. Creación de cadenas a varias veces con el mismo valor en lugar de crear y reutilizar una cadena, desperdicia memoria. Si es probable que la creación de varias veces el mismo valor de cadena mediante una llamada a la <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> anticipo de constructor, incluso si no sabe en cuál pueden ser esos valores de cadena idéntica, puede usar una tabla de búsqueda en su lugar.  
  
 Por ejemplo, supongamos que lee y analizar un flujo de caracteres de un archivo que contiene los atributos y etiquetas XML. Cuando se analiza el flujo, varias veces encontrar ciertos tokens (es decir, secuencias de caracteres que tienen un significado simbólico). Los tokens equivalentes a las cadenas "0", "1", "true" y "false" están probables que se producen con frecuencia en una secuencia XML.  
  
 En lugar de convertir cada token en una nueva cadena, puede crear un <xref:System.Xml.NameTable?displayProperty=nameWithType> objeto para mantener las cadenas más frecuentes. La <xref:System.Xml.NameTable> objeto mejora el rendimiento, ya que recupera cadenas almacenadas sin asignar memoria temporal. Si se produce un token, utilice el <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para recuperar el token de la tabla. Si el token no existe, el método devuelve la cadena correspondiente. Si el token no existe, use el <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para insertar el testigo en la tabla y para obtener la cadena correspondiente.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Ejemplo 1: Uso de la asignación de cadena  
 El ejemplo siguiente crea una nueva cadena mediante la asignación de un literal de cadena. Crea una segunda cadena asignando el valor de la primera cadena a él. Estas son las dos formas más comunes para crear una nueva instancia <xref:System.String> objeto.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Ejemplo 2: Uso de una matriz de caracteres  
 En el ejemplo siguiente se muestra cómo crear un nuevo <xref:System.String> objeto a partir de una matriz de caracteres.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Ejemplo 3: Con una parte de una matriz de caracteres y un único carácter de repetición  
 En el ejemplo siguiente se muestra cómo crear un nuevo <xref:System.String> una parte de una matriz de caracteres y cómo crear un nuevo objeto <xref:System.String> objeto que contiene varias apariciones de un único carácter.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Ejemplo 4: Mediante un puntero a una matriz de caracteres  
 En el ejemplo siguiente se muestra cómo crear un nuevo <xref:System.String> objeto de un puntero a una matriz de caracteres. El ejemplo de C# debe compilarse con la `/unsafe` modificador del compilador.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Ejemplo 5: Crear una instancia de una cadena a partir de un puntero y un intervalo de una matriz  
 El ejemplo siguiente examina los elementos de una matriz de caracteres para un punto o un signo de exclamación. Si encuentra uno, crea una instancia de una cadena de caracteres de la matriz que preceden a los símbolos de puntuación. Si no es así, crea una instancia de una cadena con todo el contenido de la matriz. El ejemplo de C# debe compilarse con la `/unsafe` modificador del compilador.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Ejemplo 6: Crear una instancia de una cadena de un puntero a una matriz de bytes con signo  
 El ejemplo siguiente muestra cómo puede crear una instancia de la <xref:System.String> clase con el <xref:System.String.%23ctor%28System.SByte%2A%29> constructor.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Información de versión  
 .NET Framework  
 Todas las sobrecargas se admiten en: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Todas las sobrecargas se admiten en: 4, 3.5 SP1  
  
 Biblioteca de clases portable  
 Todas las sobrecargas sin un <xref:System.SByte> `*` se admiten el parámetro  
  
 .NET para aplicaciones de la Tienda Windows  
 Todas las sobrecargas sin un <xref:System.SByte> `*` parámetro se admite en: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Puntero a una matriz de caracteres Unicode terminada en null.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.String" /> con el valor indicado por un puntero especificado que apunta a una matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obtener ejemplos y la información de uso completa sobre esta y otras `String` sobrecargas de constructor, vea el <xref:System.String.%23ctor%2A> resumen del constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El proceso actual no tiene acceso de lectura a todos los caracteres tratados.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> especifica una matriz que contiene un carácter Unicode no válido o <paramref name="value" /> especifica una dirección menor que 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Matriz de caracteres Unicode.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.String" /> en el valor indicado por una matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obtener ejemplos y la información de uso completa sobre esta y otras `String` sobrecargas de constructor, vea el <xref:System.String.%23ctor%2A> resumen del constructor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Puntero a una matriz terminada en null de enteros de 8 bits con signo. Los números enteros se interpretan utilizando la codificación actual para páginas de códigos de sistema (es decir, la codificación especificada por <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.String" /> con el valor indicado por un puntero a una matriz de enteros de 8 bits con signo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obtener ejemplos y la información de uso completa sobre esta y otras `String` sobrecargas de constructor, vea el <xref:System.String.%23ctor%2A> resumen del constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">No se ha podido inicializar una nueva instancia de <see cref="T:System.String" /> mediante <paramref name="value" />, suponiendo que <paramref name="value" /> se ha codificado en ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud de la nueva cadena a inicializar, que viene determinada por el carácter de terminación null de <paramref name="value" />, es demasiado grande para asignar.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> especifica una dirección no válida.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode.</param>
        <param name="count">Número de veces que se presenta el parámetro <paramref name="c" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.String" /> con el valor indicado por un carácter Unicode especificado que se repite un número de veces determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obtener ejemplos y la información de uso completa sobre esta y otras `String` sobrecargas de constructor, vea el <xref:System.String.%23ctor%2A> resumen del constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Puntero a una matriz de caracteres Unicode.</param>
        <param name="startIndex">Posición inicial de <paramref name="value" />.</param>
        <param name="length">Número de caracteres de <paramref name="value" /> que se van a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.String" /> con el valor indicado por un puntero especificado que apunta a una matriz de caracteres Unicode, una posición de carácter inicial dentro de dicha matriz y una longitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obtener ejemplos y la información de uso completa sobre esta y otras `String` sobrecargas de constructor, vea el <xref:System.String.%23ctor%2A> resumen del constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> o <paramref name="length" /> es menor que cero, <paramref name="value" /> + <paramref name="startIndex" /> produce un desbordamiento de puntero o el proceso actual no tiene acceso de lectura a todos los caracteres tratados.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> especifica una matriz que contiene un carácter Unicode no válido, o <paramref name="value" /> + <paramref name="startIndex" /> especifica una dirección menor que 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Matriz de caracteres Unicode.</param>
        <param name="startIndex">Posición inicial de <paramref name="value" />.</param>
        <param name="length">Número de caracteres de <paramref name="value" /> que se van a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.String" /> con el valor indicado por una matriz de caracteres Unicode, una posición de carácter inicial dentro de dicha matriz y una longitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obtener ejemplos y la información de uso completa sobre esta y otras `String` sobrecargas de constructor, vea el <xref:System.String.%23ctor%2A> resumen del constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> o <paramref name="length" /> es menor que cero.  
  
O bien 
La suma de <paramref name="startIndex" /> y <paramref name="length" /> es mayor que el número de elementos de <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Puntero a una matriz de enteros de 8 bits con signo. Los números enteros se interpretan utilizando la codificación actual para páginas de códigos de sistema (es decir, la codificación especificada por <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">Posición inicial de <paramref name="value" />.</param>
        <param name="length">Número de caracteres de <paramref name="value" /> que se van a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.String" /> con el valor indicado por un puntero a una matriz de enteros de 8 bits con signo especificado, una posición inicial dentro de dicha matriz y una longitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obtener ejemplos y la información de uso completa sobre esta y otras `String` sobrecargas de constructor, vea el <xref:System.String.%23ctor%2A> resumen del constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> o <paramref name="length" /> es menor que cero.  
  
O bien 
La dirección especificada por <paramref name="value" /> + <paramref name="startIndex" /> es demasiado grande para la plataforma actual, es decir, se ha desbordado el cálculo de la dirección.  
  
O bien 
La longitud de la nueva cadena que se va a inicializar es demasiado grande para asignarla.</exception>
        <exception cref="T:System.ArgumentException">La dirección especificada por <paramref name="value" /> + <paramref name="startIndex" /> es inferior a 64 000.  
  
O bien 
No se ha podido inicializar una nueva instancia de <see cref="T:System.String" /> mediante <paramref name="value" />, suponiendo que <paramref name="value" /> se ha codificado en ANSI.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> y <paramref name="length" /> colectivamente especifican una dirección no válida.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Puntero a una matriz de enteros de 8 bits con signo.</param>
        <param name="startIndex">Posición inicial de <paramref name="value" />.</param>
        <param name="length">Número de caracteres de <paramref name="value" /> que se van a usar.</param>
        <param name="enc">Un objeto que especifica la forma en que se codifica la matriz a la que <paramref name="value" /> hace referencia. Si el valor de <paramref name="enc" /> es <see langword="null" />, se supone que se trata de la codificación ANSI.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.String" /> con el valor indicado por un puntero a una matriz de enteros de 8 bits con signo especificado, una posición inicial dentro de dicha matriz, una longitud y un objeto <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obtener ejemplos y la información de uso completa sobre esta y otras `String` sobrecargas de constructor, vea el <xref:System.String.%23ctor%2A> resumen del constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> o <paramref name="length" /> es menor que cero.  
  
O bien 
La dirección especificada por <paramref name="value" /> + <paramref name="startIndex" /> es demasiado grande para la plataforma actual, es decir, se ha desbordado el cálculo de la dirección.  
  
O bien 
La longitud de la nueva cadena que se va a inicializar es demasiado grande para asignarla.</exception>
        <exception cref="T:System.ArgumentException">La dirección especificada por <paramref name="value" /> + <paramref name="startIndex" /> es inferior a 64 000.  
  
O bien 
No se ha podido inicializar una nueva instancia de <see cref="T:System.String" /> mediante <paramref name="value" />, suponiendo que <paramref name="value" /> se ha codificado según lo especificado por <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> y <paramref name="length" /> colectivamente especifican una dirección no válida.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Index) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[Index] { char get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Index) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la cadena actual.</param>
        <summary>Obtiene el objeto <see cref="T:System.Char" /> situado en una posición específica en el objeto <see cref="T:System.String" /> actual.</summary>
        <value>Objeto en la posición <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `index` parámetro está basado en cero.  
  
 Esta propiedad devuelve el <xref:System.Char> objeto en la posición especificada por el `index` parámetro. Sin embargo, se podría representar un carácter Unicode por más de un <xref:System.Char>. Use la <xref:System.Globalization.StringInfo?displayProperty=nameWithType> clase para que funcionen con Unicode de caracteres en lugar de <xref:System.Char> objetos. Para obtener más información, vea la sección "Char objetos y caracteres de Unicode" en la <xref:System.String> información general de clases.  
  
 En C#, la <xref:System.String.Chars%2A> propiedad es un indizador. En Visual Basic, es la propiedad predeterminada de la <xref:System.String> clase. Cada <xref:System.Char> puede tener acceso al objeto en la cadena mediante el uso de código como el siguiente.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo puede usar este indizador en una rutina para validar una cadena.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> es mayor o igual que la longitud de este objeto o menor que cero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public string this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Chars(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(range As Range) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[Range] { System::String ^ get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Range) : string" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una referencia a la instancia de <see cref="T:System.String" />.</summary>
        <returns>Instancia de <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto no es una copia independiente de esta instancia; es simplemente otra vista de los mismos datos. Use la <xref:System.String.Copy%2A> o <xref:System.String.CopyTo%2A> método para crear otro <xref:System.String> objeto con el mismo valor que esta instancia.  
  
 Dado que el <xref:System.String.Clone%2A> método simplemente devuelve la instancia existente de la cadena, hay pocas razones para llamarlo directamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara dos objetos <see cref="T:System.String" /> especificados y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todas las sobrecargas del método <xref:System.String.Compare%2A> devuelven un entero de 32 bits con signo que indica la relación léxica que existe entre los dos términos de una comparación.  
  
|Valor|Condición|  
|-----------|---------------|  
|Menor que cero|La primera subcadena precede a la segunda subcadena en el criterio de ordenación.|  
|Cero|Las subcadenas aparecen en la misma posición en el criterio de ordenación, o `length` es cero.|  
|Mayor que cero|La primera subcadena sigue la segunda subcadena en el criterio de ordenación.|  
  
> [!WARNING]
>  Siempre que sea posible, debe llamar a una sobrecarga de la <xref:System.String.Compare%2A> método que incluye un <xref:System.StringComparison> parámetro. Para obtener más información, consulte [Procedimientos recomendados para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Procedimientos recomendados para el uso de cadenas en .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a comparar.</param>
        <param name="strB">Segunda cadena que se va a comparar.</param>
        <summary>Compara dos objetos <see cref="T:System.String" /> especificados y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
        <returns>Entero de 32 bits con signo que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description><paramref name="strA" /> precede a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description><paramref name="strA" /> se produce en la misma posición que <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Mayor que cero 
 </term><description><paramref name="strA" /> sigue a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparación utiliza la referencia cultural actual para obtener información específica de la referencia cultural como reglas de mayúsculas y minúsculas y el orden alfabético de los caracteres individuales. Por ejemplo, una referencia cultural podría especificar que ciertas combinaciones de caracteres se tratan como un único carácter o caracteres en mayúsculas y minúsculas se comparan de una manera determinada, o que el criterio de ordenación de un carácter depende de los caracteres que preceden o seguirlo.  
  
 La comparación se realiza mediante las reglas de ordenación de word. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Cuando se comparan cadenas, debe llamar a la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, que requiere que se especifique explícitamente el tipo de comparación de cadenas que utiliza el método. Para obtener más información, consulte [Procedimientos recomendados para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md).  
  
 Pueden ser uno o ambos términos de la comparación `null`. Por definición, cualquier cadena, incluida la cadena vacía (""), son mayores que una referencia null; y dos referencias nulas son iguales entre sí.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos cadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, a continuación, la cadena de caracteres restantes se considera mayor. El valor devuelto es el resultado de la última comparación realizada.  
  
 Pueden producirse resultados inesperados cuando las comparaciones se ven afectadas por las reglas de mayúsculas y minúsculas específicas de la referencia cultural. Por ejemplo, en turco, en el ejemplo siguiente se genera los malos resultados porque el sistema de archivos en turco no utiliza las reglas lingüísticas de mayúsculas y minúsculas para la letra "i" en "file".  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Comparar el nombre de ruta de acceso a "file" utilizando una comparación ordinal. El código correcto para hacer esto es como sigue:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.String.Compare%28System.String%2CSystem.String%29> método para comparar tres conjuntos de cadenas.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 En el ejemplo siguiente, la `ReverseStringComparer` clase muestra cómo puede evaluar dos cadenas con el <xref:System.String.Compare%2A> método.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.Compare(System.String,System.String)" /> método no tiene en cuenta dichos caracteres cuando realiza una comparación dependiente de la referencia cultural. Por ejemplo, si se ejecuta el código siguiente en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versiones posteriores, una comparación de referencias culturales de "animal" con "ani correo" (con un guion o 00AD U +) indica que las dos cadenas son equivalentes.  
  
[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
Para que reconozca los caracteres pueden pasar por alto en una comparación de cadenas, llamar a la <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método y proporcione un valor de uno de ellos <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para el `comparisonType` parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a comparar.</param>
        <param name="strB">Segunda cadena que se va a comparar.</param>
        <param name="ignoreCase"><see langword="true" /> para no distinguir entre mayúsculas y minúsculas durante la comparación; de lo contrario, <see langword="false" />.</param>
        <summary>Compara dos objetos <see cref="T:System.String" /> especificados, pasando por alto o teniendo en cuenta el uso de mayúsculas y minúsculas, y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
        <returns>Entero de 32 bits con signo que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description><paramref name="strA" /> precede a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description><paramref name="strA" /> se produce en la misma posición que <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Mayor que cero 
 </term><description><paramref name="strA" /> sigue a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparación utiliza la referencia cultural actual para obtener información específica de la referencia cultural como reglas de mayúsculas y minúsculas y el orden alfabético de los caracteres individuales. Por ejemplo, una referencia cultural podría especificar que ciertas combinaciones de caracteres se tratan como un único carácter o caracteres en mayúsculas y minúsculas se comparan de una manera determinada, o que el criterio de ordenación de un carácter depende de los caracteres que preceden o seguirlo.  
  
 La comparación se realiza mediante las reglas de ordenación de word. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Cuando se comparan cadenas, debe llamar a la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, que requiere que se especifique explícitamente el tipo de comparación de cadenas que utiliza el método. Para obtener más información, consulte [Procedimientos recomendados para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md).  
  
 Pueden ser uno o ambos términos de la comparación `null`. Por definición, cualquier cadena, incluida la cadena vacía (""), son mayores que una referencia null; y dos referencias nulas son iguales entre sí.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos cadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, a continuación, la cadena de caracteres restantes se considera mayor. El valor devuelto es el resultado de la última comparación realizada.  
  
 Pueden producirse resultados inesperados cuando las comparaciones se ven afectadas por las reglas de mayúsculas y minúsculas específicas de la referencia cultural. Por ejemplo, en turco, en el ejemplo siguiente se genera los malos resultados porque el sistema de archivos en turco no utiliza las reglas lingüísticas de mayúsculas y minúsculas para la letra "i" en "file".  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Comparar el nombre de ruta de acceso a "file" utilizando una comparación ordinal. El código correcto para hacer esto es como sigue:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra que el <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> método es equivalente a usar <xref:System.String.ToUpper%2A> o <xref:System.String.ToLower%2A> cuando se comparan cadenas.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> método no tiene en cuenta dichos caracteres cuando realiza una comparación dependiente de la referencia cultural. Por ejemplo, si se ejecuta el código siguiente en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versiones posteriores, una comparación de referencias culturales, mayúsculas y minúsculas de "animal" con "Ani correo" (con un guion o 00AD U +) indica que las dos cadenas son equivalentes.  
  
[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
Para que reconozca los caracteres pueden pasar por alto en una comparación de cadenas, llamar a la <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método y proporcione un valor de uno de ellos <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para el <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a comparar.</param>
        <param name="strB">Segunda cadena que se va a comparar.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica las reglas que se van a usar en la comparación.</param>
        <summary>Compara dos objetos <see cref="T:System.String" /> especificados usando las reglas especificadas y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
        <returns>Entero de 32 bits con signo que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description><paramref name="strA" /> precede a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description><paramref name="strA" /> se encuentra en la misma posición que <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Mayor que cero 
 </term><description><paramref name="strA" /> sigue a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `comparisonType` parámetro indica si la comparación debe utilizar la referencia cultural actual o invariable, respetan omitir la grafía de la comparación o utilizar word (referencia cultural) o las reglas de ordenación ordinal de (referencia cultural).  
  
 Pueden ser uno o ambos términos de la comparación `null`. Por definición, cualquier cadena, incluida la cadena vacía (""), son mayores que una referencia null; y dos referencias nulas son iguales entre sí.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos cadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, la cadena de caracteres restantes se considera mayor. El valor devuelto es el resultado de la última comparación realizada.  
  
 Pueden producirse resultados inesperados cuando las comparaciones se ven afectadas por las reglas de mayúsculas y minúsculas específicas de la referencia cultural. Por ejemplo, en turco, en el ejemplo siguiente se genera los malos resultados porque el sistema de archivos en turco no utiliza las reglas lingüísticas de mayúsculas y minúsculas para la letra "i" en "file".  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Comparar el nombre de ruta de acceso a "file" utilizando una comparación ordinal. El código correcto para hacer esto es como sigue:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 En el ejemplo siguiente se comparan tres versiones de la letra "I". Los resultados se ven afectados por la elección de la referencia cultural, si se omiten los casos, y si se realiza una comparación ordinal.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método no tiene en cuenta dichos caracteres cuando realiza una comparación dependiente de la referencia cultural. Para que reconozca los caracteres pueden pasar por alto en la comparación, proporcione un valor de <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> para el <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a comparar.</param>
        <param name="strB">Segunda cadena que se va a comparar.</param>
        <param name="ignoreCase"><see langword="true" /> para no distinguir entre mayúsculas y minúsculas durante la comparación; de lo contrario, <see langword="false" />.</param>
        <param name="culture">Un objeto que proporciona información de comparación específica de la referencia cultural.</param>
        <summary>Compara dos objetos <see cref="T:System.String" /> especificados, pasando por alto o teniendo en cuenta el uso de mayúsculas y minúsculas, usa información específica de la referencia cultural para influir en la comparación y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
        <returns>Entero de 32 bits con signo que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description><paramref name="strA" /> precede a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description><paramref name="strA" /> se produce en la misma posición que <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Mayor que cero 
 </term><description><paramref name="strA" /> sigue a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa la comparación el `culture` parámetro para obtener información específica de la referencia cultural como reglas de mayúsculas y minúsculas y el orden alfabético de los caracteres individuales. Por ejemplo, una referencia cultural podría especificar que ciertas combinaciones de caracteres se tratan como un único carácter o caracteres en mayúsculas y minúsculas se comparan de una manera determinada, o que el criterio de ordenación de un carácter depende de los caracteres que preceden o seguirlo.  
  
 La comparación se realiza mediante las reglas de ordenación de word. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Pueden ser uno o ambos términos de la comparación `null`. Por definición, cualquier cadena, incluida la cadena vacía (""), son mayores que una referencia null; y dos referencias nulas son iguales entre sí.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos cadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, a continuación, la cadena de caracteres restantes se considera mayor. El valor devuelto es el resultado de la última comparación realizada.  
  
 Pueden producirse resultados inesperados cuando las comparaciones se ven afectadas por las reglas de mayúsculas y minúsculas específicas de la referencia cultural. Por ejemplo, en turco, en el ejemplo siguiente se genera los malos resultados porque el sistema de archivos en turco no utiliza las reglas lingüísticas de mayúsculas y minúsculas para la letra "i" en "file".  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Comparar el nombre de ruta de acceso a "file" utilizando una comparación ordinal. El código correcto para hacer esto es como sigue:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo referencia cultural puede afectar a una comparación. Checo - referencia cultural de la República Checa, "ch" es un carácter único que es mayor que "d". Sin embargo, en inglés - Estados Unidos cultura, "ch" consta de dos caracteres y "c" es menor que "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> método no tiene en cuenta dichos caracteres cuando realiza una comparación dependiente de la referencia cultural. Por ejemplo, si se ejecuta el código siguiente en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versiones posteriores, una comparación entre mayúsculas y minúsculas de "animal" con "Ani correo" (con un guion o U + 00AD) con el nombre invariable referencia cultural indica que las dos cadenas son equivalentes.  
  
[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
Para que reconozca los caracteres pueden pasar por alto en una comparación de cadenas, llamar a la <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método y proporcione un valor de uno de ellos <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para el <paramref name="options" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a comparar.</param>
        <param name="strB">Segunda cadena que se va a comparar.</param>
        <param name="culture">Referencia cultural que proporciona información de comparación específica de la referencia cultural.</param>
        <param name="options">Opciones que se pueden usar al realizar la comparación (como pasar por alto los símbolos o el uso de mayúsculas y minúsculas).</param>
        <summary>Compara dos objetos <see cref="T:System.String" /> especificados usando las opciones de comparación especificadas e información específica de la referencia cultural para influir en la comparación y devuelve un entero que indica la relación mutua de las dos cadenas en el criterio de ordenación.</summary>
        <returns>Un entero con signo de 32 bits que indica la relación léxica entre <paramref name="strA" /> y <paramref name="strB" />, como se muestra en la tabla siguiente 
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description><paramref name="strA" /> precede a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description><paramref name="strA" /> se produce en la misma posición que <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Mayor que cero 
 </term><description><paramref name="strA" /> sigue a <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa la comparación el `culture` parámetro para obtener información específica de la referencia cultural, como las reglas de mayúsculas y minúsculas y el orden alfabético de los caracteres individuales. Por ejemplo, una referencia cultural determinada podría especificar que ciertas combinaciones de caracteres se tratan como un único carácter, que se comparan caracteres en mayúsculas y minúsculas de una manera determinada, o que el criterio de ordenación de un carácter depende de los caracteres que anteriores o posteriores.  
  
> [!CAUTION]
>  El <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método está diseñado principalmente para su uso en la ordenación de las operaciones o alfabética. No debe usarse cuando el propósito principal de la llamada al método es determinar si dos cadenas son equivalentes (es decir, cuando el propósito de la llamada al método es comprobar un valor devuelto de cero). Para determinar si dos cadenas son equivalentes, llame a la <xref:System.String.Equals%2A> método.  
  
 La comparación se puede especificar aún más por el `options` parámetro, que consta de uno o varios miembros de la <xref:System.Globalization.CompareOptions> enumeración. Sin embargo, dado que es el propósito de este método para llevar a cabo una comparación de cadenas dependientes de la referencia cultural, el <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> y <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valores no tienen ningún efecto.  
  
 Pueden ser uno o ambos términos de la comparación `null`. Por definición, cualquier cadena, incluyendo <xref:System.String.Empty?displayProperty=nameWithType>, compara mayor que una referencia nula y dos referencias nulas es igual entre sí.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos cadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, la cadena con el resto de caracteres se considera mayor.  
  
   
  
## Examples  
 En el ejemplo siguiente se comparan dos cadenas de tres maneras diferentes: mediante la comparación lingüística para la referencia cultural en-US; usar comparación lingüística de mayúsculas y minúsculas para la referencia cultural en-US; y el uso de una comparación ordinal. Ilustra cómo los tres métodos de comparación producen tres resultados diferentes.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> no es un valor <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. El <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método no tiene en cuenta dichos caracteres cuando realiza una comparación dependiente de la referencia cultural. Para que reconozca los caracteres pueden pasar por alto en la comparación, proporcione un valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para el <paramref name="options" /> parámetro.</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a usar en la comparación.</param>
        <param name="indexA">Posición de la subcadena dentro de <paramref name="strA" />.</param>
        <param name="strB">Segunda cadena que se va a usar en la comparación.</param>
        <param name="indexB">Posición de la subcadena dentro de <paramref name="strB" />.</param>
        <param name="length">Número máximo de caracteres de las subcadenas que se van a comparar.</param>
        <summary>Compara subcadenas de dos objetos <see cref="T:System.String" /> especificados y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
        <returns>Entero de 32 bits con signo que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description> La subcadena <paramref name="strA" /> precede a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description> Las subcadenas aparecen en la misma posición en el criterio de ordenación, o <paramref name="length" /> es cero.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> La subcadena <paramref name="strA" /> sigue a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar las subcadenas que se compara en `strA` en `indexA` y en `strB` en `indexB`. Ambos `indexA` y `indexB` está basado en cero; es decir, el primer carácter de `strA` y `strB` está en la posición cero. La longitud de la primera subcadena es igual que la longitud de `strA` menos `indexA` más uno. La longitud de la segunda subcadena es igual que la longitud de `strB` menos `indexB` más uno.  
  
 El número de caracteres que se va a comparar es el menor de las longitudes de las dos subcadenas, y `length`. El `indexA`, `indexB`, y `length` parámetros deben ser no negativos.  
  
 La comparación utiliza la referencia cultural actual para obtener información específica de la referencia cultural como reglas de mayúsculas y minúsculas y el orden alfabético de los caracteres individuales. Por ejemplo, una referencia cultural podría especificar que ciertas combinaciones de caracteres se tratan como un único carácter o caracteres en mayúsculas y minúsculas se comparan de una manera determinada, o que el criterio de ordenación de un carácter depende de los caracteres que preceden o seguirlo.  
  
 La comparación se realiza mediante las reglas de ordenación de word. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Cuando se comparan cadenas, debe llamar a la <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método, que requiere que se especifique explícitamente el tipo de comparación de cadenas que utiliza el método. Para obtener más información, consulte [Procedimientos recomendados para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md).  
  
 Pueden ser uno o ambos términos de la comparación `null`. Por definición, cualquier cadena, incluida la cadena vacía (""), son mayores que una referencia null; y dos referencias nulas son iguales entre sí.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos subcadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, a continuación, la cadena de caracteres restantes se considera mayor. El valor devuelto es el resultado de la última comparación realizada.  
  
 Pueden producirse resultados inesperados cuando las comparaciones se ven afectadas por las reglas de mayúsculas y minúsculas específicas de la referencia cultural. Por ejemplo, en turco, en el ejemplo siguiente se genera los malos resultados porque el sistema de archivos en turco no utiliza las reglas lingüísticas de mayúsculas y minúsculas para la letra "i" en "file".  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Comparar el nombre de ruta de acceso a "file" utilizando una comparación ordinal. El código correcto para hacer esto es como sigue:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 El ejemplo siguiente compara dos subcadenas.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> es mayor que <paramref name="strA" /> <see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="indexB" /> es mayor que <paramref name="strB" /> <see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> es negativo.  
  
O bien 
<paramref name="indexA" /> o <paramref name="indexB" /> es <see langword="null" /> y <paramref name="length" /> es mayor que cero.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> método no tiene en cuenta estos caracteres cuando realiza una comparación lingüística o la referencia cultural. Para que reconozca los caracteres pueden pasar por alto en la comparación, llame a la <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método y proporcione un valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para el <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a usar en la comparación.</param>
        <param name="indexA">Posición de la subcadena dentro de <paramref name="strA" />.</param>
        <param name="strB">Segunda cadena que se va a usar en la comparación.</param>
        <param name="indexB">Posición de la subcadena dentro de <paramref name="strB" />.</param>
        <param name="length">Número máximo de caracteres de las subcadenas que se van a comparar.</param>
        <param name="ignoreCase"><see langword="true" /> para no distinguir entre mayúsculas y minúsculas durante la comparación; de lo contrario, <see langword="false" />.</param>
        <summary>Compara las subcadenas de dos objetos <see cref="T:System.String" /> especificados, pasando por alto o teniendo en cuenta el uso de mayúsculas y minúsculas, y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
        <returns>Entero de 32 bits con signo que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description> La subcadena <paramref name="strA" /> precede a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description> Las subcadenas aparecen en la misma posición en el criterio de ordenación, o <paramref name="length" /> es cero.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> La subcadena <paramref name="strA" /> sigue a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar las subcadenas que se compara en `strA` en `indexA`y en `strB` en `indexB`. Ambos `indexA` y `indexB` está basado en cero; es decir, el primer carácter de `strA` y `strB` está en la posición cero. La longitud de la primera subcadena es igual que la longitud de `strA` menos `indexA` más uno. La longitud de la segunda subcadena es igual que la longitud de `strB` menos `indexB` más uno.  
  
 El número de caracteres que se va a comparar es el menor de las longitudes de las dos subcadenas, y `length`. El `indexA`, `indexB`, y `length` parámetros deben ser no negativos.  
  
 La comparación utiliza la referencia cultural actual para obtener información específica de la referencia cultural como reglas de mayúsculas y minúsculas y el orden alfabético de los caracteres individuales. Por ejemplo, una referencia cultural podría especificar que ciertas combinaciones de caracteres se tratan como un único carácter o caracteres en mayúsculas y minúsculas se comparan de una manera determinada, o que el criterio de ordenación de un carácter depende de los caracteres que preceden o seguirlo.  
  
 La comparación se realiza mediante las reglas de ordenación de word. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Cuando se comparan cadenas, debe llamar a la <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método, que requiere que se especifique explícitamente el tipo de comparación de cadenas que utiliza el método. Para obtener más información, consulte [Procedimientos recomendados para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md).  
  
 Pueden ser uno o ambos términos de la comparación `null`. Por definición, cualquier cadena, incluida la cadena vacía (""), son mayores que una referencia null; y dos referencias nulas son iguales entre sí.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos subcadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, a continuación, la cadena de caracteres restantes se considera mayor. El valor devuelto es el resultado de la última comparación realizada.  
  
 Pueden producirse resultados inesperados cuando las comparaciones se ven afectadas por las reglas de mayúsculas y minúsculas específicas de la referencia cultural. Por ejemplo, en turco, en el ejemplo siguiente se genera los malos resultados porque el sistema de archivos en turco no utiliza las reglas lingüísticas de mayúsculas y minúsculas para la letra "i" en "file".  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 El nombre de ruta de acceso debe compararse utilizando la referencia cultural. El código correcto para hacer esto es como sigue.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 El ejemplo siguiente realiza dos comparaciones de dos subcadenas que solo difieren en el caso. La primera comparación no distingue entre mayúsculas y considera que la comparación segundo caso.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> es mayor que <paramref name="strA" /> <see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="indexB" /> es mayor que <paramref name="strB" /> <see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> es negativo.  
  
O bien 
<paramref name="indexA" /> o <paramref name="indexB" /> es <see langword="null" /> y <paramref name="length" /> es mayor que cero.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> método no tiene en cuenta estos caracteres cuando realiza una comparación lingüística o la referencia cultural. Para que reconozca los caracteres pueden pasar por alto en la comparación, llame a la <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método y proporcione un valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para el <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a usar en la comparación.</param>
        <param name="indexA">Posición de la subcadena dentro de <paramref name="strA" />.</param>
        <param name="strB">Segunda cadena que se va a usar en la comparación.</param>
        <param name="indexB">Posición de la subcadena dentro de <paramref name="strB" />.</param>
        <param name="length">Número máximo de caracteres de las subcadenas que se van a comparar.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica las reglas que se van a usar en la comparación.</param>
        <summary>Compara las subcadenas de dos objetos <see cref="T:System.String" /> especificados usando las reglas especificadas y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
        <returns>Entero de 32 bits con signo que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description> La subcadena <paramref name="strA" /> precede a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description> Las subcadenas aparecen en la misma posición en el criterio de ordenación, o el parámetro <paramref name="length" /> es cero.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> La subcadena <paramref name="strA" /> sigue a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar las subcadenas que se compara en `strA` en `indexA` y en `strB` en `indexB`. Ambos `indexA` y `indexB` está basado en cero; es decir, el primer carácter de `strA` y `strB` está en posición cero, no coloque uno. La longitud de la primera subcadena es igual que la longitud de `strA` menos `indexA` más uno. La longitud de la segunda subcadena es igual que la longitud de `strB` menos `indexB` más uno.  
  
 El número de caracteres que se va a comparar es el menor de las longitudes de las dos subcadenas, y `length`. El `indexA`, `indexB`, y `length` parámetros deben ser no negativos.  
  
 El `comparisonType` parámetro indica si la comparación debe utilizar la referencia cultural actual o invariable, respetan omitir la grafía de la comparación o utilizar word (referencia cultural) o las reglas de ordenación ordinal de (referencia cultural).  
  
 Pueden ser uno o ambos términos de la comparación `null`. Por definición, cualquier cadena, incluida la cadena vacía (""), son mayores que una referencia null; y dos referencias nulas son iguales entre sí.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos subcadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, la cadena de caracteres restantes se considera mayor. El valor devuelto es el resultado de la última comparación realizada.  
  
 Pueden producirse resultados inesperados cuando las comparaciones se ven afectadas por las reglas de mayúsculas y minúsculas específicas de la referencia cultural. Por ejemplo, en turco, en el ejemplo siguiente se genera los malos resultados porque el sistema de archivos en turco no utiliza las reglas lingüísticas de mayúsculas y minúsculas para la letra "i" en "file".  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Comparar el nombre de ruta de acceso a "file" utilizando una comparación ordinal. El código correcto para hacer esto es como sigue:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 El ejemplo siguiente compara dos subcadenas.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> es mayor que <paramref name="strA" /> <see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="indexB" /> es mayor que <paramref name="strB" /> <see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> es negativo.  
  
O bien 
<paramref name="indexA" /> o <paramref name="indexB" /> es <see langword="null" /> y <paramref name="length" /> es mayor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método no tiene en cuenta estos caracteres cuando realiza una comparación lingüística o la referencia cultural. Para que reconozca los caracteres pueden pasar por alto en la comparación, proporcione un valor de <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> para el <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a usar en la comparación.</param>
        <param name="indexA">Posición de la subcadena dentro de <paramref name="strA" />.</param>
        <param name="strB">Segunda cadena que se va a usar en la comparación.</param>
        <param name="indexB">Posición de la subcadena dentro de <paramref name="strB" />.</param>
        <param name="length">Número máximo de caracteres de las subcadenas que se van a comparar.</param>
        <param name="ignoreCase"><see langword="true" /> para no distinguir entre mayúsculas y minúsculas durante la comparación; de lo contrario, <see langword="false" />.</param>
        <param name="culture">Un objeto que proporciona información de comparación específica de la referencia cultural.</param>
        <summary>Compara las subcadenas de dos objetos <see cref="T:System.String" /> especificados, pasando por alto o teniendo en cuenta el uso de mayúsculas y minúsculas, usa información específica de la referencia cultural para influir en la comparación y devuelve un entero que indica su posición relativa en el criterio de ordenación.</summary>
        <returns>Entero que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description> La subcadena <paramref name="strA" /> precede a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description> Las subcadenas aparecen en la misma posición en el criterio de ordenación, o <paramref name="length" /> es cero.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> La subcadena <paramref name="strA" /> sigue a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar las subcadenas que se compara en `strA` en `indexA`y en `strB` en `indexB`. Ambos `indexA` y `indexB` está basado en cero; es decir, el primer carácter de `strA` y `strB` está en posición cero, no coloque uno. La longitud de la primera subcadena es igual que la longitud de `strA` menos `indexA` más uno. La longitud de la segunda subcadena es igual que la longitud de `strB` menos `indexB` más uno.  
  
 El número de caracteres que se va a comparar es el menor de las longitudes de las dos subcadenas, y `length`. El `indexA`, `indexB`, y `length` parámetros deben ser no negativos.  
  
 Usa la comparación el `culture` parámetro para obtener información específica de la referencia cultural como reglas de mayúsculas y minúsculas y el orden alfabético de los caracteres individuales. Por ejemplo, una referencia cultural podría especificar que ciertas combinaciones de caracteres se tratan como un único carácter o caracteres en mayúsculas y minúsculas se comparan de una manera determinada, o que el criterio de ordenación de un carácter depende de los caracteres que preceden o seguirlo.  
  
 La comparación se realiza mediante las reglas de ordenación de word. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Pueden ser uno o ambos términos de la comparación `null`. Por definición, cualquier cadena, incluida la cadena vacía (""), son mayores que una referencia null; y dos referencias nulas son iguales entre sí.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos subcadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, a continuación, la cadena de caracteres restantes se considera mayor. El valor devuelto es el resultado de la última comparación realizada.  
  
 Pueden producirse resultados inesperados cuando las comparaciones se ven afectadas por las reglas de mayúsculas y minúsculas específicas de la referencia cultural. Por ejemplo, en turco, en el ejemplo siguiente se genera los malos resultados porque el sistema de archivos en turco no utiliza las reglas lingüísticas de mayúsculas y minúsculas para la letra "i" en "file".  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Comparar el nombre de ruta de acceso a "file" utilizando una comparación ordinal. El código correcto para hacer esto es como sigue:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 El ejemplo siguiente compara dos subcadenas con las distintas referencias culturales y omitir el caso de las subcadenas. La elección de la referencia cultural afecta a cómo la letra "I" es en comparación con.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> es mayor que <paramref name="strA" /> <see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="indexB" /> es mayor que <paramref name="strB" /> <see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> es negativo.  
  
O bien 
<paramref name="strA" /> o <paramref name="strB" /> es <see langword="null" /> y <paramref name="length" /> es mayor que cero.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> método no tiene en cuenta estos caracteres cuando realiza una comparación lingüística o la referencia cultural. Para que reconozca los caracteres pueden pasar por alto en la comparación, llame a la <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método y proporcione un valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para el <paramref name="options" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a usar en la comparación.</param>
        <param name="indexA">Posición inicial de la subcadena dentro de <paramref name="strA" />.</param>
        <param name="strB">Segunda cadena que se va a usar en la comparación.</param>
        <param name="indexB">Posición inicial de la subcadena dentro de <paramref name="strB" />.</param>
        <param name="length">Número máximo de caracteres de las subcadenas que se van a comparar.</param>
        <param name="culture">Un objeto que proporciona información de comparación específica de la referencia cultural.</param>
        <param name="options">Opciones que se pueden usar al realizar la comparación (como pasar por alto los símbolos o el uso de mayúsculas y minúsculas).</param>
        <summary>Compara las subcadenas de dos objetos <see cref="T:System.String" /> especificados usando las opciones de comparación especificadas e información específica de la referencia cultural para influir en la comparación y devuelve un entero que indica la relación mutua de las dos subcadenas en el criterio de ordenación.</summary>
        <returns>Un entero que indica la relación léxica entre las dos subcadenas, como se muestra en la tabla siguiente.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description> La subcadena <paramref name="strA" /> precede a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item><item><term> Cero 
 </term><description> Las subcadenas aparecen en la misma posición en el criterio de ordenación, o <paramref name="length" /> es cero.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> La subcadena <paramref name="strA" /> sigue a la subcadena <paramref name="strB" /> en el criterio de ordenación.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar las subcadenas que se compara en `strA` en posición `indexA` y en `strB` en posición `indexB`. La longitud de la primera subcadena es la longitud de `strA` menos `indexA`. La longitud de la segunda subcadena es la longitud de `strB` menos `indexB`.  
  
 El número de caracteres que se va a comparar es el menor de las longitudes de las dos subcadenas, y `length`. El `indexA`, `indexB`, y `length` parámetros deben ser no negativos.  
  
 Usa la comparación el `culture` parámetro para obtener información específica de la referencia cultural, como las reglas de mayúsculas y minúsculas y el orden alfabético de los caracteres individuales. Por ejemplo, una referencia cultural determinada podría especificar que ciertas combinaciones de caracteres se tratan como un único carácter, que se comparan caracteres en mayúsculas y minúsculas de una manera determinada, o que el criterio de ordenación de un carácter depende de los caracteres que anteriores o posteriores.  
  
> [!CAUTION]
>  El <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método está diseñado principalmente para su uso en la ordenación de las operaciones o alfabética. No debe usarse cuando el propósito principal de la llamada al método es determinar si dos subcadenas son equivalentes (es decir, cuando el propósito de la llamada al método es comprobar un valor devuelto de cero). Para determinar si dos cadenas son equivalentes, llame a la <xref:System.String.Equals%2A> método.  
  
 Uno o ambos `strA` y `strB` puede ser `null`. Por definición, cualquier cadena, incluyendo <xref:System.String.Empty?displayProperty=nameWithType>, compara mayor que una referencia nula y dos referencias nulas es igual entre sí.  
  
 La comparación se puede especificar aún más por el `options` parámetro, que consta de uno o varios miembros de la <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeración. Sin embargo, dado que es el propósito de este método para llevar a cabo una comparación de cadenas dependientes de la referencia cultural, el <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> y <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valores no tienen ningún efecto.  
  
 La comparación finaliza cuando se detecta una desigualdad o se han comparado las dos subcadenas. Sin embargo, si las dos cadenas son iguales al final de una cadena y la otra cadena tiene caracteres restantes, la cadena con el resto de caracteres se considera mayor. El valor devuelto es el resultado de la última comparación realizada.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método para comparar los apellidos de dos personas. A continuación, se enumeran en orden alfabético.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> no es un valor <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> es mayor que <paramref name="strA" /><see langword=".Length" />.  
  
O bien 
 <paramref name="indexB" /> es mayor que <paramref name="strB" /><see langword=".Length" />.  
  
O bien 
 <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> es negativo.  
  
O bien 
<paramref name="strA" /> o <paramref name="strB" /> es <see langword="null" /> y <paramref name="length" /> es mayor que cero.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método no tiene en cuenta estos caracteres cuando realiza una comparación lingüística o la referencia cultural. Para que reconozca los caracteres pueden pasar por alto en la comparación, proporcione un valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para el <paramref name="options" /> parámetro.</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara dos objetos <see cref="T:System.String" /> mediante la evaluación de los valores numéricos de los objetos <see cref="T:System.Char" /> correspondientes de cada cadena.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a comparar.</param>
        <param name="strB">Segunda cadena que se va a comparar.</param>
        <summary>Compara dos objetos <see cref="T:System.String" /> especificados mediante la evaluación de los valores numéricos de los objetos <see cref="T:System.Char" /> correspondientes de cada cadena.</summary>
        <returns>Entero que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description><paramref name="strA" /> es menor que <paramref name="strB" />.  
  
 </description></item><item><term> Cero 
 </term><description><paramref name="strA" /> y <paramref name="strB" /> son iguales.  
  
 </description></item><item><term> Mayor que cero 
 </term><description><paramref name="strA" /> es mayor que <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación de mayúsculas y minúsculas usando las reglas de ordenación ordinal. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Para realizar una comparación de mayúsculas y minúsculas usando las reglas de ordenación ordinal, llame a la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método con el `comparisonType` establecido en <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Dado que <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> es un método estático, `strA` y `strB` puede ser `null`. Si ambos valores son `null`, el método devuelve 0 (cero), que indica que `strA` y `strB` son iguales. Si solo uno de los valores es `null`, el método tiene en cuenta el valor distinto de null para que sea mayor.  
  
   
  
## Examples  
 En el ejemplo siguiente se realiza y comparación de ordinales de dos cadenas que solo difieren en el caso.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Primera cadena que se va a usar en la comparación.</param>
        <param name="indexA">Índice inicial de la subcadena de <paramref name="strA" />.</param>
        <param name="strB">Segunda cadena que se va a usar en la comparación.</param>
        <param name="indexB">Índice inicial de la subcadena de <paramref name="strB" />.</param>
        <param name="length">Número máximo de caracteres de las subcadenas que se van a comparar.</param>
        <summary>Compara las subcadenas de dos objetos <see cref="T:System.String" /> especificados mediante la evaluación de los valores numéricos de los correspondientes objetos <see cref="T:System.Char" /> en cada subcadena.</summary>
        <returns>Entero de 32 bits con signo que indica la relación léxica que existe entre los dos términos de una comparación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description> La subcadena de <paramref name="strA" /> es menor que la subcadena de <paramref name="strB" />.  
  
 </description></item><item><term> Cero 
 </term><description> Las subcadenas son iguales o <paramref name="length" /> es cero.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> La subcadena de <paramref name="strA" /> es mayor que la subcadena de <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `indexA`, `indexB`, y `length` parámetros deben ser no negativos.  
  
 El número de caracteres que se compara es el menor de la longitud de `strA` menos `indexA`, la longitud de `strB` menos `indexB`, y `length`.  
  
 Este método realiza una comparación de mayúsculas y minúsculas usando las reglas de ordenación ordinal. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Para realizar una comparación de mayúsculas y minúsculas usando las reglas de ordenación ordinal, llame a la <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método con el `comparisonType` establecido en <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Dado que <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> es un método estático, `strA` y `strB` puede ser `null`. Si ambos valores son `null`, el método devuelve 0 (cero), que indica que `strA` y `strB` son iguales. Si solo uno de los valores es `null`, el método tiene en cuenta el valor distinto de null para que sea mayor.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra que <xref:System.String.CompareOrdinal%2A> y <xref:System.String.Compare%2A> usar distintos criterios de ordenación.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> no es <see langword="null" /> y <paramref name="indexA" /> es mayor que <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="strB" /> no es <see langword="null" /> y <paramref name="indexB" /> es mayor que <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
O bien 
 <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> es negativo.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara esta instancia con un objeto especificado o un objeto <see cref="T:System.String" /> y devuelve un entero que indica si la posición de esta instancia es anterior, posterior o igual que la posición del objeto especificado u objeto <see cref="T:System.String" /> en el criterio de ordenación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las dos sobrecargas de los <xref:System.String.CompareTo%2A> método realiza la comparación de la referencia cultural y distingue mayúsculas de minúsculas. No se puede usar este método para realizar comparaciones ordinales o referencias culturales. Para mayor claridad del código, se recomienda evitar el <xref:System.String.CompareTo%2A> método y llamar a la <xref:System.String.Compare%2A> método en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Un objeto que se evalúa como un objeto <see cref="T:System.String" />.</param>
        <summary>Compara esta instancia con un <see cref="T:System.Object" /> especificado e indica si la posición de esta instancia es anterior, posterior o igual que la posición del <see cref="T:System.Object" /> especificado en el criterio de ordenación.</summary>
        <returns>Entero con signo de 32 bits que indica si la posición de esta instancia es anterior, posterior o igual que la posición del parámetro <paramref name="value" /> en el criterio de ordenación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description> Esta instancia precede a <paramref name="value" />.  
  
 </description></item><item><term> Cero 
 </term><description> En el criterio de ordenación, esta instancia tiene la misma posición que <paramref name="value" />.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> Esta instancia es posterior a <paramref name="value" />.  
  
O bien 
 <paramref name="value" /> es <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` debe ser un <xref:System.String> objeto.  
  
> [!CAUTION]
>  El <xref:System.String.CompareTo%2A> método se diseñó principalmente para su uso en la ordenación de las operaciones o alfabética. No debe usarse cuando el propósito principal de la llamada al método es determinar si dos cadenas son equivalentes. Para determinar si dos cadenas son equivalentes, llame a la <xref:System.String.Equals%2A> método.  
  
 Este método realiza una comparación de palabras (distingue mayúsculas de minúsculas y la referencia cultural) usando la referencia cultural actual. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Para obtener más información sobre el comportamiento de este método, vea la sección Comentarios de la <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.String.CompareTo%2A> método con un <xref:System.Object>. Porque intenta comparar un <xref:System.String> instancia a un `TestClass` objeto, el método produce una <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> no es un <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.CompareTo(System.Object)" /> método no tiene en cuenta dichos caracteres cuando realiza una comparación dependiente de la referencia cultural. Por ejemplo, si se ejecuta el código siguiente en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versiones posteriores, una comparación de "animal" con "ani correo" (con un guion o 00AD U +) indica que las dos cadenas son equivalentes.  
  
[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
Para que reconozca los caracteres pueden pasar por alto en una comparación de cadenas, llamar a la <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> método.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Cadena que se va a comparar con esta instancia.</param>
        <summary>Compara esta instancia con un objeto <see cref="T:System.String" /> especificado e indica si la posición de esta instancia es anterior, posterior o igual que la posición de la cadena especificada en el criterio de ordenación.</summary>
        <returns>Entero con signo de 32 bits que indica si la posición de esta instancia es anterior, posterior o igual que la posición del parámetro <paramref name="strB" /> en el criterio de ordenación.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condición 
 </description></listheader><item><term> Menor que cero 
 </term><description> Esta instancia precede a <paramref name="strB" />.  
  
 </description></item><item><term> Cero 
 </term><description> En el criterio de ordenación, esta instancia tiene la misma posición que <paramref name="strB" />.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> Esta instancia es posterior a <paramref name="strB" />.  
  
O bien 
 <paramref name="strB" /> es <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación de palabras (distingue mayúsculas de minúsculas y la referencia cultural) usando la referencia cultural actual. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  El <xref:System.String.CompareTo%2A> método se diseñó principalmente para su uso en la ordenación de las operaciones o alfabética. No debe usarse cuando el propósito principal de la llamada al método es determinar si dos cadenas son equivalentes. Para determinar si dos cadenas son equivalentes, llame a la <xref:System.String.Equals%2A> método.  
  
 Para obtener más información sobre el comportamiento de este método, vea la sección Comentarios de la <xref:System.String.Compare%28System.String%2CSystem.String%29> método.  
  
 Este método implementa el <xref:System.IComparable%601?displayProperty=nameWithType> interfaz y realiza un poco mejor que el <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> método, porque no tiene que determinar si el `strB` argumento es un tipo de valor mutable que debe realizar la conversión boxing, y no tiene que convertir su parámetro de un <xref:System.Object> a un <xref:System.String>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.String.CompareTo%2A> método para comparar la instancia de cadena actual con otra cadena.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 El ejemplo siguiente muestra las versiones no genéricas y del método CompareTo para varios tipos de valor y de referencia.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto. El <see cref="M:System.String.CompareTo(System.String)" /> método no tiene en cuenta dichos caracteres cuando realiza una comparación dependiente de la referencia cultural. Por ejemplo, si se ejecuta el código siguiente en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versiones posteriores, una comparación de "animal" con "ani correo" (con un guion o 00AD U +) indica que las dos cadenas son equivalentes.  
  
[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
Para que reconozca los caracteres pueden pasar por alto en una comparación de cadenas, llamar a la <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> método.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena una o más instancias de <see cref="T:System.String" /> o las representaciones de tipo <see cref="T:System.String" /> de los valores de una o más instancias de <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values">Objeto de colección que implementa la interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> y cuyo argumento de tipo genérico es <see cref="T:System.String" />.</param>
        <summary>Concatena los miembros de una colección <see cref="T:System.Collections.Generic.IEnumerable`1" /> construida de tipo <see cref="T:System.String" />.</summary>
        <returns>Cadenas concatenados en <paramref name="values" /> o en <see cref="F:System.String.Empty" /> si <paramref name="values" /> es un valor de <see langword="IEnumerable(Of String)" /> vacío.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método concatena todos los objetos de `values`; no agrega los delimitadores. Para especificar un delimitador entre cada miembro del `values`, llame a la <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.  
  
 Un <xref:System.String.Empty> cadena se usa en lugar de cualquier elemento null en `values`.  
  
 Si `values` está vacío `IEnumerable(Of String)`, el método devuelve <xref:System.String.Empty?displayProperty=nameWithType>. Si `values` es `null`, el método produce una <xref:System.ArgumentNullException> excepción.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> es un método de conveniencia que le permite concatenar cada elemento de un `IEnumerable(Of String)` colección sin convertir primero los elementos en una matriz de cadenas. Es especialmente útil con expresiones de consulta de Language-Integrated Query (LINQ). En el ejemplo siguiente se pasa un `List(Of String)` objeto que contiene las letras mayúsculas o minúsculas del alfabeto a una expresión lambda que selecciona las letras que sean igual o mayor que una letra determinada (que, en el ejemplo, es "M"). El `IEnumerable(Of String)` colección devuelto por la <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método se pasa a la <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método para mostrar el resultado como una sola cadena.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el algoritmo criba de Eratóstenes para calcular los números primos que son menores o iguales que 100. Asigna el resultado a un <xref:System.Collections.Generic.List%601> objeto de tipo <xref:System.String>, que, a continuación, pasa a la <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Objeto que se va a representar, o <see langword="null" />.</param>
        <summary>Crea la representación de cadena de un objeto especificado.</summary>
        <returns>Representación de cadena del valor de <paramref name="arg0" />, o el campo si <see cref="F:System.String.Empty" /> si <paramref name="arg0" /> es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.Concat%28System.Object%29> método representa `arg0` como una cadena mediante una llamada a su sin parámetros `ToString` método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.Concat%2A> método.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Matriz de objetos que contiene los elementos que se van a concatenar.</param>
        <summary>Concatena las representaciones de cadena de los elementos de una matriz <see cref="T:System.Object" /> especificada.</summary>
        <returns>Representaciones de cadena concatenadas de los valores de los elementos de <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método concatena todos los objetos de `args` llamando al método sin parámetros `ToString` método de dicho objeto; no agrega los delimitadores.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> se utiliza en lugar de un objeto nulo en la matriz.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.String.Concat%2A> método con un <xref:System.Object> matriz.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> es <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insuficiente</exception>
        <block subset="none" type="usage"><para>Este método no se llama al código de C++. El compilador de C++ resuelve las llamadas a <see cref="Overload:System.String.Concat" /> que tiene cuatro o más parámetros de objeto como una llamada a <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Matriz de instancias de cadena.</param>
        <summary>Concatena los elementos en una matriz <see cref="T:System.String" /> especificada.</summary>
        <returns>Elementos concatenados de <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método concatena todos los objetos de `values`; no agrega los delimitadores.  
  
 Un <xref:System.String.Empty> cadena se usa en lugar de un objeto nulo en la matriz.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.String.Concat%2A> método con un <xref:System.String> matriz.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> es <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insuficiente</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Primer objeto que se va a concatenar.</param>
        <param name="arg1">Segundo objeto que se va a concatenar.</param>
        <summary>Concatena las representaciones de cadena de dos objetos especificados.</summary>
        <returns>Representaciones de cadena concatenadas de los valores de los parámetros <paramref name="arg0" /> y <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método concatena `arg0` y `arg1` llamando al método sin parámetros `ToString` método `arg0` y `arg1`; no agrega los delimitadores.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> se utiliza en lugar de un argumento nulo.  
  
 Si cualquiera de los argumentos es una referencia de la matriz, el método concatena una cadena que representa esa matriz, en lugar de sus miembros (por ejemplo, "System.String[]").  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.Concat%2A> método.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Primera cadena que se va a concatenar.</param>
        <param name="str1">Segunda cadena que se va a concatenar.</param>
        <summary>Concatena dos instancias de <see cref="T:System.String" /> especificadas.</summary>
        <returns>Concatenación de <paramref name="str0" /> y <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método concatena `str0` y `str1`; no agrega los delimitadores.  
  
> [!NOTE]
>  También puede usar como operador de concatenación de cadenas de su lenguaje, `+` en C#, o `&` y `+` en Visual Basic)  
>   
>  , para concatenar cadenas.  
  
 Un <xref:System.String.Empty> cadena se usa en lugar de un argumento nulo.  
  
   
  
## Examples  
 El ejemplo siguiente concatena el nombre de y los apellidos de una persona.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Primer objeto que se va a concatenar.</param>
        <param name="arg1">Segundo objeto que se va a concatenar.</param>
        <param name="arg2">Tercer objeto que se va a concatenar.</param>
        <summary>Concatena las representaciones de cadena de tres objetos especificados.</summary>
        <returns>Representaciones de cadena concatenadas de los valores de los parámetros <paramref name="arg0" />, <paramref name="arg1" /> y <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método concatena `arg0`, `arg1`, y `arg2` llamando al método sin parámetros `ToString` método de cada objeto; no agrega los delimitadores.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> se utiliza en lugar de un argumento nulo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.Concat%2A> método.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Primera cadena que se va a concatenar.</param>
        <param name="str1">Segunda cadena que se va a concatenar.</param>
        <param name="str2">Tercera cadena que se va a concatenar.</param>
        <summary>Concatena tres instancias de <see cref="T:System.String" /> especificadas.</summary>
        <returns>Concatenación de <paramref name="str0" /> y <paramref name="str1" /><paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método concatena `str0`, `str1`, y `str2`; no agrega los delimitadores.  
  
> [!NOTE]
>  También puede usar como operador de concatenación de cadenas de su lenguaje, `+` en C#, o `&` y `+` en Visual Basic)  
>   
>  , para concatenar cadenas.  
  
 Un <xref:System.String.Empty> cadena se usa en lugar de un argumento nulo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.String.Concat%2A> método para concatenar tres cadenas y muestra el resultado.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">Primer objeto que se va a concatenar.</param>
        <param name="arg1">Segundo objeto que se va a concatenar.</param>
        <param name="arg2">Tercer objeto que se va a concatenar.</param>
        <param name="arg3">Cuarto objeto que se va a concatenar.</param>
        <summary>Concatena las representaciones de cadena de cuatro objetos especificados y cualquier otro objeto especificado en una lista opcional de parámetros de longitud variable.</summary>
        <returns>Representación de cadena concatenada de cada valor en la lista de parámetros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esta API no es conforme a CLS. La alternativa conforme a CLS es <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Los compiladores de C# y Visual Basic resolver automáticamente una llamada a este método como una llamada a <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 El método concatena cada objeto en la lista de parámetros mediante una llamada a su sin parámetros `ToString` método; no agrega los delimitadores.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> se utiliza en lugar de un argumento nulo.  
  
> [!NOTE]
>  El último parámetro de la <xref:System.String.Concat%2A> método es una lista opcional delimitada por comas de uno o varios objetos adicionales para concatenar.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para concatenar una lista de parámetros de variable. En este caso, se llama al método con nueve parámetros.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Este método está marcado con el <see langword="vararg" /> palabra clave, lo que significa que admite un número variable de parámetros. El método puede llamarse desde Visual C++, pero no se puede llamar desde el código de C# o Visual Basic. Los compiladores de C# y Visual Basic resolver llamadas a <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> como llamadas a <see cref="M:System.String.Concat(System.Object[])" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <param name="str3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Primera cadena que se va a concatenar.</param>
        <param name="str1">Segunda cadena que se va a concatenar.</param>
        <param name="str2">Tercera cadena que se va a concatenar.</param>
        <param name="str3">Cuarta cadena que se va a concatenar.</param>
        <summary>Concatena cuatro instancias de <see cref="T:System.String" /> especificadas.</summary>
        <returns>Concatenación de <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, y <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método concatena `str0`, `str1`, `str2`, y `str3`; no agrega los delimitadores.  
  
> [!NOTE]
>  También puede usar como operador de concatenación de cadenas de su lenguaje, `+` en C#, o `&` y `+` en Visual Basic)  
>   
>  , para concatenar cadenas.  
  
 Un <xref:System.String.Empty> cadena se usa en lugar de un objeto nulo en la matriz.  
  
   
  
## Examples  
 El ejemplo siguiente define una matriz de palabras de cuatro – letras y almacena las letras individuales a una matriz de cadenas para codificarlas. A continuación, llama el <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> método para volver a ensamblar las palabras codificadas.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los miembros de <paramref name="values" />.</typeparam>
        <param name="values">Objeto de colección que implementa la interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Concatena los miembros de una implementación de <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Miembros concatenados de <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método concatena todos los objetos de `values`; no agrega los delimitadores.  
  
 Un <xref:System.String.Empty> cadena se usa en lugar de un argumento nulo.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> es un método de conveniencia que le permite concatenar cada elemento de un <xref:System.Collections.Generic.IEnumerable%601> colección sin convertir primero los elementos en cadenas. Resulta especialmente útil con expresiones de consulta de Language-Integrated Query (LINQ), como se muestra en el ejemplo siguiente. La representación de cadena de cada objeto en el <xref:System.Collections.Generic.IEnumerable%601> se derivó la colección mediante una llamada a ese objeto `ToString` método.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un método muy sencillo `Animal` clase que contiene el nombre de un animal y el orden al que pertenece. A continuación, define un <xref:System.Collections.Generic.List%601> objeto para contener un número de `Animal` objetos. El <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> se denomina método de extensión para extraer el `Animal` objetos cuya propiedad `Order` propiedad es igual a "Roedor". El resultado se pasa a la <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método y se muestra en la consola.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <summary>Devuelve un valor que indica si una subcadena especificada aparece dentro de esta cadena.</summary>
        <returns>Es <see langword="true" /> si el parámetro <paramref name="value" /> aparece en esta cadena o si <paramref name="value" /> es la cadena vacía (""); en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación ordinal (distingue mayúsculas de minúsculas y cuenta la referencia cultural). La búsqueda comienza en la posición del primer carácter de esta cadena y continúa a través de la última posición de carácter.  
  
 Para determinar si una cadena contiene una subcadena especificada mediante el uso de un valor distinto de una comparación ordinal (por ejemplo, la comparación dependiente de la referencia cultural, o comparación ordinal de mayúsculas y minúsculas), puede crear un método personalizado. El ejemplo siguiente muestra uno de estos métodos. Define un <xref:System.String> método de extensión que incluye un <xref:System.StringComparison> parámetro e indica si una cadena contiene una subcadena al usar el formulario especificado de comparación de cadenas.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 El ejemplo siguiente, a continuación, llama el `Contains` método de extensión para determinar si se encuentra una subcadena en una cadena al usar comparación ordinal y comparación de ordinales entre mayúsculas y minúsculas.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Si está interesado en la posición de la subcadena `value` en la instancia actual, se puede llamar a la <xref:System.String.IndexOf%2A> puede llamar al método para obtener la posición inicial de su primera aparición, o bien el <xref:System.String.LastIndexOf%2A> colocar el método para obtener el inicio de su última repetición. El ejemplo incluye una llamada a la <xref:System.String.IndexOf%28System.String%29> método si se encuentra una subcadena en una instancia de cadena.  
  
   
  
## Examples  
 El ejemplo siguiente determina si la cadena "fox" es una subcadena de una cita conocida. Si "zorro" se encuentra en la cadena, también muestra su posición inicial.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Cadena que se va a copiar.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.String" /> con el mismo valor que una <see cref="T:System.String" /> especificada.</summary>
        <returns>Nueva cadena con el mismo valor que <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.Copy%2A> método devuelve un <xref:System.String> objeto que tiene el mismo valor que la cadena original, pero representa una referencia de objeto diferente. Difiere de una operación de asignación que asigna una referencia de cadena existente a una variable de objeto adicionales. El ejemplo ilustra la diferencia.  
  
   
  
## Examples  
 El ejemplo siguiente crea dos objetos de cadena con valores diferentes. Cuando llama a la <xref:System.String.Copy%2A> método para asignar el primer valor a la segunda cadena, el resultado indica que las cadenas representan las referencias a objetos diferentes aunque sus valores ahora son iguales. Por otro lado, cuando se asigna la primera cadena para la segunda cadena, las dos cadenas tienen valores idénticos, ya que representan la misma referencia de objeto.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Índice del primer carácter de esta instancia que se va a copiar.</param>
        <param name="destination">Matriz de caracteres Unicode a los que se copian los caracteres de esta instancia.</param>
        <param name="destinationIndex">Índice de <paramref name="destination" /> en el que comienza la operación de copia.</param>
        <param name="count">Número de caracteres de la instancia en cuestión que se van a copiar en <paramref name="destination" />.</param>
        <summary>Copia un número especificado de caracteres situados en una posición especificada de la instancia en una posición determinada de una matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia `count` caracteres desde la `sourceIndex` posición de esta instancia con el `destinationIndex` posición del `destination` matriz de caracteres. Este método no cambia de tamaño el `destination` matriz de caracteres; debe tener un número suficiente de elementos para dar cabida a los caracteres copiados o el método produce una <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` y `destinationIndex` están basadas en cero.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.CopyTo%2A> método.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> o <paramref name="count" /> es negativo. 
O bien 
 <paramref name="sourceIndex" /> no identifica una posición en la instancia actual.  
  
O bien 
 <paramref name="destinationIndex" /> no identifica un índice válido en la matriz <paramref name="destination" />.  
  
O bien 
 <paramref name="count" /> es mayor que la longitud de la subcadena desde <paramref name="sourceIndex" /> hasta el final de esta instancia. 
O bien 
 <paramref name="count" /> es mayor que la longitud de la submatriz desde <paramref name="destinationIndex" /> hasta el final de la matriz <paramref name="destination" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa la cadena vacía. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de este campo es la cadena de longitud cero, "".  
  
 En el código de aplicación, este campo se utiliza con más frecuencia en las asignaciones para inicializar una variable de cadena en una cadena vacía. Para comprobar si el valor de una cadena es `null` o <xref:System.String.Empty?displayProperty=nameWithType>, utilice el <xref:System.String.IsNullOrEmpty%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si el final de esta instancia de cadena coincide con una cadena especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comparar con la subcadena situada al final de esta instancia.</param>
        <summary>Determina si el final de esta instancia de cadena coincide con la cadena especificada.</summary>
        <returns>Es <see langword="true" /> si <paramref name="value" /> coincide con el final de esta instancia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método compara `value` a la subcadena situada al final de esta instancia de la misma longitud que `value`y devuelve una indicación de si son iguales. Para que sea igual, `value` debe ser una referencia a esta misma instancia o coincidir con el final de esta instancia.  
  
 Este método realiza una comparación de palabras (distingue mayúsculas de minúsculas y la referencia cultural) usando la referencia cultural actual.  
  
   
  
## Examples  
 El ejemplo siguiente se indica si cada cadena en una matriz termina con un punto (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 En el ejemplo siguiente se define un `StripEndTags` método que usa el <xref:System.String.EndsWith%28System.String%29> método para quitar las etiquetas de cierre HTML desde el final de una línea. Tenga en cuenta que el `StripEndTags` método se llama de forma recursiva para asegurarse de que se han quitado varias etiquetas de cierre HTML al final de la línea.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de comparación de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para determinar si una cadena termina con una subcadena concreta mediante el uso de las reglas de comparación de la referencia cultural actual, llame a la <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> sobrecarga del método con un valor de <see cref="F:System.StringComparison.CurrentCulture" /> para su <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comparar con la subcadena situada al final de esta instancia.</param>
        <param name="comparisonType">Uno de los valores de enumeración que determina cómo se comparan esta cadena y <paramref name="value" />.</param>
        <summary>Determina si el final de esta instancia de cadena coincide con la cadena especificada cuando se comparan usando la opción de comparación especificada.</summary>
        <returns>Es <see langword="true" /> si el parámetro <paramref name="value" /> coincide con el final de esta cadena; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.EndsWith%2A> método compara el `value` parámetro a la subcadena situada al final de esta cadena y devuelve un valor que indica si son iguales. Para que sea igual, `value` debe ser una referencia a esta misma cadena, debe ser una cadena vacía (""), o debe coincidir con el final de esta cadena. El tipo de comparación realizada por el <xref:System.String.EndsWith%2A> método depende del valor de la `comparisonType` parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente determina si una cadena termina con una subcadena concreta. Los resultados se ven afectados por la elección de la referencia cultural, si se omiten los casos, y si se realiza una comparación ordinal.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comparar con la subcadena situada al final de esta instancia.</param>
        <param name="ignoreCase"><see langword="true" /> para no distinguir entre mayúsculas y minúsculas durante la comparación; de lo contrario, <see langword="false" />.</param>
        <param name="culture">Información de referencia cultural que determina cómo se comparan esta instancia y <paramref name="value" />. Si <paramref name="culture" /> es <see langword="null" />, se usa la referencia cultural actual.</param>
        <summary>Determina si el final de esta instancia de cadena coincide con la cadena especificada cuando se comparan usando la referencia cultural especificada.</summary>
        <returns>Es <see langword="true" /> si el parámetro <paramref name="value" /> coincide con el final de esta cadena; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método compara la `value` parámetro a la subcadena situada al final de esta cadena que es la misma longitud que `value`y devuelve un valor que indica si son iguales. Para que sea igual, `value` debe ser una referencia a esta misma instancia o coincidir con el final de esta cadena.  
  
 Este método realiza una comparación (referencia cultural) de word mediante el uso mayúsculas y minúsculas especificada y la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente determina si se produce una cadena al final de otra cadena. El <xref:System.String.EndsWith%2A> se llama al método varias veces utilizando diferentes referencias culturales que influyen en los resultados de la búsqueda, distingue mayúsculas de minúsculas y mayúsculas y minúsculas.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si dos objetos <see cref="T:System.String" /> tienen el mismo valor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Cadena que se va a comparar con esta instancia.</param>
        <summary>Determina si esta instancia y un objeto especificado, que también debe ser un objeto <see cref="T:System.String" />, tienen el mismo valor.</summary>
        <returns>Es <see langword="true" /> si <paramref name="obj" /> es un objeto <see cref="T:System.String" /> y tiene el mismo valor que esta instancia; en caso contrario, es <see langword="false" />.  Si el valor de <paramref name="obj" /> es <see langword="null" />, el método devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación ordinal (distingue mayúsculas de minúsculas y cuenta la referencia cultural).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.Equals%2A> método.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comparar con esta instancia.</param>
        <summary>Determina si esta instancia y otro objeto <see cref="T:System.String" /> especificado tienen el mismo valor.</summary>
        <returns>Es <see langword="true" /> si el valor del parámetro <paramref name="value" /> es el mismo que el de esta instancia; en caso contrario, es <see langword="false" />. Si el valor de <paramref name="value" /> es <see langword="null" />, el método devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación ordinal (distingue mayúsculas de minúsculas y cuenta la referencia cultural).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.Equals%2A> método. Compara la palabra con título "File" con una palabra equivalente, su equivalente en minúsculas, su equivalente en mayúsculas y una palabra que contiene LATIN pequeña letra DOTLESS I (0131) en lugar de LATIN pequeña letra I (u+0069). Dado que el <xref:System.String.Equals%28System.String%29> método realiza una comparación ordinal, devuelve solo la comparación con una palabra idéntica `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Primera cadena que se va a comparar, o <see langword="null" />.</param>
        <param name="b">Segunda cadena que se va a comparar, o <see langword="null" />.</param>
        <summary>Determina si dos objetos <see cref="T:System.String" /> especificados tienen el mismo valor.</summary>
        <returns><see langword="true" /> si el valor de <paramref name="a" /> es el mismo que el valor de <paramref name="b" />; en caso contrario, <see langword="false" />. Si tanto <paramref name="a" /> como <paramref name="b" /> son <see langword="null" />, el método devuelve <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación ordinal (distingue mayúsculas de minúsculas y cuenta la referencia cultural).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.Equals%2A> método.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comparar con esta instancia.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica cómo se compararán las cadenas.</param>
        <summary>Determina si esta cadena y un objeto <see cref="T:System.String" /> especificado tienen el mismo valor. Un parámetro especifica la referencia cultural, el uso de mayúsculas y minúsculas, así como las reglas de ordenación usadas en la comparación.</summary>
        <returns>Es <see langword="true" /> si el valor del parámetro <paramref name="value" /> es el mismo que el de esta cadena; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `comparisonType` parámetro indica si la comparación debe utilizar la referencia cultural actual o invariable, respetan omitir el caso de las dos cadenas que se comparan o usar la palabra o las reglas de ordenación ordinal.  
  
   
  
## Examples  
 El ejemplo siguiente crea una matriz de cadena que consta de una letra mayúscula "I", "i" en minúscula y un punto "ı". A continuación, llama el <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> método para compararlas usando cada posible <xref:System.StringComparison> valor de enumeración.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 En el ejemplo siguiente se comparan cuatro conjuntos de palabras mediante el uso de cada miembro de la <xref:System.StringComparison> enumeración.  Las comparaciones usan las convenciones del inglés (Estados Unidos) y referencias culturales Sami (Suecia superior). Tenga en cuenta que las cadenas "encyclopædia" y "enciclopedia" se consideran equivalentes en la referencia cultural en-US, pero no en la referencia cultural Sami (septentrional Suecia).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">Primera cadena que se va a comparar, o <see langword="null" />.</param>
        <param name="b">Segunda cadena que se va a comparar, o <see langword="null" />.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica las reglas de la comparación.</param>
        <summary>Determina si dos objetos <see cref="T:System.String" /> especificados tienen el mismo valor. Un parámetro especifica la referencia cultural, el uso de mayúsculas y minúsculas, así como las reglas de ordenación usadas en la comparación.</summary>
        <returns>Es <see langword="true" /> si el valor del parámetro <paramref name="a" /> es igual que el valor del parámetro <paramref name="b" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `comparisonType` parámetro indica si la comparación debe utilizar la referencia cultural actual o invariable, respetan omitir el caso de las dos cadenas que se comparan o usar la palabra o las reglas de ordenación ordinal.  
  
   
  
## Examples  
 En el ejemplo siguiente se comparan cuatro conjuntos de palabras mediante el uso de cada miembro de la <xref:System.StringComparison> enumeración.  Las comparaciones usan las convenciones del inglés (Estados Unidos) y referencias culturales Sami (Suecia superior). Tenga en cuenta que las cadenas "encyclopædia" y "enciclopedia" se consideran equivalentes en la referencia cultural en-US, pero no en la referencia cultural Sami (septentrional Suecia).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor de los objetos en cadenas en función de los formatos especificados y los inserta en otra cadena.  
  
Si aún no conoce el método `String.Format`, vea un resumen rápido en la sección [Empezar a trabajar con el método String.Format](#Starting).  
  
Vea documentación general sobre el método `String.Format` en la sección [Comentarios](#remarks-top).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 En esta sección:  
  
 [Empezar a trabajar con el método String.Format](#Starting)   
 [¿Qué método se debe llamar?](#FTaskList)   
 [El método de formato en breve](#Format_Brief)   
 [El elemento de formato](#FormatItem)   
 [El formato de los argumentos](#HowFormatted)   
 [Elementos de formato que tienen el mismo índice](#SameIndex)   
 [Formato y la referencia cultural](#Format_Culture)   
 [Las operaciones de formato personalizado](#Format_Custom)   
 [String.Format preguntas y respuestas](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Empezar a trabajar con el método String.Format  
 Use <xref:System.String.Format%2A?displayProperty=nameWithType> si tiene que insertar el valor de un objeto, variable o expresión en otra cadena. Por ejemplo, puede insertar el valor de un <xref:System.Decimal> valor de cadena para mostrarla al usuario como una sola cadena:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Y puede controlar ese valor de formato:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Además de formato, también puede controlar alineación y espaciado.  
  
 ### <a name="inserting-a-string"></a>Insertar una cadena  

 <xref:System.String.Format%2A?displayProperty=nameWithType> comienza con una cadena de formato, seguida de uno o varios objetos o expresiones que se convierten en cadenas y se inserta en un lugar especificado en la cadena de formato. Por ejemplo:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 El `{0}` en el formato de cadena es un elemento de formato. `0` es el índice del objeto cuyo valor de cadena que se insertará en esa posición. (Los índices empiezan en 0). Si el objeto que se va a insertar no es una cadena, su `ToString` método se llama para convertirla a uno antes de insertarlo en la cadena de resultado.  
  
 Este es otro ejemplo que usa dos elementos de formato y dos objetos en la lista de objetos:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Puede tener tantos elementos de formato y tantos objetos en la lista de objetos que desean, siempre que el índice de cada elemento de formato tiene un objeto coincidente en la lista de objetos. Tampoco tiene que preocuparse acerca de la sobrecarga que se llama a; el compilador seleccionará el uno adecuado para usted.  
  
 ### <a name="controlling-formatting"></a>Controlar el formato  
 Puede seguir el índice de un elemento de formato con una cadena de formato para controlar cómo se da formato a un objeto. Por ejemplo, `{0:d}` se aplica a la cadena de formato "d" para el primer objeto de la lista de objetos. Este es un ejemplo con un solo objeto y dos elementos de formato:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Un número de tipos son compatibles con cadenas de formato, incluidos todos los tipos numéricos (ambos [estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md) cadenas con formato), todas las fechas y horas (ambos [estándar](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [personalizado](~/docs/standard/base-types/custom-date-and-time-format-strings.md) cadenas con formato) y los intervalos de tiempo (ambos [estándar](~/docs/standard/base-types/standard-timespan-format-strings.md) y [personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md) cadenas con formato), todos los tipos de enumeración [tipos de enumeración ](~/docs/standard/base-types/enumeration-format-strings.md), y [GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). También puede agregar compatibilidad para las cadenas de formato a sus propios tipos.  
  
 ### <a name="controlling-spacing"></a>Controlar el espaciado  
 Puede definir el ancho de la cadena que se inserta en la cadena de resultado mediante la sintaxis, como `{0,12}`, que inserta una cadena de 12 caracteres. En este caso, la representación de cadena del primer objeto está alineado a la derecha en el campo de 12 caracteres.  (Si la representación de cadena del primer objeto es la longitud de más de 12 caracteres, sin embargo, se omite el ancho de campo preferido, y toda la cadena se inserta en la cadena de resultado.)  
  
 En el ejemplo siguiente se define un campo de 6 caracteres para contener la cadena "Año" y algunas cadenas de año, así como un campo de 15 caracteres para contener la cadena "Rellenado" y algunos datos de población. Tenga en cuenta que los caracteres están alineados a la derecha en el campo.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Controlar la alineación  
 De forma predeterminada, las cadenas son alineado a la derecha dentro de su ámbito si se especifica un ancho de campo. Para alinear a la izquierda cadenas en un campo, comience con un signo negativo, el ancho de campo como `{0,-12}` para definir un campo de 12 caracteres alineado a la izquierda.  
  
 El ejemplo siguiente es similar al anterior, salvo que alinean a la izquierda tanto de las etiquetas de datos.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> hace uso de la característica de formato compuesto. Para obtener más información, consulte [Formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>¿Qué método se debe llamar?  
  
|En|Call|  
|--------|----------|  
|Aplicar formato a uno o varios objetos mediante las convenciones de la referencia cultural actual.|Excepto para las sobrecargas que incluyen un `provider` parámetro, el resto <xref:System.String.Format%2A> sobrecargas incluyen un <xref:System.String> parámetro seguido de uno o más parámetros de objeto. Por este motivo, no tendrá que determinar qué <xref:System.String.Format%2A> sobrecarga que piensa llamar. El compilador del lenguaje selecciona la sobrecarga adecuada entre las sobrecargas que no tienen un `provider` parámetro, en función de la lista de argumentos. Por ejemplo, si la lista de argumentos tiene cinco argumentos, el compilador llama el <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> método.|  
|Aplicar formato a uno o varios objetos mediante las convenciones de una referencia cultural concreta.|Cada <xref:System.String.Format%2A> sobrecarga que comienza con un `provider` parámetro va seguido de un <xref:System.String> parámetro y uno o varios parámetros de objeto. Por este motivo, no tiene que determinar qué específico <xref:System.String.Format%2A> sobrecarga que piensa llamar. El compilador del lenguaje selecciona la sobrecarga adecuada entre las sobrecargas que tienen un `provider` parámetro, en función de la lista de argumentos. Por ejemplo, si la lista de argumentos tiene cinco argumentos, el compilador llama el <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método.|  
|Realizar una operación de formato personalizada con un <xref:System.ICustomFormatter> implementación o un <xref:System.IFormattable> implementación.|Cualquiera de las cuatro sobrecargas con un `provider` parámetro. El compilador selecciona la sobrecarga adecuada entre las sobrecargas que tienen un `provider` parámetro, en función de la lista de argumentos.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>El método de formato en breve 

 Cada sobrecarga de la <xref:System.String.Format%2A> método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) incluir marcadores de posición indizados basado en cero, llamados *dar formato a elementos*, en una cadena de formato compuesto. En tiempo de ejecución, cada elemento de formato se reemplaza por la representación de cadena del argumento correspondiente en una lista de parámetros. Si el valor del argumento es `null`, el elemento de formato se reemplaza por <xref:System.String.Empty?displayProperty=nameWithType>. Por ejemplo, la llamada siguiente a la <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método incluye una cadena de formato con tres elementos de formato {0}, {1}, y {2}y una lista de argumentos con tres elementos.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>El elemento de formato  
 Un elemento de formato tiene esta sintaxis:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Corchetes indican elementos opcionales. Se requiere la apertura y llaves de cierre. (Para incluir una apertura literal o llave de cierre en la cadena de formato, vea el [llaves de escape](~/docs/standard/base-types/composite-formatting.md#escaping-braces) sección la [formatos compuestos](~/docs/standard/base-types/composite-formatting.md) artículo.)  
  
 Por ejemplo, puede aparecer un elemento de formato para dar formato a un valor de moneda similar al siguiente:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Un elemento de formato tiene los siguientes elementos:  
  
 *index*  
 Índice de base cero del argumento cuya representación de cadena que se va a ser incluido en esta posición en la cadena. Si este argumento es `null`, una cadena vacía se incluirá en esta posición en la cadena.  
  
 *alignment*  
 Opcional. Un entero con signo que indica la longitud total del campo en el que se inserta el argumento y si está alineado a la derecha (un entero positivo) o alineado a la izquierda (un entero negativo). Si se omite *alineación*, la representación de cadena del argumento correspondiente se inserta en un campo sin espacios iniciales o finales.  
  
 Si el valor de *alineación* es menor que la longitud del argumento que se va a insertar, *alineación* se omite y la longitud de la representación de cadena del argumento se utiliza como el ancho de campo.  
  
 *formatString*  
 Opcional. Una cadena que especifica el formato de cadena de resultado del argumento correspondiente. Si se omite *formatString*, el argumento correspondiente sin parámetros `ToString` se invoca para generar la representación de cadena. Si especifica *formatString*, el argumento al que hace referencia el elemento de formato debe implementar la <xref:System.IFormattable> interfaz. Los tipos que admiten las cadenas de formato incluyen:  
  
-   Todos los tipos enteros y de punto flotante. (Consulte [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> y <xref:System.DateTimeOffset>. (Consulte [cadenas con formato de fecha y hora estándar](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [cadenas con formato de fecha y hora personalizado](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Todos los tipos de enumeración. (Consulte [cadenas de formato de enumeración](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   valores <xref:System.TimeSpan>. (Consulte [cadenas de formato TimeSpan estándar](~/docs/standard/base-types/standard-timespan-format-strings.md) y [cadenas de formato TimeSpan personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUID. (Consulte la <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> método.)  
  
 Sin embargo, tenga en cuenta que puede implementar cualquier tipo personalizado <xref:System.IFormattable> o extender un tipo existente <xref:System.IFormattable> implementación.  
  
 En el ejemplo siguiente se usa el `alignment` y `formatString` argumentos para producir un resultado con formato.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>El formato de los argumentos  
 Elementos de formato se procesan secuencialmente desde el principio de la cadena. Cada elemento de formato tiene un índice que corresponde a un objeto de lista de argumentos del método. El <xref:System.String.Format%2A> recupera el argumento de método y se deriva a su representación de cadena como sigue:  
  
-   Si el argumento es `null`, el método inserta <xref:System.String.Empty?displayProperty=nameWithType> en la cadena de resultado. No tiene que preocuparse por el control de un <xref:System.NullReferenceException> para argumentos nulos. 
  
-   Si se llama a la <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> sobrecarga y la `provider` del objeto <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementación devuelve un valor no null <xref:System.ICustomFormatter> implementación, el argumento se pasa a su <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método. Si el elemento de formato incluye un *formatString* argumento, se pasa como primer argumento al método. Si el <xref:System.ICustomFormatter> implementación está disponible y genera una cadena no nula, que se devuelve una cadena como la representación de cadena del argumento; en caso contrario, se ejecuta el paso siguiente.  
  
-   Si el argumento implementa el <xref:System.IFormattable> interfaz, su <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> se llama a la implementación.  
  
-   El argumento sin parámetros `ToString` se llama al método, que reemplaza o se hereda de una implementación de clase base,.  
  
 Para obtener un ejemplo que intercepta las llamadas a la <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> método y le permite ver qué información del <xref:System.String.Format%2A> método pasa a un método de formato para cada elemento de formato de cadena de formato compuesto, consulte [ejemplo: Un proveedor de intersección y el formateador de número romano](#Format7_Example).  

 Para obtener más información, consulte el [el orden de procesamiento](~/docs/standard/base-types/composite-formatting.md##processing-order) sección la [formatos compuestos](~/docs/standard/base-types/composite-formatting.md) artículo.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Elementos de formato que tienen el mismo índice  
 El <xref:System.String.Format%2A> método produce una <xref:System.FormatException> excepción si el índice de un elemento de índice es mayor o igual que el número de argumentos de la lista de argumentos. Sin embargo, `format` puede incluir más elementos de formato de los argumentos, siempre y cuando varios elementos de formato tienen el mismo índice. En la llamada a la <xref:System.String.Format%28System.String%2CSystem.Object%29> método en el ejemplo siguiente, la lista de argumentos con un solo argumento, pero la cadena de formato incluye dos elementos de formato: uno muestra el valor decimal de un número, y el otro muestra su valor hexadecimal.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formato y la referencia cultural  
 Por lo general, los objetos en la lista de argumentos se convierten en sus representaciones de cadena mediante las convenciones de la referencia cultural actual, que es devuelto por la <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propiedad. Puede controlar este comportamiento mediante una llamada a una de las sobrecargas de <xref:System.String.Format%2A> que incluye un `provider` parámetro. El `provider` parámetro es un <xref:System.IFormatProvider> proceso de implementación que proporciona información de formato personalizado y específicos de la referencia cultural que se utiliza para moderar el formato.  
  
 El <xref:System.IFormatProvider> interfaz tiene un solo miembro, <xref:System.IFormatProvider.GetFormat%2A>, que es responsable de devolver el objeto que proporciona información de formato. .NET tiene tres <xref:System.IFormatProvider> implementaciones que proporcionen formato específico de la referencia cultural:  
  
-   <xref:System.Globalization.CultureInfo>. Su <xref:System.Globalization.CultureInfo.GetFormat%2A> método devuelve una referencia cultural específica <xref:System.Globalization.NumberFormatInfo> objeto para dar formato a valores numéricos y una determinada referencia cultural <xref:System.Globalization.DateTimeFormatInfo> objeto para dar formato a valores de fecha y hora.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, que se usa para aplicar formato específicos de referencias culturales de valores de fecha y hora. Su <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> método devuelve a sí mismo.  
  
-   <xref:System.Globalization.NumberFormatInfo>, que se usa para dar formato a específicas de referencias culturales de valores numéricos. Su <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> propiedad devuelve a sí mismo. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Las operaciones de formato personalizado  
 También se puede llamar cualquiera de las sobrecargas de los <xref:System.String.Format%2A> método que tiene un `provider` parámetro de tipo <xref:System.IFormatProvider> para realizar operaciones de formato personalizadas. Por ejemplo, puede dar formato entero como un número de identificación o como un número de teléfono. Para realizar un formato personalizado, su `provider` argumento debe implementar tanto el <xref:System.IFormatProvider> y <xref:System.ICustomFormatter> interfaces. Cuando el <xref:System.String.Format%2A> se pasa al método un <xref:System.ICustomFormatter> implementación como el `provider` argumento, el <xref:System.String.Format%2A> llamadas al método su <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementación y solicita un objeto de tipo <xref:System.ICustomFormatter>. A continuación, llama el valor devuelto <xref:System.ICustomFormatter> del objeto <xref:System.ICustomFormatter.Format%2A> método para dar formato a cada elemento de formato de la cadena compuesta pasa a él.  
  
 Para obtener más información acerca de cómo proporcionar soluciones personalizadas de formato, vea [Cómo: Definir y usar proveedores de formato numérico personalizado](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) y <xref:System.ICustomFormatter>. Para obtener un ejemplo que convierte números enteros para los números con formato personalizados, consulte [ejemplo: Una operación de formato personalizada](#Format6_Example). Para obtener un ejemplo que convierte los bytes sin signo en números romanos, consulte [ejemplo: Un proveedor de intersección y el formateador de número romano](#Format7_Example).  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>Ejemplo: Una operación de formato personalizada  
 Este ejemplo define un proveedor de formato que da formato a un valor entero como un número de cuenta de cliente en el formato xxxxx-x-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Ejemplo: Un proveedor de intersección y el formateador de número romano  
 Este ejemplo define un proveedor de formato personalizado que implementa el <xref:System.ICustomFormatter> y <xref:System.IFormatProvider> interfaces hacer dos cosas:  
  
-   Muestra los parámetros pasados a su <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementación. Esto nos permite ver qué parámetros la <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método está pasando a la implementación de formato personalizada para cada objeto que intenta dar formato. Esto puede ser útil al depurar la aplicación.  
  
-   Si el objeto que se va a tener el formato es un valor de byte sin signo que va a dar formato mediante la cadena de formato estándar "R", en el formateador personalizado da formato al valor numérico como un número romano.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format preguntas y respuestas  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>¿Por qué se recomienda la interpolación de cadenas a través de las llamadas a la `String.Format` método?

Interpolación de cadena es:

- Más flexible. Se puede usar en cualquier cadena sin necesidad de llamar a un método que admita formato compuesto. En caso contrario, se debe llamar a la <xref:System.String.Format%2A> método u otro método que admita formato compuesto, como <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Sea más legible. Dado que la expresión que se va a insertar en una cadena aparece en la expresión interpolada en lugar de una lista de argumentos, las cadenas interpoladas son mucho más fáciles para el código y para leer. Debido a su mayor legibilidad, cadenas interpoladas pueden reemplazar no solo las llamadas a métodos de formato compuesto, pero que también pueden utilizarse en operaciones de concatenación de cadenas para generar código más conciso y más claro. 

Una comparación de los siguientes dos ejemplos de código muestra la superioridad de cadenas interpoladas a través de la concatenación de cadenas y las llamadas a métodos de formato compuesto. El uso de varias operaciones de concatenación de cadena en el ejemplo siguiente genera código detallado y difícil de leer.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

En cambio, el uso de cadenas interpoladas en el ejemplo siguiente genera código más conciso, mucho más claro que la instrucción de concatenación de cadena y la llamada a la <xref:System.String.Format%2A> método en el ejemplo anterior.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>¿Dónde puedo encontrar una lista de las cadenas de formato predefinidos que puede usarse con elementos de formato?  
  
-   Para todos los tipos de punto flotante e integrales, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para los valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para los valores de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para <xref:System.TimeSpan> valores, vea [cadenas de formato TimeSpan estándar](~/docs/standard/base-types/standard-timespan-format-strings.md) y [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Para <xref:System.Guid> valores, vea la sección de comentarios de la <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> página de referencia.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>¿Cómo se puede controlar la alineación de las cadenas de resultado que reemplace los elementos de formato?  
 La sintaxis de un elemento de formato general es:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 donde *alineación* es un entero con signo que define el ancho de campo. Si este valor es negativo, el texto del campo está alineado a izquierda. Si es positivo, el texto está alineado a la derecha.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>¿Cómo se puede controlar el número de dígitos después del separador decimal?  
 Todos los [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) excepto "D" (que se usa con enteros solo), "G", "R" y "X" permitir que un especificador de precisión que define el número de dígitos decimales en la cadena de resultado. El ejemplo siguiente utiliza cadenas de formato numérico estándar para controlar el número de dígitos decimales en la cadena de resultado.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Si usas un [cadena de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md), usar el especificador de formato "0" para controlar el número de dígitos decimales en la cadena de resultado, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>¿Cómo se puede controlar el número de dígitos enteros?  
 De forma predeterminada, las operaciones de formato solo muestran dígitos enteros distintos de cero. Si se da formato a números enteros, puede usar un especificador de precisión con la "D" y "X" cadenas de formato estándar para controlar el número de dígitos.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Puede rellenar un entero o número de punto flotante con ceros iniciales para generar una cadena de resultado con un número especificado de dígitos enteros mediante el uso de "0" [especificador de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md), tal y como se muestra en el ejemplo siguiente.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>¿Cuántos elementos puedo incluir en la lista formato?  
 No hay ningún límite práctico. El segundo parámetro de la <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método se etiqueta con el <xref:System.ParamArrayAttribute> atributo, que le permite incluir una lista delimitada por punto o una matriz de objetos como la lista de formato.  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>¿Cómo se puede incluir entre llaves literales ("{" y "}") en la cadena de resultado?  
 Por ejemplo, ¿cómo prevenir la siguiente llamada de método genere un <xref:System.FormatException> excepción?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Una apertura única o una llave de cierre siempre se interpreta como el principio o al final de un elemento de formato. Para que se interpreten literalmente, deben convertirse. Escape de una llave agregando otro llave ("{{" y "}}" en lugar de "{" y "}"), como en la siguiente llamada de método:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Sin embargo, las llaves de escape incluso son fácilmente interpreta incorrectamente. Se recomienda que incluye llaves en la lista Formato y usar elementos de formato se va a insertar en la cadena de resultado, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>¿Por qué mi llamada al método String.Format produce excepción FormatException?  
 La causa más común de la excepción es que el índice de un elemento de formato no se corresponde con un objeto en la lista formato. Normalmente, esto indica que ha misnumbered los índices de elementos de formato o ha olvidado incluir un objeto en la lista formato. Intentar incluir una llave izquierda o derecha sin escape de caracteres también produce un <xref:System.FormatException>. En ocasiones, la excepción es el resultado de un error de escritura; Por ejemplo, un error típico es comete "[" (el corchete izquierdo) en lugar de "{" (la llave de apertura).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Si el método Format(System.IFormatProvider,System.String,System.Object[]) es compatible con las matrices de parámetros, ¿por qué mi código produce una excepción cuando usa la matriz?  
 Por ejemplo, el código siguiente produce un <xref:System.FormatException> excepción:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Se trata de un problema de resolución de sobrecarga del compilador. Dado que el compilador no puede convertir una matriz de enteros a una matriz de objetos, trata la matriz de enteros como un argumento único, por lo que llama a la <xref:System.String.Format%28System.String%2CSystem.Object%29> método. La excepción se produce porque hay cuatro elementos de formato, pero sólo un elemento en la lista formato.  
  
 Como Visual Basic ni C# puede convertir una matriz de enteros en una matriz de objetos, tendrá que realizar la conversión antes de llamar a la <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> método. El ejemplo siguiente proporciona una implementación.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Ver numerosos ejemplos que llaman a la <xref:System.String.Format%2A> método están intercalados a través de la [comentarios](#remarks) sección de este artículo.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

También puede descargar un conjunto completo de `String.Format` ejemplos, que se incluyen un [proyecto .NET Core 2.0 para C#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) y un [proyecto .NET Core 2.0 para Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), desde el [dotnet / repositorio de GitHub de ejemplos](https://github.com/dotnet/samples).

Los siguientes son algunos de los ejemplos incluidos en el artículo:

### <a name="create-a-format-string"></a>Crear una cadena de formato

[Insertar una cadena](#inserting-a-string)  
[El elemento de formato](#the-format-item)  
[Elementos de formato que tienen el mismo índice](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Controlar el formato de salida

[Controlar el formato](#controlling-formatting)  
[Controlar el espaciado](#controlling-spacing)  
[Controlar la alineación](#controlling-alignment)  
[Controlar el número de dígitos enteros](#how-do-i-control-the-number-of-integral-digits)  
[Controlar el número de dígitos después del separador decimal](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Incluido entre llaves literales en una cadena de resultado](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Asegúrese de cadenas de formato de la referencia cultural

[Formato dependiente de la referencia cultural](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Personalizar la operación de formato

[Una operación de formato personalizada](#example-a-custom-formatting-operation)  
[Un proveedor de intersección y el formateador de número romano](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Cadena de formato compuesto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Objeto al que se va a aplicar formato.</param>
        <summary>Reemplaza uno o más elementos de formato de una cadena por la representación de cadena de un objeto especificado.</summary>
        <returns>Copia de <paramref name="format" /> en la que los elementos de formato se ha reemplazado por la representación de cadena de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) para convertir el valor de una expresión en su representación de cadena e incrustar esa representación en una cadena. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Ejemplo: Aplicar formato a un solo argumento  
 
 En el ejemplo siguiente se usa el <xref:System.String.Format%28System.String%2CSystem.Object%29> método para incrustar la edad de un individuo en medio de una cadena.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">El elemento de formato de <paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato no es cero.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[Cadena de formato compuesto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Matriz de objetos que contiene cero o más objetos a los que se va a aplicar formato.</param>
        <summary>Reemplaza el elemento de formato de una cadena especificada por la representación de cadena de un objeto correspondiente de una matriz especificada.</summary>
        <returns>Copia de <paramref name="format" /> en la que los elementos de formato se han reemplazado por la representación de cadena de los objetos correspondientes de <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) para convertir el valor de cuatro o más expresiones en sus representaciones de cadena e incrustar esas representaciones en una cadena. Puesto que la `args` parámetro se marca con el <xref:System.ParamArrayAttribute?displayProperty=nameWithType> atributo, puede pasar los objetos al método como argumentos individuales o como un <xref:System.Object> matriz. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Ejemplo: Aplicar formato a más de tres argumentos  
 
 En este ejemplo se crea una cadena que contiene los datos de la temperatura alta y baja en una fecha determinada. La cadena de formato compuesto tiene cinco elementos de formato en el ejemplo de C# y seis en el ejemplo de Visual Basic. Dos de los elementos de formato definen el ancho de la representación de cadena del valor de sus correspondientes, y el primer elemento de formato también incluye una cadena de formato de hora y fecha estándar.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 También puede pasar los objetos que se va a tener el formato como una matriz en lugar de una lista de argumentos.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> o <paramref name="args" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que cero, o mayor o igual que la longitud de la matriz <paramref name="args" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <param name="format">[Cadena de formato compuesto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Objeto al que se va a aplicar formato.</param>
        <summary>Sustituye el elemento o elementos de formato en una cadena específica con la representación de cadena del objeto correspondiente. Un parámetro proporciona información de formato específica de la referencia cultural.</summary>
        <returns>Una copia de <paramref name="format" /> en la que el elemento o elementos de formato se han sustituido con la representación de cadena de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) para convertir el valor de una expresión en su representación de cadena e incrustar esa representación en una cadena. Realizar la conversión, el método utiliza un formateador personalizado o formato dependiente de la referencia cultural. El método convierte `arg0` a su representación de cadena mediante una llamada a su **ToString (IFormatProvider)** método o, si el objeto correspondiente del elemento de formato incluye una cadena de formato, mediante una llamada a su **ToString () String, IFormatProvider)** método. Si no existen estos métodos, invoca el objeto sin parámetros **ToString** método.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato no es cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <param name="format">[Cadena de formato compuesto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Matriz de objetos que contiene cero o más objetos a los que se va a aplicar formato.</param>
        <summary>Reemplaza los elementos de formato de una cadena por las representaciones de cadena de los objetos correspondientes en una matriz especificada. Un parámetro proporciona información de formato específica de la referencia cultural.</summary>
        <returns>Copia de <paramref name="format" /> en la que los elementos de formato se han reemplazado por la representación de cadena de los objetos correspondientes de <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) para convertir cuatro o más expresiones en sus representaciones de cadena e incrustar esas representaciones en una cadena. Realizar la conversión, el método utiliza un formateador personalizado o formato dependiente de la referencia cultural. El método convierte cada <xref:System.Object> argumento en su representación de cadena mediante una llamada a su **ToString (IFormatProvider)** método o, si el objeto correspondiente del elemento de formato incluye una cadena de formato, mediante una llamada a su **ToString(String,IFormatProvider)** método. Si no existen estos métodos, invoca el objeto sin parámetros **ToString** método.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Ejemplo: Formato dependiente de la referencia cultural  
 Este ejemplo se usa el <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método para mostrar la representación de cadena de algunos valores de fecha y hora y valores numéricos mediante el uso de varias referencias culturales diferentes.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> o <paramref name="args" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que cero, o mayor o igual que la longitud de la matriz <paramref name="args" />.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Cadena de formato compuesto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primer objeto al que se va a dar formato.</param>
        <param name="arg1">Segundo objeto al que se va a dar formato.</param>
        <summary>Reemplaza los elementos de formato de una cadena por la representación de cadena de dos objetos especificados.</summary>
        <returns>Copia de <paramref name="format" /> en la que los elementos de formato se ha reemplazado por las representaciones de cadena de <paramref name="arg0" /> y <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) para convertir el valor de dos expresiones en sus representaciones de cadena e incrustar esas representaciones en una cadena. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Ejemplo: Formato de dos argumentos  
 
 Este ejemplo se usa el <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> método para mostrar la temperatura y la hora de los datos almacenados en un tipo genérico <xref:System.Collections.Generic.Dictionary%602> objeto. Tenga en cuenta que la cadena de formato tiene tres elementos de formato, aunque hay solo dos objetos para dar formato. Esto es porque el primer objeto en la lista (un valor de fecha y hora) usan formato dos elementos: El primer formato elemento muestra el tiempo y el segundo muestra la fecha.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato no es cero o uno.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <param name="format">[Cadena de formato compuesto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primer objeto al que se va a dar formato.</param>
        <param name="arg1">Segundo objeto al que se va a dar formato.</param>
        <summary>Reemplaza los elementos de formato de una cadena por la representación de cadena de dos objetos especificados. Un parámetro proporciona información de formato específica de la referencia cultural.</summary>
        <returns>Copia de <paramref name="format" /> en la que los elementos de formato se ha reemplazado por las representaciones de cadena de <paramref name="arg0" /> y <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) para convertir dos expresiones en sus representaciones de cadena e incrustar esas representaciones en una cadena. Realizar la conversión, el método utiliza un formateador personalizado o formato dependiente de la referencia cultural. El método convierte cada <xref:System.Object> argumento en su representación de cadena mediante una llamada a su **ToString (IFormatProvider)** método o, si el objeto correspondiente del elemento de formato incluye una cadena de formato, mediante una llamada a su **ToString(String,IFormatProvider)** método. Si no existen estos métodos, invoca el objeto sin parámetros **ToString** método.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato no es cero o uno.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Cadena de formato compuesto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primer objeto al que se va a dar formato.</param>
        <param name="arg1">Segundo objeto al que se va a dar formato.</param>
        <param name="arg2">Tercer objeto al que se va a dar formato.</param>
        <summary>Reemplaza los elementos de formato de una cadena por la representación de cadena de tres objetos especificados.</summary>
        <returns>Copia de <paramref name="format" /> en la que los elementos de formato se ha reemplazado por las representaciones de cadena de <paramref name="arg0" />, <paramref name="arg1" /> y <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) para convertir el valor de tres expresiones en sus representaciones de cadena e incrustar esas representaciones en una cadena. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Ejemplo: Formato de tres argumentos  
 
 Este ejemplo se usa el <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para crear una cadena que se muestra el resultado de un valor booleano `And` operación con dos valores enteros. Tenga en cuenta que la cadena de formato incluye seis elementos de formato, pero el método tiene solo tres elementos en su lista de parámetros, porque cada elemento es un formato de dos maneras diferentes.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que cero o mayor que dos.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <param name="format">[Cadena de formato compuesto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primer objeto al que se va a dar formato.</param>
        <param name="arg1">Segundo objeto al que se va a dar formato.</param>
        <param name="arg2">Tercer objeto al que se va a dar formato.</param>
        <summary>Reemplaza los elementos de formato de una cadena por la representación de cadena de tres objetos especificados. Un parámetro proporciona información de formato específica de la referencia cultural.</summary>
        <returns>Copia de <paramref name="format" /> en la que los elementos de formato se ha reemplazado por las representaciones de cadena de <paramref name="arg0" />, <paramref name="arg1" /> y <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) para convertir tres expresiones en sus representaciones de cadena e incrustar esas representaciones en una cadena. Realizar la conversión, el método utiliza un formateador personalizado o formato dependiente de la referencia cultural. El método convierte cada <xref:System.Object> argumento en su representación de cadena mediante una llamada a su **ToString (IFormatProvider)** método o, si el objeto correspondiente del elemento de formato incluye una cadena de formato, mediante una llamada a su **ToString(String,IFormatProvider)** método. Si no existen estos métodos, invoca el objeto sin parámetros **ToString** método.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que cero o mayor que dos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un objeto que puede recorrer en iteración los caracteres individuales de esta cadena.</summary>
        <returns>Objeto enumerador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> En lugar de llamar a la <xref:System.String.GetEnumerator%2A> método para recuperar un <xref:System.CharEnumerator> de objeto que, a continuación, se utiliza para enumerar una cadena, en su lugar, debe usar la construcción de la iteración de su lenguaje (en C#, en C++ / c++ / CLR y en Visual Basic). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) en C#, [para cada](/cpp/dotnet/for-each-in) en C / c++ / CLR, y [para cada](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) en Visual Basic).
  
 Este método le permite recorrer en iteración los caracteres individuales de una cadena. Por ejemplo, Visual Basic `For Each` y C# `foreach` instrucciones invocan este método para devolver un <xref:System.CharEnumerator> objeto que puede proporcionar acceso de solo lectura a los caracteres de esta instancia de cadena.  
  
   
  
## Examples  
 En el ejemplo siguiente se recorre en iteración los caracteres en varias cadenas y muestra información acerca de sus caracteres individuales. Utiliza la construcción de lenguaje de iteración, en lugar de una llamada a la <xref:System.String.GetEnumerator%2A> método.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash para esta cadena.</summary>
        <returns>Código hash de un entero de 32 bits con signo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de <xref:System.String.GetHashCode%2A> depende de su implementación, que puede cambiar de una versión de common language runtime a otro. Una razón que esto ocurra es mejorar el rendimiento de <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Si dos objetos de cadena son iguales, la <xref:System.String.GetHashCode%2A> método devuelve valores idénticos. Sin embargo, no hay un valor de código hash único para cada valor de cadena único. Cadenas diferentes pueden devolver el mismo código hash.  
>   
>  El propio código hash no se garantiza que sean estables. Los códigos hash para cadenas idénticas pueden diferir en las implementaciones de. NET, en las versiones de .NET y entre plataformas .NET (por ejemplo, 32 bits y 64 bits) para una única versión de .NET. En algunos casos, incluso pueden diferir por dominio de aplicación. Esto implica que los dos ejecuciones posteriores del mismo programa pueden devolver distintos códigos hash.  
>   
>  Como resultado, hash códigos nunca deben utilizarse fuera del dominio de aplicación en el que se crearon, nunca deben usarse como campos de clave en una colección y nunca debe persistir.  
>   
>  Por último, no use el código hash en lugar de un valor devuelto por una función hash criptográfica si necesita un hash criptográficamente sólidos. Para algoritmos hash criptográficos, use una clase derivada de la <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> o <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> clase.  
>   
>  Para obtener más información sobre los códigos hash, vea <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 En las aplicaciones de escritorio, puede usar el [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) para generar códigos hash únicos en una por cada dominio de aplicación. Esto puede reducir el número de colisiones y mejorar el rendimiento general de las inserciones y búsquedas que usan las tablas hash. El ejemplo siguiente muestra cómo usar el [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Define un `DisplayString` clase que incluya una constante de cadena privada, `s`, cuyo valor es "Es una cadena". También incluye un método `ShowStringHashCode` que presenta el valor de cadena y su código hash junto con el nombre del dominio de aplicación en el que se ejecuta el método.
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Cuando ejecute el ejemplo sin proporcionar un archivo de configuración, mostrará un resultado similar al siguiente. Observe que los códigos hash de la cadena son idénticos en los dos dominios de aplicación.  
  
```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```  
  
 Sin embargo, si agrega el archivo de configuración siguiente al directorio de ejemplo y, a continuación, ejecuta el ejemplo, los códigos hash para la misma cadena diferirán en función del dominio de aplicación.  
  
```xml
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>
```  
  
 Cuando el archivo de configuración está presente, el ejemplo muestra el siguiente resultado:  
  
```  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```  
  
> [!IMPORTANT]
>  Los códigos hash se utilizan para insertar y recuperar objetos con clave de las tablas hash de manera eficiente. Sin embargo, los códigos hash no identifican las cadenas. Las cadenas idénticas tienen códigos hash iguales, pero common language runtime también puede asignar el mismo código hash para cadenas diferentes. Además, los códigos hash pueden variar según la versión de. NET, plataforma dentro de una única versión y por dominio de aplicación. Por este motivo, no debe serializar ni conservar los valores de código hash, ni debe usarlas como claves en una tabla hash o un diccionario.  
  
 Para obtener más información sobre el uso de códigos hash y el `GetHashCode` método, consulte <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.GetHashCode%2A> método utilizando varias cadenas de entrada.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>El valor devuelto por <see cref="M:System.String.GetHashCode" /> depende de la plataforma. Es diferente en las versiones de 32 bits y 64 bits de .NET Framework. También puede diferir entre las versiones de .NET Framework y .NET Core.</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; elemento</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la interfaz <see cref="T:System.TypeCode" /> para la clase <see cref="T:System.String" />.</summary>
        <returns>Constante enumerada, <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.TypeCode> constante enumerada para el <xref:System.String> tipo.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica el índice de base cero de la primera aparición de un carácter Unicode especificado o de una cadena en la instancia en cuestión. El método devuelve -1, si el carácter o cadena no se encuentran en esta instancia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Carácter Unicode que se va a buscar.</param>
        <summary>Devuelve el índice de base cero de la primera aparición del carácter Unicode especificado en esta cadena.</summary>
        <returns>Devuelve la posición de índice de base cero de <paramref name="value" /> si se encuentra dicho carácter; de lo contrario, devuelve -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo se puede buscar un <xref:System.String> para un carácter mediante la <xref:System.String.IndexOf%2A> método.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <summary>Indica el índice de base cero de la primera aparición de la cadena especificada en la instancia en cuestión.</summary>
        <returns>Devuelve la posición de índice de base cero de <paramref name="value" /> si se encuentra dicha cadena; de lo contrario, devuelve -1. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero.  
  
 Este método realiza una búsqueda de palabras (distingue mayúsculas de minúsculas y la referencia cultural) utilizando la referencia cultural actual. La búsqueda comienza en la posición del primer carácter de esta instancia y continúa hasta la última posición de carácter.  
  
 Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural, si `value` contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si `value` consta solo de uno o varios caracteres puede pasar por alto el <xref:System.String.IndexOf%28System.String%29> método siempre devuelve 0 (cero) para indicar que se encuentra la coincidencia al principio de la instancia actual. En el ejemplo siguiente, la <xref:System.String.IndexOf%28System.String%29> método se utiliza para buscar tres subcadenas (un guion (00AD), un guion seguido de "n" y un guion seguido de "m") de dos cadenas. Solo una de las cadenas contiene un guion virtual. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, en cada caso, dado que el guion virtual es un carácter ignorable, el resultado es el mismo como si no se incluía en el guion `value`. Cuando se busca un guion solo, el método devuelve 0 (cero) para indicar que ha encontrado a una coincidencia al principio de la cadena.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 El ejemplo siguiente se busca "n" en "animal". Dado que los índices de cadena comienzan en cero en lugar de a, el <xref:System.String.IndexOf%28System.String%29> método indica que es la "n" en la posición 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 En el ejemplo siguiente se usa el <xref:System.String.IndexOf%2A> método para determinar la posición inicial de un nombre de animal en una oración. A continuación, se usa esta posición para insertar un adjetivo que describe el animal en la frase.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de comparación de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para encontrar el primer índice de una subcadena dentro de una instancia de cadena mediante el uso de las reglas de comparación de la referencia cultural actual, llame a la <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> sobrecarga del método con un valor de <see cref="F:System.StringComparison.CurrentCulture" /> para su `comparisonType` parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carácter Unicode que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda.</param>
        <summary>Devuelve el índice de base cero de la primera aparición del carácter Unicode especificado en esta cadena. La búsqueda comienza en una posición de carácter especificada.</summary>
        <returns>Posición de índice de base cero de <paramref name="value" /> desde el principio de la cadena si se encuentra ese carácter, o -1 en caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza en 0. El parámetro `startIndex` puede estar comprendido entre 0 y la longitud de la instancia de cadena. Si `startIndex` es igual a la longitud de la instancia de cadena, el método devuelve -1.  
  
 La búsqueda comienza en `startIndex` al final de la cadena.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.IndexOf%2A> método.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> es menor que 0 (cero) o mayor que la longitud de la cadena.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Carácter que se va a buscar.</param>
        <param name="comparisonType">Valor de enumeración que especifica las reglas de la búsqueda.</param>
        <summary>Devuelve el índice de base cero de la primera aparición del carácter Unicode especificado en esta cadena. Un parámetro especifica el tipo de búsqueda que se va a usar para el carácter especificado.</summary>
        <returns>Devuelve el índice de base cero de <paramref name="value" /> si se encuentra dicho carácter; de lo contrario, devuelve -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Índice de la numeración empieza desde cero.  
  
El `comparisonType` parámetro es un <xref:System.StringComparison> miembro de enumeración que especifica si la búsqueda de la `value` argumento usa la referencia cultural actual o invariable, es distingue mayúsculas de minúsculas o mayúsculas y minúsculas o usa la palabra o las reglas de comparación de ordinales.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda.</param>
        <summary>Indica el índice de base cero de la primera aparición de la cadena especificada en la instancia en cuestión. La búsqueda comienza en una posición de carácter especificada.</summary>
        <returns>Posición de índice de base cero de <paramref name="value" /> desde el principio de la instancia actual si se encuentra esa cadena o, de lo contrario, -1. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza en 0. El parámetro `startIndex` puede estar comprendido entre 0 y la longitud de la instancia de cadena. Si `startIndex` es igual a la longitud de la instancia de cadena, el método devuelve -1.  
  
 Este método realiza una búsqueda de palabras (distingue mayúsculas de minúsculas y la referencia cultural) utilizando la referencia cultural actual. La búsqueda comienza en la `startIndex` posición de esta instancia de carácter y continúa hasta la última posición de carácter.  
  
 Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural, si `value` contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si `value` consta solo de uno o varios caracteres puede pasar por alto el <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> método siempre devuelve `startIndex`, que es la posición del carácter donde comienza la búsqueda. En el ejemplo siguiente, la <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> método se utiliza para buscar la posición de un guion (00AD) seguida por una "m" en dos cadenas. Solo una de las cadenas contiene la subcadena necesaria. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, en ambos casos, dado que el guion virtual es un carácter ignorable, el método devuelve el índice de "m" en la cadena. Observe que en el caso de la primera cadena, que incluye el guion virtual seguido de una "m", el método no devuelve el índice del guion virtual, sino el índice de "m".  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 El ejemplo siguiente se busca en todas las apariciones de una cadena especificada dentro de una cadena de destino.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> es menor que 0 (cero) o mayor que la longitud de esta instancia.</exception>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de comparación de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para encontrar el primer índice de una subcadena que se produce después de una posición de caracteres determinada mediante el uso de las reglas de comparación de la referencia cultural actual, llame a la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> sobrecarga del método con un valor de <see cref="F:System.StringComparison.CurrentCulture" /> para su `comparisonType` parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica las reglas de la búsqueda.</param>
        <summary>Devuelve el índice de base cero de la primera aparición de la cadena especificada en el objeto <see cref="T:System.String" /> actual. Un parámetro especifica el tipo de búsqueda que se va a usar para la cadena especificada.</summary>
        <returns>Posición de índice del parámetro <paramref name="value" /> si se encuentra la cadena; de lo contrario, -1. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero.  
  
 El `comparisonType` especifica el parámetro para buscar el `value` parámetro usando la referencia cultural actual o invariable, mediante una búsqueda de mayúsculas y minúsculas o mayúsculas y minúsculas y con word o con reglas de comparación de ordinales.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres sobrecargas de los <xref:System.String.IndexOf%2A> método que busque la primera aparición de una cadena dentro de otra cadena utilizando diferentes valores de la <xref:System.StringComparison> enumeración.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural (es decir, si <paramref name="comparisonType" /> no es <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si <paramref name="value" /> consta solo de uno o varios caracteres puede pasar por alto el <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> método siempre devuelve 0 (cero) para indicar que se encuentra la coincidencia al principio de la instancia actual.  
  
En el ejemplo siguiente, la <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> método se utiliza para buscar tres subcadenas (un guion (00AD), un guion seguido de "n" y un guion seguido de "m") de dos cadenas. Solo una de las cadenas contiene un guion virtual. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versiones posteriores, ya que el guion virtual es un carácter ignorable, una búsqueda de la referencia cultural devuelve el mismo valor que devolvería si el guion no se incluyeron en la cadena de búsqueda. Una búsqueda ordinal, sin embargo, busca el guion en una cadena y notifica que está presente correctamente desde la segunda cadena.  
  
[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carácter Unicode que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda.</param>
        <param name="count">Número de posiciones de caracteres que se van a examinar.</param>
        <summary>Devuelve el índice de base en cero de la primera aparición del carácter especificado en la instancia en cuestión. La búsqueda comienza en una posición de carácter especificada y examina un número especificado de posiciones de caracteres.</summary>
        <returns>Posición de índice de base cero de <paramref name="value" /> desde el principio de la cadena si se encuentra ese carácter, o -1 en caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda comienza en `startIndex` y continúa `startIndex`  +  `count` -1. El carácter que ocupa `startIndex`  +  `count` no se incluye en la búsqueda.  
  
 Índice de la numeración empieza en 0 (cero). El parámetro `startIndex` puede estar comprendido entre 0 y la longitud de la instancia de cadena.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.IndexOf%2A> método.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> o <paramref name="startIndex" /> es negativo.  
  
O bien 
 <paramref name="startIndex" /> es mayor que la longitud de esta cadena.  
  
O bien 
 <paramref name="count" /> es mayor que la longitud de esta cadena menos <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda.</param>
        <param name="count">Número de posiciones de caracteres que se van a examinar.</param>
        <summary>Indica el índice de base cero de la primera aparición de la cadena especificada en la instancia en cuestión. La búsqueda comienza en una posición de carácter especificada y examina un número especificado de posiciones de caracteres.</summary>
        <returns>Posición de índice de base cero de <paramref name="value" /> desde el principio de la instancia actual si se encuentra esa cadena o, de lo contrario, -1. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza en 0 (cero). El parámetro `startIndex` puede estar comprendido entre 0 y la longitud de la instancia de cadena.  
  
 Este método realiza una búsqueda de palabras (distingue mayúsculas de minúsculas y la referencia cultural) utilizando la referencia cultural actual. La búsqueda comienza en `startIndex` y continúa `startIndex`  +  `count` -1. El carácter que ocupa `startIndex`  +  `count` no se incluye en la búsqueda.  
  
 Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural, si `value` contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si `value` consta solo de uno o varios caracteres puede pasar por alto el <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> método siempre devuelve `startIndex`, que es la posición del carácter donde comienza la búsqueda. En el ejemplo siguiente, la <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> método se utiliza para buscar la posición de un guion (00AD) seguida por una "m" a partir de la tercera y la sexta posición de carácter de dos cadenas. Solo una de las cadenas contiene la subcadena necesaria. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, en ambos casos, dado que el guion virtual es un carácter ignorable, el método devuelve el índice de "m" en la cadena cuando realiza una comparación dependiente de la referencia cultural. Observe que en el caso de la primera cadena, que incluye el guion virtual seguido de una "m", el método no devuelve el índice del guion virtual, sino el índice de "m".  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 El ejemplo siguiente busca el índice de todas las apariciones de la cadena "ho" en una subcadena de otra cadena. Tenga en cuenta que se debe volver a calcular el número de caracteres que se debe buscar para cada iteración de la búsqueda.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> o <paramref name="startIndex" /> es negativo.  
  
O bien 
 <paramref name="startIndex" /> es mayor que la longitud de esta cadena.  
  
O bien 
 <paramref name="count" /> es mayor que la longitud de esta cadena menos <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de comparación de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para usar las reglas de comparación de la referencia cultural actual para realizar esta operación, llame a la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> sobrecarga del método con un valor de <see cref="F:System.StringComparison.CurrentCulture" /> para su `comparisonType` parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica las reglas de la búsqueda.</param>
        <summary>Devuelve el índice de base cero de la primera aparición de la cadena especificada en el objeto <see cref="T:System.String" /> actual. Los parámetros indican la posición inicial de búsqueda en la cadena actual y el tipo de búsqueda que se usa para la cadena especificada.</summary>
        <returns>Posición de índice de base cero del parámetro <paramref name="value" /> desde el principio de la instancia actual si se encuentra esa cadena o, de lo contrario, -1. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza en 0. El parámetro `startIndex` puede estar comprendido entre 0 y la longitud de la instancia de cadena. Si `startIndex` es igual a la longitud de la instancia de cadena, el método devuelve -1.  
  
 El `comparisonType` especifica el parámetro para buscar el `value` parámetro usando la referencia cultural actual o invariable, mediante una búsqueda de mayúsculas y minúsculas o mayúsculas y minúsculas y con word o con reglas de comparación de ordinales.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres sobrecargas de los <xref:System.String.IndexOf%2A> método que busque la primera aparición de una cadena dentro de otra cadena utilizando diferentes valores de la <xref:System.StringComparison> enumeración.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> es menor que 0 (cero) o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural (es decir, si <paramref name="comparisonType" /> no es <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si <paramref name="value" /> consta solo de uno o varios caracteres puede pasar por alto el <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> método siempre devuelve <paramref name="startIndex" />, que es la posición del carácter donde comienza la búsqueda.  
  
En el ejemplo siguiente, la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> método se utiliza para buscar la posición de un guion (00AD) seguida por una "m" a partir de la tercera posición de carácter de dos cadenas. Solo una de las cadenas contiene la subcadena necesaria. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, en ambos casos, dado que el guion virtual es un carácter ignorable, el método devuelve el índice de "m" en la cadena cuando realiza una comparación dependiente de la referencia cultural. Observe que en el caso de la primera cadena, que incluye el guion virtual seguido de una "m", el método no devuelve el índice del guion virtual, sino el índice de "m". El método devuelve el índice del guion virtual de la primera cadena solo cuando realiza una comparación ordinal.  
  
[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda.</param>
        <param name="count">Número de posiciones de caracteres que se van a examinar.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica las reglas de la búsqueda.</param>
        <summary>Devuelve el índice de base cero de la primera aparición de la cadena especificada en el objeto <see cref="T:System.String" /> actual. Los parámetros indican la posición inicial de búsqueda en la cadena actual, el número de caracteres de la cadena actual en los que buscar y el tipo de búsqueda que se va a usar para la cadena especificada.</summary>
        <returns>Posición de índice de base cero del parámetro <paramref name="value" /> desde el principio de la instancia actual si se encuentra esa cadena o, de lo contrario, -1. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza en 0 (cero). El parámetro `startIndex` puede estar comprendido entre 0 y la longitud de la instancia de cadena.  
  
 La búsqueda comienza en `startIndex` y continúa `startIndex`  +  `count` -1. El carácter que ocupa `startIndex`  +  `count` no se incluye en la búsqueda.  
  
 El `comparisonType` especifica el parámetro para buscar el `value` parámetro usando la referencia cultural actual o invariable, mediante una búsqueda de mayúsculas y minúsculas o mayúsculas y minúsculas y con word o con reglas de comparación de ordinales.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres sobrecargas de los <xref:System.String.IndexOf%2A> método que busque la primera aparición de una cadena dentro de otra cadena utilizando diferentes valores de la <xref:System.StringComparison> enumeración.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> o <paramref name="startIndex" /> es negativo.  
  
O bien 
 <paramref name="startIndex" /> es mayor que la longitud de esta instancia.  
  
O bien 
 <paramref name="count" /> es mayor que la longitud de esta cadena menos <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural (es decir, si <paramref name="comparisonType" /> no es <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si <paramref name="value" /> consta solo de uno o varios caracteres puede pasar por alto el <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método siempre devuelve <paramref name="startIndex" />, que es la posición del carácter donde comienza la búsqueda.  
  
En el ejemplo siguiente, la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método se utiliza para buscar la posición de un guion (00AD) seguida por una "m" a partir de la tercera y la sexta posición de carácter de dos cadenas. Solo una de las cadenas contiene la subcadena necesaria. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, en ambos casos, dado que el guion virtual es un carácter ignorable, el método devuelve el índice de "m" en la cadena cuando realiza una comparación dependiente de la referencia cultural. Cuando realiza una comparación ordinal, sin embargo, busca la subcadena solo en la primera cadena. Tenga en cuenta que en el caso de la primera cadena, que incluye el guion seguido de una "m", el método no devuelve el índice del guion, pero en su lugar, devuelve el índice de la "m" cuando realiza una comparación dependiente de la referencia cultural. El método devuelve el índice del guion virtual de la primera cadena solo cuando realiza una comparación ordinal.  
  
[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el índice de la primera aparición en la instancia de un carácter de una matriz de caracteres Unicode especificada. El método devuelve -1 si los caracteres de la matriz no se encuentran en esta instancia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matriz de caracteres Unicode que contiene uno o más caracteres que se van a buscar.</param>
        <summary>Devuelve el índice de base cero de la primera aparición en la instancia de un carácter de una matriz de caracteres Unicode especificada.</summary>
        <returns>Posición de índice de base cero de la primera aparición en la instancia en cuestión donde se encontró cualquier carácter de <paramref name="anyOf" />; -1 si no se encontró ningún carácter de <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero.  
  
 La búsqueda de `anyOf` distingue mayúsculas de minúsculas. Si `anyOf` es una matriz vacía, la encuentra método una coincidencia al principio de la cadena (es decir, en el índice cero).  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente busca la primera vocal en una cadena.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matriz de caracteres Unicode que contiene uno o más caracteres que se van a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda.</param>
        <summary>Devuelve el índice de base cero de la primera aparición en la instancia de un carácter de una matriz de caracteres Unicode especificada. La búsqueda comienza en una posición de carácter especificada.</summary>
        <returns>Posición de índice de base cero de la primera aparición en la instancia en cuestión donde se encontró cualquier carácter de <paramref name="anyOf" />; -1 si no se encontró ningún carácter de <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. El `startIndex` parámetro puede oscilar entre 0 y uno menos que la longitud de la instancia de cadena.  
  
 La búsqueda comienza en `startIndex` al final de la cadena.  
  
 La búsqueda de `anyOf` distingue mayúsculas de minúsculas.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente se busca el índice de la aparición de cualquier carácter de la cadena "es" dentro de una subcadena de otra cadena.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> es negativo.  
  
O bien 
 <paramref name="startIndex" /> es mayor que el número de caracteres de esta instancia.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matriz de caracteres Unicode que contiene uno o más caracteres que se van a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda.</param>
        <param name="count">Número de posiciones de caracteres que se van a examinar.</param>
        <summary>Devuelve el índice de base cero de la primera aparición en la instancia de un carácter de una matriz de caracteres Unicode especificada. La búsqueda comienza en una posición de carácter especificada y examina un número especificado de posiciones de caracteres.</summary>
        <returns>Posición de índice de base cero de la primera aparición en la instancia en cuestión donde se encontró cualquier carácter de <paramref name="anyOf" />; -1 si no se encontró ningún carácter de <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La búsqueda comienza en `startIndex` y continúa `startIndex`  +  `count` -1. El carácter que ocupa `startIndex`  +  `count` no se incluye en la búsqueda.  
  
 Índice de la numeración empieza desde cero. El `startIndex` parámetro puede oscilar entre 0 y uno menos que la longitud de la instancia de cadena.  
  
 La búsqueda de `anyOf` distingue mayúsculas de minúsculas.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente busca el índice de la aparición de cualquier carácter de la cadena "Ayuda" en una subcadena de otra cadena.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> o <paramref name="startIndex" /> es negativo.  
  
O bien 
 <paramref name="count" /> + <paramref name="startIndex" /> es mayor que el número de caracteres de esta instancia.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Índice de posición de base cero de la inserción.</param>
        <param name="value">Cadena que se va a insertar.</param>
        <summary>Devuelve una nueva cadena en la que se inserta una cadena especificada en una posición de índice concreta en esta instancia.</summary>
        <returns>Nueva cadena que es equivalente a la instancia en cuestión, pero con <paramref name="value" /> insertado en la posición <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `startIndex` es igual que la longitud de esta instancia, `value` se anexa al final de esta instancia.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en la que `value` se inserta en la instancia actual.  
  
 Por ejemplo, el valor devuelto de `"abc".Insert(2, "XYZ")` es "abXYZc".  
  
   
  
## Examples  
 El ejemplo siguiente inserta un carácter de espacio en la cuarta posición de carácter (el carácter en el índice 3) de una cadena.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 La siguiente aplicación de consola, pide a los usuarios que escriba adjetivos uno o más para describir dos de los animales. A continuación, llama el <xref:System.String.Insert%2A> método para insertar el texto escrito por el usuario en una cadena.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> es negativo o mayor que la longitud de esta instancia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Cadena que se va a buscar en el grupo de internos.</param>
        <summary>Recupera la referencia del sistema al objeto <see cref="T:System.String" /> especificado.</summary>
        <returns>Referencia del sistema a <paramref name="str" /> si se le ha aplicado el método Intern; de lo contrario, una nueva referencia a una cadena con el valor de <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Common language runtime conserva el almacenamiento de cadenas mediante el mantenimiento de una tabla, denominada el grupo de internos, que contiene una referencia única a cada cadena literal única, declarada o creada mediante programación en el programa. Por lo tanto, existe una instancia de una cadena literal con un valor determinado solo una vez en el sistema.  
  
 Por ejemplo, si asigna la misma cadena literal a varias variables, el tiempo de ejecución recupera la misma referencia a la cadena literal desde el grupo de internos y lo asigna a cada variable.  
  
 El <xref:System.String.Intern%2A> método usa el grupo de internos para buscar una cadena igual que el valor de `str`. Si no existe este tipo de cadena, se devuelve su referencia en el grupo de internos. Si la cadena no existe, una referencia a `str` se agrega para el grupo de internos, a continuación, se devuelven esa referencia.  
  
 En el ejemplo siguiente, la cadena s1, que tiene un valor de "MyTest", ya se esté internado porque es un literal en el programa. La <xref:System.Text.StringBuilder?displayProperty=nameWithType> clase genera un nuevo objeto de cadena que tiene el mismo valor que s1. Una referencia a esa cadena se asigna a s2. El <xref:System.String.Intern%2A> método busca una cadena que tiene el mismo valor que s2. Dado que este tipo de cadena existe, el método devuelve la misma referencia que está asignada a s1. Esta referencia, a continuación, se asigna a s3. Las referencias s1 y s2 son iguales porque hacen referencia a objetos diferentes; las referencias s1 y s3 son iguales porque hacen referencia a la misma cadena.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Compare este método con el <xref:System.String.IsInterned%2A> método.  
  
## <a name="version-considerations"></a>Consideraciones sobre la versión  
 En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], el <xref:System.String.Intern%2A> método revierte a su comportamiento en .NET Framework 1.0 y 1.1 con respecto a la cadena vacía. En el ejemplo siguiente, la variable `str1` se asigna una referencia a <xref:System.String.Empty>y la variable `str2` se asigna a la referencia a <xref:System.String.Empty> devuelto por una llamada a la <xref:System.String.Intern%2A> método después de convertir un <xref:System.Text.StringBuilder>objeto cuyo valor es <xref:System.String.Empty> en una cadena. A continuación, las referencias contenidas en `str1` y `str2` se compara la igualdad.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 En el [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], y [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` y `str2` son iguales. En el [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] y [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` y `str2` no son iguales.  
  
## <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 Si intenta reducir la cantidad total de memoria asigna la aplicación, tenga en cuenta que el método Intern a una cadena tiene dos efectos secundarios no deseados. En primer lugar, la memoria asignada para Intern <xref:System.String> objetos no es probable que se libere hasta que finaliza el common language runtime (CLR). El motivo es que la referencia de CLR para el método Intern <xref:System.String> object puede persistir después de la aplicación, o incluso el dominio de aplicación, finaliza. En segundo lugar, para intern una cadena, primero debe crear la cadena. La memoria utilizada por el <xref:System.String> objeto todavía se debe asignar, aunque la memoria será finalmente recolectado.  
  
 .NET Framework versión 2.0 presenta la <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> miembro de enumeración. El <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> miembro marca un ensamblado que no es necesario ser un literal de cadena interno. Puede aplicar <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> a un ensamblado mediante el <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> atributo. Además, cuando usa el [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) para compilar un ensamblado antes de tiempo de ejecución, las cadenas no aplica el método Intern a través de módulos.  
  
   
  
## Examples  
 El ejemplo siguiente utiliza tres cadenas que tienen el mismo valor para determinar si una cadena recién creada y una cadena de método Intern son iguales.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Cadena que se va a buscar en el grupo de internos.</param>
        <summary>Recupera una referencia a un objeto <see cref="T:System.String" /> especificado.</summary>
        <returns>Una referencia a <paramref name="str" /> si está en el grupo de internos de Common Language Runtime; de lo contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Common language runtime mantiene automáticamente una tabla, denominada el grupo de internos, que contiene una sola instancia de cada constante de cadena literal única, declarada en un programa, así como cualquier instancia única de <xref:System.String> agregar mediante programación llamando el <xref:System.String.Intern%2A> método.  
  
 El grupo de internos conserva el almacenamiento de la cadena. Si asigna una constante de cadena literal a varias variables, cada variable se establece para hacer referencia a la misma constante en el grupo de internos en lugar de hacer referencia a varias instancias diferentes de <xref:System.String> que tienen valores idénticos.  
  
 Este método busca un `str` en el grupo de internos. Si `str` ya ha sido Intern, es una referencia a la instancia devuelta; de lo contrario, `null` se devuelve.  
  
 Compare este método con el <xref:System.String.Intern%2A> método.  
  
 Este método no devuelve un valor booleano. Si llama al método porque desea que un valor booleano que indica si una cadena concreta se aplica el método Intern, puede usar código como el siguiente.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  A partir de la versión 2.0 de .NET Framework, puede reemplazar el uso del grupo de internos cuando se usa el [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) para instalar un ensamblado en la caché de imágenes nativas en un equipo local. Para obtener más información, consulte las consideraciones de rendimiento en la sección Comentarios para el <xref:System.String.Intern%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra que las cadenas literales se aplica el método Intern automáticamente por el compilador.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si esta cadena tiene una forma de normalización Unicode determinada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica si esta cadena tiene la forma de normalización Unicode C.</summary>
        <returns><see langword="true" /> si esta cadena tiene la forma de normalización C; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos caracteres Unicode tienen múltiples representaciones binarias equivalentes que consta de conjuntos de combinación o caracteres Unicode compuestos. La existencia de varias representaciones de un único carácter complica la búsqueda, ordenación, coincidencia y otras operaciones.  
  
 El estándar Unicode define un proceso denominado normalización, que devuelve una representación binaria cuando se da cualquiera de las representaciones binarias equivalentes de un carácter. Normalización puede realizarse con varios algoritmos, denominados formas de normalización, que siguen reglas diferentes. .NET admite actualmente las formas de normalización C, D, KC y KD.  
  
 Para obtener una descripción de formas de normalización Unicode compatibles, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo siguiente determina si una cadena se normaliza correctamente en diversas formas de normalización.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La instancia actual contiene caracteres Unicode no válidos.</exception>
        <block subset="none" type="usage"><para>El <see cref="Overload:System.String.IsNormalized" /> devuelve del método <see langword="false" /> tan pronto como encuentra el primer carácter no normalizado en una cadena. Por lo tanto, si una cadena contiene caracteres no normalizado seguidos de caracteres Unicode no válidos, el <see cref="Overload:System.String.Normalize" /> método producirá una <see cref="T:System.ArgumentException" /> aunque <see cref="Overload:System.String.IsNormalized" /> devuelve <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Forma de normalización Unicode.</param>
        <summary>Indica si esta cadena tiene la forma de normalización Unicode especificada.</summary>
        <returns><see langword="true" /> si esta cadena tiene la forma de normalización especificada por el parámetro <paramref name="normalizationForm" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos caracteres Unicode tienen múltiples representaciones binarias equivalentes que consta de conjuntos de combinación o caracteres Unicode compuestos. La existencia de varias representaciones de un único carácter complica la búsqueda, ordenación, coincidencia y otras operaciones.  
  
 El estándar Unicode define un proceso denominado normalización, que devuelve una representación binaria cuando se da cualquiera de las representaciones binarias equivalentes de un carácter. Normalización puede realizarse con varios algoritmos, denominados formas de normalización, que siguen reglas diferentes. .NET admite actualmente las formas de normalización C, D, KC y KD.  
  
 Para obtener una descripción de formas de normalización Unicode compatibles, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.IsNormalized%2A> y <xref:System.String.Normalize%2A> métodos.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La instancia actual contiene caracteres Unicode no válidos.</exception>
        <block subset="none" type="usage"><para>El <see cref="Overload:System.String.IsNormalized" /> devuelve del método <see langword="false" /> tan pronto como encuentra el primer carácter no normalizado en una cadena. Por lo tanto, si una cadena contiene caracteres no normalizado seguidos de caracteres Unicode no válidos, el <see cref="Overload:System.String.Normalize" /> método producirá una <see cref="T:System.ArgumentException" /> aunque <see cref="Overload:System.String.IsNormalized" /> devuelve <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comprobar.</param>
        <summary>Indica si el valor de la cadena especificada es <see langword="null" /> o una cadena vacía ("").</summary>
        <returns><see langword="true" /> si el parámetro <paramref name="value" /> es <see langword="null" /> o una cadena vacía (""); en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> es un método de conveniencia que le permite probar simultáneamente si un <xref:System.String> es `null` o su valor es <xref:System.String.Empty?displayProperty=nameWithType>. Es equivalente al código siguiente:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Puede usar el <xref:System.String.IsNullOrWhiteSpace%2A> método para comprobar si una cadena es `null`, su valor es <xref:System.String.Empty?displayProperty=nameWithType>, o consta únicamente de caracteres de espacio en blanco.  
  
## <a name="what-is-a-null-string"></a>¿Qué es una cadena null?

Una cadena es `null` si no se ha asignado un valor (en C++ y Visual Basic) o si explícitamente se ha asignado un valor de `null`. Aunque el [formatos compuestos](~/docs/standard/base-types/composite-formatting.md) característica puede controlar correctamente una cadena nula, como muestra el siguiente ejemplo, al intentar llamar a uno si sus miembros produce un <xref:System.NullReferenceException>.  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>¿Qué es una cadena vacía?  

Una cadena está vacía si se asigna explícitamente una cadena vacía ("") o <xref:System.String.Empty?displayProperty=nameWithType>. Una cadena vacía tiene un <xref:System.String.Length%2A> de 0.  En el ejemplo siguiente se crea una cadena vacía y se muestra su valor y su longitud.  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 En el ejemplo siguiente se examinan las tres cadenas y determina si cada cadena tiene un valor, es una cadena vacía o es `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comprobar.</param>
        <summary>Indica si la cadena especificada es <see langword="null" />, está vacía o consta únicamente de caracteres de espacio en blanco.</summary>
        <returns>Es <see langword="true" /> si el parámetro <paramref name="value" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />, o bien si <paramref name="value" /> consta únicamente de caracteres de espacio en blanco.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> es un método de conveniencia que es similar al siguiente código, salvo que ofrece un rendimiento superior:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Caracteres de espacio en blanco se definen en el estándar Unicode. El <xref:System.String.IsNullOrWhiteSpace%2A> método interpreta cualquier carácter que se devuelve un valor de `true` cuando se pasa a la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método como un carácter de espacio en blanco.  
  
   
  
## Examples  
 El ejemplo siguiente se crea una matriz de cadenas y, a continuación, pasa cada elemento de la matriz a la <xref:System.String.IsNullOrWhiteSpace%2A> método.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena los elementos de la matriz especificada o los miembros de una colección, usando el separador indicado entre todos los elementos o miembros.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Cadena que se va a usar como separador.<paramref name="separator" /> se incluye en la cadena devuelta solo si <paramref name="values" /> tiene más de un elemento.</param>
        <param name="values">Colección que contiene las cadenas que se van a concatenar.</param>
        <summary>Concatena los miembros de una colección <see cref="T:System.Collections.Generic.IEnumerable`1" /> construida de tipo <see cref="T:System.String" />, usando el separador especificado entre todos los miembros.</summary>
        <returns>Cadena que consta de los miembros de <paramref name="values" /> delimitados por la cadena de <paramref name="separator" />. Si <paramref name="values" /> no tiene ningún miembro, el método devuelve <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `separator` es `null`, una cadena vacía (<xref:System.String.Empty?displayProperty=nameWithType>) se usa en su lugar. Si cualquier miembro de `values` es `null`, una cadena vacía se usa en su lugar.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> es un método de conveniencia que le permite concatenar cada elemento de un `IEnumerable(Of String)` colección sin convertir primero los elementos en una matriz de cadenas. Es especialmente útil con expresiones de consulta de Language-Integrated Query (LINQ). En el ejemplo siguiente se pasa un `List(Of String)` objeto que contiene las letras mayúsculas o minúsculas del alfabeto a una expresión lambda que selecciona las letras que sean igual o mayor que una letra determinada (que, en el ejemplo, es "M"). El `IEnumerable(Of String)` colección devuelta por la <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método se pasa a la <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método para mostrar el resultado como una sola cadena.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el algoritmo criba de Eratóstenes para calcular los números primos que son menores o iguales que 100. Asigna el resultado a un <xref:System.Collections.Generic.List%601> objeto de tipo <xref:System.String>, que, a continuación, pasa a la <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Cadena que se va a usar como separador. <paramref name="separator" /> se incluye en la cadena devuelta solo si <paramref name="values" /> tiene más de un elemento.</param>
        <param name="values">Matriz que contiene los elementos que se van a concatenar.</param>
        <summary>Concatena los elementos de una matriz de objetos, usando el separador especificado entre todos los elementos.</summary>
        <returns>Cadena que consta de los elementos de <paramref name="values" /> delimitados por la cadena de <paramref name="separator" />. Si <paramref name="values" /> es una matriz vacía, el método devuelve <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `separator` es `null` o si algún elemento de `values` no sea el primer elemento es `null`, una cadena vacía (<xref:System.String.Empty?displayProperty=nameWithType>) se usa en su lugar. Consulte la sección Notas a los autores de llamadas si el primer elemento de `values` es `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> es un método de conveniencia que le permite concatenar cada elemento en una matriz de objetos sin convertir explícitamente sus elementos en cadenas. La representación de cadena de cada objeto de la matriz se deriva mediante una llamada a ese objeto `ToString` método.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el algoritmo criba de Eratóstenes para calcular los números primos que son menores o iguales que 100. Asigna el resultado a una matriz de enteros, que, a continuación, pasa a la <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> método.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Si el primer elemento de <paramref name="values" /> es <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> método no concatenar los elementos de <paramref name="values" /> , sino que devuelve <see cref="F:System.String.Empty" />. Existen varias soluciones para resolver este problema. La más fácil es asignar un valor de <see cref="F:System.String.Empty" /> al primer elemento de la matriz, como en el ejemplo siguiente se muestra.  
  
[!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Cadena que se va a usar como separador. <paramref name="separator" /> se incluye en la cadena devuelta solo si <paramref name="value" /> tiene más de un elemento.</param>
        <param name="value">Matriz que contiene los elementos que se van a concatenar.</param>
        <summary>Concatena todos los elementos de una matriz de cadenas, usando el separador especificado entre todos los elementos.</summary>
        <returns>Cadena que consta de los elementos de <paramref name="value" /> delimitados por la cadena de <paramref name="separator" />. Si <paramref name="value" /> es una matriz vacía, el método devuelve <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por ejemplo, si `separator` es "," y los elementos de `value` son "manzana", "orange", "uva" y "pera", `Join(separator, value)` devuelve "manzana, naranja, uva, pera".  
  
 Si `separator` es `null`, una cadena vacía (<xref:System.String.Empty?displayProperty=nameWithType>) se usa en su lugar. Si algún elemento `value` es `null`, una cadena vacía se usa en su lugar.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.Join%2A> método.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Cadena que se va a usar como separador. <paramref name="separator" /> se incluye en la cadena devuelta solo si <paramref name="value" /> tiene más de un elemento.</param>
        <param name="value">Matriz que contiene los elementos que se van a concatenar.</param>
        <param name="startIndex">Primer elemento de <paramref name="value" /> que se va a usar.</param>
        <param name="count">Número de elementos de <paramref name="value" /> que se van a usar.</param>
        <summary>Concatena los elementos especificados de una matriz de cadenas, usando el separador indicado entre todos los elementos.</summary>
        <returns>Cadena que consta de las cadenas de <paramref name="value" /> delimitadas por la cadena de <paramref name="separator" />.  
  
O bien 
 <see cref="F:System.String.Empty" /> si el valor de <paramref name="count" /> es cero, <paramref name="value" /> no tiene elementos, o <paramref name="separator" /> y todos los elementos de <paramref name="value" /> tienen el valor <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por ejemplo, si `separator` es "," y los elementos de `value` son "manzana", "orange", "uva" y "pera", `Join(separator, value, 1, 2)` devuelve "naranja, uva".  
  
 Si `separator` es `null`, una cadena vacía (<xref:System.String.Empty?displayProperty=nameWithType>) se usa en su lugar. Si algún elemento `value` es `null`, una cadena vacía se usa en su lugar.  
  
   
  
## Examples  
 En el ejemplo siguiente se concatena dos elementos de una matriz de nombres de fruta.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> o <paramref name="count" /> es menor que 0.  
  
O bien 
 <paramref name="startIndex" /> más <paramref name="count" /> es mayor que el número de elementos de <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insuficiente</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los miembros de <paramref name="values" />.</typeparam>
        <param name="separator">Cadena que se va a usar como separador.<paramref name="separator" /> se incluye en la cadena devuelta solo si <paramref name="values" /> tiene más de un elemento.</param>
        <param name="values">Colección que contiene los objetos que se van a concatenar.</param>
        <summary>Concatena los miembros de una colección, usando el separador especificado entre todos los miembros.</summary>
        <returns>Cadena que consta de los miembros de <paramref name="values" /> delimitados por la cadena de <paramref name="separator" />. Si <paramref name="values" /> no tiene ningún miembro, el método devuelve <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `separator` es `null`, una cadena vacía (<xref:System.String.Empty?displayProperty=nameWithType>) se usa en su lugar. Si cualquier miembro de `values` es `null`, una cadena vacía se usa en su lugar.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> es un método de conveniencia que le permite concatenar cada miembro de un <xref:System.Collections.Generic.IEnumerable%601> colección sin convertirlos antes a cadenas. La representación de cadena de cada objeto en el <xref:System.Collections.Generic.IEnumerable%601> se derivó la colección mediante una llamada a ese objeto `ToString` método.  
  
 Este método es especialmente útil con expresiones de consulta de Language-Integrated Query (LINQ). Por ejemplo, el código siguiente define un método muy sencillo `Animal` clase que contiene el nombre de un animal y el orden al que pertenece. A continuación, define un <xref:System.Collections.Generic.List%601> objeto que contiene un número de `Animal` objetos. El <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> se denomina método de extensión para extraer el `Animal` objetos cuya propiedad `Order` propiedad es igual a "Roedor". El resultado se pasa a la <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el algoritmo criba de Eratóstenes para calcular los números primos que son menores o iguales que 100. Asigna el resultado a un <xref:System.Collections.Generic.List%601> objeto de tipo entero, que, a continuación, pasa a la <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica la posición de índice de base cero de la última aparición de un carácter Unicode especificado o de una cadena en la instancia en cuestión. El método devuelve -1, si el carácter o cadena no se encuentran en esta instancia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Carácter Unicode que se va a buscar.</param>
        <summary>Devuelve la posición de índice de base cero de la última aparición de un carácter Unicode especificado en la instancia.</summary>
        <returns>Devuelve la posición de índice de base cero de <paramref name="value" /> si se encuentra dicho carácter; de lo contrario, devuelve -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. Es decir, es el primer carácter de la cadena en el índice cero y el último está en <xref:System.String.Length%2A> - 1.  
  
 Este método comienza a buscar en la última posición de carácter de esta instancia y continúa hacia atrás hacia el principio hasta que `value` se encuentra o se examina la posición del primer carácter. La búsqueda distingue mayúsculas de minúsculas.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `ExtractFilename` método que usa el <xref:System.String.LastIndexOf%28System.Char%29> método para buscar el último carácter de separador de directorio en una cadena y extraer el nombre del archivo de la cadena. Si el archivo existe, el método devuelve el nombre de archivo sin su ruta de acceso.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <summary>Indica la posición de índice de base cero de la última aparición de una cadena especificada en la instancia en cuestión.</summary>
        <returns>Devuelve la posición de índice inicial de base cero de <paramref name="value" /> si se encuentra dicha cadena; de lo contrario, devuelve -1. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es la última posición de índice en esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. Es decir, es el primer carácter de la cadena en el índice cero y el último está en <xref:System.String.Length%2A> - 1.  
  
 La búsqueda comienza en la última posición de carácter de esta instancia y continúa hacia atrás hacia el principio hasta que `value` se encuentra o se examina la posición del primer carácter.  
  
 Este método realiza una búsqueda de palabras (distingue mayúsculas de minúsculas y la referencia cultural) utilizando la referencia cultural actual.  
  
 Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural, si `value` contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si `value` consta solo de uno o varios caracteres puede pasar por alto el <xref:System.String.LastIndexOf%28System.String%29> método siempre devuelve <xref:System.String.Length%2A?displayProperty=nameWithType> -1, que representa la última posición de índice en la instancia actual. En el ejemplo siguiente, la <xref:System.String.LastIndexOf%28System.String%29> método se utiliza para buscar tres subcadenas (un guion (00AD), un guion seguido de "n" y un guion seguido de "m") de dos cadenas. Solo una de las cadenas contiene un guion virtual. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, en cada caso, dado que el guion virtual es un carácter ignorable, el resultado es el mismo como si no se incluía en el guion `value`. Cuando se busca un guion solo, el método devuelve 6 y 5. Estos valores se corresponden con el índice del último carácter de las dos cadenas.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 En el ejemplo siguiente se quita de apertura y cierre de las etiquetas HTML una cadena si las etiquetas se inicia y el final de la cadena. Si una cadena termina con un cierre caracteres corchete angular de cierre (">"), el ejemplo se usa el <xref:System.String.LastIndexOf%2A> método para buscar el inicio de la etiqueta de cierre.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de comparación de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para encontrar el último índice de una subcadena dentro de una instancia de cadena mediante el uso de las reglas de comparación de la referencia cultural actual, llame a la <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> sobrecarga del método con un valor de <see cref="F:System.StringComparison.CurrentCulture" /> para su <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carácter Unicode que se va a buscar.</param>
        <param name="startIndex">Posición inicial de la búsqueda. La búsqueda continúa desde <paramref name="startIndex" /> hacia el principio de esta instancia.</param>
        <summary>Devuelve la posición de índice de base cero de la última aparición de un carácter Unicode especificado en la instancia. La búsqueda se inicia en una posición de carácter especificada y continúa hacia atrás hacia el principio de la cadena.</summary>
        <returns>Posición del índice de base cero de <paramref name="value" />, si se encuentra ese carácter, o -1 si no se encuentra o si la instancia actual es igual que <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. Es decir, es el primer carácter de la cadena en el índice cero y el último está en <xref:System.String.Length%2A> -1. este método comienza a buscar en la `startIndex` posición de esta instancia y continúa hacia atrás hacia el principio de la instancia actual hasta que de carácter `value` se encuentra o se examina la posición del primer carácter. Por ejemplo, si `startIndex` es <xref:System.String.Length%2A> - 1, el método busca todos los caracteres desde el último carácter de la cadena hasta el principio. La búsqueda distingue mayúsculas de minúsculas.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente busca el índice de todas las apariciones de un carácter en una cadena, desde el final de la cadena hasta el principio de la cadena.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es menor que cero o mayor o igual que la longitud de esta instancia.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda. La búsqueda continúa desde <paramref name="startIndex" /> hacia el principio de esta instancia.</param>
        <summary>Indica la posición de índice de base cero de la última aparición de una cadena especificada en la instancia en cuestión. La búsqueda se inicia en una posición de carácter especificada y continúa hacia atrás hacia el principio de la cadena.</summary>
        <returns>Posición del índice de inicio de base cero de <paramref name="value" />, si se encuentra esa cadena, o -1 si no se encuentra o si la instancia actual es igual que <see cref="F:System.String.Empty" />. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es el menor de <paramref name="startIndex" /> y la última posición de índice de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. Es decir, es el primer carácter de la cadena en el índice cero y el último está en <xref:System.String.Length%2A> - 1.  
  
 La búsqueda comienza en el `startIndex` posición de esta instancia y continúa hacia atrás hacia el principio hasta que ya sea de carácter `value` se encuentra o se examina la posición del primer carácter. Por ejemplo, si `startIndex` es <xref:System.String.Length%2A> - 1, el método busca todos los caracteres desde el último carácter de la cadena hasta el principio.  
  
 Este método realiza una búsqueda de palabras (distingue mayúsculas de minúsculas y la referencia cultural) utilizando la referencia cultural actual.  
  
 Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural, si `value` contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si `value` consta solo de uno o varios caracteres puede pasar por alto el <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> método siempre devuelve `startIndex`, que es la posición del carácter donde comienza la búsqueda. En el ejemplo siguiente, la <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> método se utiliza para buscar una subcadena que incluye un guion (00AD) y que precede o que incluya la "m" final en una cadena. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, ya que se pasa por alto el guion en la cadena de búsqueda, llamando al método para buscar una subcadena que consta del guion y "m" devuelve la posición de la "m" en la cadena, mientras que llamarlo para buscar un substrin g que consta del guion y "n" devuelve la posición de las "n". Cuando la cadena de búsqueda contiene sólo el guion, el método devuelve el índice de la letra "m", que representa el valor de `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 El ejemplo siguiente busca el índice de todas las apariciones de una cadena de la cadena de destino, desde el final de la cadena de destino al principio de la cadena de destino.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es menor que cero o mayor que la longitud de la instancia actual.  
  
O bien 
La instancia actual es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es menor que -1 o mayor que cero.</exception>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de comparación de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para encontrar el índice de una subcadena que precede a una posición de caracteres determinada mediante el uso de las reglas de comparación de la referencia cultural actual, llame a la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> sobrecarga del método con un valor de <see cref="F:System.StringComparison.CurrentCulture" /> para su <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica las reglas de la búsqueda.</param>
        <summary>Devuelve el índice de base cero de la última aparición de una cadena especificada dentro del objeto <see cref="T:System.String" /> actual. Un parámetro especifica el tipo de búsqueda que se va a usar para la cadena especificada.</summary>
        <returns>Devuelve la posición de índice inicial de base cero del parámetro <paramref name="value" /> si se encuentra dicha cadena; de lo contrario, devuelve -1. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es la última posición de índice en esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. Es decir, es el primer carácter de la cadena en el índice cero y el último está en <xref:System.String.Length%2A> - 1.  
  
 El `comparisonType` especifica el parámetro para buscar el `value` parámetro usando la referencia cultural actual o invariable, mediante una búsqueda de mayúsculas y minúsculas o mayúsculas y minúsculas y con word o con reglas de comparación de ordinales.  
  
 La búsqueda comienza en la última posición de carácter de esta instancia y continúa hacia atrás hacia el principio hasta que `value` se encuentra o se examina la posición del primer carácter.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres sobrecargas de los <xref:System.String.LastIndexOf%2A> método que buscar la última aparición de una cadena dentro de otra cadena utilizando diferentes valores de la <xref:System.StringComparison> enumeración.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural (es decir, si <paramref name="options" /> no es <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si <paramref name="value" /> consta solo de uno o varios caracteres puede pasar por alto el <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> método siempre devuelve <see cref="P:System.String.Length" /> -1, que representa la última posición de índice en la instancia actual.  
  
En el ejemplo siguiente, la <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> método se utiliza para buscar tres subcadenas (un guion (00AD), un guion seguido de "n" y un guion seguido de "m") de dos cadenas. Solo una de las cadenas contiene un guion virtual. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versiones posteriores, ya que el guion virtual es un carácter ignorable, una búsqueda de la referencia cultural devuelve el mismo valor que devolvería si el guion no se incluyeron en la cadena de búsqueda. Una búsqueda ordinal, sin embargo, busca el guion en una cadena y notifica que está presente correctamente desde la segunda cadena.  
  
[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carácter Unicode que se va a buscar.</param>
        <param name="startIndex">Posición inicial de la búsqueda. La búsqueda continúa desde <paramref name="startIndex" /> hacia el principio de esta instancia.</param>
        <param name="count">Número de posiciones de caracteres que se van a examinar.</param>
        <summary>Devuelve la posición de índice de base cero de la última aparición del carácter Unicode especificado en una subcadena de la instancia. La búsqueda se inicia en una posición de caracteres especificada y continúa hacia atrás hacia el principio de la cadena durante un número especificado de posiciones de caracteres.</summary>
        <returns>Posición del índice de base cero de <paramref name="value" />, si se encuentra ese carácter, o -1 si no se encuentra o si la instancia actual es igual que <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. Es decir, es el primer carácter de la cadena en el índice cero y el último está en <xref:System.String.Length%2A> - 1.  
  
 Este método comienza a buscar en el `startIndex` caracteres posición y continúa hacia atrás hacia el principio de esta instancia hasta que `value` se encuentra o `count` se examinan las posiciones de caracteres. Por ejemplo, si `startIndex` es <xref:System.String.Length%2A> - 1, el método realiza búsquedas hacia atrás `count` caracteres desde el último carácter en la cadena. La búsqueda distingue mayúsculas de minúsculas.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente busca el índice de todas las apariciones de un carácter en una subcadena, desde el final de la subcadena al principio de la subcadena.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es menor que cero o mayor o igual que la longitud de esta instancia.  
  
O bien 
La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> - <paramref name="count" /> + 1 es inferior a cero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda. La búsqueda continúa desde <paramref name="startIndex" /> hacia el principio de esta instancia.</param>
        <param name="count">Número de posiciones de caracteres que se van a examinar.</param>
        <summary>Indica la posición de índice de base cero de la última aparición de una cadena especificada en la instancia en cuestión. La búsqueda se inicia en una posición de caracteres especificada y continúa hacia atrás hacia el principio de la cadena durante un número especificado de posiciones de caracteres.</summary>
        <returns>Posición del índice de inicio de base cero de <paramref name="value" />, si se encuentra esa cadena, o -1 si no se encuentra o si la instancia actual es igual que <see cref="F:System.String.Empty" />. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es el menor de <paramref name="startIndex" /> y la última posición de índice de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. Es decir, es el primer carácter de la cadena en el índice cero y el último está en <xref:System.String.Length%2A> - 1.  
  
 La búsqueda comienza en el `startIndex` posición de esta instancia y continúa hacia atrás hacia el principio hasta que ya sea de carácter `value` se encuentra o `count` se examinan las posiciones de caracteres. Por ejemplo, si `startIndex` es <xref:System.String.Length%2A> - 1, el método realiza búsquedas hacia atrás `count` caracteres desde el último carácter en la cadena.  
  
 Este método realiza una búsqueda de palabras (distingue mayúsculas de minúsculas y la referencia cultural) utilizando la referencia cultural actual.  
  
 Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural, si `value` contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si `value` consta solo de uno o varios caracteres puede pasar por alto el <xref:System.String.LastIndexOf%2A> método siempre devuelve `startIndex`, que es la posición del carácter donde comienza la búsqueda. En el ejemplo siguiente, la <xref:System.String.LastIndexOf%2A> método se utiliza para buscar la posición de un guion (00AD) en los dos caracteres que preceden a la última "m" de dos cadenas. Solo una de las cadenas contiene la subcadena necesaria. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, en ambos casos, dado que el guion virtual es un carácter ignorable, el método devuelve el índice de "m" en la cadena cuando realiza una comparación dependiente de la referencia cultural. Observe que en el caso de la primera cadena, que incluye el guion virtual seguido de una "m", el método no devuelve el índice del guion virtual, sino el índice de "m".  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 El ejemplo siguiente busca el índice de todas las apariciones de una cadena en una subcadena, desde el final de la subcadena al principio de la subcadena.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es negativo.  
  
O bien 
La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es negativo.  
  
O bien 
La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es mayor que la longitud de esta instancia.  
  
O bien 
La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> - <paramref name="count" />+ 1 especifica una posición que no se encuentra dentro de esta instancia.  
  
O bien 
La instancia actual es igual a <see cref="F:System.String.Empty" /> y <paramref name="start" /> es menor que -1 o mayor que cero.  
  
O bien 
La instancia actual es igual a <see cref="F:System.String.Empty" /> y <paramref name="count" /> es mayor que 1.</exception>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de comparación de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para realizar esta operación mediante el uso de las reglas de comparación de la referencia cultural actual, llame a la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> sobrecarga del método con un valor de <see cref="F:System.StringComparison.CurrentCulture" /> para su <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda. La búsqueda continúa desde <paramref name="startIndex" /> hacia el principio de esta instancia.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica las reglas de la búsqueda.</param>
        <summary>Devuelve el índice de base cero de la última aparición de una cadena especificada dentro del objeto <see cref="T:System.String" /> actual. La búsqueda se inicia en una posición de carácter especificada y continúa hacia atrás hacia el principio de la cadena. Un parámetro especifica el tipo de comparación que se debe realizar cuando se busca la cadena especificada.</summary>
        <returns>Posición del índice de inicio de base cero del parámetro <paramref name="value" />, si se encuentra esa cadena, o -1 si no se encuentra o si la instancia actual es igual que <see cref="F:System.String.Empty" />. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es el menor de <paramref name="startIndex" /> y la última posición de índice de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. Es decir, es el primer carácter de la cadena en el índice cero y el último está en <xref:System.String.Length%2A> - 1.  
  
 La búsqueda comienza en el `startIndex` caracteres posición y continúa hacia atrás hasta que `value` se encuentra o se examina la posición del primer carácter. Por ejemplo, si `startIndex` es <xref:System.String.Length%2A> - 1, el método busca todos los caracteres desde el último carácter de la cadena hasta el principio.  
  
 El `comparisonType` especifica el parámetro para buscar el `value` parámetro usando la referencia cultural actual o invariable, mediante una búsqueda de mayúsculas y minúsculas o mayúsculas y minúsculas y con word o con reglas de comparación de ordinales.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres sobrecargas de los <xref:System.String.LastIndexOf%2A> método que buscar la última aparición de una cadena dentro de otra cadena utilizando diferentes valores de la <xref:System.StringComparison> enumeración.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es menor que cero o mayor que la longitud de la instancia actual.  
  
O bien 
La instancia actual es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es menor que -1 o mayor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural (es decir, si <paramref name="comparisonType" /> no es <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si <paramref name="value" /> consta solo de uno o varios caracteres puede pasar por alto el <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> método siempre devuelve <paramref name="startIndex" />, que es la posición del carácter donde comienza la búsqueda.  
  
En el ejemplo siguiente, la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> método se utiliza para buscar la posición de un guion (00AD) seguida por una "m", empezando por el final de la "m" en dos cadenas. Solo una de las cadenas contiene la subcadena necesaria. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, en ambos casos, dado que el guion virtual es un carácter ignorable, el método devuelve el índice de "m" en la cadena cuando realiza una comparación dependiente de la referencia cultural. Observe que en el caso de la primera cadena, que incluye el guion virtual seguido de una "m", el método no devuelve el índice del guion virtual, sino el índice de "m". El método devuelve el índice del guion virtual de la primera cadena solo cuando realiza una comparación ordinal.  
  
[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda. La búsqueda continúa desde <paramref name="startIndex" /> hacia el principio de esta instancia.</param>
        <param name="count">Número de posiciones de caracteres que se van a examinar.</param>
        <param name="comparisonType">Uno de los valores de enumeración que especifica las reglas de la búsqueda.</param>
        <summary>Indica la posición de índice de base cero de la última aparición de una cadena especificada en la instancia en cuestión. La búsqueda se inicia en una posición de caracteres especificada y continúa hacia atrás hacia el principio de la cadena durante el número especificado de posiciones de caracteres. Un parámetro especifica el tipo de comparación que se debe realizar cuando se busca la cadena especificada.</summary>
        <returns>Posición del índice de inicio de base cero del parámetro <paramref name="value" />, si se encuentra esa cadena, o -1 si no se encuentra o si la instancia actual es igual que <see cref="F:System.String.Empty" />. Si <paramref name="value" /> es <see cref="F:System.String.Empty" />, el valor devuelto es el menor de <paramref name="startIndex" /> y la última posición de índice de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero. Es decir, es el primer carácter de la cadena en el índice cero y el último está en <xref:System.String.Length%2A> - 1.  
  
 La búsqueda comienza en el `startIndex` caracteres posición y continúa hacia atrás hasta que `value` se encuentra o `count` se examinan las posiciones de caracteres. Por ejemplo, si `startIndex` es <xref:System.String.Length%2A> - 1, el método realiza búsquedas hacia atrás `count` caracteres desde el último carácter en la cadena.  
  
 El `comparisonType` especifica el parámetro para buscar el `value` parámetro usando la referencia cultural actual o invariable, mediante una búsqueda de mayúsculas y minúsculas o mayúsculas y minúsculas y con word o con reglas de comparación de ordinales.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres sobrecargas de los <xref:System.String.LastIndexOf%2A> método que buscar la última aparición de una cadena dentro de otra cadena utilizando diferentes valores de la <xref:System.StringComparison> enumeración.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es negativo.  
  
O bien 
La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es negativo.  
  
O bien 
La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> es mayor que la longitud de esta instancia.  
  
O bien 
La instancia actual no es igual a <see cref="F:System.String.Empty" />, y <paramref name="startIndex" /> + 1 - <paramref name="count" /> especifica una posición que no se encuentra dentro de esta instancia.  
  
O bien 
La instancia actual es igual a <see cref="F:System.String.Empty" /> y <paramref name="start" /> es menor que -1 o mayor que cero.  
  
O bien 
La instancia actual es igual a <see cref="F:System.String.Empty" /> y <paramref name="count" /> es mayor que 1.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Los juegos de caracteres incluyen caracteres que se pueden pasar por alto, que son los caracteres que no se tienen en cuenta al realizar una comparación lingüística o en la que se tiene en cuenta la referencia cultural. En una búsqueda que tiene en cuenta la referencia cultural (es decir, si <paramref name="comparisonType" /> no es <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contiene un carácter que se puede pasar por alto, el resultado es equivalente a buscar sin ese carácter. Si <paramref name="value" /> consta solo de uno o varios caracteres puede pasar por alto el <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método siempre devuelve <paramref name="startIndex" />, que es la posición del carácter donde comienza la búsqueda.  
  
En el ejemplo siguiente, la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método se utiliza para buscar la posición de un guion (00AD) seguido por una "m" en todas, pero la posición del primer carácter antes de la última "m" en dos cadenas. Solo una de las cadenas contiene la subcadena necesaria. Si el ejemplo se ejecuta en el [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o posterior, en ambos casos, dado que el guion virtual es un carácter ignorable, el método devuelve el índice de "m" en la cadena cuando realiza una comparación dependiente de la referencia cultural. Cuando realiza una comparación ordinal, sin embargo, busca la subcadena solo en la primera cadena. Tenga en cuenta que en el caso de la primera cadena, que incluye el guion seguido de una "m", el método no devuelve el índice del guion, pero en su lugar, devuelve el índice de la "m" cuando realiza una comparación dependiente de la referencia cultural. El método devuelve el índice del guion virtual de la primera cadena solo cuando realiza una comparación ordinal.  
  
[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve la posición de índice de base cero de la última aparición en la instancia de uno o varios caracteres especificados de una matriz de caracteres Unicode. El método devuelve -1 si los caracteres de la matriz no se encuentran en esta instancia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matriz de caracteres Unicode que contiene uno o más caracteres que se van a buscar.</param>
        <summary>Devuelve la posición de índice de base cero de la última aparición en la instancia de uno o varios caracteres especificados de una matriz de caracteres Unicode.</summary>
        <returns>Posición de índice de la última aparición en la instancia en cuestión donde se encontró cualquier carácter de <paramref name="anyOf" />; -1 si no se encontró ningún carácter de <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero.  
  
 Este método comienza a buscar en la última posición de carácter de esta instancia y continúa hacia atrás hacia el principio hasta que un carácter de `anyOf` se encuentra o se examina la posición del primer carácter. La búsqueda distingue mayúsculas de minúsculas.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente se busca el índice de la última aparición de cualquier carácter de la cadena "es" dentro de otra cadena.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matriz de caracteres Unicode que contiene uno o más caracteres que se van a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda. La búsqueda continúa desde <paramref name="startIndex" /> hacia el principio de esta instancia.</param>
        <summary>Devuelve la posición de índice de base cero de la última aparición en la instancia de uno o varios caracteres especificados de una matriz de caracteres Unicode. La búsqueda se inicia en una posición de carácter especificada y continúa hacia atrás hacia el principio de la cadena.</summary>
        <returns>Posición de índice de la última aparición en esta instancia donde se encontraron caracteres en <paramref name="anyOf" />; -1 si no se encontraron caracteres en <paramref name="anyOf" /> o si la instancia actual es igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero.  
  
 Este método comienza a buscar en el `startIndex` posición de esta instancia y continúa hacia atrás hacia el principio hasta que un carácter de carácter `anyOf` se encuentra o se examina la posición del primer carácter. La búsqueda distingue mayúsculas de minúsculas.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente se busca el índice de la última aparición de cualquier carácter de la cadena "es" dentro de una subcadena de otra cadena.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> especifica una posición que no se encuentra dentro de esta instancia.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matriz de caracteres Unicode que contiene uno o más caracteres que se van a buscar.</param>
        <param name="startIndex">Posición en la que comienza la búsqueda. La búsqueda continúa desde <paramref name="startIndex" /> hacia el principio de esta instancia.</param>
        <param name="count">Número de posiciones de caracteres que se van a examinar.</param>
        <summary>Devuelve la posición de índice de base cero de la última aparición en la instancia de uno o varios caracteres especificados de una matriz de caracteres Unicode. La búsqueda se inicia en una posición de caracteres especificada y continúa hacia atrás hacia el principio de la cadena durante un número especificado de posiciones de caracteres.</summary>
        <returns>Posición de índice de la última aparición en esta instancia donde se encontraron caracteres en <paramref name="anyOf" />; -1 si no se encontraron caracteres en <paramref name="anyOf" /> o si la instancia actual es igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de la numeración empieza desde cero.  
  
 Este método comienza a buscar en el `startIndex` posición de esta instancia y continúa hacia atrás hacia el principio hasta que un carácter de carácter `anyOf` se encuentra o `count` se examinan las posiciones de caracteres. La búsqueda distingue mayúsculas de minúsculas.  
  
 Este método realiza una búsqueda ordinal (sin tener en cuenta la referencia cultural), donde un carácter se considera equivalente a otro carácter solo si los valores escalares Unicode son iguales. Para realizar una búsqueda de referencias culturales, utilice el <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> método, donde un valor escalar Unicode que representa un carácter compuesto, como la ligadura "Æ" U + 00 C 6, es posible que se considera equivalente a cualquier aparición de los componentes del carácter en el Corrija la secuencia, como "AE" (u+0041, u+0045), en función de la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente busca el índice de la última aparición de cualquier carácter de la cadena "Ayuda" en una subcadena de otra cadena.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="count" /> o <paramref name="startIndex" /> es negativo.  
  
O bien 
La instancia actual no es igual a <see cref="F:System.String.Empty" /> y <paramref name="startIndex" /> menos <paramref name="count" /> + 1 es inferior a cero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de caracteres del objeto <see cref="T:System.String" /> actual.</summary>
        <value>Número de caracteres de la cadena actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.Length%2A> propiedad devuelve el número de <xref:System.Char> objetos en esta instancia, no el número de caracteres Unicode. El motivo es que se puede representar un carácter Unicode por más de un <xref:System.Char>. Use la <xref:System.Globalization.StringInfo?displayProperty=nameWithType> clase para trabajar con cada carácter Unicode en lugar de cada uno <xref:System.Char>.  
  
 En algunos lenguajes, como C y C++, un carácter null indica el final de una cadena. En. NET, se puede incrustar un carácter nulo en una cadena. Cuando una cadena incluye uno o varios caracteres nulos, se incluyen en la longitud de la cadena completa. Por ejemplo, en la siguiente cadena, las subcadenas "abc" y "def" están separados por un carácter nulo. El <xref:System.String.Length%2A> propiedad devuelve 7, lo que indica que incluye los seis caracteres alfabéticos, así como el carácter nulo.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.Length%2A> propiedad.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una nueva cadena cuya representación binaria tiene una forma de normalización Unicode determinada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una nueva cadena cuyo valor textual es igual que esta cadena, pero cuya representación binaria tiene la forma de normalización Unicode C.</summary>
        <returns>Una nueva cadena normalizada cuyo valor textual es igual que esta cadena, pero cuya representación binaria tiene la forma de normalización C.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos caracteres Unicode tienen múltiples representaciones binarias equivalentes que consta de conjuntos de combinación o caracteres Unicode compuestos. Por ejemplo, cualquiera de los puntos de código siguiente puede representar la letra "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 La existencia de varias representaciones de un único carácter complica la búsqueda, ordenación, coincidencia y otras operaciones.  
  
 El estándar Unicode define un proceso denominado normalización, que devuelve una representación binaria cuando se da cualquiera de las representaciones binarias equivalentes de un carácter. Normalización puede realizarse con varios algoritmos, denominados formas de normalización, que siguen reglas diferentes. .NET admite cuatro formas de normalización (C, D, KC y KD) que se definen en el estándar Unicode. Si dos cadenas se representan en la misma forma de normalización, pueden compararse por medio de una comparación ordinal.  
  
 Para normalizar y comparar dos cadenas, realice lo siguiente:  
  
1.  Obtener las cadenas que se comparará desde un origen de entrada, como un archivo o un dispositivo de entrada de usuario.  
  
2.  Llame a la <xref:System.String.Normalize> método para normalizar las cadenas a la forma de normalización C.  
  
3.  Para comparar dos cadenas, llamar a un método que admita la comparación de cadenas ordinales, como el <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método y proporcione un valor de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> como el <xref:System.StringComparison> argumento. Para ordenar una matriz de cadenas normalizadas, pasar un `comparer` valor <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> o <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> a una sobrecarga adecuada del <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emita las cadenas en la salida ordenada según el orden indicado por el paso anterior.  
  
 Para obtener una descripción de formas de normalización Unicode compatibles, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo siguiente se normaliza una cadena a cada uno de cuatro formas de normalización, confirma que la cadena se normaliza a la forma de normalización especificada, a continuación, enumera los puntos de código en la cadena normalizada.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La instancia actual contiene caracteres Unicode no válidos.</exception>
        <block subset="none" type="usage"><para>El <see cref="Overload:System.String.IsNormalized" /> devuelve del método <see langword="false" /> tan pronto como encuentra el primer carácter no normalizado en una cadena. Por lo tanto, si una cadena contiene caracteres no normalizado seguidos de caracteres Unicode no válidos, el <see cref="Overload:System.String.Normalize" /> método producirá una <see cref="T:System.ArgumentException" /> aunque <see cref="Overload:System.String.IsNormalized" /> devuelve <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Forma de normalización Unicode.</param>
        <summary>Devuelve una nueva cadena cuyo valor textual es igual que esta cadena, pero cuya representación binaria tiene la forma de normalización Unicode especificada.</summary>
        <returns>Una nueva cadena cuyo valor textual es igual que esta cadena, pero cuya representación binaria tiene la forma de normalización especificada por el parámetro <paramref name="normalizationForm" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos caracteres Unicode tienen múltiples representaciones binarias equivalentes que consta de conjuntos de combinación o caracteres Unicode compuestos. La existencia de varias representaciones de un único carácter complica la búsqueda, ordenación, coincidencia y otras operaciones.  
  
 El estándar Unicode define un proceso denominado normalización, que devuelve una representación binaria cuando se da cualquiera de las representaciones binarias equivalentes de un carácter. Normalización puede realizarse con varios algoritmos, denominados formas de normalización, que siguen reglas diferentes. .NET admite cuatro formas de normalización (C, D, KC y KD) que se definen en el estándar Unicode. Si dos cadenas se representan en la misma forma de normalización, pueden compararse por medio de una comparación ordinal.  
  
 Para normalizar y comparar dos cadenas, realice lo siguiente:  
  
1.  Obtener las cadenas que se comparará desde un origen de entrada, como un archivo o un dispositivo de entrada de usuario.  
  
2.  Llame a la <xref:System.String.Normalize%28System.Text.NormalizationForm%29> método para normalizar las cadenas de una forma de normalización especificada.  
  
3.  Para comparar dos cadenas, llamar a un método que admita la comparación de cadenas ordinales, como el <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método y proporcione un valor de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> como el <xref:System.StringComparison> argumento. Para ordenar una matriz de cadenas normalizadas, pasar un `comparer` valor <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> o <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> a una sobrecarga adecuada del <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emita las cadenas en la salida ordenada según el orden indicado por el paso anterior.  
  
 Para obtener una descripción de formas de normalización Unicode compatibles, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo siguiente se normaliza una cadena a cada uno de cuatro formas de normalización, confirma que la cadena se normaliza a la forma de normalización especificada, a continuación, enumera los puntos de código en la cadena normalizada.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La instancia actual contiene caracteres Unicode no válidos.</exception>
        <block subset="none" type="usage"><para>El <see cref="Overload:System.String.IsNormalized" /> devuelve del método <see langword="false" /> tan pronto como encuentra el primer carácter no normalizado en una cadena. Por lo tanto, si una cadena contiene caracteres no normalizado seguidos de caracteres Unicode no válidos, el <see cref="Overload:System.String.Normalize" /> método puede producir un <see cref="T:System.ArgumentException" /> aunque <see cref="Overload:System.String.IsNormalized" /> devuelve <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Primera cadena que se va a comparar, o <see langword="null" />.</param>
        <param name="b">Segunda cadena que se va a comparar, o <see langword="null" />.</param>
        <summary>Determina si dos cadenas especificadas tienen el mismo valor.</summary>
        <returns><see langword="true" /> si el valor de <paramref name="a" /> es el mismo que el valor de <paramref name="b" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.op_Equality%2A> método define la operación del operador de igualdad para los <xref:System.String> clase. Permite código como se muestra en la sección ejemplo. El operador, a su vez, llama a estático <xref:System.String.Equals%28System.String%2CSystem.String%29> método, que realiza una comparación ordinal (distingue mayúsculas de minúsculas y cuenta la referencia cultural).  
  
> [!NOTE]
>  El compilador de Visual Basic no resuelve el operador de igualdad como una llamada a la <xref:System.String.op_Equality%2A> método. En su lugar, el operador de igualdad ajusta una llamada a la <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el operador de igualdad.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Primera cadena que se va a comparar, o <see langword="null" />.</param>
        <param name="b">Segunda cadena que se va a comparar, o <see langword="null" />.</param>
        <summary>Determina si dos cadenas especificadas tienen valores diferentes.</summary>
        <returns><see langword="true" /> si el valor de <paramref name="a" /> es diferente que el valor de <paramref name="b" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.op_Inequality%2A> método define la operación del operador de desigualdad para los <xref:System.String> clase.   Permite código como se muestra en la sección ejemplos.  
  
 El <xref:System.String.op_Inequality%2A> operador a su vez llama a estático <xref:System.String.Equals%28System.String%2CSystem.String%29> método, que realiza una comparación ordinal (distingue mayúsculas de minúsculas y cuenta la referencia cultural).  
  
> [!NOTE]
>  El compilador de Visual Basic no resuelve el operador de desigualdad como una llamada a la <xref:System.String.op_Inequality%2A> método. En su lugar, el operador de desigualdad ajusta una llamada a la <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el operador de desigualdad.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una nueva cadena de una longitud especificada en la que el principio de la cadena actual se rellena con espacios o con un carácter Unicode especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Número de caracteres de la cadena resultante, igual al número de caracteres originales más el número de caracteres de relleno adicionales.</param>
        <summary>Devuelve una nueva cadena que alinea a la derecha los caracteres de la instancia e inserta espacios en blanco a la izquierda hasta alcanzar la longitud total especificada.</summary>
        <returns>Nueva cadena que es equivalente a esta instancia, pero que se alinea a la derecha y en la que se insertan a la izquierda los espacios que sean necesarios para crear la longitud especificada por el parámetro <paramref name="totalWidth" />. Sin embargo, si <paramref name="totalWidth" /> es menor que la longitud de esta instancia, el método devuelve una referencia a la instancia existente. Si <paramref name="totalWidth" /> es igual que la longitud de esta instancia, el método devuelve una nueva cadena que es idéntica a esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un espacio de Unicode se define como hexadecimal 0 x 0020.  
  
 El <xref:System.String.PadLeft%28System.Int32%29> método rellena el principio de la cadena devuelta. Esto significa que, cuando se usa con idiomas de derecha a izquierda, rellena la parte derecha de la cadena.  
  
> [!NOTE]
>  Si el <xref:System.String.PadLeft%2A> método rellena la instancia actual con espacios en blanco, este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena que se rellena con espacios en blanco iniciales para que su longitud total `totalWidth` caracteres.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.PadLeft%2A> método.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> es menor que cero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Número de caracteres de la cadena resultante, igual al número de caracteres originales más el número de caracteres de relleno adicionales.</param>
        <param name="paddingChar">Carácter Unicode de relleno.</param>
        <summary>Devuelve una nueva cadena que alinea a la derecha los caracteres de la instancia e inserta a la izquierda un carácter Unicode especificado hasta alcanzar la longitud total especificada.</summary>
        <returns>Nueva cadena que es equivalente a esta instancia, pero que se alinea a la derecha y en la que se insertan a la izquierda los caracteres de <paramref name="paddingChar" /> que sean necesarios para crear la longitud especificada por el parámetro <paramref name="totalWidth" />. Sin embargo, si <paramref name="totalWidth" /> es menor que la longitud de esta instancia, el método devuelve una referencia a la instancia existente. Si <paramref name="totalWidth" /> es igual que la longitud de esta instancia, el método devuelve una nueva cadena que es idéntica a esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> método rellena el principio de la cadena devuelta. Esto significa que, cuando se usa con idiomas de derecha a izquierda, rellena la parte derecha de la cadena.  
  
> [!NOTE]
>  Si el <xref:System.String.PadLeft%2A> método rellena la instancia actual con espacios en blanco, este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena que se rellena con líderes `paddingChar` caracteres para que su longitud total `totalWidth` caracteres.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.PadLeft%2A> método.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> es menor que cero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una nueva cadena de una longitud especificada en la que el final de la cadena actual se rellena con espacios o con un carácter Unicode especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Número de caracteres de la cadena resultante, igual al número de caracteres originales más el número de caracteres de relleno adicionales.</param>
        <summary>Devuelve una nueva cadena que alinea a la izquierda los caracteres de la cadena e inserta espacios en blanco a la derecha hasta alcanzar la longitud total especificada.</summary>
        <returns>Nueva cadena que es equivalente a esta instancia, pero que se alinea a la izquierda y en la que se insertan a la derecha los espacios que sean necesarios para crear la longitud especificada por el parámetro <paramref name="totalWidth" />. Sin embargo, si <paramref name="totalWidth" /> es menor que la longitud de esta instancia, el método devuelve una referencia a la instancia existente. Si <paramref name="totalWidth" /> es igual que la longitud de esta instancia, el método devuelve una nueva cadena que es idéntica a esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un espacio de Unicode se define como hexadecimal 0 x 0020.  
  
 El <xref:System.String.PadRight%28System.Int32%29> método rellena el final de la cadena devuelta. Esto significa que, cuando se usa con idiomas de derecha a izquierda, rellena la parte izquierda de la cadena.  
  
> [!NOTE]
>  Si el <xref:System.String.PadRight%2A> método rellena la instancia actual con espacios en blanco, este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena que se rellena con espacios en blanco finales para que su longitud total `totalWidth` caracteres.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.PadRight%2A> método.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> es menor que cero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Número de caracteres de la cadena resultante, igual al número de caracteres originales más el número de caracteres de relleno adicionales.</param>
        <param name="paddingChar">Carácter Unicode de relleno.</param>
        <summary>Devuelve una nueva cadena que alinea a la izquierda los caracteres de la cadena e inserta a la derecha un carácter Unicode especificado hasta alcanzar la longitud total especificada.</summary>
        <returns>Nueva cadena que es equivalente a esta instancia, pero que se alinea a la izquierda y en la que se insertan a la derecha los caracteres de <paramref name="paddingChar" /> que sean necesarios para crear la longitud especificada por el parámetro <paramref name="totalWidth" />. Sin embargo, si <paramref name="totalWidth" /> es menor que la longitud de esta instancia, el método devuelve una referencia a la instancia existente. Si <paramref name="totalWidth" /> es igual que la longitud de esta instancia, el método devuelve una nueva cadena que es idéntica a esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> método rellena el final de la cadena devuelta. Esto significa que, cuando se usa con idiomas de derecha a izquierda, rellena la parte izquierda de la cadena.  
  
> [!NOTE]
>  Si el <xref:System.String.PadRight%2A> método rellena la instancia actual con espacios en blanco, este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena que se rellena con finales `paddingChar` caracteres para que su longitud total `totalWidth` caracteres.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.PadRight%2A> método.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> es menor que cero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una nueva cadena en la que se elimina un número de caracteres especificado de la cadena actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posición de base cero a partir de la cual comienza la eliminación de caracteres.</param>
        <summary>Devuelve una nueva cadena en la que se han eliminado todos los caracteres de la instancia actual, a partir de una posición especificada y hasta la última posición.</summary>
        <returns>Una nueva cadena que es equivalente a esta cadena, excepto por los caracteres quitados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], las cadenas son de base cero. El valor de la `startIndex` parámetro puede variar de cero hasta uno menos que la longitud de la instancia de cadena.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en que todos los caracteres desde la posición `startIndex` al final de la cadena original se han quitado.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.Remove%2A> método. El caso siguiente al último quita todo el texto a partir del índice especificado hasta el final de la cadena. El último caso, quita tres caracteres, empezando por el índice especificado.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> especifica una posición que no está dentro de esta cadena.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posición de base cero a partir de la cual comienza la eliminación de caracteres.</param>
        <param name="count">Número de caracteres que se va a eliminar.</param>
        <summary>Devuelve una nueva cadena en la que se ha eliminado un número de caracteres especificado en la instancia actual a partir de una posición especificada.</summary>
        <returns>Una nueva cadena que es equivalente a esta instancia, excepto por los caracteres quitados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], las cadenas son de base cero. El valor de la `startIndex` parámetro puede variar de cero hasta uno menos que la longitud de la instancia de cadena.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en el que el número de caracteres especificado por el `count` parámetro se han quitado. Se quitan los caracteres en la posición especificada por `startIndex`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo se puede quitar el segundo nombre de un nombre completo.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> más <paramref name="count" /> especifican una posición fuera de esta instancia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una nueva cadena en la que todas las apariciones de un carácter Unicode especificado o <see cref="T:System.String" /> de la cadena actual se reemplazan por otro carácter Unicode especificado o <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Carácter Unicode que se va a reemplazar.</param>
        <param name="newChar">Carácter Unicode que va a reemplazar todas las apariciones de <paramref name="oldChar" />.</param>
        <summary>Devuelve una nueva cadena en la que todas las apariciones de un carácter Unicode especificado de esta instancia se reemplazan por otro carácter Unicode especificado.</summary>
        <returns>Cadena que es equivalente a esta instancia salvo en que todas las instancias de <paramref name="oldChar" /> se reemplazan con <paramref name="newChar" />. Si <paramref name="oldChar" /> no se encuentra en la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una búsqueda ordinal (distingue mayúsculas de minúsculas y culturales) para buscar `oldChar`.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en que todas las apariciones de `oldChar` se reemplazan por `newChar`.  
  
 Dado que este método devuelve la cadena modificada, puede encadenar las llamadas sucesivas a la <xref:System.String.Replace%2A> método para realizar varias sustituciones en la cadena original. Las llamadas a métodos se ejecutan de izquierda a derecha. Esto se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 El ejemplo siguiente crea una lista de valores separados por comas mediante la sustitución de comas para los espacios en blanco entre una serie de números.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Cadena que se va a reemplazar.</param>
        <param name="newValue">Cadena que va a reemplazar todas las apariciones de <paramref name="oldValue" />.</param>
        <summary>Devuelve una nueva cadena en la que todas las apariciones de una cadena especificada en la instancia actual se reemplazan por otra cadena especificada.</summary>
        <returns>Cadena que es equivalente a la cadena actual salvo en que todas las instancias de <paramref name="oldValue" /> se reemplacen por <paramref name="newValue" />. Si <paramref name="oldValue" /> no se encuentra en la instancia actual, el método devuelve la instancia actual sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `newValue` es `null`, todas las apariciones de `oldValue` se quitan.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en que todas las apariciones de `oldValue` se reemplazan por `newValue`.  
  
 Este método realiza una búsqueda ordinal (distingue mayúsculas de minúsculas y culturales) para buscar `oldValue`.  
  
 Dado que este método devuelve la cadena modificada, puede encadenar las llamadas sucesivas a la <xref:System.String.Replace%2A> método para realizar varias sustituciones en la cadena original. Las llamadas a métodos se ejecutan de izquierda a derecha. Esto se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo puede usar el <xref:System.String.Replace%2A> método para corregir un error ortográfico.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> es la cadena vacía ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una matriz de cadenas que contiene las subcadenas de esta instancia que están delimitadas por elementos de la matriz de cadenas o caracteres Unicode especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> se usa para dividir una cadena delimitada en subcadenas. Puede usar una matriz de caracteres para especificar cero, uno o varios caracteres delimitadores (el <xref:System.String.Split%28System.Char%5B%5D%29> método), o bien puede usar una matriz de caracteres para especificar cero, una o varias cadenas delimitadoras. Las sobrecargas de la <xref:System.String.Split%2A> método le permiten limitar el número de subcadenas devuelto por el método (el <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> método), para determinar si las cadenas vacías se incluyen en las subcadenas devueltas (el <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> y <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> métodos, o para realizar ambas acciones (el <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> y <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> métodos).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>Alternativas a String.Split

 El <xref:System.String.Split%2A> método no siempre es la mejor manera de dividir una cadena delimitada en subcadenas. Si no desea extraer todas las subcadenas de una cadena delimitada, o si desea analizar una cadena según un patrón en lugar de un conjunto de caracteres delimitadores, considere las siguientes alternativas.  
  
### <a name="regular-expressions"></a>Expresiones regulares  
 Si las cadenas se ajustan a un patrón fijo, puede usar una expresión regular para extraer y controlar sus elementos. Por ejemplo, si las cadenas adoptan la forma "*número* *operando* *número*" puede usar un [expresión regular](~/docs/standard/base-types/regular-expressions.md) para extraer y controlar el elementos de la cadena. Por ejemplo:  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 El patrón de expresión regular `(\d+)\s+([-+*/])\s+(\d+)` se define así:  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`(\d+)`|Buscar coincidencias con uno o más dígitos decimales. Este es el primer grupo de captura.|  
|`\s+`|Coincide con uno o más caracteres de espacio en blanco.|  
|`([-+*/])`|Coincide con un operador aritmético de signo (+, -, *, o /). Este es el segundo grupo de captura.|  
|`\s+`|Coincide con uno o más caracteres de espacio en blanco.|  
|`(\d+)`|Buscar coincidencias con uno o más dígitos decimales. Éste es el tercer grupo de captura.|  
  
 También puede usar una expresión regular para extraer subcadenas de una cadena según un patrón en lugar de un conjunto fijo de caracteres. Se trata de un escenario común cuando se produce cualquiera de estas condiciones:  
  
-   Uno o varios de los caracteres delimitadores no actuar siempre como un delimitador en la <xref:System.String> instancia.  
  
-   La secuencia y el número de caracteres de delimitador es variable o desconocido.  
  
 Por ejemplo, el <xref:System.String.Split%2A> método no puede utilizarse para dividir la cadena siguiente, porque el número de `\n` (en C#) o `vbCrLf` (en Visual Basic) de caracteres es variable y no siempre actúan como delimitadores.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 Una expresión regular puede dividir fácilmente, como el siguiente ejemplo se muestra esta cadena.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 El patrón de expresión regular `\[([^\[\]]+)\]` se define así:  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\[`|Coincide con un corchete de apertura.|  
|`([^\[\]]+)`|Coincide con cualquier carácter que no es una corchete de apertura o un cierre una o varias veces. Este es el primer grupo de captura.|  
|`\]`|Coincide con un corchete de cierre.|  
  
 El <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> es casi idéntico al método <xref:System.String.Split%2A?displayProperty=nameWithType>, excepto en que divide una cadena según un patrón de expresión regular en lugar de un juego de caracteres fijos. Por ejemplo, en el ejemplo siguiente se utiliza el <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método para dividir una cadena que contiene subcadenas delimitadas por varias combinaciones de guiones y otros caracteres.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 El patrón de expresión regular `\s-\s?[+*]?\s?-\s` se define así:  
  
|Modelo|Descripción|  
|-------------|-----------------|  
|`\s-`|Coincide con un carácter de espacio en blanco seguido por un guión.|  
|`\s?`|Busca coincidencias con cero o un carácter de espacio en blanco.|  
|`[+*]?`|Coincide con cero o una aparición de uno de ellos la + o * caracteres.|  
|`\s?`|Busca coincidencias con cero o un carácter de espacio en blanco.|  
|`-\s`|Coincide con un guión seguido de un carácter de espacio en blanco.|  
  
### <a name="search-methods-and-the-substring-method"></a>Los métodos de búsqueda y Substring (método)  
 Si no está interesado en todas las subcadenas de una cadena, prefiere trabajar con uno de los métodos de comparación de cadenas que devuelve el índice donde comienza la coincidencia. A continuación, puede llamar a la <xref:System.String.Substring%2A> método para extraer la subcadena que desee. Los métodos de comparación de cadenas incluyen:  
  
-   <xref:System.String.IndexOf%2A>, que devuelve el índice de base cero de la primera aparición de un carácter o cadena en una instancia de cadena.  
  
-   <xref:System.String.IndexOfAny%2A>, que devuelve el índice de base cero de la instancia actual de la cadena de la primera aparición de un carácter de una matriz de caracteres.  
  
-   <xref:System.String.LastIndexOf%2A>, que devuelve el índice de base cero de la última aparición de un carácter o cadena en una instancia de cadena.  
  
-   <xref:System.String.LastIndexOfAny%2A>, que devuelve un índice de base cero de la instancia actual de la cadena de la última aparición de un carácter de una matriz de caracteres.  
  
 En el ejemplo siguiente se usa el <xref:System.String.IndexOf%2A> método para buscar los períodos en una cadena. A continuación, usa el <xref:System.String.Substring%2A> método para devolver las oraciones completas.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Matriz de caracteres que delimitan las subcadenas de esta cadena, una matriz vacía sin delimitadores o <see langword="null" />.</param>
        <summary>Divide una cadena en subcadenas basadas en los caracteres de una matriz.</summary>
        <returns>Una matriz cuyos elementos contienen las subcadenas de esta instancia que están delimitadas por uno o varios caracteres de <paramref name="separator" />. Para obtener más información, vea la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando una cadena está delimitada por un conjunto conocido de caracteres, puede usar el <xref:System.String.Split%28System.Char%5B%5D%29> método para separarlo en subcadenas.   
  
### <a name="return-value-details"></a>Detalles de valor devuelto  
 No se incluyen los caracteres delimitadores en los elementos de la matriz devuelta. Por ejemplo, si la matriz de separador incluye el carácter "-" y el valor de la instancia de la cadena actual es "aa-bb-cc", el método devuelve una matriz que contiene tres elementos: "aa", "bb" y "cc".  
  
 Si esta instancia no contiene ninguno de los caracteres en `separator`, la matriz devuelta consta de un solo elemento que contiene esta instancia.  
  
 Cada elemento de `separator` define un carácter delimitador independiente. Si dos delimitadores son adyacentes, o se encuentra un delimitador al principio o al final de esta instancia, el elemento correspondiente en la matriz devuelta contiene <xref:System.String.Empty>. A continuación se muestran algunos ejemplos:  
  
|Valor de cadena|Separador|Matriz devuelta|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|nuevo Char [] {',', ' '} (C#)<br /><br /> Char() = {"," c, "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|new Char[] {'.'} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> VbLf "Darb" y "Smarba" (Visual Basic)|nuevo Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> VbLf "Darb" y "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>La matriz de separador  
 Cada elemento de separador que define un delimitador independiente que consta de un solo carácter. Si el `separator` argumento es `null` o no contiene ningún carácter, el método trata los caracteres de espacio en blanco como delimitadores. Caracteres de espacio en blanco se definen mediante el estándar; Unicode devuelven `true` si se pasan a la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>Resolución de sobrecarga String.Split(Char[]) y compilador  
 Aunque el parámetro único para esta sobrecarga de <xref:System.String.Split%2A?displayProperty=nameWithType> es una matriz de caracteres, podemos llamarlo con un carácter único, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Dado que el `separator` parámetro esté decorado con el <xref:System.ParamArrayAttribute> atributo, compiladores interpretará un único carácter como una matriz de caracteres único elemento. Esto no es así para otros <xref:System.String.Split%2A?displayProperty=nameWithType> sobrecargas que incluyen un `separator` parámetro; debe pasar explícitamente estas sobrecargas de una matriz de caracteres como el `separator` argumento.  
  
### <a name="comparison-details"></a>Detalles de la comparación  
 El <xref:System.String.Split%28System.Char%5B%5D%29> método extrae las subcadenas de esta cadena que están delimitadas por uno o varios de los caracteres de la `separator` de matriz y devuelve esas subcadenas como elementos de una matriz.  
  
 El <xref:System.String.Split%28System.Char%5B%5D%29> método busca delimitadores realizar comparaciones usando las reglas de ordenación ordinal entre mayúsculas y minúsculas. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea el <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeración.  
  
### <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 El <xref:System.String.Split%2A> métodos asignan memoria para el objeto de matriz devuelto y un <xref:System.String> objeto para cada elemento de matriz. Si la aplicación requiere un rendimiento óptimo o administrar la asignación de memoria es fundamental en la aplicación, considere el uso de la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método. También tiene la opción de usar el <xref:System.String.Compare%2A> método para localizar una subcadena dentro de una cadena.  
  
 Para dividir una cadena en un carácter separador, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar un carácter separador en la cadena. Para dividir una cadena en una cadena separadora, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar el primer carácter de la cadena separadora. A continuación, utilice el <xref:System.String.Compare%2A> método para determinar si los caracteres después de ese primer carácter son iguales a los caracteres restantes de la cadena separadora.  
  
 Además, si el mismo conjunto de caracteres se utiliza para dividir las cadenas en varios <xref:System.String.Split%2A> llamadas a métodos, considere la posibilidad de crear una sola matriz y hacer referencia a ella en cada llamada al método. Esto reduce considerablemente la sobrecarga adicional de cada llamada al método.  
  
## Examples  
 El ejemplo siguiente muestra cómo extraer palabras individuales de un bloque de texto tratando los espacios en blanco y signos de puntuación como delimitadores. La matriz de caracteres que se pasa a la `separator` parámetro de la <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método consta de un carácter de espacio y un carácter de tabulación, junto con algunos símbolos de puntuación comunes.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] y versiones anteriores, si la <see cref="M:System.String.Split(System.Char[])" /> se pasa al método un <paramref name="separator" /> decir <see langword="null" /> o no contiene ningún carácter, el método usa un conjunto de caracteres ligeramente diferentes para dividir la cadena que el <see cref="M:System.String.Trim(System.Char[])" /> hace el método para recorta la cadena. A partir de .NET Framework 4, ambos métodos usan un conjunto idéntico de caracteres de espacio en blanco de Unicode.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Matriz de caracteres que delimitan las subcadenas de esta cadena, una matriz vacía sin delimitadores o <see langword="null" />.</param>
        <param name="count">Número máximo de subcadenas que se van devolver.</param>
        <summary>Divide una cadena en un número máximo de subcadenas en función de los caracteres de una matriz. Número máximo de subcadenas que se va devolver.</summary>
        <returns>Una matriz cuyos elementos contienen las subcadenas de esta instancia que están delimitadas por uno o varios caracteres de <paramref name="separator" />. Para obtener más información, vea la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se incluyen los caracteres delimitadores en los elementos de la matriz devuelta.  
  
 Si esta instancia no contiene ninguno de los caracteres en `separator`, la matriz devuelta consta de un solo elemento que contiene esta instancia. Si `count` es cero, se devuelve una matriz vacía.  
  
 Si el `separator` parámetro es `null` o no contiene caracteres, caracteres de espacio en blanco se supone que los delimitadores. Caracteres de espacio en blanco se definen mediante Unicode estándar y devuelven `true` si se pasan a la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.  
  
 Cada elemento de `separator` define un carácter delimitador independiente. Si dos delimitadores son adyacentes, o se encuentra un delimitador al principio o al final de esta instancia, el elemento correspondiente de la matriz contiene <xref:System.String.Empty>.  
  
 Si hay más de `count` subcadenas de esta instancia, la primera `count` menos 1 subcadenas se devuelven en la primera `count` menos 1 elementos del valor devuelto y los caracteres restantes de esta instancia se devuelven en los últimos elemento del valor devuelto.  
  
 Si `count` es mayor que el número de subcadenas, se devuelven las subcadenas disponibles y se produce ninguna excepción.  
  
 En la tabla siguiente se proporciona ejemplos.  
  
|Valor de cadena|Separador|Recuento|Matriz devuelta|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|nuevo Char [] {',', ' '} (C#)<br /><br /> Char() = {"," c, "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|new Char[] {'.'} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> VbLf "Darb" y "Smarba" (Visual Basic)|nuevo Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> VbLf "Darb" y "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> VbLf "Darb" y "Smarba" (Visual Basic)|nuevo Char [] null (C#)<br /><br /> Char() = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> VbLf "Darb" y "Smarba" (Visual Basic)|nuevo Char [] null (C#)<br /><br /> Char() = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 El <xref:System.String.Split%2A> métodos asignan memoria para el objeto de matriz devuelto y un <xref:System.String> objeto para cada elemento de matriz. Si la aplicación requiere un rendimiento óptimo o administrar la asignación de memoria es fundamental en la aplicación, considere el uso de la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método y opcionalmente el <xref:System.String.Compare%2A> método para localizar una subcadena dentro de una cadena.  
  
 Si va a dividir una cadena en un carácter separador, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar un carácter separador en la cadena. Si va a dividir una cadena en una cadena separadora, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar el primer carácter de la cadena separadora. A continuación, utilice el <xref:System.String.Compare%2A> método para determinar si los caracteres después de ese primer carácter son iguales a los caracteres restantes de la cadena separadora.  
  
 Además, si el mismo conjunto de caracteres se utiliza para dividir las cadenas en varios <xref:System.String.Split%2A> llamadas a métodos, considere la posibilidad de crear una sola matriz y hacer referencia a ella en cada llamada al método. Esto reduce considerablemente la sobrecarga adicional de cada llamada al método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo `count` afecta al número de cadenas devuelta por <xref:System.String.Split%2A>.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es negativo.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] y versiones anteriores, si la <see cref="M:System.String.Split(System.Char[])" /> se pasa al método un <paramref name="separator" /> decir <see langword="null" /> o no contiene ningún carácter, el método usa un conjunto de caracteres ligeramente diferentes para dividir la cadena que el <see cref="M:System.String.Trim(System.Char[])" /> hace el método para recorta la cadena. A partir de .NET Framework 4, ambos métodos usan un conjunto idéntico de caracteres de espacio en blanco de Unicode.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Matriz de caracteres que delimitan las subcadenas de esta cadena, una matriz vacía sin delimitadores o <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir los elementos de matriz vacíos de la matriz devuelta; o bien, <see cref="F:System.StringSplitOptions.None" /> para incluir los elementos de matriz vacíos en la matriz devuelta.</param>
        <summary>Divide una cadena en subcadenas en función de los caracteres de una matriz. Puede especificar si las subcadenas incluyen elementos de matriz vacíos.</summary>
        <returns>Una matriz cuyos elementos contienen las subcadenas de esta cadena que están delimitadas por uno o varios caracteres de <paramref name="separator" />. Para obtener más información, vea la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Detalles de valor devuelto  
 Caracteres delimitadores (los caracteres de la `separator` matriz) no se incluyen en los elementos de la matriz devuelta. Por ejemplo, si la `separator` matriz incluye el carácter "-" y el valor de la instancia de la cadena actual es "aa-bb-cc", el método devuelve una matriz que contiene tres elementos: "aa", "bb" y "cc".  
  
 Si esta instancia no contiene ninguno de los caracteres en `separator`, la matriz devuelta consta de un solo elemento que contiene esta instancia.  
  
 Si el `options` parámetro es <xref:System.StringSplitOptions.RemoveEmptyEntries> y la longitud de esta instancia es cero, el método devuelve una matriz vacía.  
  
 Cada elemento de `separator` define un delimitador independiente que consta de un solo carácter. Si el `options` argumento es <xref:System.StringSplitOptions.None>y dos delimitadores son adyacentes o se encuentra un delimitador al principio o al final de esta instancia, el elemento correspondiente de la matriz contiene <xref:System.String.Empty?displayProperty=nameWithType>. Por ejemplo, si `separator` incluye dos elementos, "-" y "\_", el valor de la instancia de cadena es "-\_aa -\_" y el valor de la `options` argumento es <xref:System.StringSplitOptions.None>, el método devuelve una matriz de cadenas los siguientes cinco elementos:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa la cadena vacía que precede a la "-" carácter en el índice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa la cadena vacía entre la "-" carácter en el índice 0 y el carácter "_" en el índice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa la cadena vacía que sigue al carácter "_" en el índice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa la cadena vacía que sigue a la "-" carácter en el índice 5.  
  
### <a name="the-separator-array"></a>La matriz de separador  
 Si el `separator` parámetro es `null` o no contiene caracteres, caracteres de espacio en blanco se supone que los delimitadores. Caracteres de espacio en blanco se definen mediante Unicode estándar y devuelven `true` si se pasan a la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.  
  
 Si el `separator` parámetro en la llamada a esta sobrecarga del método es `null`, se produce un error en la resolución de sobrecarga del compilador. Para identificar de forma inequívoca el método llamado, el código debe indicar el tipo de la `null`. El ejemplo siguiente muestra varias maneras para identificar inequívocamente esta sobrecarga.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>Detalles de la comparación  
 El <xref:System.String.Split%2A> método extrae las subcadenas de esta cadena que están delimitadas por uno o varios de los caracteres de la `separator` parámetro y devuelve esas subcadenas como elementos de una matriz.  
  
 El <xref:System.String.Split%2A> método busca delimitadores realizar comparaciones usando las reglas de ordenación ordinal entre mayúsculas y minúsculas. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea el <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeración.  
  
### <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 El <xref:System.String.Split%2A> métodos asignan memoria para el objeto de matriz devuelto y un <xref:System.String> objeto para cada elemento de matriz. Si la aplicación requiere un rendimiento óptimo o administrar la asignación de memoria es fundamental en la aplicación, considere el uso de la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método y opcionalmente el <xref:System.String.Compare%2A> método para localizar una subcadena dentro de una cadena.  
  
 Si va a dividir una cadena en un carácter separador, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar un carácter separador en la cadena. Si va a dividir una cadena en una cadena separadora, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar el primer carácter de la cadena separadora. A continuación, utilice el <xref:System.String.Compare%2A> método para determinar si los caracteres después de ese primer carácter son iguales a los caracteres restantes de la cadena separadora.  
  
 Además, si el mismo conjunto de caracteres se utiliza para dividir las cadenas en varios <xref:System.String.Split%2A> llamadas a métodos, considere la posibilidad de crear una sola matriz y hacer referencia a ella en cada llamada al método. Esto reduce considerablemente la sobrecarga adicional de cada llamada al método.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.StringSplitOptions> enumeración para incluir o excluir las subcadenas generadas por el <xref:System.String.Split%2A> método.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> no es uno de los valores de <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] y versiones anteriores, si la <see cref="M:System.String.Split(System.Char[])" /> se pasa al método un <paramref name="separator" /> decir <see langword="null" /> o no contiene ningún carácter, el método usa un conjunto de caracteres ligeramente diferentes para dividir la cadena que el <see cref="M:System.String.Trim(System.Char[])" /> hace el método para recorta la cadena. A partir de .NET Framework 4, ambos métodos usan un conjunto idéntico de caracteres de espacio en blanco de Unicode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Matriz de cadenas que delimitan las subcadenas de esta cadena, una matriz vacía sin delimitadores o <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir los elementos de matriz vacíos de la matriz devuelta; o bien, <see cref="F:System.StringSplitOptions.None" /> para incluir los elementos de matriz vacíos en la matriz devuelta.</param>
        <summary>Divide una cadena en subcadenas en función de las cadenas de una matriz. Puede especificar si las subcadenas incluyen elementos de matriz vacíos.</summary>
        <returns>Una matriz cuyos elementos contienen las subcadenas de esta cadena que están delimitadas por una o varias cadenas de <paramref name="separator" />. Para obtener más información, vea la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando una cadena está delimitada por un conjunto conocido de cadenas, puede usar el <xref:System.String.Split%2A> método para separarlo en subcadenas.  
  
### <a name="return-value-details"></a>Detalles de valor devuelto  
 Las cadenas delimitadoras no se incluyen en los elementos de la matriz devuelta. Por ejemplo, si la `separator` matriz incluye la cadena "--" y el valor de la instancia de la cadena actual es "aa, bb-cc", el método devuelve una matriz que contiene tres elementos: "aa", "bb" y "cc".  
  
 Si esta instancia no contiene ninguna de las cadenas de `separator`, la matriz devuelta consta de un solo elemento que contiene esta instancia.  
  
 Si el `options` parámetro es <xref:System.StringSplitOptions.RemoveEmptyEntries> y la longitud de esta instancia es cero, el método devuelve una matriz vacía.  
  
 Cada elemento de `separator` define un delimitador independiente que consta de uno o más caracteres. Si el `options` argumento es <xref:System.StringSplitOptions.None>y dos delimitadores son adyacentes o se encuentra un delimitador al principio o al final de esta instancia, el elemento correspondiente de la matriz contiene <xref:System.String.Empty?displayProperty=nameWithType>. Por ejemplo, si `separator` incluye dos elementos, "-" y "\_", el valor de la instancia de cadena es "-\_aa -\_" y el valor de la `options` argumento es <xref:System.StringSplitOptions.None>, el método devuelve una matriz de cadenas con los siguientes cinco elementos:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa la cadena vacía que precede a la "-" subcadena en el índice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa la cadena vacía entre la "-" subcadena al índice 0 y la subcadena "_" en el índice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa la cadena vacía que sigue a la subcadena "_" en el índice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa la cadena vacía que sigue a la "-" subcadena en el índice 5.  
  
### <a name="the-separator-array"></a>La matriz de separador  
 Si alguno de los elementos de `separator` consta de varios caracteres, toda la subcadena se considera un delimitador. Por ejemplo, si uno de los elementos de `separator` es "10", intenta dividir la cadena "This10is10a10string." Devuelve la siguiente matriz de cuatro elementos: {"This", "is", "a", "string". }.  
  
 Si el `separator` parámetro es `null` o no contiene caracteres, caracteres de espacio en blanco se supone que los delimitadores. Caracteres de espacio en blanco se definen mediante Unicode estándar y devuelven `true` si se pasan a la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.  
  
 Si el `separator` parámetro en la llamada a esta sobrecarga del método es `null`, se produce un error en la resolución de sobrecarga del compilador. Para identificar de forma inequívoca el método llamado, el código debe indicar el tipo de la `null`. El ejemplo siguiente muestra varias maneras para identificar inequívocamente esta sobrecarga.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>Detalles de la comparación  
 El <xref:System.String.Split%2A> método extrae las subcadenas de esta cadena que están delimitadas por una o varias de las cadenas en el `separator` parámetro y devuelve esas subcadenas como elementos de una matriz.  
  
 El <xref:System.String.Split%2A> método busca delimitadores realizar comparaciones usando las reglas de ordenación ordinal entre mayúsculas y minúsculas. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea el <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeración.  
  
 El <xref:System.String.Split%2A> método omite cualquier elemento de `separator` cuyo valor es `null` o una cadena vacía ("").  
  
 Para evitar resultados ambiguos cuando las cadenas en `separator` tienen caracteres en común, el <xref:System.String.Split%2A> operación continúa desde el principio hasta el final del valor de la instancia y coincide con el primer elemento de `separator` que es igual a un delimitador de la instancia de. El orden en el que se encuentran las subcadenas en la instancia tiene prioridad sobre el orden de los elementos en `separator`.  
  
 Por ejemplo, considere la posibilidad de una instancia cuyo valor es "abcdef". Si el primer elemento de `separator` era "ef" y el segundo elemento es "bcde", el resultado de la operación de división sería una matriz de cadenas que contiene dos elementos, "a" y "f". Esto es porque la subcadena en la instancia de "bcde", se encuentra y coincide con un elemento en `separator` antes de que se encuentra la subcadena "f".  
  
 Sin embargo, si el primer elemento de `separator` era "bcd" y el segundo elemento es "bc", el resultado de la operación de división sería una matriz de cadenas que contiene dos elementos, "a" y "ef". Esto es porque "bcd" es el primer delimitador en `separator` que coincide con un delimitador en la instancia. Si se invierte el orden de los separadores, por lo que el primer elemento es "bc" y el segundo elemento es "bcd", el resultado sería una matriz de cadenas que contiene dos elementos, "a" y "def".  
  
### <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 El <xref:System.String.Split%2A> métodos asignan memoria para el objeto de matriz devuelto y un <xref:System.String> objeto para cada elemento de matriz. Si la aplicación requiere un rendimiento óptimo o administrar la asignación de memoria es fundamental en la aplicación, considere el uso de la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método y opcionalmente el <xref:System.String.Compare%2A> método para localizar una subcadena dentro de una cadena.  
  
 Si va a dividir una cadena en un carácter separador, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar un carácter separador en la cadena. Si va a dividir una cadena en una cadena separadora, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar el primer carácter de la cadena separadora. A continuación, utilice el <xref:System.String.Compare%2A> método para determinar si los caracteres después de ese primer carácter son iguales a los caracteres restantes de la cadena separadora.  
  
 Además, si el mismo conjunto de caracteres se utiliza para dividir las cadenas en varios <xref:System.String.Split%2A> llamadas a métodos, considere la posibilidad de crear una sola matriz y hacer referencia a ella en cada llamada al método. Esto reduce considerablemente la sobrecarga adicional de cada llamada al método.  
  
   
  
## Examples  
 El ejemplo siguiente ilustra la diferencia entre las matrices devueltas por una llamada a una cadena <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> método con su `options` igual al parámetro <xref:System.StringSplitOptions.None?displayProperty=nameWithType> y <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 El ejemplo siguiente define una matriz de separadores que incluyen signos de puntuación y caracteres de espacio en blanco. Si se pasa esta matriz junto con un valor de <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> a la <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> método devuelve una matriz que consta de las palabras individuales de la cadena.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Tenga en cuenta que se llama al método con el `options` establecido en <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Esto impide que la matriz devuelta incluya <xref:System.String.Empty?displayProperty=nameWithType> valores que representan las coincidencias de subcadena vacía entre signos de puntuación y caracteres de espacio en blanco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> no es uno de los valores de <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] y versiones anteriores, si la <see cref="M:System.String.Split(System.Char[])" /> se pasa al método un <paramref name="separator" /> decir <see langword="null" /> o no contiene ningún carácter, el método usa un conjunto de caracteres ligeramente diferentes para dividir la cadena que el <see cref="M:System.String.Trim(System.Char[])" /> hace el método para recorta la cadena. A partir de .NET Framework 4, ambos métodos usan un conjunto idéntico de caracteres de espacio en blanco de Unicode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Matriz de caracteres que delimitan las subcadenas de esta cadena, una matriz vacía sin delimitadores o <see langword="null" />.</param>
        <param name="count">Número máximo de subcadenas que se van devolver.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir los elementos de matriz vacíos de la matriz devuelta; o bien, <see cref="F:System.StringSplitOptions.None" /> para incluir los elementos de matriz vacíos en la matriz devuelta.</param>
        <summary>Divide una cadena en un número máximo de subcadenas en función de los caracteres de una matriz.</summary>
        <returns>Una matriz cuyos elementos contienen las subcadenas de esta cadena que están delimitadas por uno o varios caracteres de <paramref name="separator" />. Para obtener más información, vea la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se incluyen los caracteres delimitadores en los elementos de la matriz devuelta.  
  
 Si esta instancia no contiene ninguno de los caracteres en `separator`, o el `count` del parámetro es 1, la matriz devuelta consta de un solo elemento que contiene esta instancia. Si el `separator` parámetro es `null` o no contiene caracteres, caracteres de espacio en blanco se supone que los delimitadores. Caracteres de espacio en blanco se definen mediante Unicode estándar y devuelven `true` si se pasan a la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método. Sin embargo, si la `separator` parámetro en la llamada a esta sobrecarga del método es `null`, se produce un error en la resolución de sobrecarga del compilador. Para identificar de forma inequívoca el método llamado, el código debe indicar el tipo del valor null. El ejemplo siguiente muestra varias maneras para identificar inequívocamente esta sobrecarga.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Si el `count` parámetro es cero, o la `options` parámetro es <xref:System.StringSplitOptions.RemoveEmptyEntries> y la longitud de esta instancia es cero, se devuelve una matriz vacía.  
  
 Cada elemento de `separator` define un carácter delimitador independiente. Si el `options` parámetro es <xref:System.StringSplitOptions.None>y dos delimitadores son adyacentes o se encuentra un delimitador al principio o al final de esta instancia, el elemento correspondiente de la matriz contiene <xref:System.String.Empty>.  
  
 Si hay más de `count` subcadenas de esta instancia, la primera `count` menos 1 subcadenas se devuelven en la primera `count` menos 1 elementos del valor devuelto y los caracteres restantes de esta instancia se devuelven en los últimos elemento del valor devuelto.  
  
 Si `count` es mayor que el número de subcadenas, se devuelven las subcadenas disponibles y se produce ninguna excepción.  
  
### <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 El <xref:System.String.Split%2A> métodos asignan memoria para el objeto de matriz devuelto y un <xref:System.String> objeto para cada elemento de matriz. Si la aplicación requiere un rendimiento óptimo o administrar la asignación de memoria es fundamental en la aplicación, considere el uso de la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método y opcionalmente el <xref:System.String.Compare%2A> método para localizar una subcadena dentro de una cadena.  
  
 Si va a dividir una cadena en un carácter separador, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar un carácter separador en la cadena. Si va a dividir una cadena en una cadena separadora, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar el primer carácter de la cadena separadora. A continuación, utilice el <xref:System.String.Compare%2A> método para determinar si los caracteres después de ese primer carácter son iguales a los caracteres restantes de la cadena separadora.  
  
 Además, si el mismo conjunto de caracteres se utiliza para dividir las cadenas en varios <xref:System.String.Split%2A> llamadas a métodos, considere la posibilidad de crear una sola matriz y hacer referencia a ella en cada llamada al método. Esto reduce considerablemente la sobrecarga adicional de cada llamada al método.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.StringSplitOptions> enumeración para incluir o excluir las subcadenas generadas por el <xref:System.String.Split%2A> método.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> no es uno de los valores de <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] y versiones anteriores, si la <see cref="M:System.String.Split(System.Char[])" /> se pasa al método un <paramref name="separator" /> decir <see langword="null" /> o no contiene ningún carácter, el método usa un conjunto de caracteres ligeramente diferentes para dividir la cadena que el <see cref="M:System.String.Trim(System.Char[])" /> hace el método para recorta la cadena. A partir de .NET Framework 4, ambos métodos usan un conjunto idéntico de caracteres de espacio en blanco de Unicode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Matriz de cadenas que delimitan las subcadenas de esta cadena, una matriz vacía sin delimitadores o <see langword="null" />.</param>
        <param name="count">Número máximo de subcadenas que se van devolver.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir los elementos de matriz vacíos de la matriz devuelta; o bien, <see cref="F:System.StringSplitOptions.None" /> para incluir los elementos de matriz vacíos en la matriz devuelta.</param>
        <summary>Divide una cadena en un número máximo de subcadenas en función de las cadenas de una matriz. Puede especificar si las subcadenas incluyen elementos de matriz vacíos.</summary>
        <returns>Una matriz cuyos elementos contienen las subcadenas de esta cadena que están delimitadas por una o varias cadenas de <paramref name="separator" />. Para obtener más información, vea la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Detalles de valor devuelto  
 Las cadenas delimitadoras no se incluyen en los elementos de la matriz devuelta.  
  
 Si esta instancia no contiene ninguna de las cadenas de `separator`, o el `count` del parámetro es 1, la matriz devuelta consta de un solo elemento que contiene esta instancia. Si el `separator` parámetro es `null` o no contiene caracteres, caracteres de espacio en blanco se supone que los delimitadores. Caracteres de espacio en blanco se definen mediante Unicode estándar y devuelven `true` si se pasan a la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método. Sin embargo, si la `separator` parámetro en la llamada a esta sobrecarga del método es `null`, se produce un error en la resolución de sobrecarga del compilador. Para identificar de forma inequívoca el método llamado, el código debe indicar el tipo de la `null`. El ejemplo siguiente muestra varias maneras para identificar inequívocamente esta sobrecarga.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Si el `count` parámetro es cero, o la `options` parámetro es <xref:System.StringSplitOptions.RemoveEmptyEntries> y la longitud de esta instancia es cero, se devuelve una matriz vacía.  
  
 Cada elemento de `separator` define un delimitador independiente que consta de uno o más caracteres. Si el `options` parámetro es <xref:System.StringSplitOptions.None>y dos delimitadores son adyacentes o se encuentra un delimitador al principio o al final de esta instancia, el elemento correspondiente de la matriz contiene <xref:System.String.Empty>.  
  
 Si hay más de `count` subcadenas de esta instancia, la primera `count` menos 1 subcadenas se devuelven en la primera `count` menos 1 elementos del valor devuelto y los caracteres restantes de esta instancia se devuelven en los últimos elemento del valor devuelto.  
  
 Si `count` es mayor que el número de subcadenas, se devuelven las subcadenas disponibles y se produce ninguna excepción.  
  
### <a name="the-separator-array"></a>La matriz de separador  
 Si alguno de los elementos de `separator` consta de varios caracteres, toda la subcadena se considera un delimitador. Por ejemplo, si uno de los elementos de `separator` es "10", intenta dividir la cadena "This10is10a10string." devuelve esta matriz de cuatro elementos: {"This", "is", "a", "string". }.  
  
### <a name="comparison-details"></a>Detalles de la comparación  
 El <xref:System.String.Split%2A> método extrae las subcadenas de esta cadena que están delimitadas por una o varias de las cadenas en el `separator` parámetro y devuelve esas subcadenas como elementos de una matriz.  
  
 El <xref:System.String.Split%2A> método busca delimitadores realizar comparaciones usando las reglas de ordenación ordinal entre mayúsculas y minúsculas. Para obtener más información acerca de la ordenación de palabras, cadena y ordinal, vea el <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeración.  
  
 El <xref:System.String.Split%2A> método omite cualquier elemento de `separator` cuyo valor es `null` o una cadena vacía ("").  
  
 Para evitar resultados ambiguos cuando las cadenas en `separator` tienen caracteres en común, el <xref:System.String.Split%2A> continúa desde el principio hasta el final del valor de la instancia de método y coincide con el primer elemento de `separator` que es igual a un delimitador de la instancia de. El orden en el que se encuentran las subcadenas en la instancia tiene prioridad sobre el orden de los elementos en `separator`.  
  
 Por ejemplo, considere la posibilidad de una instancia cuyo valor es "abcdef". Si el primer elemento de `separator` era "ef" y el segundo elemento es "bcde", el resultado de la operación de división sería "a" y "f". Esto es porque la subcadena en la instancia de "bcde", se encuentra y coincide con un elemento en `separator` antes de que se encuentra la subcadena "f".  
  
 Sin embargo, si el primer elemento de `separator` era "bcd" y el segundo elemento es "bc", el resultado de la operación de división sería "a" y "ef". Esto es porque "bcd" es el primer delimitador en `separator` que coincide con un delimitador en la instancia. Si se invierte el orden de los separadores, por lo que el primer elemento es "bc" y el segundo elemento es "bcd", el resultado sería "a" y "def".  
  
### <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 El <xref:System.String.Split%2A> métodos asignan memoria para el objeto de matriz devuelto y un <xref:System.String> objeto para cada elemento de matriz. Si la aplicación requiere un rendimiento óptimo o administrar la asignación de memoria es fundamental en la aplicación, considere el uso de la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método y opcionalmente el <xref:System.String.Compare%2A> método para localizar una subcadena dentro de una cadena.  
  
 Si va a dividir una cadena en un carácter separador, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar un carácter separador en la cadena. Si va a dividir una cadena en una cadena separadora, utilice el <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> método para buscar el primer carácter de la cadena separadora. A continuación, utilice el <xref:System.String.Compare%2A> método para determinar si los caracteres después de ese primer carácter son iguales a los caracteres restantes de la cadena separadora.  
  
 Además, si el mismo conjunto de caracteres se utiliza para dividir las cadenas en varios <xref:System.String.Split%2A> llamadas a métodos, considere la posibilidad de crear una sola matriz y hacer referencia a ella en cada llamada al método. Esto reduce considerablemente la sobrecarga adicional de cada llamada al método.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.StringSplitOptions> enumeración para incluir o excluir las subcadenas generadas por el <xref:System.String.Split%2A> método.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> no es uno de los valores de <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] y versiones anteriores, si la <see cref="M:System.String.Split(System.Char[])" /> se pasa al método un <paramref name="separator" /> decir <see langword="null" /> o no contiene ningún carácter, el método usa un conjunto de caracteres ligeramente diferentes para dividir la cadena que el <see cref="M:System.String.Trim(System.Char[])" /> hace el método para recorta la cadena. A partir de .NET Framework 4, ambos métodos usan un conjunto idéntico de caracteres de espacio en blanco de Unicode.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si el principio de esta instancia de cadena coincide con una cadena especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comparar.</param>
        <summary>Determina si el principio de esta instancia de cadena coincide con la cadena especificada.</summary>
        <returns><see langword="true" /> si <paramref name="value" /> coincide con el principio de esta cadena; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método compara `value` a la subcadena al principio de esta instancia de la misma longitud que `value`y devuelve una indicación de si son iguales. Para que sea igual, `value` debe ser una cadena vacía (<xref:System.String.Empty?displayProperty=nameWithType>), debe ser una referencia a esta misma instancia, o debe coincidir con el principio de esta instancia.  
  
 Este método realiza una comparación de palabras (distingue mayúsculas de minúsculas y la referencia cultural) usando la referencia cultural actual.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `StripStartTags` método que usa el <xref:System.String.StartsWith%28System.String%29> las etiquetas de apertura de método para quitar HTML desde el principio de una cadena. Tenga en cuenta que el `StripStartTags` método se llama de forma recursiva para asegurarse de que se han quitado varias etiquetas de inicio HTML al principio de la línea. El ejemplo no quita las etiquetas HTML incrustadas en una cadena.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de comparación de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para determinar si una cadena comienza con una subcadena concreta mediante el uso de las reglas de comparación de la referencia cultural actual, llame a la <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> sobrecarga del método con un valor de <see cref="F:System.StringComparison.CurrentCulture" /> para su <paramref name="comparisonType" /> parámetro.</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comparar.</param>
        <param name="comparisonType">Uno de los valores de enumeración que determina cómo se comparan esta cadena y <paramref name="value" />.</param>
        <summary>Determina si el principio de esta instancia de cadena coincide con la cadena especificada cuando se comparan usando la opción de comparación especificada.</summary>
        <returns><see langword="true" /> si esta instancia comienza con <paramref name="value" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.StartsWith%2A> método compara el `value` parámetro a la subcadena al principio de esta cadena y devuelve un valor que indica si son iguales. Para que sea igual, `value` debe ser una referencia a esta misma cadena, debe ser una cadena vacía (""), o debe coincidir con el principio de esta cadena. El tipo de comparación realizada por el <xref:System.String.StartsWith%2A> método depende del valor de la `comparisonType` parámetro. La comparación puede usar las convenciones de la referencia cultural actual (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> y <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) o la referencia cultural (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> y <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), o puede constar de una comparación carácter a carácter de puntos de código (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). También puede ser la comparación distingue mayúsculas de minúsculas (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, o <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), o pueden omitir mayúsculas y minúsculas (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 El ejemplo siguiente se busca la cadena "the" al principio de una cadena más larga que comienza con la palabra "The". Como se muestra en el ejemplo, una llamada a la salida del <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> método que realiza una comparación entre mayúsculas y minúsculas pero cuenta la referencia cultural no coincide con la cadena, mientras que una llamada que realiza una comparación de referencia cultural y caso insensitive coincide con la cadena.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 El ejemplo siguiente determina si una cadena comienza con una subcadena concreta. Inicializa una matriz bidimensional de cadena. El primer elemento en la segunda dimensión contiene una cadena, y el segundo elemento contiene la cadena que se busca al principio de la primera cadena. Los resultados se ven afectados por la elección de la referencia cultural, si se omiten los casos, y si se realiza una comparación ordinal. Tenga en cuenta que cuando la instancia de cadena contiene una ligadura, las comparaciones de referencias culturales con sus caracteres consecutivos que coincida correctamente.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> no es un valor <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a comparar.</param>
        <param name="ignoreCase"><see langword="true" /> para no distinguir entre mayúsculas y minúsculas durante la comparación; de lo contrario, <see langword="false" />.</param>
        <param name="culture">Información de referencia cultural que determina cómo se comparan esta cadena y <paramref name="value" />. Si <paramref name="culture" /> es <see langword="null" />, se usa la referencia cultural actual.</param>
        <summary>Determina si el principio de esta instancia de cadena coincide con la cadena especificada cuando se comparan usando la referencia cultural especificada.</summary>
        <returns><see langword="true" /> si el parámetro <paramref name="value" /> coincide con el principio de esta cadena; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método compara la `value` parámetro a la subcadena al principio de esta cadena que es la misma longitud que `value`y devuelve un valor que indica si son iguales. Para que sea igual, `value` debe ser una cadena vacía (<xref:System.String.Empty?displayProperty=nameWithType>), debe ser una referencia a esta misma instancia, o debe coincidir con el principio de esta instancia.  
  
 Este método realiza una comparación con la grafía especificado y la referencia cultural.  
  
   
  
## Examples  
 El ejemplo siguiente determina si se produce una cadena al principio de otra cadena. El <xref:System.String.StartsWith%2A> se llama al método varias veces utilizando diferentes referencias culturales que influyen en los resultados de la búsqueda, distingue mayúsculas de minúsculas y mayúsculas y minúsculas.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera una subcadena de la instancia.  
  
Este miembro está sobrecargado. Para obtener información completa sobre este miembro, incluida la sintaxis, el uso y algunos ejemplos, haga clic en un nombre de la lista de sobrecarga.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Index) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : Index -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posición de carácter inicial de base cero de una subcadena en la instancia.</param>
        <summary>Recupera una subcadena de la instancia. La subcadena empieza en una posición de caracteres especificada y continúa hasta el final de la cadena.</summary>
        <returns>Cadena equivalente a la subcadena que comienza en el valor de <paramref name="startIndex" /> de esta instancia, o bien, <see cref="F:System.String.Empty" /> si el valor de <paramref name="startIndex" /> es igual a la longitud de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a la <xref:System.String.Substring%28System.Int32%29> método para extraer una subcadena de una cadena que comienza en una posición de carácter especificado y termina al final de la cadena. La posición del carácter inicial está basado en cero; en otras palabras, el primer carácter de la cadena está en el índice 0, no el índice 1. Para extraer una subcadena que comienza en una posición de carácter especificado y termina antes del final de la cadena, llame a la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena que comienza en la `startIndex` posición en la cadena actual.  
  
 Para extraer una subcadena que comienza con un determinado carácter o secuencia de caracteres, llamar a un método como <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> para obtener el valor de `startIndex`. El segundo ejemplo muestra cómo hacerlo; extrae un valor de clave que se inicia una posición de carácter después del carácter "=".  
  
 Si `startIndex` es igual a cero, el método devuelve la cadena original sin cambios.  
   
  
## Examples  
 El ejemplo siguiente muestra cómo obtener una subcadena de una cadena.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 En el ejemplo siguiente se usa el <xref:System.String.Substring%2A> método para separar los pares clave-valor que están delimitados por es igual a carácter ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 El <xref:System.String.IndexOf%2A> método se usa para obtener la posición del carácter es igual a en la cadena. La llamada a la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método extrae el nombre de clave, que se inicia desde el primer carácter de la cadena y amplía el número de caracteres devueltos por la llamada a la <xref:System.String.IndexOf%2A> método. La llamada a la <xref:System.String.Substring%28System.Int32%29> método, a continuación, extrae el valor asignado a la clave. Se inicia en una posición de caracteres situados después del carácter es igual a y se extiende hasta el final de la cadena.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Range range);" />
      <MemberSignature Language="F#" Value="member this.Substring : Range -&gt; string" Usage="string.Substring range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posición de carácter inicial de base cero de una subcadena en la instancia.</param>
        <param name="length">Número de caracteres de la subcadena.</param>
        <summary>Recupera una subcadena de la instancia. La subcadena comienza en una posición de carácter especificada y tiene una longitud especificada.</summary>
        <returns>Cadena equivalente a la subcadena de longitud de <paramref name="length" /> que comienza en el valor de <paramref name="startIndex" /> de esta instancia, o bien, <see cref="F:System.String.Empty" /> si el valor de <paramref name="startIndex" /> es igual a la longitud de esta instancia y el valor de <paramref name="length" /> es cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método para extraer una subcadena de una cadena que comienza en una posición de carácter especificado y termina antes del final de la cadena. La posición del carácter inicial está basado en cero; en otras palabras, el primer carácter de la cadena está en el índice 0, no el índice 1. Para extraer una subcadena que comienza en una posición de carácter especificada y continúa hasta el final de la cadena, llame a la <xref:System.String.Substring%28System.Int32%29> método.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena con `length` caracteres a partir de la `startIndex` posición en la cadena actual.  
  
 El `length` parámetro representa el número total de caracteres que se va a extraer de la instancia actual de la cadena. Esto incluye el carácter inicial que se encuentra en el índice `startIndex`.  En otras palabras, el <xref:System.String.Substring%2A> método intenta extraer caracteres de índice `startIndex` al índice `startIndex`  +  `length` - 1.  
  
 Para extraer una subcadena que comienza con un determinado carácter o secuencia de caracteres, llamar a un método como <xref:System.String.IndexOf%2A> o <xref:System.String.LastIndexOf%2A> para obtener el valor de `startIndex`.  
  
 Si la subcadena que se extiende desde `startIndex` a una secuencia de caracteres especificado, se puede llamar a un método como <xref:System.String.IndexOf%2A> o <xref:System.String.LastIndexOf%2A> para obtener el índice del carácter final o la secuencia de caracteres.  A continuación, puede convertir ese valor a una posición de índice en la cadena como sigue:  
  
-   Si ha buscado para un único carácter que va a marcar el final de la subcadena, el `length` parámetro es igual a `endIndex`  -  `startIndex` + 1, donde `endIndex` es el valor devuelto de la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> método. El ejemplo siguiente extrae un bloque continuo de los caracteres "b" de una cadena.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Si ha buscado para varios caracteres que son marcar el final de la subcadena, el `length` parámetro es igual a `endIndex`  +  `endMatchLength`  -  `startIndex`, donde `endIndex` es el valor devuelto de la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> método, y `endMatchLength` es la longitud de la secuencia de caracteres que marca el final de la subcadena. En el ejemplo siguiente se extrae un bloque de texto que contiene un documento XML `<definition>` elemento.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Si no se incluye el carácter o secuencia de caracteres al final de la subcadena, el `length` parámetro es igual a `endIndex`  -  `startIndex`, donde `endIndex` es el valor devuelto de la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> método.  
  
 Si `startIndex` es igual a cero y es igual a la longitud de la cadena actual, el método devuelve la cadena original sin cambios.  
  
   
  
## Examples  
 El ejemplo siguiente muestra una llamada sencilla a la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método que extrae los dos caracteres de una cadena a partir de la sexta posición de carácter (es decir, en el índice cinco).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 En el ejemplo siguiente se usa el <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método en los tres casos siguientes para aislar las subcadenas dentro de una cadena. En dos casos se usan las subcadenas en las comparaciones y en el tercer caso se produce una excepción porque se especificaron parámetros no válidos.  
  
-   Extrae el carácter único y la tercera posición en la cadena (en el índice 2) y lo compara con una "c". Esta comparación devuelve `true`.  
  
-   Extrae cero caracteres a partir de la cuarta posición de la cadena (en el índice 3) y lo pasa a la <xref:System.String.IsNullOrEmpty%2A> método. Esto devuelve true porque la llamada a la <xref:System.String.Substring%2A> devuelve del método <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Intenta extraer un carácter que comienza en la cuarta posición de la cadena. Dado que no hay ningún carácter en esa posición, la llamada al método produce una <xref:System.ArgumentOutOfRangeException> excepción.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 En el ejemplo siguiente se usa el <xref:System.String.Substring%2A> método para separar los pares clave-valor que están delimitados por es igual a carácter ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 El <xref:System.String.IndexOf%2A> método se usa para obtener la posición del carácter es igual a en la cadena. La llamada a la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método extrae el nombre de clave, que se inicia desde el primer carácter de la cadena y amplía el número de caracteres devueltos por la llamada a la <xref:System.String.IndexOf%2A> método. La llamada a la <xref:System.String.Substring%28System.Int32%29> método, a continuación, extrae el valor asignado a la clave. Se inicia en una posición de caracteres situados después del carácter es igual a y se extiende hasta el final de la cadena.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> más <paramref name="length" /> indica una posición fuera de esta instancia.  
  
O bien 
 <paramref name="startIndex" /> o <paramref name="length" /> es menor que cero.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración el objeto <see cref="T:System.String" /> actual.</summary>
        <returns>Enumerador fuertemente tipado que se puede usar para iterar por el objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Puede usarse solo cuando la <xref:System.String> instancia se convierte en un <xref:System.Collections.Generic.IEnumerable%601> objeto de interfaz. Para obtener más información, vea el método <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración el objeto <see cref="T:System.String" /> actual.</summary>
        <returns>Enumerador que se puede usar para iterar por la cadena actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.Collections.IEnumerable>. Para obtener más información, vea el método <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" /> si el valor de la cadena actual es <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> si el valor de la cadena actual es <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">El valor de la cadena actual no es <see cref="F:System.Boolean.TrueString" /> o <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">El valor del objeto actual <see cref="T:System.String" /> no se puede analizar.</exception>
        <exception cref="T:System.OverflowException">El valor del objeto <see cref="T:System.String" /> actual es un número mayor de <see cref="F:System.Byte.MaxValue" /> o menor que <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Carácter en el índice 0 del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">El valor del objeto actual <see cref="T:System.String" /> no se puede analizar.</exception>
        <exception cref="T:System.OverflowException">El valor del objeto <see cref="T:System.String" /> actual es un número menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">El valor del objeto actual <see cref="T:System.String" /> no se puede analizar.</exception>
        <exception cref="T:System.OverflowException">El valor del objeto <see cref="T:System.String" /> actual es un número menor de <see cref="F:System.Double.MinValue" /> o mayor que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">El valor del objeto actual <see cref="T:System.String" /> no se puede analizar.</exception>
        <exception cref="T:System.OverflowException">El valor del objeto <see cref="T:System.String" /> actual es un número mayor de <see cref="F:System.Int16.MaxValue" /> o menor que <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">El valor del objeto actual <see cref="T:System.String" /> no se puede analizar.</exception>
        <exception cref="T:System.OverflowException">El valor del objeto <see cref="T:System.String" /> actual es un número mayor de <see cref="F:System.SByte.MaxValue" /> o menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del objeto devuelto.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ChangeType%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">El valor del objeto <see cref="T:System.String" /> actual no se puede convertir al tipo especificado por el parámetro <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">El valor del objeto actual <see cref="T:System.String" /> no se puede analizar.</exception>
        <exception cref="T:System.OverflowException">El valor del objeto <see cref="T:System.String" /> actual es un número mayor de <see cref="F:System.UInt16.MaxValue" /> o menor que <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">El valor del objeto actual <see cref="T:System.String" /> no se puede analizar.</exception>
        <exception cref="T:System.OverflowException">El valor del objeto <see cref="T:System.String" /> actual es un número mayor que <see cref="F:System.UInt32.MaxValue" /> o menor que <see cref="F:System.UInt32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.String" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.String> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia los caracteres de la instancia en una matriz de caracteres Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia los caracteres de la instancia en una matriz de caracteres Unicode.</summary>
        <returns>Matriz de caracteres Unicode cuyos elementos son los caracteres individuales de la instancia. Si la instancia es una cadena vacía, la matriz devuelta es una matriz vacía y su longitud es nula.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia cada carácter (es decir, cada uno de ellos <xref:System.Char> objeto) en una cadena a una matriz de caracteres. Es el primer carácter que se copian en el índice cero de la matriz de caracteres devueltos; el último carácter copiado está en el índice <xref:System.Array.Length%2A?displayProperty=nameWithType> - 1.  
  
 Para crear una cadena de los caracteres en una matriz de caracteres, llame a la <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor.  
  
 Para crear una matriz de bytes que contiene los caracteres codificados en una cadena, cree una instancia adecuado <xref:System.Text.Encoding> objeto y llamar a su <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> método. Algunas de las codificaciones estándares disponibles en .NET incluyen lo siguiente:  
  
|Codificación|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Para obtener más información, consulte [codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.String.ToCharArray%2A> método para extraer los caracteres de una cadena en una matriz de caracteres. A continuación, se muestra la cadena original y los elementos de la matriz.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 El ejemplo siguiente define una cadena que contiene los caracteres que actúan como delimitadores en una cadena delimitada. A continuación, llama el <xref:System.String.ToCharArray%2A> método para crear una matriz de caracteres que se puede pasar a la <xref:System.String.Split%28System.Char%5B%5D%29> método para separar la cadena delimitada en sus subcadenas individuales.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posición inicial de una subcadena en la instancia.</param>
        <param name="length">Longitud de la subcadena en la instancia.</param>
        <summary>Copia los caracteres de una subcadena especificada de la instancia en una matriz de caracteres Unicode.</summary>
        <returns>Matriz de caracteres Unicode cuyos elementos son el número de caracteres de la instancia especificado en <paramref name="length" /> a partir de la posición de carácter <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia los caracteres en una parte de una cadena en una matriz de caracteres. Para crear una cadena de un intervalo de caracteres en una matriz de caracteres, llame a la <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor.  
  
 El `startIndex` parámetro está basado en cero. Es decir, el índice del primer carácter en la instancia de cadena es cero.  
  
 Si `length` es cero, la matriz devuelta está vacía y tiene una longitud cero. Si esta instancia es `null` o una cadena vacía (""), la matriz devuelta está vacía y tiene una longitud cero.  
  
 Para crear una matriz de bytes que contiene los caracteres codificados en una parte de una cadena, cree una instancia adecuado <xref:System.Text.Encoding> objeto y llamar a su <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> método. Algunas de las codificaciones estándares disponibles en .NET incluyen:  
  
|Codificación|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Para obtener más información, consulte [codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 El ejemplo siguiente convierte una subcadena dentro de una cadena en una matriz de caracteres, a continuación, enumera y muestra los elementos de la matriz.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> o <paramref name="length" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> más <paramref name="length" /> es mayor que la longitud de esta instancia.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una copia de esta cadena convertida en minúsculas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una copia de esta cadena convertida en minúsculas.</summary>
        <returns>Una cadena en minúsculas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método tiene en cuenta las reglas de mayúsculas y minúsculas de la referencia cultural actual.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en el que todos los caracteres de la instancia actual se convierten a minúsculas.  
  
## <a name="security-considerations"></a>Consideraciones de seguridad  
 La operación de mayúsculas y minúsculas que se obtiene al llamar a la <xref:System.String.ToLower> método toma las convenciones de mayúsculas y minúsculas de la referencia cultural actual en la cuenta. Si necesita la versión en mayúsculas o minúsculas de un identificador de sistema operativo, como un nombre de archivo, denominado canalización o la clave del registro, use el <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> métodos. Esto produce el mismo resultado en todas las referencias culturales (a diferencia de la <xref:System.String.ToLower> método) y realiza de forma más eficaz.  
  
   
  
## Examples  
 El ejemplo siguiente convierte varias cadenas mixtas de mayúsculas a minúsculas.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de mayúsculas y minúsculas de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para convertir un carácter a minúsculas mediante las convenciones de mayúsculas y minúsculas de la referencia cultural actual, llame a la <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> sobrecarga del método con un valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para su <paramref name="culture" /> parámetro.</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Objeto que proporciona reglas de mayúsculas y minúsculas específicas de la referencia cultural.</param>
        <summary>Devuelve una copia de esta cadena convertida en minúsculas, aplicando las reglas de mayúsculas y minúsculas de la referencia cultural especificada.</summary>
        <returns>Equivalente en minúsculas de la cadena actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las reglas de mayúsculas y minúsculas de la referencia cultural especificada por el `culture` parámetro determinan la forma en el caso de la cadena ha cambiado.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en el que todos los caracteres de la instancia actual se convierten a minúsculas.  
  
## <a name="security-considerations"></a>Consideraciones de seguridad  
 Si se pasa el <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> método un <xref:System.Globalization.CultureInfo> objeto distinto <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, la operación de mayúsculas y minúsculas tendrá reglas específicas de la referencia cultural en la cuenta. Si necesita la versión en mayúsculas o minúsculas de un identificador de sistema operativo, como un nombre de archivo, denominado canalización o la clave del registro, use el <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> método. Esto produce el mismo resultado en todas las referencias culturales y se realiza de forma más eficaz.  
  
   
  
## Examples  
 El ejemplo siguiente convierte dos cadenas de caracteres en mayúsculas a minúsculas usando las referencias culturales de inglés de Estados Unidos y Turco-Turquía y, luego, compara las cadenas en minúsculas. Las cadenas en mayúsculas son idénticas salvo que cada aparición del Unicode LATÍN letra mayúscula I en una cadena, la otra cadena contiene letra mayúscula de LATÍN I con un punto encima.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una copia de este objeto <see cref="T:System.String" /> convertido en minúsculas, aplicando las reglas de mayúsculas y minúsculas de la referencia cultural de todos los idiomas.</summary>
        <returns>Equivalente en minúsculas de la cadena actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La referencia cultural invariable representa una referencia cultural que no tiene en cuenta la referencia cultural. Está asociado con el idioma inglés, pero no con un país o región determinados. Para obtener más información, vea la propiedad <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Si depende de la aplicación en el caso de una cadena cambien de forma predecible que se ve afectada por la referencia cultural actual, use el <xref:System.String.ToLowerInvariant%2A> método. El <xref:System.String.ToLowerInvariant%2A> método es equivalente a `ToLower(CultureInfo.InvariantCulture)`. El método se recomienda cuando una colección de cadenas debe aparecer en un orden predecible en un control de interfaz de usuario.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en el que todos los caracteres de la instancia actual se convierten a minúsculas.  
  
## <a name="security-considerations"></a>Consideraciones de seguridad  
 Si necesita la versión en mayúsculas o minúsculas de un identificador de sistema operativo, como un nombre de archivo, denominado canalización o la clave del registro, use el <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> métodos.  
  
   
  
## Examples  
 El ejemplo siguiente define una matriz de cadenas que contiene una palabra única en varios idiomas. El <xref:System.String.ToLowerInvariant%2A> método se usa para rellenar los elementos de una matriz paralela con la versión de mayúsculas y minúsculas de cada palabra. El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método se utiliza para ordenar la matriz entre mayúsculas y minúsculas, según el orden de elementos de la matriz en minúsculas para garantizar que los elementos aparecen en el mismo orden, independientemente del lenguaje.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor de la instancia en un objeto <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la instancia de <see cref="T:System.String" />; no se efectúa una conversión real.</summary>
        <returns>Cadena actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que este método simplemente devuelve la cadena actual sin modificar, no hay ninguna necesidad de llamar directamente a. Normalmente, se llama implícitamente en un operación, como se muestra en el ejemplo de formato compuesto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.String.ToString%2A> método. Tenga en cuenta que el ejemplo no llamar explícitamente la <xref:System.String.ToString%2A> método. En su lugar, el método se llama de forma implícita el [formatos compuestos](~/docs/standard/base-types/composite-formatting.md) característica.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">(Reservado) Un objeto que aporta información de formato específica de la referencia cultural.</param>
        <summary>Devuelve la instancia de <see cref="T:System.String" />; no se efectúa una conversión real.</summary>
        <returns>Cadena actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` está reservado y no participa actualmente en esta operación.  
  
 Dado que este método simplemente devuelve la cadena actual sin modificar, no hay ninguna necesidad de llamar directamente a.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una copia de esta cadena convertida en mayúsculas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una copia de esta cadena convertida en mayúsculas.</summary>
        <returns>Equivalente en mayúsculas de la cadena actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa las reglas de mayúsculas y minúsculas de la referencia cultural actual para convertir cada carácter en la instancia actual en su equivalente en mayúsculas. Si un carácter no tiene un equivalente en mayúsculas, se incluye sin cambios en la cadena devuelta.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en el que todos los caracteres de la instancia actual se convierten a mayúsculas.  
  
 El <xref:System.String.ToUpper%2A> a menudo se usa el método para convertir una cadena a mayúsculas para que se puede utilizar en una comparación entre mayúsculas y minúsculas. Un método mejor para realizar una comparación entre mayúsculas y minúsculas es llamar a un método de comparación de cadenas que tiene un <xref:System.StringComparison> parámetro cuyo valor se establece en <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> para ver una comparación entre mayúsculas y minúsculas, de la referencia cultural.  
  
## <a name="security-considerations"></a>Consideraciones de seguridad  
 La operación de mayúsculas y minúsculas que se obtiene al llamar a la <xref:System.String.ToUpper> método toma las convenciones de mayúsculas y minúsculas de la referencia cultural actual en la cuenta. Si necesita la versión en mayúsculas o minúsculas de un identificador de sistema operativo, como un nombre de archivo, denominado canalización o la clave del registro, use el <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> método. Esto produce el mismo resultado en todas las referencias culturales (a diferencia de la <xref:System.String.ToUpper> método) y realiza de forma más eficaz.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.String.ToUpper%2A> método para convertir una serie de cadenas de caracteres de uno que contenga cada carácter en los conjuntos de caracteres extendido-A Latín básico, suplemento de Latín-1 y latino. A continuación, se muestra cada cadena cuyos caracteres en mayúsculas es diferente de su carácter en minúscula.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de mayúsculas y minúsculas de cadenas que sustituyen los valores predeterminados y en su lugar, llame a métodos que requieren parámetros para especificarse explícitamente. Para convertir una cadena a mayúsculas mediante las convenciones de mayúsculas y minúsculas de la referencia cultural actual, llame a la <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> sobrecarga del método con un valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para su <paramref name="culture" /> parámetro.</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Objeto que proporciona reglas de mayúsculas y minúsculas específicas de la referencia cultural.</param>
        <summary>Devuelve una copia de esta cadena convertida en mayúsculas, aplicando las reglas de mayúsculas y minúsculas de la referencia cultural especificada.</summary>
        <returns>Equivalente en mayúsculas de la cadena actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las reglas de mayúsculas y minúsculas de la referencia cultural especificada por el `culture` parámetro determinar se cambia la forma en el caso de una cadena.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en el que todos los caracteres de la instancia actual se convierten a mayúsculas.  
  
## <a name="security-considerations"></a>Consideraciones de seguridad  
 Si se pasa el <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> método un <xref:System.Globalization.CultureInfo> objeto distinto <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, la operación de mayúsculas y minúsculas tendrá reglas específicas de la referencia cultural en la cuenta. Si necesita la versión en mayúsculas o minúsculas de un identificador de sistema operativo, como un nombre de archivo, denominado canalización o la clave del registro, use el <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> método. Esto produce el mismo resultado en todas las referencias culturales y se realiza de forma más eficaz.  
  
   
  
## Examples  
 El ejemplo siguiente convierte una cadena de caracteres en minúsculas en dos cadenas de caracteres en mayúsculas utilizando las referencias culturales de inglés de Estados Unidos y Turco-Turquía y, luego, compara las cadenas en mayúsculas. Las cadenas en mayúsculas son idénticas salvo que cada aparición del Unicode LATÍN letra mayúscula I en una cadena, la otra cadena contiene letra mayúscula de LATÍN I con un punto encima.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una copia de este objeto <see cref="T:System.String" /> convertido en mayúsculas, aplicando las reglas de mayúsculas y minúsculas de la referencia cultural de todos los idiomas.</summary>
        <returns>Equivalente en mayúsculas de la cadena actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La referencia cultural invariable representa una referencia cultural que no tiene en cuenta la referencia cultural. Está asociado con el idioma inglés, pero no con un país o región determinados. Para obtener más información, vea la propiedad <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Si depende de la aplicación en el caso de una cadena cambien de forma predecible que se ve afectada por la referencia cultural actual, use el <xref:System.String.ToUpperInvariant%2A> método. El <xref:System.String.ToUpperInvariant%2A> método es equivalente a `ToUpper(CultureInfo.InvariantCulture)`. El método se recomienda cuando una colección de cadenas debe aparecer en un orden predecible en un control de interfaz de usuario.  
  
> [!NOTE]
>  Este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en el que todos los caracteres de la instancia actual se convierten a mayúsculas.  
  
## <a name="security-considerations"></a>Consideraciones de seguridad  
 Si necesita la versión en mayúsculas o minúsculas de un identificador de sistema operativo, como un nombre de archivo, denominado canalización o la clave del registro, use el <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> métodos.  
  
   
  
## Examples  
 El ejemplo siguiente define una matriz de cadenas que contiene una palabra única en varios idiomas. El <xref:System.String.ToUpperInvariant%2A> método se usa para rellenar los elementos de una matriz paralela con la versión de mayúsculas y minúsculas de cada palabra. El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método se utiliza para ordenar la matriz entre mayúsculas y minúsculas, según el orden de elementos de la matriz en mayúsculas para asegurarse de que los elementos aparecen en el mismo orden con independencia de lenguaje.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una nueva cadena en la que se han quitado todas las apariciones interlineadas y finales de un conjunto de caracteres especificados en el objeto <see cref="T:System.String" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los caracteres de espacio en blanco del principio y el final del objeto <see cref="T:System.String" /> actual.</summary>
        <returns>Cadena que queda una vez quitados todos los caracteres de espacio en blanco del principio y el final de la cadena actual. Si no se puede quitar ningún carácter de la instancia actual, el método devuelve la instancia actual sin cambios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.Trim%2A> método quita de la cadena actual todos los caracteres de espacio en blanco iniciales y finales. Cada operación de recorte inicial y final se detiene cuando se encuentra un carácter que no sea un espacio en blanco. Por ejemplo, si la cadena actual es "abc xyz", el <xref:System.String.Trim%2A> método devuelve "abc xyz". Para quitar los caracteres de espacio en blanco entre las palabras en una cadena, use [expresiones regulares de .NET](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Si el <xref:System.String.Trim%2A> método quita los caracteres de la instancia actual, este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en la que se quitan todos los caracteres de espacio en blanco iniciales y finales que se encuentra en la instancia actual.  
  
 Si la cadena actual es igual a <xref:System.String.Empty> o constan de todos los caracteres de la instancia actual de caracteres de espacio en blanco, el método devuelve <xref:System.String.Empty>.  
  
 Caracteres de espacio en blanco se definen en el estándar Unicode. El <xref:System.String.Trim> método quita los caracteres iniciales y finales que generan un valor devuelto de `true` cuando se pasa a la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.String.Trim?displayProperty=nameWithType> método para quitar los espacios en blanco adicional de las cadenas especificadas por el usuario antes de concatenarlas todas.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>El [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores mantienen una lista interna de caracteres de espacio en blanco que recorta este método. A partir de la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el método recorta todos los caracteres de espacio en blanco de Unicode (es decir, los caracteres que producen un <see langword="true" /> valor devuelto cuando se pasan a la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Debido a este cambio, el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores se quitan dos caracteres, espacio de ancho cero (200B) y el espacio de NO separación de ancho cero (U+FEFF), que el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]y versiones posteriores No quitar. Además, el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores no recorta los tres caracteres de espacio en blanco de Unicode: SEPARADOR de vocal mongol (180E), espacio de NO separación estrecha (202F) y espacio matemático intermedio (205F).</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Matriz de caracteres Unicode que se van a quitar, o <see langword="null" />.</param>
        <summary>Quita todas las apariciones del principio y el final de un conjunto de caracteres especificados en una matriz del objeto <see cref="T:System.String" /> actual.</summary>
        <returns>Cadena que queda una vez quitadas todas las apariciones de los caracteres especificados por el parámetro <paramref name="trimChars" /> del principio y del final de la cadena actual. Si <paramref name="trimChars" /> es <see langword="null" /> o una matriz vacía, se quitarán los caracteres de espacio en blanco. Si no se puede quitar ningún carácter de la instancia actual, el método devuelve la instancia actual sin cambios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.Trim%2A> método quita de la cadena actual todos los caracteres iniciales y finales que se encuentran en el `trimChars` parámetro. Cada iniciales y finales se detenga cuando un carácter que no esté en la operación de recorte `trimChars` se encuentra. Por ejemplo, si la cadena actual es "123abc456xyz789" y `trimChars` contiene los dígitos de "1" al "9", el <xref:System.String.Trim%2A> método devuelve "abc456xyz".  
  
> [!NOTE]
>  Si el <xref:System.String.Trim%2A> método quita los caracteres de la instancia actual, este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en el que todos los iniciales y finales `trimChars` se quitan los caracteres que se encuentran en la instancia actual.  
  
 Si la cadena actual es igual a <xref:System.String.Empty> o constan de todos los caracteres de la instancia actual de caracteres de la `trimChars` de matriz, el método devuelve <xref:System.String.Empty>.  
  
 Si `trimChars` es `null` o una matriz vacía, este método quita los caracteres iniciales o finales que dar lugar a la devolución del método `true` cuando se pasa a la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método,  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> método para quitar caracteres de apóstrofo ('), asterisco (*) y espacio de una cadena.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>El [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores se mantiene una lista interna de caracteres de espacio en blanco que recorta este método si <paramref name="trimChars" /> es <see langword="null" /> o una matriz vacía. A partir de la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]si <paramref name="trimChars" /> es <see langword="null" /> o una matriz vacía, el método recorta todos los caracteres de espacio en blanco de Unicode (es decir, los caracteres que producen un <see langword="true" /> valor devuelto cuando se pasan a la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Debido a este cambio, el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores se quitan dos caracteres, espacio de ancho cero (200B) y el espacio de NO separación de ancho cero (U+FEFF), que el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]y versiones posteriores No quitar. Además, el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores no recorta los tres caracteres de espacio en blanco de Unicode: SEPARADOR de vocal mongol (180E), espacio de NO separación estrecha (202F) y espacio matemático intermedio (205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Matriz de caracteres Unicode que se van a quitar, o <see langword="null" />.</param>
        <summary>Quita todas las apariciones del final de un conjunto de caracteres especificados en una matriz del objeto <see cref="T:System.String" /> actual.</summary>
        <returns>Cadena que queda una vez quitadas todas las apariciones de los caracteres especificados por el parámetro <paramref name="trimChars" /> del final de la cadena actual. Si <paramref name="trimChars" /> es <see langword="null" /> o una matriz vacía, se quitarán los caracteres de espacio en blanco de Unicode. Si no se puede quitar ningún carácter de la instancia actual, el método devuelve la instancia actual sin cambios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.TrimEnd%2A> método quita de la cadena actual todos los caracteres finales que se encuentran en el `trimChars` parámetro. La operación de recorte se detiene cuando el primer carácter que no está en `trimChars` se encuentra al final de la cadena. Por ejemplo, si la cadena actual es "123abc456xyz789" y `trimChars` contiene los dígitos de "1" al "9", el <xref:System.String.TrimEnd%2A> método devuelve "123abc456xyz".  
  
> [!NOTE]
>  Si el <xref:System.String.TrimEnd%2A> método quita los caracteres de la instancia actual, este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en que al final de todos los caracteres que se encuentren en `trimChars` se quitan de la cadena actual.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo puede usar el <xref:System.String.TrimEnd%28System.Char%5B%5D%29> método recortar espacios en blanco o signos de puntuación del final de una cadena.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>El [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores se mantiene una lista interna de caracteres de espacio en blanco que recorta este método si <paramref name="trimChars" /> es <see langword="null" /> o una matriz vacía. A partir de la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]si <paramref name="trimChars" /> es <see langword="null" /> o una matriz vacía, el método recorta todos los caracteres de espacio en blanco de Unicode (es decir, los caracteres que producen un <see langword="true" /> valor devuelto cuando se pasan a la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Debido a este cambio, el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores se quitan dos caracteres, espacio de ancho cero (200B) y el espacio de NO separación de ancho cero (U+FEFF), que el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] y versiones posteriores No quitar. Además, el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores no recorta los tres caracteres de espacio en blanco de Unicode: SEPARADOR de vocal mongol (180E), espacio de NO separación estrecha (202F) y espacio matemático intermedio (205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Matriz de caracteres Unicode que se van a quitar, o <see langword="null" />.</param>
        <summary>Quita todas las apariciones del principio de un conjunto de caracteres especificados en una matriz del objeto <see cref="T:System.String" /> actual.</summary>
        <returns>Cadena que queda una vez quitadas todas las apariciones de los caracteres especificados por el parámetro <paramref name="trimChars" /> del principio de la cadena actual. Si <paramref name="trimChars" /> es <see langword="null" /> o una matriz vacía, se quitarán los caracteres de espacio en blanco.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.String.TrimStart%2A> método quita de la cadena actual todos los caracteres iniciales que se encuentran en el `trimChars` parámetro. La operación de recorte se detiene cuando un carácter que no esté en `trimChars` se encuentra. Por ejemplo, si la cadena actual es "123abc456xyz789" y `trimChars` contiene los dígitos de "1" al "9", el <xref:System.String.TrimStart%2A> método devuelve "abc456xyz789".  
  
> [!NOTE]
>  Si el <xref:System.String.TrimStart%2A> método quita los caracteres de la instancia actual, este método no modifica el valor de la instancia actual. En su lugar, devuelve una nueva cadena en la que se quitan todos los caracteres de espacio en blanco iniciales se encuentra en la instancia actual.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la funcionalidad básica de la <xref:System.String.TrimStart%2A> método:

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 En el ejemplo siguiente se usa el <xref:System.String.TrimStart%2A> método recortar espacios en blanco y caracteres de comentario de las líneas de código fuente. El `StripComments` método ajusta una llamada a <xref:System.String.TrimStart%2A> y lo pasa una matriz de caracteres que contiene un espacio y el carácter de comentario, que es el apóstrofo (') en Visual Basic y una barra diagonal (/) en C#. El <xref:System.String.TrimStart%2A> también se llama el método para quitar el espacio en blanco inicial al evaluar si una cadena es un comentario.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 En el ejemplo siguiente se muestra la llamada al método `StripComments`.  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>El [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores se mantiene una lista interna de caracteres de espacio en blanco que recorta este método si <paramref name="trimChars" /> es <see langword="null" /> o una matriz vacía. A partir de la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]si <paramref name="trimChars" /> es <see langword="null" /> o una matriz vacía, el método recorta todos los caracteres de espacio en blanco de Unicode (es decir, los caracteres que producen un <see langword="true" /> valor devuelto cuando se pasan a la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Debido a este cambio, el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores se quitan dos caracteres, espacio de ancho cero (200B) y el espacio de NO separación de ancho cero (U+FEFF), que el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] y versiones posteriores No quitar. Además, el <see cref="M:System.String.Trim" /> método en el [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] y versiones anteriores no recorta los tres caracteres de espacio en blanco de Unicode: SEPARADOR de vocal mongol (180E), espacio de NO separación estrecha (202F) y espacio matemático intermedio (205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>