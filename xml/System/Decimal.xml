<Type Name="Decimal" FullName="System.Decimal">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="21d399bb6ab16180910e704f47a0a42624bfa5f7" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34255419" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Decimal : IComparable, IComparable&lt;decimal&gt;, IConvertible, IEquatable&lt;decimal&gt;, IFormattable, System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Decimal extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Decimal&gt;, class System.IConvertible, class System.IEquatable`1&lt;valuetype System.Decimal&gt;, class System.IFormattable, class System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="DocId" Value="T:System.Decimal" />
  <TypeSignature Language="VB.NET" Value="Public Structure Decimal&#xA;Implements IComparable, IComparable(Of Decimal), IConvertible, IDeserializationCallback, IEquatable(Of Decimal), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Decimal : IComparable, IComparable&lt;System::Decimal&gt;, IConvertible, IEquatable&lt;System::Decimal&gt;, IFormattable, System::Runtime::Serialization::IDeserializationCallback" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Decimal&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Decimal&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un número decimal.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal> tipo de valor representa números decimales comprendidos entre positivo 79,228,162,514,264,337,593,543,950,335 hasta el negativo 79,228,162,514,264,337,593,543,950,335. El valor predeterminado de un `Decimal` es 0. El <xref:System.Decimal> el tipo de valor es adecuado para realizar cálculos financieros que requieren gran número de dígitos enteros y fraccionarios significativos y no hay errores de redondeo. El <xref:System.Decimal> tipo no elimina la necesidad de redondeo. En su lugar, minimiza los errores debidos al redondeo. Por ejemplo, el código siguiente genera un resultado de 0,9999999999999999999999999999 en lugar de 1.  
  
 [!code-cpp[System.Decimal.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Class/cpp/decimal1.cpp#1)]
 [!code-csharp[System.Decimal.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Class/cs/DecimalDivision_46630_1.cs#1)]
 [!code-vb[System.Decimal.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Class/vb/DecimalDivision_46630_1.vb#1)]  
  
 Cuando se pasa el resultado de la división y multiplicación a la <xref:System.Math.Round%2A> método, el resultado sufre ninguna pérdida de precisión, como se muestra en el código siguiente.  
  
 [!code-cpp[System.Decimal.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Class/cpp/decimal2.cpp#2)]
 [!code-csharp[System.Decimal.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Class/cs/DecimalDivision_46630_1.cs#2)]
 [!code-vb[System.Decimal.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Class/vb/DecimalDivision_46630_1.vb#2)]  
  
 Un número decimal es un valor de punto flotante que consta de un inicio de sesión, un valor numérico, donde cada dígito en el valor comprendido entre 0 y 9 y un factor de escala que indica la posición de un punto decimal flotante que separa las partes enteros y fraccionarias del valor numérico.  
  
 La representación binaria de un <xref:System.Decimal> valor consta de un signo de 1 bit, un número entero de 96 bits y un factor de escala utilizado para dividir el entero de 96 bits y especificar qué parte de ella es una fracción decimal. El factor de escala es implícitamente el número 10 elevado a un exponente comprendido entre 0 y 28. Por lo tanto, la representación binaria de un <xref:System.Decimal> valor el formato ((-2<sup>96</sup> a 2<sup>96</sup>) / 10<sup>(de 0 a 28)</sup>), donde-(2<sup>96</sup>-1) es igual a <xref:System.Decimal.MinValue>y 2<sup>96</sup>-1 es igual a <xref:System.Decimal.MaxValue>. Para obtener más información acerca de la representación binaria del <xref:System.Decimal> valores y un ejemplo, vea el <xref:System.Decimal.%23ctor%28System.Int32%5B%5D%29> constructor y el <xref:System.Decimal.GetBits%2A> método.  
  
 El escalado también factor conserva cualquier finales ceros finales en un <xref:System.Decimal> número. Los ceros finales no afecta al valor de una <xref:System.Decimal> números en las operaciones de comparación o aritméticas. Sin embargo, los ceros finales podrían revelarse por la <xref:System.Decimal.ToString%2A> método si se aplica una cadena de formato adecuado.  
  
## <a name="conversion-considerations"></a>Consideraciones de conversión  
 Este tipo proporciona métodos que convierten <xref:System.Decimal> valores a y desde <xref:System.SByte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Byte>, <xref:System.UInt16>, <xref:System.UInt32>, y <xref:System.UInt64> valores. Conversiones de estos tipos enteros para <xref:System.Decimal> son conversiones de ampliación que nunca se pierden información ni se producen excepciones.  
  
 Conversiones de <xref:System.Decimal> a cualquiera de los tipos enteros son conversiones de restricción que redondean el <xref:System.Decimal> valor para el valor de entero más próximo a cero. Algunos lenguajes, como C#, también admiten la conversión de <xref:System.Decimal> valores <xref:System.Char> valores. Si el resultado de estas conversiones no se puede representar en el tipo de destino, un <xref:System.OverflowException> se produce la excepción.  
  
 El <xref:System.Decimal> tipo también proporciona métodos que convierten <xref:System.Decimal> valores a y desde <xref:System.Single> y <xref:System.Double> valores. Conversiones de <xref:System.Decimal> a <xref:System.Single> o <xref:System.Double> son conversiones de restricción que podrían perder precisión, pero no la información sobre la magnitud del valor convertido. La conversión no produce una excepción.  
  
 Conversiones de <xref:System.Single> o <xref:System.Double> a <xref:System.Decimal> producir una <xref:System.OverflowException> excepción si el resultado de la conversión no se puede representar como un <xref:System.Decimal>.  
  
## <a name="performing-operations-on-decimal-values"></a>Realizar operaciones en valores decimales  
 El <xref:System.Decimal> tipo es compatible con operaciones matemáticas estándares, como suma, resta, división, multiplicación y unario de negación. También puede trabajar directamente con la representación binaria de un <xref:System.Decimal> valor mediante una llamada a la <xref:System.Decimal.GetBits%2A> método.  
  
 Para comparar los dos <xref:System.Decimal> valores, puede usar los operadores de comparación numéricos estándar, o puede llamar a la <xref:System.Decimal.CompareTo%2A> o <xref:System.Decimal.Equals%2A> método.  
  
 También puede llamar a los miembros de la <xref:System.Math> clase para realizar una amplia variedad de operaciones numéricas, incluidos obtener el valor absoluto de un número, determinando el valor máximo o mínimo de dos <xref:System.Decimal> valores, obtener el signo de un número y un número de redondeo.  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Decimal>.  
  
 [!code-cpp[Decimal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#1)]
 [!code-csharp[Decimal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#1)]
 [!code-vb[Decimal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros de este tipo son seguros para subprocesos. Los miembros que aparecen modificar el estado de instancia realmente devuelven una nueva instancia inicializada con el nuevo valor. Como con cualquier otro tipo, leer y escribir en una variable compartida que contiene una instancia de este tipo deben protegerse mediante un bloqueo para garantizar la seguridad para subprocesos.</threadsafe>
    <altmember cref="T:System.SByte" />
    <altmember cref="T:System.Int16" />
    <altmember cref="T:System.Int32" />
    <altmember cref="T:System.Int64" />
    <altmember cref="T:System.Byte" />
    <altmember cref="T:System.UInt16" />
    <altmember cref="T:System.UInt32" />
    <altmember cref="T:System.UInt64" />
    <altmember cref="T:System.Single" />
    <altmember cref="T:System.Double" />
    <altmember cref="T:System.Char" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Decimal" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(double value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a representar como <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Decimal" /> en el valor del número de punto flotante de precisión doble especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor redondea `value` a 15 dígitos significativos mediante un redondeo al más cercano. Esto se hace incluso si el número tiene más de 15 dígitos y los dígitos menos significativos son iguales a cero.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea varias `Decimal` números utilizando la sobrecarga del constructor que inicializa un `Decimal` estructura con un <xref:System.Double> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Reals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CPP/ctordo.cpp#2)]
 [!code-csharp[System.Decimal.Ctor.Reals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CS/ctordo.cs#2)]
 [!code-vb[System.Decimal.Ctor.Reals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/VB/ctordo.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es mayor que <see cref="F:System.Decimal.MaxValue" /> o menor que <see cref="F:System.Decimal.MinValue" />.  -o bien- <paramref name="value" /> es <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a representar como <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Decimal" /> en el valor del entero de 32 bits con signo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea varias `Decimal` números utilizando la sobrecarga del constructor que inicializa un `Decimal` estructura con un <xref:System.Int32> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctori.cpp#1)]
 [!code-csharp[System.Decimal.Ctor.Ints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctori.cs#1)]
 [!code-vb[System.Decimal.Ctor.Ints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctori.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (int[] bits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32[] bits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bits As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(cli::array &lt;int&gt; ^ bits);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bits" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="bits">Matriz de enteros de 32 bits con signo que contiene una representación de un valor decimal.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Decimal" /> en un valor decimal representado en binario e incluido en una matriz especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación binaria de un <xref:System.Decimal> número se compone de un signo de 1 bit, un número entero de 96 bits y un factor de escala utilizado para dividir el número entero y especificar qué parte de ella es una fracción decimal. El factor de escala es implícitamente el número 10 elevado a un exponente comprendido entre 0 y 28.  
  
 `bits` es una matriz de longitud de cuatro elementos de enteros de 32 bits con signo.  
  
 `bits` [0], `bits` [1] y `bits` [2] contienen los 32 bits bajos, medio y altos del número entero de 96 bits.  
  
 `bits` [3] contiene el factor de escala y el signo y consta de las siguientes partes:  
  
 Los bits 0 y 15, la palabra inferior, no se utilizan y deben ser cero.  
  
 Los bits del 16 al 23 deben contener a un exponente entre 0 y 28, que indica la potencia de 10 para dividir el número entero.  
  
 Los bits 24 a 30 no se utilizan y deben ser cero.  
  
 El bit 31 contiene el signo; 0 significa positivo y 1 significa negativo.  
  
 Un valor numérico podría tener varias representaciones binarias; todas son igualmente válidas y numéricamente equivalentes. Tenga en cuenta que la representación de bits se distingue entre cero positivo y negativo. Estos valores se tratan como si fueran iguales en todas las operaciones.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea varias `Decimal` números utilizando la sobrecarga del constructor que inicializa un `Decimal` estructura con una matriz de cuatro <xref:System.Int32> valores.  
  
 [!code-cpp[System.Decimal.Ctor.Arrays#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CPP/ctoriarr.cpp#1)]
 [!code-csharp[System.Decimal.Ctor.Arrays#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CS/ctoriarr.cs#1)]
 [!code-vb[System.Decimal.Ctor.Arrays#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/VB/ctoriarr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bits" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="bits" /> no es 4.  -o bien- La representación del valor decimal en <paramref name="bits" /> no es válida.</exception>
        <altmember cref="M:System.Decimal.GetBits(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a representar como <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Decimal" /> en el valor del entero de 64 bits con signo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea varias `Decimal` números utilizando la sobrecarga del constructor que inicializa un `Decimal` estructura con un <xref:System.Int64> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctorl.cpp#3)]
 [!code-csharp[System.Decimal.Ctor.Ints#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctorl.cs#3)]
 [!code-vb[System.Decimal.Ctor.Ints#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctorl.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(float value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a representar como <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Decimal" /> en el valor del número de punto flotante de precisión sencilla especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor redondea `value` a 7 dígitos significativos mediante un redondeo al más próximo. Esto se hace incluso si el número tiene más de 7 dígitos y los dígitos menos significativos son iguales a cero.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea varias `Decimal` números utilizando la sobrecarga del constructor que inicializa un `Decimal` estructura con un <xref:System.Single> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Reals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CPP/ctors.cpp#1)]
 [!code-csharp[System.Decimal.Ctor.Reals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CS/ctors.cs#1)]
 [!code-vb[System.Decimal.Ctor.Reals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/VB/ctors.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es mayor que <see cref="F:System.Decimal.MaxValue" /> o menor que <see cref="F:System.Decimal.MinValue" />.  -o bien- <paramref name="value" /> es <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> o <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(System::UInt32 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a representar como <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Decimal" /> en el valor del entero de 32 bits sin signo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea varias `Decimal` números utilizando la sobrecarga del constructor que inicializa un `Decimal` estructura con un <xref:System.UInt32> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctorui.cpp#2)]
 [!code-csharp[System.Decimal.Ctor.Ints#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctorui.cs#2)]
 [!code-vb[System.Decimal.Ctor.Ints#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctorui.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(System::UInt64 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a representar como <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Decimal" /> en el valor del entero de 64 bits sin signo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea varias `Decimal` números utilizando la sobrecarga del constructor que inicializa un `Decimal` estructura con un <xref:System.UInt64> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctorul.cpp#4)]
 [!code-csharp[System.Decimal.Ctor.Ints#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctorul.cs#4)]
 [!code-vb[System.Decimal.Ctor.Ints#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctorul.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (int lo, int mid, int hi, bool isNegative, byte scale);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 lo, int32 mid, int32 hi, bool isNegative, unsigned int8 scale) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (lo As Integer, mid As Integer, hi As Integer, isNegative As Boolean, scale As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(int lo, int mid, int hi, bool isNegative, System::Byte scale);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="lo" Type="System.Int32" />
        <Parameter Name="mid" Type="System.Int32" />
        <Parameter Name="hi" Type="System.Int32" />
        <Parameter Name="isNegative" Type="System.Boolean" />
        <Parameter Name="scale" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="lo">32 bits inferiores de un entero de 96 bits.</param>
        <param name="mid">32 bits intermedios de un entero de 96 bits.</param>
        <param name="hi">32 bits superiores de un entero de 96 bits.</param>
        <param name="isNegative">
          <see langword="true" /> para indicar un número negativo; <see langword="false" /> para indicar un número positivo.</param>
        <param name="scale">Potencia de 10 comprendida entre el 0 y el 28.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Decimal" /> a partir de los parámetros que especifican las partes constituyentes de la instancia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación binaria de un <xref:System.Decimal> número se compone de un signo de 1 bit, un número entero de 96 bits y un factor de escala utilizado para dividir el número entero y especificar qué parte de ella es una fracción decimal. El factor de escala es implícitamente el número 10 elevado a un exponente comprendido entre 0 y 28.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea varias `Decimal` números utilizando la sobrecarga del constructor que inicializa un `Decimal` estructura con tres <xref:System.Int32> valor palabras, un <xref:System.Boolean> inicio de sesión y un <xref:System.Byte> factor de escala.  
  
 [!code-cpp[System.Decimal.Ctor.Arrays#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CPP/ctoriiibby.cpp#2)]
 [!code-csharp[System.Decimal.Ctor.Arrays#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CS/ctoriiibby.cs#2)]
 [!code-vb[System.Decimal.Ctor.Arrays#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/VB/ctoriiibby.vb#2)]  
  
 En el ejemplo siguiente se usa el <xref:System.Decimal.GetBits%2A> método para recuperar los componentes de una matriz. A continuación, utiliza esta matriz en la llamada a la <xref:System.Decimal.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Byte%29> constructor para crear instancias de un nuevo <xref:System.Decimal> valor.  
  
 [!code-csharp[System.Decimal.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.ctor/cs/ctor2a.cs#1)]
 [!code-vb[System.Decimal.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.ctor/vb/ctor2a.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="scale" /> es mayor que 28.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static decimal Add (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Add(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Add(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a sumar.</param>
        <param name="d2">Segundo valor que se va a sumar.</param>
        <summary>Suma dos valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>La suma de <paramref name="d1" /> y <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El ejemplo de código siguiente muestra el uso de `Add` :  
  
 [!code-cpp[Decimal Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#5)]
 [!code-csharp[Decimal Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#5)]
 [!code-vb[Decimal Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La suma de <paramref name="d1" /> y <paramref name="d2" /> es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Ceiling(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Ceiling(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal.</param>
        <summary>Devuelve el valor integral más pequeño que es mayor o igual que el número decimal especificado.</summary>
        <returns>Valor integral más pequeño que es mayor o igual que el parámetro <paramref name="d" />. Tenga en cuenta que este método devuelve un valor <see cref="T:System.Decimal" /> en lugar de un tipo entero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de este método sigue el estándar IEEE 754, sección 4. Este tipo de redondeo a veces se denomina redondeo hacia el infinito positivo. En otras palabras, si `d` es positivo, la presencia de las causas de cualquier componente de fracción `d` se redondea al entero más alto siguiente. Si `d` es negativo, la operación de redondeo hace que cualquier componente fraccionario de `d` van a descartar. La operación de este método difiere de la <xref:System.Decimal.Floor%2A> método, que es compatible con redondeo a infinito negativo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la <xref:System.Decimal.Ceiling%2A> método y se contrasta con la <xref:System.Decimal.Floor%2A> método.  
  
 [!code-csharp[System.Decimal.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ceiling/cs/ceiling1.cs#1)]
 [!code-vb[System.Decimal.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (d1 As Decimal, d2 As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a comparar.</param>
        <param name="d2">Segundo valor que se va a comparar.</param>
        <summary>Compara dos valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>Número con signo que indica los valores relativos de <paramref name="d1" /> y <paramref name="d2" />.  
  
 <list type="table"><listheader><term> Valor devuelto </term><description> Significado </description></listheader><item><term> Menor que cero </term><description><paramref name="d1" /> es menor que <paramref name="d2" />.  </description></item><item><term> Cero </term><description><paramref name="d1" /> y <paramref name="d2" /> son iguales.  </description></item><item><term> Mayor que cero </term><description><paramref name="d1" /> es mayor que <paramref name="d2" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se comparan varias <xref:System.Decimal> valores. Tenga en cuenta que la primera comparación indica que los dos valores son iguales a pesar de la operación de resta realizada con la `value2` variable. Esto es porque el <xref:System.Decimal> tipo tiene 29 dígitos de precisión, mientras que una diferencia entre estos dos valores se pueden detectar solo con 30 dígitos de precisión.  
  
 [!code-csharp[System.Decimal.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Decimal.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.CompareTo(System.Object)" />
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara esta instancia con un objeto especificado o con un objeto <see cref="T:System.Decimal" /> y devuelve una indicación de sus valores relativos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.CompareTo(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a comparar con esta instancia.</param>
        <summary>Compara esta instancia con un objeto <see cref="T:System.Decimal" /> especificado y devuelve una comparación de los valores relativos.</summary>
        <returns>Número con signo que indica los valores relativos de esta instancia y <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valor devuelto </term><description> Significado </description></listheader><item><term> Menor que cero </term><description> Esta instancia es menor que <paramref name="value" />.  </description></item><item><term> Cero </term><description> Esta instancia es igual a <paramref name="value" />.  </description></item><item><term> Mayor que cero </term><description> Esta instancia es mayor que <paramref name="value" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el <xref:System.IComparable%601?displayProperty=nameWithType> interfaz y realiza ligeramente mejor que la <xref:System.Decimal.CompareTo%2A?displayProperty=nameWithType> método porque no tiene que convertir el `value` parámetro a un objeto.  
  
 Dependiendo del lenguaje de programación, es posible al código un <xref:System.Decimal.CompareTo%2A> método donde el tipo de parámetro tiene menos bits (es más estrecho) que el tipo de instancia. Esto es posible porque algunos lenguajes de programación realizan una conversión de ampliación implícita que representa el parámetro como un tipo con tantos bits como la instancia.  
  
 Por ejemplo, suponga que el tipo de instancia es <xref:System.Int32> y el tipo de parámetro es <xref:System.Byte>. El compilador de Microsoft C# genera instrucciones para representar el parámetro como un <xref:System.Int32> objeto, a continuación, genera un <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> método para comparar los valores de la <xref:System.Int32> instancia y el <xref:System.Int32> representación del parámetro.  
  
 Consulte la documentación de su lenguaje de programación para determinar si el compilador realiza las conversiones de ampliación implícitas en tipos numéricos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra versiones genéricas y de la <xref:System.Decimal.CompareTo%2A> método para varios tipos de valor y de referencia.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
        <summary>Compara esta instancia con un objeto especificado y devuelve una comparación de los valores relativos.</summary>
        <returns>Número con signo que indica los valores relativos de esta instancia y <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valor devuelto </term><description> Significado </description></listheader><item><term> Menor que cero </term><description> Esta instancia es menor que <paramref name="value" />.  </description></item><item><term> Cero </term><description> Esta instancia es igual a <paramref name="value" />.  </description></item><item><term> Mayor que cero </term><description> Esta instancia es mayor que <paramref name="value" />. -o bien- <paramref name="value" /> es <see langword="null" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier instancia de <xref:System.Decimal>, independientemente de su valor, se considera mayor que `null`.  
  
 Parámetro `value` debe ser `null` o una instancia de <xref:System.Decimal>; en caso contrario, se produce una excepción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se compara varios `Decimal` y otros objetos en una referencia `Decimal` valor mediante la `CompareTo` método.  
  
 [!code-cpp[System.Decimal.Compare_Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CPP/cto_eq_obj.cpp#1)]
 [!code-csharp[System.Decimal.Compare_Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CS/cto_eq_obj.cs#1)]
 [!code-vb[System.Decimal.Compare_Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/VB/cto_eq_obj.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no es un <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static decimal Divide (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Divide(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Divide(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Dividendo.</param>
        <param name="d2">Divisor.</param>
        <summary>Divide dos valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>Resultado de dividir <paramref name="d1" /> entre <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Decimal.Divide%2A> método dividir un intervalo de valores por 22.1.  
  
 [!code-csharp[System.Decimal.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Decimal.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> es cero.</exception>
        <exception cref="T:System.OverflowException">El valor devuelto (es decir, el cociente) es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si dos instancias de <see cref="T:System.Decimal" /> representan el mismo valor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Equals(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Un objeto que se va a comparar con esta instancia.</param>
        <summary>Devuelve un valor que indica si esta instancia y un objeto <see cref="T:System.Decimal" /> especificado representan el mismo valor.</summary>
        <returns>Es <see langword="true" /> si <paramref name="value" /> es igual a esta instancia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el <xref:System.IEquatable%601?displayProperty=nameWithType> interfaz y se ejecuta ligeramente mejor que <xref:System.Decimal.Equals%2A> porque no tiene que convertir el `value` parámetro a un objeto.  
  
 Si `value` tiene menos bits (es más estrecho) que el tipo de instancia, algunos lenguajes de programación realizan una conversión de ampliación implícita que transforma el valor del parámetro en un valor con más bits.  
  
 Por ejemplo, suponga que el tipo de instancia es <xref:System.Int32> y el tipo de parámetro es <xref:System.Byte>. El compilador de Microsoft C# genera instrucciones para representar el valor del parámetro como un <xref:System.Int32> objeto, a continuación, genera un <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> método para comparar la <xref:System.Int32> representación en forma de instancia y los parámetros.  
  
 Consulte la documentación de su lenguaje de programación para determinar si el compilador realiza las conversiones de ampliación implícitas en tipos numéricos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>La resolución de sobrecarga de compilador puede representar una diferencia aparente en el comportamiento de los dos <see cref="M:System.Decimal.Equals(System.Object)" /> sobrecargas del método. Si una conversión implícita entre el <paramref name="obj" /> argumento y un <see cref="T:System.Decimal" /> se define y el argumento no se ha escrito como una <see cref="T:System.Object" />, compiladores pueden realizar una conversión implícita y la llamada la <see cref="M:System.Decimal.Equals(System.Decimal)" /> método. De lo contrario, llame a la <see cref="M:System.Decimal.Equals(System.Object)" /> método, que siempre devuelve <see langword="false" /> si su <paramref name="obj" /> el argumento no es un <see cref="T:System.Decimal" /> valor. En el ejemplo siguiente se ilustra la diferencia de comportamiento entre las sobrecargas del dos método. En el caso de todos los tipos enteros primitivos, incluidos tipos signed y unsigned, devuelve la primera comparación <see langword="true" /> porque el compilador realiza automáticamente una conversión de ampliación y llama el <see cref="M:System.Decimal.Equals(System.Decimal)" /> método, mientras que el segundo comparación devuelve <see langword="false" /> porque el compilador llama el <see cref="M:System.Decimal.Equals(System.Object)" /> método.  [! code-csharp[System.Decimal.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Decimal.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
        <altmember cref="Overload:System.Decimal.CompareTo" />
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a comparar con esta instancia.</param>
        <summary>Devuelve un valor que indica si esta instancia y un <see cref="T:System.Object" /> especificado representan el mismo tipo y valor.</summary>
        <returns>Es <see langword="true" /> si <paramref name="value" /> es <see cref="T:System.Decimal" /> y es igual a esta instancia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se compara varios `Decimal` y otros objetos en una referencia `Decimal` valor mediante la `Equals` método.  
  
 [!code-cpp[System.Decimal.Compare_Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CPP/cto_eq_obj.cpp#1)]
 [!code-csharp[System.Decimal.Compare_Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CS/cto_eq_obj.cs#1)]
 [!code-vb[System.Decimal.Compare_Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/VB/cto_eq_obj.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>La resolución de sobrecarga de compilador puede representar una diferencia aparente en el comportamiento de los dos <see cref="M:System.Decimal.Equals(System.Object)" /> sobrecargas del método. Si una conversión implícita entre el <paramref name="obj" /> argumento y un <see cref="T:System.Decimal" /> se define y el argumento no se ha escrito como una <see cref="T:System.Object" />, compiladores pueden realizar una conversión implícita y la llamada la <see cref="M:System.Decimal.Equals(System.Decimal)" /> método. De lo contrario, llame a la <see cref="M:System.Decimal.Equals(System.Object)" /> método, que siempre devuelve <see langword="false" /> si su <paramref name="obj" /> el argumento no es un <see cref="T:System.Decimal" /> valor. En el ejemplo siguiente se ilustra la diferencia de comportamiento entre las sobrecargas del dos método. En el caso de todos los tipos enteros primitivos, incluidos tipos signed y unsigned, devuelve la primera comparación <see langword="true" /> porque el compilador realiza automáticamente una conversión de ampliación y llama el <see cref="M:System.Decimal.Equals(System.Decimal)" /> método, mientras que el segundo comparación devuelve <see langword="false" /> porque el compilador llama el <see cref="M:System.Decimal.Equals(System.Object)" /> método.  [! code-csharp[System.Decimal.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Decimal.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Equals(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a comparar.</param>
        <param name="d2">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si dos instancias especificadas de <see cref="T:System.Decimal" /> representan el mismo valor.</summary>
        <returns>
          <see langword="true" /> si <paramref name="d1" /> y <paramref name="d2" /> son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se compara varios `Decimal` valores en una referencia `Decimal` valor mediante el método estático `Equals` método.  
  
 [!code-cpp[System.Decimal.Compare_Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CPP/comp_equal.cpp#2)]
 [!code-csharp[System.Decimal.Compare_Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CS/comp_equal.cs#2)]
 [!code-vb[System.Decimal.Compare_Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/VB/comp_equal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Floor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Floor(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">El valor que se va a redondear.</param>
        <summary>Redondea un número <see cref="T:System.Decimal" /> especificado al entero más próximo a infinito negativo.</summary>
        <returns>Si <paramref name="d" /> tiene una parte fraccionaria, el siguiente número entero <see cref="T:System.Decimal" /> que tiende a infinito negativo y que es menor que <paramref name="d" />.  -o bien- Si <paramref name="d" /> no tiene una parte fraccionaria, <paramref name="d" /> se devuelve sin modificar. Tenga en cuenta que el método devuelve un valor entero de tipo <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de este método sigue el estándar IEEE 754, sección 4. Este tipo de redondeo a veces se denomina redondeo a infinito negativo. En otras palabras, si `d` es positivo, se trunca cualquier componente fraccionario. Si `d` es negativo, la presencia de cualquier componente fraccionario hace que se redondea al entero más pequeño. La operación de este método difiere de la <xref:System.Decimal.Ceiling%2A> método, que es compatible con redondeo a infinito positivo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la <xref:System.Decimal.Floor%2A> método y se contrasta con la <xref:System.Decimal.Ceiling%2A> método.  
  
 [!code-csharp[System.Decimal.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ceiling/cs/ceiling1.cs#1)]
 [!code-vb[System.Decimal.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
        <altmember cref="M:System.Decimal.Truncate(System.Decimal)" />
        <altmember cref="M:System.Decimal.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="FromOACurrency">
      <MemberSignature Language="C#" Value="public static decimal FromOACurrency (long cy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal FromOACurrency(int64 cy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.FromOACurrency(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromOACurrency (cy As Long) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal FromOACurrency(long cy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cy" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="cy">Valor de moneda de Automation OLE.</param>
        <summary>Convierte el entero de 64 bits con signo especificado, que contiene un valor de moneda de Automation OLE, en el valor <see cref="T:System.Decimal" /> equivalente.</summary>
        <returns>
          <see cref="T:System.Decimal" /> que contiene el equivalente de <paramref name="cy" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el `FromOACurrency` método para convertir <xref:System.Int64> campos que contienen valores de moneda de automatización OLE equivalente `Decimal` números.  
  
 [!code-cpp[System.Decimal.OACurrency#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CPP/fromoacurrency.cpp#2)]
 [!code-csharp[System.Decimal.OACurrency#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CS/fromoacurrency.cs#2)]
 [!code-vb[System.Decimal.OACurrency#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.OACurrency/VB/fromoacurrency.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.ToOACurrency(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="GetBits">
      <MemberSignature Language="C#" Value="public static int[] GetBits (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32[] GetBits(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.GetBits(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBits (d As Decimal) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;int&gt; ^ GetBits(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Valor que se va a convertir.</param>
        <summary>Convierte el valor de una instancia de <see cref="T:System.Decimal" /> especificada en la representación binaria equivalente.</summary>
        <returns>Matriz de enteros de 32 bits con signo con cuatro elementos que contiene la representación binaria de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación binaria de un <xref:System.Decimal> número se compone de un signo de 1 bit, un número entero de 96 bits y un factor de escala utilizado para dividir el número entero y especificar qué parte de ella es una fracción decimal. El factor de escala es implícitamente el número 10 elevado a un exponente comprendido entre 0 y 28.  
  
 El valor devuelto es una matriz de cuatro elementos de enteros de 32 bits con signo.  
  
 El primer, segundo y tercer elementos de la matriz devuelta contienen los 32 bits bajos, medio y altos del número entero de 96 bits.  
  
 El cuarto elemento de la matriz devuelta contiene el factor de escala y el inicio de sesión. Consta de las siguientes partes:  
  
 Los bits 0 y 15, la palabra inferior, no se utilizan y deben ser cero.  
  
 Los bits del 16 al 23 deben contener a un exponente entre 0 y 28, que indica la potencia de 10 para dividir el número entero.  
  
 Los bits 24 a 30 no se utilizan y deben ser cero.  
  
 El bit 31 contiene el inicio de sesión: 0 significa positivo y 1 significa negativo.  
  
 Tenga en cuenta que la representación de bits se distingue entre cero positivo y negativo. Estos valores se tratan como si fueran iguales en todas las operaciones.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `GetBits` método para convertir varias `Decimal` valores en sus representaciones binarias equivalentes. A continuación, muestra los valores decimales y el valor hexadecimal de los elementos en la matriz devuelta por la <xref:System.Decimal.GetBits%2A> método.  
  
 [!code-cpp[System.Decimal.Get_Bits_Hash_Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CPP/getbits.cpp#2)]
 [!code-csharp[System.Decimal.Get_Bits_Hash_Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CS/getbits.cs#2)]
 [!code-vb[System.Decimal.Get_Bits_Hash_Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/VB/getbits.vb#2)]  
  
 En el ejemplo siguiente se usa el <xref:System.Decimal.GetBits%2A> método para recuperar los componentes de una matriz. A continuación, utiliza esta matriz en la llamada a la <xref:System.Decimal.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Byte%29> constructor para crear instancias de un nuevo <xref:System.Decimal> valor.  
  
 [!code-csharp[System.Decimal.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.ctor/cs/ctor2a.cs#1)]
 [!code-vb[System.Decimal.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.ctor/vb/ctor2a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Decimal.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de esta instancia.</summary>
        <returns>Código hash de un entero de 32 bits con signo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el <see cref="T:System.TypeCode" /> para el tipo de valor <see cref="T:System.Decimal" />.</summary>
        <returns>Constante enumerada <see cref="F:System.TypeCode.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el `GetTypeCode` método para devolver el código de tipo de `Decimal` un tipo de valor.  
  
 [!code-cpp[System.Decimal.Get_Bits_Hash_Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CPP/gettypecode.cpp#3)]
 [!code-csharp[System.Decimal.Get_Bits_Hash_Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CS/gettypecode.cs#3)]
 [!code-vb[System.Decimal.Get_Bits_Hash_Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/VB/gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static readonly decimal MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxValue As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal MaxValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el mayor valor posible de <see cref="T:System.Decimal" />. Este campo es constante y de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es positivo 79,228,162,514,264,337,593,543,950,335.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra el uso de `MaxValue` :  
  
 [!code-cpp[Decimal Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#2)]
 [!code-csharp[Decimal Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#2)]
 [!code-vb[Decimal Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.Zero" />
        <altmember cref="F:System.Decimal.One" />
        <altmember cref="F:System.Decimal.MinusOne" />
        <altmember cref="F:System.Decimal.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static readonly decimal MinusOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal MinusOne" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinusOne As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal MinusOne;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el número menos uno (-1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la `MinusOne` campo.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.Zero" />
        <altmember cref="F:System.Decimal.One" />
        <altmember cref="F:System.Decimal.MaxValue" />
        <altmember cref="F:System.Decimal.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static readonly decimal MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal MinValue" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinValue As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal MinValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el menor valor posible de <see cref="T:System.Decimal" />. Este campo es constante y de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es negativo 79,228,162,514,264,337,593,543,950,335.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la `MinValue` campo.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.Zero" />
        <altmember cref="F:System.Decimal.One" />
        <altmember cref="F:System.Decimal.MinusOne" />
        <altmember cref="F:System.Decimal.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static decimal Multiply (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Multiply(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Multiply(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Multiplicando.</param>
        <param name="d2">Multiplicador.</param>
        <summary>Multiplica dos valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>Resultado de multiplicar <paramref name="d1" /> y <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea varios pares de `Decimal` valores y calcula sus productos con el `Multiply` método.  
  
 [!code-cpp[System.Decimal.Mul_Div_Rem#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Mul_Div_Rem/CPP/mul_div_rem.cpp#1)]
 [!code-csharp[System.Decimal.Mul_Div_Rem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Mul_Div_Rem/CS/mul_div_rem.cs#1)]
 [!code-vb[System.Decimal.Mul_Div_Rem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Mul_Div_Rem/VB/mul_div_rem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static decimal Negate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Negate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Negate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Negate(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Valor que se va a negar.</param>
        <summary>Devuelve el resultado de multiplicar el valor <see cref="T:System.Decimal" /> especificado por menos uno.</summary>
        <returns>Número decimal con el valor de <paramref name="d" /> pero con signo opuesto.  -o bien- Cero, si <paramref name="d" /> es cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el `Negate` método para cambiar el inicio de sesión de varios `Decimal` valores.  
  
 [!code-cpp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CPP/floor_neg_trunc.cpp#1)]
 [!code-csharp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CS/floor_neg_trunc.cs#1)]
 [!code-vb[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/VB/floor_neg_trunc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly decimal One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal One" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal One;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el número uno (1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la `One` campo.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.Zero" />
        <altmember cref="F:System.Decimal.MinusOne" />
        <altmember cref="F:System.Decimal.MaxValue" />
        <altmember cref="F:System.Decimal.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static decimal operator + (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Addition(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Addition(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator +(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a sumar.</param>
        <param name="d2">Segundo valor que se va a sumar.</param>
        <summary>Suma dos valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>Resultado de sumar <paramref name="d1" /> y <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_Addition%2A> método define el funcionamiento del operador de suma para <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/addition1.cs#3)]
 [!code-vb[System.Decimal.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/addition1.vb#3)]  
  
 Si el idioma que está usando no admite operadores personalizados, llame a la <xref:System.Decimal.Add%2A> método en su lugar.  
  
 El método equivalente para este operador es <xref:System.Decimal.Add%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static decimal operator -- (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Decrement(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Decrement(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator --(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Valor que se va a disminuir.</param>
        <summary>Reduce en uno el operando <see cref="T:System.Decimal" />.</summary>
        <returns>Valor de <paramref name="d" /> reducido en 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_Decrement%2A> método define el funcionamiento del operador de decremento de <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/decrement1.cs#4)]  
  
 Algunos lenguajes (como Visual Basic) que no tienen un operador de incremento pueden llamar a la <xref:System.Decimal.op_Decrement%2A> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Decimal.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/decrement1.vb#5)]  
  
 Si su lenguaje no admite operadores personalizados, llame a la <xref:System.Decimal.Subtract%2A> método en su lugar, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Decimal.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/decrement2.cs#6)]
 [!code-vb[System.Decimal.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/decrement2.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static decimal operator / (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Division(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Division(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator /(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Dividendo.</param>
        <param name="d2">Divisor.</param>
        <summary>Divide dos valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>Resultado de dividir <paramref name="d1" /> entre <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_Division%2A> método define el funcionamiento del operador de división de <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/division1.cs#7)]
 [!code-vb[System.Decimal.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/division1.vb#7)]  
  
 Si el idioma que está usando no admite operadores personalizados, llame a la <xref:System.Decimal.Divide%2A> método en su lugar.  
  
 El método equivalente para este operador es <xref:System.Decimal.Divide%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> es cero.</exception>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Equality(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a comparar.</param>
        <param name="d2">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si dos valores <see cref="T:System.Decimal" /> son iguales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="d1" /> y <paramref name="d2" /> son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_Equality%2A> método define el funcionamiento del operador de igualdad para <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/equality1.cs#1)]
 [!code-vb[System.Decimal.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/equality1.vb#1)]  
  
 Si el idioma que está usando no admite operadores personalizados, llame a la <xref:System.Decimal.Equals%2A> método en su lugar.  
  
 El método equivalente para este operador es <xref:System.Decimal.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
        <altmember cref="M:System.Decimal.op_Inequality(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define una conversión explícita entre un objeto <see cref="T:System.Decimal" /> y otro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Decimal" /> en un entero de 8 bits sin signo.</summary>
        <returns>Entero de 8 bits sin signo que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.Byte>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.Byte> valor mediante el uso de C#, C++ y Visual Basic. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToByte%28System.Decimal%29?displayProperty=nameWithType> o <xref:System.Convert.ToByte%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples 
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.Byte> valores usando el explícita <xref:System.Decimal> a <xref:System.Byte> operador de conversión.

 [!code-cpp[System.Decimal.ConvTo#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctos_byte.cpp#4)] 
 [!code-csharp[System.Decimal.ConvTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctos_byte.cs#4)] 
 [!code-vb[System.Decimal.ConvTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctos_byte.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.Byte.MinValue" /> o mayor que <see cref="F:System.Byte.MaxValue" />.</exception>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator char (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname char op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Char" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator char(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Decimal" /> en un carácter Unicode.</summary>
        <returns>Carácter Unicode que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.Char>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes, o quizás no admita la conversión de en absoluto. Por ejemplo, los compiladores de Visual Basic y C++ no admiten explícito <xref:System.Decimal> a una <xref:System.Char> conversión.
 

## Examples 
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.Char> valores (caracteres Unicode) usando el explícita <xref:System.Decimal> a <xref:System.Char> operador de conversión.

 [!code-csharp[System.Decimal.ConvTo#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctochar.cs#6)]
 [!code-vb[System.Decimal.ConvTo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctochar.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.Char.MinValue" /> o mayor que <see cref="F:System.Char.MaxValue" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un <see cref="T:System.Decimal" /> en un número de punto flotante de precisión doble.</summary>
        <returns>Número de punto flotante de precisión doble que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación puede provocar una pérdida de precisión, porque un número de punto flotante de precisión doble tiene menos dígitos significativos que un <xref:System.Decimal>.
 
 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.Double>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.Double> valor mediante el uso de C#, C++ y Visual Basic. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToDouble%28System.Decimal%29?displayProperty=nameWithType> o <xref:System.Convert.ToDouble%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.Double> valores usando el explícita <xref:System.Decimal> a <xref:System.Double> operador de conversión.

 [!code-cpp[System.Decimal.ConvTo#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctosgl_dbl.cpp#5)] 
 [!code-csharp[System.Decimal.ConvTo#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctosgl_dbl.cs#5)]
 [!code-vb[System.Decimal.ConvTo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctosgl_dbl.vb#5)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un <see cref="T:System.Decimal" /> en un entero de 16 bits con signo.</summary>
        <returns>Entero de 16 bits con signo que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.Int16>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.Int16> valor mediante el uso de C#, Visual Basic y C++. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToInt16%28System.Decimal%29?displayProperty=nameWithType> o <xref:System.Convert.ToInt16%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.Int16> valores usando el explícita <xref:System.Decimal> a <xref:System.Int16> operador de conversión.

 [!code-cpp[System.Decimal.ConvTo#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int16.cpp#3)] 
 [!code-csharp[System.Decimal.ConvTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int16.cs#3)] 
 [!code-vb[System.Decimal.ConvTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int16.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.Int16.MinValue" /> o mayor que <see cref="F:System.Int16.MaxValue" />.</exception>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un <see cref="T:System.Decimal" /> en un entero de 32 bits con signo.</summary>
        <returns>Entero de 32 bits con signo que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.Int32>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.Int32> valor mediante el uso de C#, C++ y Visual Basic. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToInt32%28System.Decimal%29?displayProperty=nameWithType> o <xref:System.Convert.ToInt32%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.Int32> valores usando el explícita <xref:System.Decimal> a <xref:System.Int32> operador de conversión.

 [!code-cpp[System.Decimal.ConvTo#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int32.cpp#2)] 
 [!code-csharp[System.Decimal.ConvTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int32.cs#2)] 
 [!code-vb[System.Decimal.ConvTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int32.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.Int32.MinValue" /> o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un <see cref="T:System.Decimal" /> en un entero de 64 bits con signo.</summary>
        <returns>Entero de 64 bits con signo que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.Int64>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.Int64> valor mediante el uso de C# y Visual Basic. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToInt64%28System.Decimal%29?displayProperty=nameWithType> o <xref:System.Convert.ToInt64%28System.Decimal%29?displayProperty=nameWithType> método.
 
## Examples
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.Int64> valores usando el explícita <xref:System.Decimal> a <xref:System.Int64> operador de conversión.

 [!code-cpp[System.Decimal.ConvTo#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int64.cpp#1)] 
 [!code-csharp[System.Decimal.ConvTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int64.cs#1)] 
 [!code-vb[System.Decimal.ConvTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int64.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.Int64.MinValue" /> o mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Decimal" /> en un entero de 8 bits con signo.  Esta API no es conforme a CLS.</summary>
        <returns>Entero de 8 bits con signo que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.SByte>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.Byte> y un <xref:System.SByte> valor mediante el uso de C# y Visual Basic. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToSByte%28System.Decimal%29?displayProperty=nameWithType> método o la <xref:System.Convert.ToSByte%28System.Decimal%29?displayProperty=nameWithType> método.   


## Examples 
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.SByte> valores usando el explícita <xref:System.Decimal> a <xref:System.SByte> operador de conversión.

 [!code-cpp[System.Decimal.Operators.Explicit#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cpp/tosbyte.cpp#1)] 
 [!code-csharp[System.Decimal.Operators.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cs/tosbyte.cs#1)]
 [!code-vb[System.Decimal.Operators.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators.explicit/vb/tosbyte.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.SByte.MinValue" /> o mayor que <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="M:System.Decimal.ToInt16(System.Decimal)" />
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un <see cref="T:System.Decimal" /> en un número de punto flotante de precisión sencillo.</summary>
        <returns>Número de punto flotante de precisión sencilla que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación puede provocar una pérdida de precisión, porque un número de punto flotante de precisión simple tiene menos dígitos significativos que un <xref:System.Decimal>.

 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.Single>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.Single> valor mediante el uso de C# y Visual Basic. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToSingle%28System.Decimal%29?displayProperty=nameWithType> o <xref:System.Convert.ToSingle%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.Single> valores usando el explícita <xref:System.Decimal> a <xref:System.Single> operador de conversión.

 [!code-cpp[System.Decimal.Operators.Explicit#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cpp/tosingle1.cpp#2)] 
 [!code-csharp[System.Decimal.Operators.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cs/tosingle1.cs#2)]
 [!code-vb[System.Decimal.Operators.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators.explicit/vb/tosingle1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un <see cref="T:System.Decimal" /> en un entero de 16 bits sin signo.  Esta API no es conforme a CLS.</summary>
        <returns>Entero de 16 bits sin signo que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.UInt16>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.UInt16> valor mediante el uso de C# y Visual Basic. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToUInt16%28System.Decimal%29?displayProperty=nameWithType> o <xref:System.Convert.ToUInt16%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.UInt16> valores usando el explícita <xref:System.Decimal> a <xref:System.UInt16> operador de conversión.

 [!code-cpp[System.Decimal.ConvTo#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int16.cpp#3)] 
 [!code-csharp[System.Decimal.ConvTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int16.cs#3)]
 [!code-vb[System.Decimal.ConvTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int16.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.UInt16.MinValue" /> o mayor que <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un <see cref="T:System.Decimal" /> en un entero de 32 bits sin signo.  Esta API no es conforme a CLS.</summary>
        <returns>Entero de 32 bits sin signo que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.UInt32>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.UInt32> valor mediante el uso de C# y Visual Basic. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToUInt32%28System.Decimal%29?displayProperty=nameWithType> o <xref:System.Convert.ToUInt32%28System.Decimal%29?displayProperty=nameWithType> método.


## Examples
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.UInt32> valores usando el explícita <xref:System.Decimal> a <xref:System.UInt32> operador de conversión.

 [!code-cpp[System.Decimal.ConvTo#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int32.cpp#2)] 
 [!code-csharp[System.Decimal.ConvTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int32.cs#2)]
 [!code-vb[System.Decimal.ConvTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int32.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.UInt32.MinValue" /> o mayor que <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="M:System.Decimal.ToInt64(System.Decimal)" />
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir.</param>
        <summary>Define una conversión explícita de un <see cref="T:System.Decimal" /> en un entero de 64 bits sin signo.  Esta API no es conforme a CLS.</summary>
        <returns>Entero de 64 bits sin signo que representa el <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador admite la conversión explícita de un <xref:System.Decimal> a una <xref:System.UInt64>. La sintaxis para estas conversiones explícitas depende del lenguaje y compiladores de lenguaje individuales pueden proporcionar diferentes implementaciones y devolver resultados diferentes. El ejemplo muestran los diferentes valores devueltos cuando se convierte explícitamente un <xref:System.Decimal> valor a un <xref:System.UInt64> valor mediante el uso de C# y Visual Basic. Para llevar a cabo una conversión que sea independiente del idioma, puede llamar a la <xref:System.Decimal.ToUInt64%28System.Decimal%29?displayProperty=nameWithType> o <xref:System.Convert.ToUInt64%28System.Decimal%29?displayProperty=nameWithType> método.


## Examples 
 El ejemplo siguiente se convierte <xref:System.Decimal> números a <xref:System.UInt64> valores usando el explícita <xref:System.Decimal> a <xref:System.UInt64> operador de conversión.

 [!code-cpp[System.Decimal.ConvTo#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int64.cpp#1)] 
 [!code-csharp[System.Decimal.ConvTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int64.cs#1)]
 [!code-vb[System.Decimal.ConvTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int64.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es negativo o mayor que <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Double)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Número de punto flotante de precisión doble que se va a convertir.</param>
        <summary>Define una conversión explícita de un número de punto flotante de precisión doble en un <see cref="T:System.Decimal" />.</summary>
        <returns>Número de punto flotante de precisión doble que se ha convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  

 El ejemplo siguiente se convierte <xref:System.Double> valores <xref:System.Decimal> números utilizando la <xref:System.Double> a <xref:System.Decimal> operador de conversión. Esta conversión requiere el operador op_Explicit en Visual Basic.

 [!code-cpp[System.Decimal.ConvFrom.Others#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CPP/cfromdouble.cpp#2)]
 [!code-csharp[System.Decimal.ConvFrom.Others#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CS/cfromdouble.cs#2)]
 [!code-vb[System.Decimal.ConvFrom.Others#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/VB/cfromdouble.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es mayor que <see cref="F:System.Decimal.MaxValue" /> o menor que <see cref="F:System.Decimal.MinValue" />.  -o bien- <paramref name="value" /> es <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" />.</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Single)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Número de punto flotante de precisión sencilla que se va a convertir.</param>
        <summary>Define una conversión explícita de un número de punto flotante de precisión sencilla en un <see cref="T:System.Decimal" />.</summary>
        <returns>Número de punto flotante de precisión sencilla que se ha convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se convierte <xref:System.Single> valores <xref:System.Decimal> números utilizando la <xref:System.Single> a <xref:System.Decimal> operador de conversión. Esta conversión requiere el operador op_Explicit en Visual Basic.

 [!code-cpp[System.Decimal.ConvFrom.Others#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CPP/cfromsingle.cpp#3)]
 [!code-csharp[System.Decimal.ConvFrom.Others#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CS/cfromsingle.cs#3)]
 [!code-vb[System.Decimal.ConvFrom.Others#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/VB/cfromsingle.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es mayor que <see cref="F:System.Decimal.MaxValue" /> o menor que <see cref="F:System.Decimal.MinValue" />.  -o bien- <paramref name="value" /> es <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> o <see cref="F:System.Single.NegativeInfinity" />.</exception>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_GreaterThan(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a comparar.</param>
        <param name="d2">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un <see cref="T:System.Decimal" /> especificado es mayor que otro <see cref="T:System.Decimal" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="d1" /> es mayor que <paramref name="d2" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_GreaterThan%2A> método define el funcionamiento del operador para mayor que <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/greaterthan1.cs#8)]
 [!code-vb[System.Decimal.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthan1.vb#8)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Decimal.Compare%2A> método en su lugar. Es posible que también puedan llamar a la <xref:System.Decimal.op_GreaterThan%2A> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Decimal.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthan2.vb#9)]  
  
 El método equivalente para este operador es <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_GreaterThanOrEqual(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a comparar.</param>
        <param name="d2">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un <see cref="T:System.Decimal" /> especificado es mayor o igual que otro <see cref="T:System.Decimal" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="d1" /> es mayor o igual que <paramref name="d2" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_GreaterThanOrEqual%2A> método define el funcionamiento del operador mayor o igual de <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/greaterthanorequal1.cs#10)]
 [!code-vb[System.Decimal.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthanorequal1.vb#10)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Decimal.Compare%2A> método en su lugar. Es posible que también puedan llamar a la <xref:System.Decimal.op_GreaterThanOrEqual%2A> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Decimal.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthanorequal2.vb#11)]  
  
 El método equivalente para este operador es <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define una conversión implícita del valor de un tipo a un valor <see cref="T:System.Decimal" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Byte)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 8 bits sin signo que se va a convertir.</param>
        <summary>Define una conversión implícita de un entero de 8 bits sin signo en un valor <see cref="T:System.Decimal" />.</summary>
        <returns>Entero de 8 bits sin signo que se ha convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  


## Examples
 El ejemplo siguiente se convierte <xref:System.Byte> valores <xref:System.Decimal> números.

 [!code-cpp[System.Decimal.ConvFrom.UInts#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfrombyte.cpp#4)]
 [!code-csharp[System.Decimal.ConvFrom.UInts#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfrombyte.cs#4)]
 [!code-vb[System.Decimal.ConvFrom.UInts#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfrombyte.vb#4)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Char)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Char) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Carácter Unicode que se va a convertir.</param>
        <summary>Define una conversión implícita de un carácter Unicode en un <see cref="T:System.Decimal" />.</summary>
        <returns>Carácter Unicode convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  


## Examples
 El ejemplo siguiente se convierte <xref:System.Char> valores (caracteres Unicode) para <xref:System.Decimal> números. Esta conversión requiere el operador op_Implicit en Visual Basic, pero no en C# y C++. 

 [!code-cpp[System.Decimal.ConvFrom.Others#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CPP/cfromchar.cpp#1)]
 [!code-csharp[System.Decimal.ConvFrom.Others#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CS/cfromchar.cs#1)]
 [!code-vb[System.Decimal.ConvFrom.Others#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/VB/cfromchar.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Int16)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 16 bits con signo que se va a convertir.</param>
        <summary>Define una conversión implícita de un entero de 16 bits con signo en un <see cref="T:System.Decimal" />.</summary>
        <returns>Entero de 16 bits con signo convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  


## Examples
 El ejemplo siguiente se convierte <xref:System.Int16> valores <xref:System.Decimal> números. Esta conversión requiere el operador op_Implicit en Visual Basic, pero no en C# y C++. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromint16.cpp#3)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromint16.cs#3)]
 [!code-vb[System.Decimal.ConvFrom.SInts#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromint16.vb#3)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Int32)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 32 bits con signo que se va a convertir.</param>
        <summary>Define una conversión implícita de un entero de 32 bits con signo en un <see cref="T:System.Decimal" />.</summary>
        <returns>Entero de 32 bits con signo convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  


## Examples
 El ejemplo siguiente se convierte <xref:System.Int32> valores <xref:System.Decimal> números. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromint32.cpp#2)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromint32.cs#2)]
 [!code-vb[System.Decimal.ConvFrom.SInts#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromint32.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Int64)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 64 bits con signo que se va a convertir.</param>
        <summary>Define una conversión implícita de un entero de 64 bits con signo en un <see cref="T:System.Decimal" />.</summary>
        <returns>Entero de 64 bits con signo convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  


## Examples
 El ejemplo siguiente se convierte <xref:System.Int64> valores <xref:System.Decimal> números. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromint64.cpp#1)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromint64.cs#1)]
 [!code-vb[System.Decimal.ConvFrom.SInts#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromint64.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.SByte)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 8 bits con signo que se va a convertir.</param>
        <summary>Define una conversión implícita de un entero de 8 bits con signo en un valor <see cref="T:System.Decimal" />.  Esta API no es conforme a CLS.</summary>
        <returns>Entero de 8 bits con signo convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  


## Examples
 El ejemplo siguiente se convierte <xref:System.SByte> valores <xref:System.Decimal> números. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromsbyte.cpp#4)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromsbyte.cs#4)]
 [!code-vb[System.Decimal.ConvFrom.SInts#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromsbyte.vb#4)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.UInt16)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 16 bits sin signo que se va a convertir.</param>
        <summary>Define una conversión implícita de un entero sin signo de 16 bits en <see cref="T:System.Decimal" />.  Esta API no es conforme a CLS.</summary>
        <returns>Entero de 16 bits sin signo que se ha convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  


## Examples
 El ejemplo siguiente se convierte <xref:System.UInt16> valores <xref:System.Decimal> números. 

 [!code-cpp[System.Decimal.ConvFrom.UInts#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfromuint16.cpp#3)]
 [!code-csharp[System.Decimal.ConvFrom.UInts#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfromuint16.cs#3)]
 [!code-vb[System.Decimal.ConvFrom.UInts#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfromuint16.vb#3)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.UInt32)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 32 bits sin signo que se va a convertir.</param>
        <summary>Define una conversión implícita de un entero sin signo de 32 bits en un <see cref="T:System.Decimal" />.  Esta API no es conforme a CLS.</summary>
        <returns>Entero de 32 bits sin signo que se ha convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  


## Examples
 El ejemplo siguiente se convierte <xref:System.UInt32> valores <xref:System.Decimal> números.

 [!code-cpp[System.Decimal.ConvFrom.UInts#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfromuint32.cpp#2)] 
 [!code-csharp[System.Decimal.ConvFrom.UInts#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfromuint32.cs#2)] 
 [!code-vb[System.Decimal.ConvFrom.UInts#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfromuint32.vb#2)]   

 ]]></format>
        </remarks>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.UInt64)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 64 bits sin signo que se va a convertir.</param>
        <summary>Define una conversión implícita de un entero sin signo de 64 bits en un <see cref="T:System.Decimal" />.  Esta API no es conforme a CLS.</summary>
        <returns>Entero de 64 bits sin signo que se ha convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Decimal.op_Implicit%2A> método definen los tipos desde el que el compilador puede convertir automáticamente un <xref:System.Decimal> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException> excepción.  


## Examples
 El ejemplo siguiente se convierte <xref:System.UInt64> valores <xref:System.Decimal> números utilizando la <xref:System.UInt64> a <xref:System.Decimal> operador de conversión. 

 [!code-cpp[System.Decimal.ConvFrom.UInts#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfromuint64.cpp#1)] 
 [!code-csharp[System.Decimal.ConvFrom.UInts#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfromuint64.cs#1)] 
 [!code-vb[System.Decimal.ConvFrom.UInts#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfromuint64.vb#1)]   

 ]]></format>
        </remarks>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static decimal operator ++ (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Increment(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Increment(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator ++(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Valor que se va a aumentar.</param>
        <summary>Incrementa en 1 el operando <see cref="T:System.Decimal" />.</summary>
        <returns>Valor de <paramref name="d" /> incrementado en 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_Increment%2A> método define el funcionamiento del operador de incremento de <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/increment1.cs#12)]  
  
 Algunos lenguajes (como Visual Basic) que no tienen un operador de incremento pueden llamar a la <xref:System.Decimal.op_Increment%2A> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Decimal.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/increment1.vb#13)]  
  
 Si su lenguaje no admite operadores personalizados, llame a la <xref:System.Decimal.Add%2A> método en su lugar, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Decimal.Operators#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/increment2.cs#14)]
 [!code-vb[System.Decimal.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/increment2.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Inequality(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a comparar.</param>
        <param name="d2">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si dos objetos <see cref="T:System.Decimal" /> tienen valores diferentes.</summary>
        <returns>
          <see langword="true" /> si <paramref name="d1" /> y <paramref name="d2" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_Inequality%2A> método define el funcionamiento del operador de desigualdad para <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/inequality1.cs#2)]
 [!code-vb[System.Decimal.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/inequality1.vb#2)]  
  
 Si el idioma que está usando no admite operadores personalizados, puede comprobar la desigualdad mediante una de las siguientes técnicas:  
  
-   Llamar a la <xref:System.Decimal.Compare%2A> método, que indica la relación entre dos <xref:System.Decimal> valores.  
  
-   Llamar a la <xref:System.Decimal.Equals%2A> método e invertir su valor.  
  
 El método equivalente para este operador es <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
        <altmember cref="M:System.Decimal.op_Equality(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_LessThan(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a comparar.</param>
        <param name="d2">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un <see cref="T:System.Decimal" /> especificado es menor que otro <see cref="T:System.Decimal" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="d1" /> es menor que <paramref name="d2" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_LessThan%2A> método define el funcionamiento del operador para menor que <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/lessthan1.cs#15)]
 [!code-vb[System.Decimal.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthan1.vb#15)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Decimal.Compare%2A> método en su lugar. Es posible que también puedan llamar a la <xref:System.Decimal.op_LessThan%2A> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Decimal.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthan2.vb#16)]  
  
 El método equivalente para este operador es <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_LessThanOrEqual(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a comparar.</param>
        <param name="d2">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un <see cref="T:System.Decimal" /> especificado es menor o igual que otro <see cref="T:System.Decimal" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="d1" /> es menor o igual que <paramref name="d2" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_LessThanOrEqual%2A> método define la operación de la menor que o el operador igual de <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/lessthanorequal1.cs#17)]
 [!code-vb[System.Decimal.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthanorequal1.vb#17)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Decimal.Compare%2A> método en su lugar. Es posible que también puedan llamar a la <xref:System.Decimal.op_LessThanOrEqual%2A> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Decimal.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthanorequal2.vb#18)]  
  
 El método equivalente para este operador es <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static decimal operator % (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Modulus(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Modulus(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator %(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Dividendo.</param>
        <param name="d2">Divisor.</param>
        <summary>Devuelve el resto que se obtiene como resultado de dividir dos valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>Resto que resulta de dividir <paramref name="d1" /> por <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_Modulus%2A> operador define la operación de resto que devuelve el resto resultante de dividir dos especificado <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/modulus1.cs#19)]
 [!code-vb[System.Decimal.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/modulus1.vb#19)]  
  
 El signo del valor devuelto por la operación de resto depende del signo del dividendo. Si el dividendo es positivo, la operación de resto devuelve un resultado positivo; Si es negativo, la operación de resto devuelve un resultado negativo.  
  
 El método equivalente para este operador es <xref:System.Decimal.Remainder%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>. Si el idioma que está usando no admite operadores personalizados, llame a la <xref:System.Decimal.Remainder%2A> método en su lugar.  
         ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> es <see langword="zero" />.</exception>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Remainder(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static decimal operator * (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Multiply(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Multiply(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator *(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Primer valor que se va a multiplicar.</param>
        <param name="d2">Segundo valor que se va a multiplicar.</param>
        <summary>Multiplica dos valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>Resultado de multiplicar <paramref name="d1" /> por <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_Multiply%2A> método define el funcionamiento del operador de multiplicación para <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/multiply1.cs#20)]
 [!code-vb[System.Decimal.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/multiply1.vb#20)]  
  
 Si el idioma que está usando no admite operadores personalizados, llame a la <xref:System.Decimal.Multiply%2A> método en su lugar.  
  
 El método equivalente para este operador es <xref:System.Decimal.Multiply%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static decimal operator - (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Subtraction(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Subtraction(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator -(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Minuendo.</param>
        <param name="d2">Sustraendo.</param>
        <summary>Resta dos valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>Resultado de restar <paramref name="d2" /> de <paramref name="d1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_Subtraction%2A> método define el funcionamiento del operador de sustracción de <xref:System.Decimal> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Decimal.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/subtraction1.cs#21)]
 [!code-vb[System.Decimal.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/subtraction1.vb#21)]  
  
 Si el idioma que está usando no admite operadores personalizados, llame a la <xref:System.Decimal.Subtract%2A> método en su lugar.  
  
 El método equivalente para este operador es <xref:System.Decimal.Subtract%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static decimal operator - (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_UnaryNegation(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_UnaryNegation(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator -(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Valor que se va a negar.</param>
        <summary>Convierte en negativo el valor del operando <see cref="T:System.Decimal" /> especificado.</summary>
        <returns>Resultado de multiplicar <paramref name="d" /> por menos uno (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_UnaryPlus%2A> método define el funcionamiento del operador unario de negación (o el operador inverso aditivo) para <xref:System.Decimal> valores. La operación genera un valor que se obtiene en 0 (cero) cuando se agrega al número original. Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Decimal.Negate%2A> método en su lugar.  
  
 El método equivalente para este operador es <xref:System.Decimal.Negate%28System.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Negate(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static decimal operator + (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_UnaryPlus(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_UnaryPlus(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator +(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">El operando para devolver.</param>
        <summary>Devuelve el valor del operando <see cref="T:System.Decimal" /> (el signo del operando no se modifica).</summary>
        <returns>Valor del operando, <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.op_UnaryPlus%2A> método define el funcionamiento del operador unario positivo para <xref:System.Decimal> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la representación en forma de cadena de un número en su <see cref="T:System.Decimal" /> equivalente.</summary>
        <altmember cref="Overload:System.Decimal.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Representación de cadena del número que va a convertirse.</param>
        <summary>Convierte la representación en forma de cadena de un número en su <see cref="T:System.Decimal" /> equivalente.</summary>
        <returns>Equivalente al número que se incluye en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parámetro `s` contiene un número de la forma:  
  
 [ws] [inicio de sesión] [dígitos,] dígitos [. dígitos fraccionarios] [eb]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional.|  
|*sign*|Un signo opcional.|  
|*digits*|Una secuencia de dígitos que comprende del 0 al 9.|  
|*,*|Específicas de referencias culturales miles símbolo de separador.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas.|  
|*dígitos fraccionarios*|Una secuencia de dígitos que comprende del 0 al 9.|  
  
 Parámetro `s` se interpreta usando el <xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType> estilo. Esto significa que el espacio en blanco y miles se permiten separadores pero no los símbolos de divisa. Para definir explícitamente los elementos (como símbolos de moneda, miles separadores y espacios en blanco) que pueden estar presentes en `s`, use la <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> o <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (método).  
  
 Parámetro `s` se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo> inicializado para la referencia cultural del sistema actual. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Para analizar una cadena usando la información de formato de alguna otra referencia cultural, use el <xref:System.Decimal.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> o <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 Si es necesario, el valor de `s` se redondea utilizando el redondeo al más cercano.  
  
 Un <xref:System.Decimal> tiene 29 dígitos de precisión. Si `s` representa un número que tiene más de 29 dígitos, pero tiene una parte fraccionaria y está dentro del intervalo de <xref:System.Decimal.MaxValue> y <xref:System.Decimal.MinValue>, el número se redondea, no se trunca a 29 dígitos utilizando el redondeo al más cercano.  
  
 Si durante una operación de análisis se encuentra un separador en la `s` parámetro y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un separador de grupos. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Decimal.Parse%28System.String%29> método analizar representaciones de cadena de <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Decimal.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Parse/CS/parse.cs#1)]
 [!code-vb[System.Decimal.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> no tiene el formato correcto.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa un número menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="Overload:System.Decimal.TryParse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Representación de cadena del número que va a convertirse.</param>
        <param name="style">Combinación bit a bit de valores <see cref="T:System.Globalization.NumberStyles" /> que indica los elementos de estilo que pueden estar presentes en <c>s</c>. Un valor que se especifica de forma habitual es <see cref="F:System.Globalization.NumberStyles.Number" />.</param>
        <summary>Convierte la representación de cadena de un número con un estilo especificado en su <see cref="T:System.Decimal" /> equivalente.</summary>
        <returns>Número <see cref="T:System.Decimal" /> equivalente al número contenido en <paramref name="s" />, tal y como especifica <paramref name="style" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `style` parámetro define los elementos de estilo (como miles separadores, espacio en blanco y símbolos de moneda) que se permiten en la `s` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración. El siguiente <xref:System.Globalization.NumberStyles> miembros no son compatibles:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Dependiendo del valor de `style`, el `s` parámetro puede incluir los siguientes elementos:  
  
 [ws] [$] [inicio de sesión] [dígitos,] dígitos [. dígitos fraccionarios] [e [signo] dígitos] [eb]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional. Espacio en blanco puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca y pueden aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|*$*|Un símbolo de moneda específico de la referencia cultural. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual. Símbolo de divisa de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Un signo opcional. El signo puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y pueden aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `s` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*digits*|Una secuencia de dígitos que comprende del 0 al 9.|  
|*,*|Específicas de referencias culturales miles símbolo de separador. Miles de la referencia cultural actual separador puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas. Símbolo de separador decimal de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*dígitos fraccionarios*|Una secuencia de dígitos que comprende del 0 al 9. Pueden aparecer dígitos fraccionarios en `s` solo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*e*|El 'e' o el carácter 'E', lo que indica que el valor se representa en notación exponencial. El `s` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
  
 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None> estilo) siempre se analiza correctamente. El resto <xref:System.Globalization.NumberStyles> miembros controlan los elementos que pueden ser pero no tienen que estar presentes en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> miembros afectan a los elementos que pueden estar presentes en `s`.  
  
|Valor NumberStyles|Elementos permitidos en s además de dígitos|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos* solo el elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El elemento de lenguaje *.* y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|El `s` parámetro también puede utilizar la notación exponencial. Esta marca es compatible con los valores en el formulario *dígitos*E*dígitos*; adicionales se necesitan marcadores para analizar correctamente cadenas con elementos como signos positivos o negativos y los símbolos de separador decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *inicio de sesión* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *inicio de sesión* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *inicio de sesión* elemento en forma de paréntesis delimitando el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|El *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El * $ * elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos. El `s` parámetro no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `s`, *inicio de sesión* al principio de `s`y el *.* símbolo. El `s` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, *,*, y *.* elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los estilos excepto `s` no puede representar un número hexadecimal.|  
  
 El `s` parámetro se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto inicializado para la referencia cultural del sistema actual. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Un <xref:System.Decimal> tiene 29 dígitos de precisión. Si `s` representa un número que tiene más de 29 dígitos, pero tiene una parte fraccionaria y está dentro del intervalo de <xref:System.Decimal.MaxValue> y <xref:System.Decimal.MinValue>, el número se redondea, no se trunca a 29 dígitos utilizando el redondeo al más cercano.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis, `styles` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> son los mismos valores y la divisa aplicable o número decimal y separadores de grupos, la operación de análisis supone que se trata de un separador decimal en lugar de un separador de grupos. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método para analizar las representaciones de cadena de <xref:System.Decimal> valores mediante la referencia cultural en-US.  
  
 [!code-csharp[System.Decimal.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Parse/CS/parse.cs#2)]
 [!code-vb[System.Decimal.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Parse/VB/parse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> no es un valor <see cref="T:System.Globalization.NumberStyles" />.  -o bien- <paramref name="style" /> es el valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> no tiene el formato correcto.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa un número menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" /></exception>
        <altmember cref="Overload:System.Decimal.TryParse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Representación de cadena del número que va a convertirse.</param>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> que aporta información de análisis específica de la referencia cultural sobre <c>s</c>.</param>
        <summary>Convierte la representación de cadena de un número en su <see cref="T:System.Decimal" /> equivalente utilizando la información de formato específica de la referencia cultural especificada.</summary>
        <returns>Número <see cref="T:System.Decimal" /> equivalente al número contenido en <paramref name="s" />, tal y como especifica <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de la <xref:System.Decimal.Parse%28System.String%2CSystem.IFormatProvider%29> método normalmente se utiliza para convertir texto al que se puede aplicar formato en una variedad de formas de un <xref:System.Decimal> valor. Por ejemplo, se puede utilizar para convertir el texto escrito por un usuario en un cuadro de texto HTML en un valor numérico.  
  
 El `s` parámetro contiene un número del formulario:  
  
 [ws] [inicio de sesión] [dígitos,] dígitos [. dígitos fraccionarios] [eb]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional.|  
|*sign*|Un signo opcional.|  
|*digits*|Una secuencia de dígitos que comprende del 0 al 9.|  
|*,*|Específicas de referencias culturales miles símbolo de separador.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas.|  
|*dígitos fraccionarios*|Una secuencia de dígitos que comprende del 0 al 9.|  
  
 El `s` parámetro se interpreta usando el <xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType> estilo. Esto significa que el espacio en blanco y miles se permiten separadores pero no los símbolos de divisa. Para definir explícitamente los elementos (como símbolos de moneda, miles separadores y espacios en blanco) que pueden estar presentes en `s`, use el <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación, como un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural utilizada en el análisis. Si `provider` es `null`, se usa la referencia cultural actual del subproceso.  
  
 Un <xref:System.Decimal> objeto tiene 29 dígitos de precisión. Si `s` representa un número que tiene más de 29 dígitos, pero tiene una parte fraccionaria y está dentro del intervalo de <xref:System.Decimal.MaxValue> y <xref:System.Decimal.MinValue>, el número se redondea, no se trunca a 29 dígitos utilizando el redondeo al más cercano.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un separador de grupos. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente es el botón, haga clic en el controlador de eventos de un formulario Web Forms. Utiliza la matriz devuelta por la <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> propiedad para determinar la configuración regional del usuario. A continuación, crea una instancia de un <xref:System.Globalization.CultureInfo> objeto que corresponde a esa configuración regional. El <xref:System.Globalization.NumberFormatInfo> objeto al que pertenece a la <xref:System.Globalization.CultureInfo> , a continuación, se pasa el objeto a la <xref:System.Decimal.Parse%28System.String%2CSystem.IFormatProvider%29> para convertir el usuario de entrada del método a un <xref:System.Decimal> valor.  
  
 [!code-csharp[ParseMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#3)]
 [!code-vb[ParseMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> no tiene el formato correcto</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa un número menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" /></exception>
        <altmember cref="Overload:System.Decimal.TryParse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Number, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Number, Optional provider As IFormatProvider = null) As Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Representación de cadena del número que va a convertirse.</param>
        <param name="style">Combinación bit a bit de valores <see cref="T:System.Globalization.NumberStyles" /> que indica los elementos de estilo que pueden estar presentes en <c>s</c>. Un valor que se especifica de forma habitual es <see cref="F:System.Globalization.NumberStyles.Number" />.</param>
        <param name="provider">Objeto <see cref="T:System.IFormatProvider" /> que aporta información específica de la referencia cultural sobre el formato de <c>s</c>.</param>
        <summary>Convierte la representación de cadena de un número en su <see cref="T:System.Decimal" /> equivalente utilizando el estilo y el formato específico de la referencia cultural que se hayan especificado.</summary>
        <returns>Número <see cref="T:System.Decimal" /> equivalente al número contenido en <paramref name="s" />, tal y como especifican <paramref name="style" /> y <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `style` parámetro define el formato permitido de la `s` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración. El siguiente <xref:System.Globalization.NumberStyles> miembros no son compatibles:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Dependiendo del valor de `style`, el `s` parámetro puede incluir los siguientes elementos:  
  
 [ws] [$] [inicio de sesión] [dígitos,] dígitos [. dígitos fraccionarios] [e [signo] dígitos] [eb]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*$*|Un símbolo de moneda específico de la referencia cultural. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A> y <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> propiedades de la <xref:System.Globalization.NumberFormatInfo> objeto devuelto por la <xref:System.IFormatProvider.GetFormat%2A> método de la `provider` parámetro. El símbolo de moneda puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*ws*|Espacio en blanco opcional. Espacio en blanco puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca y pueden aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|*sign*|Un signo opcional. El signo puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y pueden aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `s` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*digits*|Una secuencia de dígitos que comprende del 0 al 9.|  
|*,*|Específicas de referencias culturales miles símbolo de separador. Los miles separador de la referencia cultural definida por `provider` pueden aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas. El símbolo de separador decimal de la referencia cultural definida por `provider` pueden aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*dígitos fraccionarios*|Una secuencia de dígitos que comprende del 0 al 9. Pueden aparecer dígitos fraccionarios en `s` solo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*e*|El 'e' o el carácter 'E', lo que indica que el valor se representa en notación exponencial. El `s` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
  
 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None> estilo) siempre se analiza correctamente. El resto <xref:System.Globalization.NumberStyles> miembros controlan los elementos que pueden ser pero no tienen que estar presentes en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> miembros afectan a los elementos que pueden estar presentes en `s`.  
  
|Valor NumberStyles|Elementos permitidos en s además de dígitos|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos* solo el elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El elemento de lenguaje *.* y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|El `s` parámetro también puede utilizar la notación exponencial.  Esta marca es compatible con los valores en el formulario *dígitos*E*dígitos*; adicionales se necesitan marcadores para analizar correctamente cadenas con elementos como signos positivos o negativos y los símbolos de separador decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *inicio de sesión* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *inicio de sesión* elemento situado al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *inicio de sesión* elemento en forma de paréntesis delimitando el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|El *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El * $ * elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos. El `s` parámetro no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `s`, *inicio de sesión* al principio de `s`y el *.* símbolo. El `s` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, *,*, y *.* elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los estilos excepto `s` no puede representar un número hexadecimal.|  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación, como un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural utilizada en el análisis. Si `provider` es `null`, se usa la referencia cultural actual del subproceso.  
  
 Un <xref:System.Decimal> objeto tiene 29 dígitos de precisión. Si `s` representa un número que tiene más de 29 dígitos, pero tiene una parte fraccionaria y está dentro del intervalo de <xref:System.Decimal.MaxValue> y <xref:System.Decimal.MinValue>, el número se redondea, no se trunca a 29 dígitos utilizando el redondeo al más cercano.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un separador de grupos. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza una variedad de `style` y `provider` parámetros para analizar las representaciones de cadena de <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Decimal.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Parse/CS/parse.cs#3)]
 [!code-vb[System.Decimal.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Parse/VB/parse.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> no tiene el formato correcto.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa un número menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> no es un valor <see cref="T:System.Globalization.NumberStyles" />.  -o bien- <paramref name="style" /> es el valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="Overload:System.Decimal.TryParse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static decimal Remainder (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Remainder(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Remainder(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Remainder(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Dividendo.</param>
        <param name="d2">Divisor.</param>
        <summary>Calcula el resto de la división de dos valores <see cref="T:System.Decimal" />.</summary>
        <returns>Resto después de dividir <paramref name="d1" /> por <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.Remainder%2A> método para calcular el resto de una serie de operaciones de división.  
  
 [!code-csharp[System.Decimal.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.remainder/cs/remainder.cs#1)]
 [!code-vb[System.Decimal.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.remainder/vb/remainder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> es cero.</exception>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redondea un valor al entero más próximo o al número especificado de posiciones decimales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a redondear.</param>
        <summary>Redondea un valor decimal al entero más próximo.</summary>
        <returns>El entero más cercano al parámetro <paramref name="d" />. Si <paramref name="d" /> se encuentra a la mitad del intervalo entre dos números enteros, uno par y el otro impar, se devuelve el número par.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de este método sigue el estándar IEEE 754, sección 4. Este tipo de redondeo a veces se denomina *de ida y vuelta para igualar la mitad* o *el redondeo bancario*. Minimiza los errores de redondeo que son el resultado de redondear de forma consistente un valor de punto medio en una dirección única. Es equivalente a llamar a la <xref:System.Decimal.Round%28System.Decimal%2CSystem.MidpointRounding%29> método con un `mode` argumento de <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se redondea a un intervalo de <xref:System.Decimal> valores entre 100 y 102 al entero más próximo. Dado que el método usa redondeo bancario, tenga en cuenta que 100.5 se redondea a 100 y 101,5 se redondeará hasta el valor 102.  
  
 [!code-csharp[System.Decimal.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Round/cs/Round1.cs#1)]
 [!code-vb[System.Decimal.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Round/vb/Round1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El resultado está fuera del intervalo de un valor <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a redondear.</param>
        <param name="decimals">Valor comprendido entre el 0 y el 28 que especifica el número de posiciones decimales a las que se va a redondear.</param>
        <summary>Redondea un valor <see cref="T:System.Decimal" /> a un número especificado de posiciones decimales.</summary>
        <returns>Número decimal equivalente a <paramref name="d" /> redondeado a un número <paramref name="decimals" /> de posiciones decimales.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente a llamar a la <xref:System.Decimal.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29> método con un `mode` argumento de <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>. Cuando `d` está exactamente comprendido entre dos valores redondeados, el resultado es el valor redondeado que tiene un dígito par en la posición decimal más a la derecha. Por ejemplo, cuando se redondea a dos decimales, el valor 2,345 se convierte en 2,34 y el valor 2,355 pasa a ser 2,36. Este proceso se conoce como *redondeo al par*, o *el redondeo bancario*. Minimiza los errores de redondeo que son el resultado de redondear de forma consistente un valor de punto medio en una dirección única.  
  
   
  
## Examples  
 En el ejemplo siguiente se redondea varios `Decimal` valores a un número especificado de posiciones decimales mediante el `Round` método.  
  
 [!code-csharp[System.Decimal.Round#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Round/cs/Round12.cs#12)]
 [!code-vb[System.Decimal.Round#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Round/vb/Round12.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> no es un valor comprendido entre 0 y 28.</exception>
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
        <altmember cref="M:System.Decimal.Truncate(System.Decimal)" />
        <altmember cref="M:System.Math.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a redondear.</param>
        <param name="mode">Valor que especifica el redondeo de <c>d</c> si su valor está a la mitad del intervalo entre otros dos números.</param>
        <summary>Redondea un valor decimal al entero más próximo. Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre otros dos números.</summary>
        <returns>El entero más cercano al parámetro <paramref name="d" />. Si <paramref name="d" /> se encuentra a la mitad del intervalo entre dos números, uno par y otro impar, el parámetro <paramref name="mode" /> determina el número que se devuelve.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de punto medio, el valor después de los dígitos menos significativos en el resultado es precisamente mitad de camino entre dos números. Por ejemplo, 7.5 es un valor de punto medio si no se redondea a un entero. Para los valores de punto medio, el valor más cercano no puede identificarse fácilmente sin una convención de redondeo, que se especifica mediante el `mode` argumento. El <xref:System.Decimal.Round%2A> método es compatible con dos convenciones de redondeo para controlar los valores de punto medio.  
  
 Redondeo para evitar el cero.  
 Los valores de punto medio se redondean al siguiente número de dirección contraria a cero. Por ejemplo, 3,5 se redondea a 4, 4.5 se redondeará a 5,-3.5 se redondea a -4, y-4.5 se redondea a -5. Esta forma de redondeo es representada por la <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> miembro de enumeración.  
  
 Redondeo para evitar el cero es la forma más ampliamente conocida de redondeo.  
  
 Redondeo incluso o redondeo bancario  
 Los valores de punto medio se redondean al número par más cercano. Por ejemplo, 3.5 y 4.5 de ida y vuelta a 4 y-3.5 y-4.5 de ida y vuelta a -4. Esta forma de redondeo es representada por la <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> miembro de enumeración.  
  
 Redondeo al más cercano es la forma estándar de redondeo utilizado en las operaciones financieras y estadísticas. Se ajusta al estándar IEEE 754, sección 4. Cuando se utiliza en varias operaciones de redondeo, reduce el error de redondeo que se debe a los valores de punto medio en una dirección única de redondear de forma consistente. En algunos casos, este error de redondeo puede ser significativo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra los valores devueltos por la <xref:System.Math.Round%28System.Decimal%29> método, el <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> método con un `mode` argumento de <xref:System.MidpointRounding.ToEven>y el <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> método con un `mode` argumento de <xref:System.MidpointRounding.AwayFromZero>.  
  
 [!code-csharp[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
 [!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> no es un valor <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">El resultado está fuera del intervalo de un objeto <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a redondear.</param>
        <param name="decimals">Número de posiciones decimales significativas (precisión) del valor devuelto.</param>
        <param name="mode">Valor que especifica el redondeo de <c>d</c> si su valor está a la mitad del intervalo entre otros dos números.</param>
        <summary>Redondea un valor decimal a una precisión especificada. Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre otros dos números.</summary>
        <returns>Número más cercano al parámetro <paramref name="d" /> con una precisión igual al parámetro <paramref name="decimals" />. Si <paramref name="d" /> se encuentra a la mitad del intervalo entre dos números, uno par y otro impar, el parámetro <paramref name="mode" /> determina el número que se devuelve. Si la precisión de <paramref name="d" /> es menor que <paramref name="decimals" />, se devuelve <paramref name="d" /> sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `decimals` parámetro especifica el número de posiciones decimales significativas en el valor devuelto y comprendido entre 0 y 28. Si `decimals` es cero, se devuelve un entero.  
  
 Un valor de punto medio, el valor después de los dígitos menos significativos en el resultado es precisamente mitad de camino entre dos números. Por ejemplo, 3.47500 es un valor de punto medio si no redondea a dos posiciones decimales y 7.500 es un valor de punto medio si no se redondea a un entero. En estos casos, el valor más cercano no puede identificarse fácilmente sin una convención de redondeo, que se especifica mediante el `mode` argumento. El <xref:System.Decimal.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29> método es compatible con dos convenciones de redondeo para controlar los valores de punto medio.  
  
 Redondeo para evitar el cero.  
 Los valores de punto medio se redondean al siguiente número de dirección contraria a cero. Por ejemplo, se redondea 3,75 a 3.8, 3.85 se redondeará a 3.9,-3.75 se redondea a-3.8, y-3.85 se redondea a-3.9. Esta forma de redondeo es representada por la <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> miembro de enumeración.  
  
 Redondeo para evitar el cero es la forma más ampliamente conocida de redondeo.  
  
 Redondeo incluso o redondeo bancario  
 Los valores de punto medio se redondean al número par más cercano. Por ejemplo, redondear 3.8 3,75 y 3.85 y-3.75 y-3.85 de ida y vuelta a-3.8. Esta forma de redondeo es representada por la <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> miembro de enumeración.  
  
 Redondeo al más cercano es la forma estándar de redondeo utilizado en las operaciones financieras y estadísticas. Se ajusta al estándar IEEE 754, sección 4. Cuando se utiliza en varias operaciones de redondeo, reduce el error de redondeo que se debe a los valores de punto medio en una dirección única de redondear de forma consistente. En algunos casos, este error de redondeo puede ser significativo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29> método con el <xref:System.MidpointRounding> enumeración.  
  
 [!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
 [!code-csharp[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
 [!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> es menor que 0 o mayor que 28.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> no es un valor <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">El resultado está fuera del intervalo de un objeto <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static decimal Subtract (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Subtract(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Subtract(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Minuendo.</param>
        <param name="d2">Sustraendo.</param>
        <summary>Resta un valor <see cref="T:System.Decimal" /> especificado de otro.</summary>
        <returns>Resultado de restar <paramref name="d2" /> de <paramref name="d1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra el uso de `Subtract`.  
  
 [!code-cpp[Decimal Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#4)]
 [!code-csharp[Decimal Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#4)]
 [!code-vb[Decimal Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor devuelto es menor que <see cref="F:System.Decimal.MinValue" /> o mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>Es <see langword="true" /> si el valor de la instancia actual no es cero; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToBoolean%28System.Decimal%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToByte%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToByte%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor entero resultante es menor que <see cref="F:System.Byte.MinValue" /> o mayor que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>No se admite esta conversión. Cualquier intento de usar este método produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Ninguno. No se admite esta conversión.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>No se admite esta conversión. Cualquier intento de usar este método produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Ninguno. No se admite esta conversión.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, sin ningún tipo de modificación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToDouble%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToDouble%2A?displayProperty=nameWithType> método.  
  
 Dado que un <xref:System.Double> tiene menos dígitos significativos que un <xref:System.Decimal>, esta operación puede producir errores de redondeo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToInt16%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToInt16%2A?displayProperty=nameWithType> método.  
  
 El <xref:System.Decimal> valor se redondea hacia cero al valor entero más cercano.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor entero resultante es menor que <see cref="F:System.Int16.MinValue" /> o mayor que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Se omite el parámetro.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToInt32%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToInt32%2A?displayProperty=nameWithType> método.  
  
 El <xref:System.Decimal> valor se redondea hacia cero al valor entero más cercano.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor entero resultante es menor que <see cref="F:System.Int32.MinValue" /> o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToInt64%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToInt64%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor entero resultante es menor que <see cref="F:System.Int64.MinValue" /> o mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToSByte%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToSByte%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor entero resultante es menor que <see cref="F:System.SByte.MinValue" /> o mayor que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToSingle%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToSingle%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo al que se va a convertir el valor de esta instancia de <see cref="T:System.Decimal" />.</param>
        <param name="provider">Implementación de <see cref="T:System.IFormatProvider" /> que proporciona información específica de la referencia cultural sobre el formato del valor devuelto.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la `static` (`Shared` en Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> método en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">No se admite la conversión de tipo solicitada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToUInt16%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToUInt16%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor entero resultante es menor que <see cref="F:System.UInt16.MinValue" /> o mayor que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToUInt32%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToUInt32%2A?displayProperty=nameWithType> método.  
  
 El <xref:System.Decimal> valor se redondea hacia cero al valor entero más cercano.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor entero resultante es menor que <see cref="F:System.UInt32.MinValue" /> o mayor que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Decimal> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Decimal.ToUInt64%2A?displayProperty=nameWithType> método o la <xref:System.Convert.ToUInt64%2A?displayProperty=nameWithType> método.  
  
 El <xref:System.Decimal> valor se redondea hacia cero al valor entero más cercano.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor entero resultante es menor que <see cref="F:System.UInt64.MinValue" /> o mayor que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Objeto que inició la devolución de llamada. La funcionalidad de este parámetro aún no está implementada.</param>
        <summary>Se ejecuta cuando se completa la deserialización de un objeto.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">El objeto <see cref="T:System.Decimal" /> contiene datos no válidos o dañados.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToByte(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToByte (value As Decimal) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ToByte(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el entero de 8 bits sin signo equivalente.</summary>
        <returns>Entero de 8 bits sin signo equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parámetro `value` se redondea al valor entero más cercano a cero, y se devuelve el resultado.  
  
 También puede convertir un <xref:System.Decimal> valor a un entero de 8 bits sin signo mediante el uso de la <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que el operador realiza una conversión de restricción, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.ToByte%2A> método para convertir números decimales <xref:System.Byte> valores.  
  
 [!code-csharp[System.Decimal.ToByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.tobyte/cs/tobyte_1.cs#1)]
 [!code-vb[System.Decimal.ToByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.tobyte/vb/tobyte_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.Byte.MinValue" /> o mayor que <see cref="F:System.Byte.MaxValue" />.</exception>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToDouble(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToDouble (d As Decimal) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ToDouble(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el número de punto flotante de precisión doble equivalente.</summary>
        <returns>Número de punto flotante de precisión doble equivalente a <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación puede producir errores de redondeo porque un número de punto flotante de precisión doble tiene menos dígitos significativos que un <xref:System.Decimal>.  
  
 También puede convertir un <xref:System.Decimal> a una <xref:System.Double> valor mediante el uso de la <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que la conversión puede implicar una pérdida de precisión, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 El siguiente código de ejemplo convierte `Decimal` números a <xref:System.Double> valores mediante `ToDouble` método.  
  
 [!code-cpp[System.Decimal.ToXXX#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CPP/tosgl_dbl.cpp#5)]
 [!code-csharp[System.Decimal.ToXXX#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CS/tosgl_dbl.cs#5)]
 [!code-vb[System.Decimal.ToXXX#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToXXX/VB/tosgl_dbl.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToInt16(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt16 (value As Decimal) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ToInt16(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el entero de 16 bits con signo equivalente.</summary>
        <returns>Entero de 16 bits con signo que equivale a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 También puede convertir un <xref:System.Decimal> valor en un entero de 16 bits mediante el uso de la <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que el operador realiza una conversión de restricción, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.ToInt16%2A> método para convertir números decimales <xref:System.Int16> valores.  
  
 [!code-csharp[System.Decimal.ToInt16#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.toint16/cs/toint16_1.cs#1)]
 [!code-vb[System.Decimal.ToInt16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.toint16/vb/toint16_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.Int16.MinValue" /> o mayor que <see cref="F:System.Int16.MaxValue" />.</exception>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToInt32(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt32 (d As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ToInt32(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el entero de 32 bits con signo equivalente.</summary>
        <returns>Entero de 32 bits con signo que equivale al valor de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto es la parte entera del valor decimal; se truncan los dígitos fraccionarios.  
  
 También puede convertir un <xref:System.Decimal> valor en un entero de 32 bits mediante el uso de la <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que el operador realiza una conversión de restricción, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.ToInt32%2A> método para convertir números decimales <xref:System.Int32> valores.  
  
 [!code-csharp[System.Decimal.ToInt32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.toint32/cs/toint32_1.cs#1)]
 [!code-vb[System.Decimal.ToInt32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.toint32/vb/toint32_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> es menor que <see cref="F:System.Int32.MinValue" /> o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToInt64(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt64 (d As Decimal) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ToInt64(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el entero de 64 bits con signo equivalente.</summary>
        <returns>Entero de 64 bits con signo que equivale al valor de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto es la parte entera del valor decimal; se truncan los dígitos fraccionarios.  
  
 También puede convertir un <xref:System.Decimal> valor en un entero de 64 bits mediante el uso de la <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que el operador realiza una conversión de restricción, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.ToInt64%2A> método para convertir números decimales <xref:System.Int64> valores.  
  
 [!code-csharp[System.Decimal.ToInt64#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.toint64/cs/toint64_1.cs#1)]
 [!code-vb[System.Decimal.ToInt64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.toint64/vb/toint64_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> es menor que <see cref="F:System.Int64.MinValue" /> o mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="ToOACurrency">
      <MemberSignature Language="C#" Value="public static long ToOACurrency (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToOACurrency(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToOACurrency(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToOACurrency (value As Decimal) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ToOACurrency(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor <see cref="T:System.Decimal" /> especificado en el valor de moneda de Automation OLE equivalente, que está contenido en un entero de 64 bits con signo.</summary>
        <returns>Entero de 64 bits con signo que contiene el equivalente de Automation OLE de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el `ToOACurrency` método para convertir `Decimal` números en los valores de moneda de automatización OLE equivalente que se encuentran en <xref:System.Int64> campos.  
  
 [!code-cpp[System.Decimal.OACurrency#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CPP/tooacurrency.cpp#1)]
 [!code-csharp[System.Decimal.OACurrency#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CS/tooacurrency.cs#1)]
 [!code-vb[System.Decimal.OACurrency#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.OACurrency/VB/tooacurrency.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.FromOACurrency(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToSByte(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToSByte (value As Decimal) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte ToSByte(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el entero de 8 bits con signo equivalente.</summary>
        <returns>Entero de 8 bits con signo que equivale a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 También puede convertir un <xref:System.Decimal> valor a un entero de 8 bits con signo utilizando el <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que el operador realiza una conversión de restricción, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.ToSByte%2A> método para convertir números decimales <xref:System.SByte> valores.  
  
 [!code-csharp[System.Decimal.ToSByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.tosbyte/cs/tosbyte1.cs#1)]
 [!code-vb[System.Decimal.ToSByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.tosbyte/vb/tosbyte1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Decimal.ToInt16(System.Decimal)" />
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es menor que <see cref="F:System.SByte.MinValue" /> o mayor que <see cref="F:System.SByte.MaxValue" />.</exception>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToSingle(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToSingle (d As Decimal) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ToSingle(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el número de punto flotante de precisión sencilla equivalente.</summary>
        <returns>Número de punto flotante de precisión sencilla que equivale al valor de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación puede producir errores de redondeo porque un número de punto flotante de precisión simple tiene menos dígitos significativos que un <xref:System.Decimal>.  
  
 También puede convertir un <xref:System.Decimal> a una <xref:System.Single> valor mediante el uso de la <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que la conversión puede implicar una pérdida de precisión, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 El siguiente código de ejemplo convierte `Decimal` números a <xref:System.Single> valores mediante la `ToSingle` método.  
  
 [!code-cpp[System.Decimal.ToXXX#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CPP/tosgl_dbl.cpp#5)]
 [!code-csharp[System.Decimal.ToXXX#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CS/tosgl_dbl.cs#5)]
 [!code-vb[System.Decimal.ToXXX#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToXXX/VB/tosgl_dbl.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor numérico de esta instancia en la representación de <see cref="T:System.String" /> equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente.</summary>
        <returns>Cadena que representa el valor de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.ToString> método formatos un <xref:System.Decimal> valor en el valor predeterminado ("G" o general), formato de la referencia cultural actual. Si desea especificar un formato diferente o la referencia cultural, use las otras sobrecargas de la <xref:System.Decimal.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Una referencia cultural específica|<xref:System.Decimal.ToString%28System.IFormatProvider%29>|  
|Un formato concreto|Referencia cultural predeterminada de (actual).|<xref:System.Decimal.ToString%28System.String%29>|  
|Un formato concreto|Una referencia cultural específica|<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre cómo dar formato, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un <xref:System.Decimal> valor mediante el valor predeterminado <xref:System.Decimal.ToString> método. También muestra las representaciones de cadena de la <xref:System.Decimal> valor derivados del uso de un número de especificadores de formato estándar.  
  
 [!code-csharp[System.Decimal.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#2)]
 [!code-vb[System.Decimal.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#2)]  
  
 En el ejemplo siguiente se muestra la cantidad de dinero de una cuenta.  
  
 [!code-cpp[Decimal Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#5)]
 [!code-csharp[Decimal Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#5)]
 [!code-vb[Decimal Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente usando la información de formato específica de la referencia cultural especificada.</summary>
        <returns>Representación en forma de cadena del valor de esta instancia, tal y como especifica <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.ToString%28System.IFormatProvider%29> método formatos un <xref:System.Decimal> valor en el valor predeterminado ("G" o general), formato de una referencia cultural especificada. Si desea especificar un formato diferente o la referencia cultural actual, use las otras sobrecargas de la <xref:System.Decimal.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Referencia cultural predeterminada de (actual).|<xref:System.Decimal.ToString>|  
|Un formato concreto|Referencia cultural predeterminada de (actual).|<xref:System.Decimal.ToString%28System.String%29>|  
|Un formato concreto|Una referencia cultural específica|<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre cómo dar formato, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto. Por lo general, `provider` es un <xref:System.Globalization.NumberFormatInfo> objeto o un <xref:System.Globalization.CultureInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural utilizada para dar formato. Si `provider` es `null`, se usa la referencia cultural actual del subproceso.  
  
 Para convertir un <xref:System.Decimal> valor en su representación de cadena utilizando una referencia cultural especificada y una cadena de formato específico, llamada la <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la representación de cadena de un <xref:System.Decimal> valor usando <xref:System.Globalization.CultureInfo> objetos que representan varias referencias culturales diferentes.  
  
 [!code-csharp[System.Decimal.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#3)]
 [!code-vb[System.Decimal.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato numérico estándar o personalizada.</param>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente usando el formato especificado.</summary>
        <returns>Representación en forma de cadena del valor de esta instancia, tal y como especifica <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Decimal.ToString%28System.String%29> método formatos un <xref:System.Decimal> valor en un formato especificado usando las convenciones de la referencia cultural actual. Si desea utilizar el valor predeterminado ("G" o general) dar formato o especificar una referencia cultural diferente, use las otras sobrecargas de la <xref:System.Decimal.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Referencia cultural predeterminada de (actual).|<xref:System.Decimal.ToString>|  
|Formato predeterminado ("G")|Una referencia cultural específica|<xref:System.Decimal.ToString%28System.IFormatProvider%29>|  
|Un formato concreto|Una referencia cultural específica|<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 El <xref:System.Decimal.ToString%2A> método usa la cadena de formato numérico estándar o personalizada especificada por el `format` parámetro para convertir el valor de la instancia actual en su representación de cadena. El `format` parámetro puede ser cualquier [especificador de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) salvo D, R y X, así como cualquier combinación de [especificadores de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Si `format` es `null` o una cadena vacía, el valor devuelto de esta instancia está formateada con el especificador de formato numérico general (G).  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre cómo dar formato, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
 El valor devuelto se da formato mediante la <xref:System.Globalization.NumberFormatInfo> objeto para la referencia cultural actual. Para aplicar las convenciones de formato de una referencia cultural especificada, llame a la <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un <xref:System.Decimal> valor con cada uno de los especificadores de formato numérico estándar compatibles, junto con dos cadenas de formato numérico personalizado. Para convertir los valores numéricos en cadenas, el ejemplo utiliza las convenciones de formato de la referencia cultural en-US.  
  
 [!code-csharp[System.Decimal.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#4)]
 [!code-vb[System.Decimal.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> no es válido.</exception>
        <altmember cref="M:System.Decimal.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato numérico.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor numérico de esta instancia en su representación de cadena equivalente mediante el formato y la información de formato específica de la referencia cultural que se especificaran.</summary>
        <returns>Representación de cadena del valor de esta instancia, tal y como especifican <paramref name="format" /> y <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> método formatos un <xref:System.Double> valor en un formato específico de la referencia cultural especificada. Si desea utilizar la configuración predeterminada de formato o la referencia cultural, use las otras sobrecargas de la <xref:System.Double.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Referencia cultural predeterminada de (actual).|<xref:System.Double.ToString>|  
|Formato predeterminado ("G")|Una referencia cultural específica|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato concreto|Referencia cultural predeterminada de (actual).|<xref:System.Double.ToString%28System.String%29>|  
  
 El `format` parámetro puede ser cualquier especificador de formato numérico estándar válido salvo D, R y X, así como cualquier combinación de especificadores de formato numérico personalizado. Si `format` es `null` o una cadena vacía, el valor devuelto de esta instancia está formateada con el especificador de formato numérico general ("G").  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre cómo dar formato, consulte [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto. Por lo general, `provider` es un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural utilizada para dar formato. Si `provider` es `null`, se usa la referencia cultural actual del subproceso.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un <xref:System.Decimal> valor con cada uno de los especificadores de formato numérico estándar compatibles para varias referencias culturales diferentes.  
  
 [!code-csharp[System.Decimal.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#5)]
 [!code-vb[System.Decimal.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> no es válido.</exception>
        <altmember cref="M:System.Decimal.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToUInt16(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUInt16 (value As Decimal) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ToUInt16(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el entero de 16 bits sin signo equivalente.</summary>
        <returns>Entero de 16 bits sin signo que equivale al valor de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto es la parte entera del valor decimal; se truncan los dígitos fraccionarios.  
  
 También puede convertir un <xref:System.Decimal> valor a un entero de 16 bits sin signo mediante el uso de la <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que el operador realiza una conversión de restricción, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.ToUInt16%2A> método para convertir números decimales <xref:System.UInt16> valores.  
  
 [!code-csharp[System.Decimal.ToUInt16#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.touint16/cs/touint16_1.cs#1)]
 [!code-vb[System.Decimal.ToUInt16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.touint16/vb/touint16_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Decimal.ToInt32(System.Decimal)" />
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> es mayor que <see cref="F:System.UInt16.MaxValue" /> o menor que <see cref="F:System.UInt16.MinValue" />.</exception>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToUInt32(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUInt32 (d As Decimal) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ToUInt32(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el entero de 32 bits sin signo equivalente.</summary>
        <returns>Entero de 32 bits sin signo que equivale al valor de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto es la parte entera del valor decimal; se truncan los dígitos fraccionarios.  
  
 También puede convertir un <xref:System.Decimal> valor en un entero sin signo de 32 bits mediante el uso de la <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que el operador realiza una conversión de restricción, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.ToUInt32%2A> método para convertir números decimales <xref:System.UInt32> valores.  
  
 [!code-csharp[System.Decimal.ToUInt32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.touint32/cs/touint32_1.cs#1)]
 [!code-vb[System.Decimal.ToUInt32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.touint32/vb/touint32_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Decimal.ToInt64(System.Decimal)" />
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> es negativo o mayor que <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToUInt64(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUInt64 (d As Decimal) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ToUInt64(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a convertir.</param>
        <summary>Convierte el valor del <see cref="T:System.Decimal" /> especificado en el entero de 64 bits sin signo equivalente.</summary>
        <returns>Entero de 64 bits sin signo que equivale al valor de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto es la parte entera del valor decimal; se truncan los dígitos fraccionarios.  
  
 También puede convertir un <xref:System.Decimal> valor en un entero sin signo de 64 bits mediante el uso de la <xref:System.Decimal.op_Explicit%2A> operador de asignación. Dado que el operador realiza una conversión de restricción, debe usar un operador de conversión en C# o una función de conversión en Visual Basic.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.ToUInt64%2A> método para convertir números decimales <xref:System.UInt64> valores.  
  
 [!code-csharp[System.Decimal.ToUInt64#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.touint64/cs/touint64_1.cs#1)]
 [!code-vb[System.Decimal.ToUInt64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.touint64/vb/touint64_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> es negativo o mayor que <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Truncate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Truncate(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Número decimal que se va a truncar.</param>
        <summary>Devuelve los dígitos integrales del <see cref="T:System.Decimal" /> especificado; los dígitos fraccionarios se descartan.</summary>
        <returns>Resultado de redondear <paramref name="d" /> al número entero más próximo, hacia cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método redondea `d` hacia cero, al número entero más próximo, que corresponde a descartar los dígitos situados después del punto decimal.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el `Truncate` método para descartar los dígitos fraccionarios de varios `Decimal` valores.  
  
 [!code-cpp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CPP/floor_neg_trunc.cpp#1)]
 [!code-csharp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CS/floor_neg_trunc.cs#1)]
 [!code-vb[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/VB/floor_neg_trunc.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la representación en forma de cadena de un número en su <see cref="T:System.Decimal" /> equivalente. Un valor devuelto indica si la conversión se realizó correctamente o si se produjeron errores.</summary>
        <altmember cref="Overload:System.Decimal.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.ReadOnlySpan{System.Char},System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] System::Decimal % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.String,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] System::Decimal % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Representación de cadena del número que va a convertirse.</param>
        <param name="result">To be added.</param>
        <summary>Convierte la representación en forma de cadena de un número en su <see cref="T:System.Decimal" /> equivalente. Un valor devuelto indica si la conversión se realizó correctamente o si se produjeron errores.</summary>
        <returns>
          <see langword="true" /> si <paramref name="s" /> se convirtió correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga difiere de la <xref:System.Decimal.Parse%28System.String%29?displayProperty=nameWithType> método devolviendo un valor booleano que indica si la operación de análisis se realizó correctamente en lugar de devolver el valor numérico analizado. Elimina la necesidad de utilizar el control de excepciones para probar una <xref:System.FormatException> en caso de que `s` no es válido y no se puede analizar correctamente.  
  
 Parámetro `s` contiene un número de la forma:  
  
 [ws] [inicio de sesión] [dígitos,] dígitos [. dígitos fraccionarios] [eb]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional.|  
|*sign*|Un signo opcional.|  
|*digits*|Una secuencia de dígitos que comprende del 0 al 9.|  
|*,*|Específicas de referencias culturales miles símbolo de separador.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas.|  
|*dígitos fraccionarios*|Una secuencia de dígitos que comprende del 0 al 9.|  
  
 Parámetro `s` se interpreta usando el <xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType> estilo. Esto significa que el espacio en blanco y miles se permiten separadores pero no los símbolos de divisa. Para definir explícitamente los elementos (como símbolos de moneda, miles separadores y espacios en blanco) que pueden estar presentes en `s`, use el <xref:System.Decimal.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Decimal%40%29?displayProperty=nameWithType> sobrecarga del método.  
  
 Parámetro `s` se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto inicializado para la referencia cultural del sistema actual. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Para analizar una cadena usando la información de formato de alguna otra especifica la referencia cultural, use el <xref:System.Decimal.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Decimal%40%29?displayProperty=nameWithType> sobrecarga del método.  
  
 Si es necesario, el valor de `s` se redondea utilizando el redondeo al más cercano.  
  
 Un <xref:System.Decimal> objeto tiene 29 dígitos de precisión. Si `s` representa un número que tiene más de 29 dígitos, pero tiene una parte fraccionaria y está dentro del intervalo de <xref:System.Decimal.MaxValue> y <xref:System.Decimal.MinValue>, el número se redondea, no se trunca a 29 dígitos utilizando el redondeo al más cercano.  
  
 Si durante una operación de análisis se encuentra un separador en la `s` parámetro y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un separador de grupos. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Decimal.TryParse%28System.String%2CSystem.Decimal%40%29?displayProperty=nameWithType> método para convertir las representaciones de cadena de valores numéricos a <xref:System.Decimal> valores. Se supone que en-US es la referencia cultural actual.  
  
 [!code-csharp[System.Decimal.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.TryParse/cs/TryParse.cs#1)]
 [!code-vb[System.Decimal.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.TryParse/vb/TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Decimal.Parse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Decimal % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Decimal % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Representación de cadena del número que va a convertirse.</param>
        <param name="style">Combinación bit a bit de valores de enumeración que indica el formato permitido de <c>s</c>. Un valor que se especifica de forma habitual es <see cref="F:System.Globalization.NumberStyles.Number" />.</param>
        <param name="provider">Objeto que proporciona información de análisis específica de la referencia cultural sobre <c>s</c>.</param>
        <param name="result">To be added.</param>
        <summary>Convierte la representación de cadena de un número en su <see cref="T:System.Decimal" /> equivalente utilizando el estilo y el formato específico de la referencia cultural que se hayan especificado. Un valor devuelto indica si la conversión se realizó correctamente o si se produjeron errores.</summary>
        <returns>
          <see langword="true" /> si <paramref name="s" /> se convirtió correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga difiere de la <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método devolviendo un valor booleano que indica si la operación de análisis se realizó correctamente en lugar de devolver el valor numérico analizado. Elimina la necesidad de utilizar el control de excepciones para probar una <xref:System.FormatException> en caso de que `s` no es válido y no se puede analizar correctamente.  
  
 El `style` parámetro define el formato permitido de la `s` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración. El siguiente <xref:System.Globalization.NumberStyles> miembros no son compatibles:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Dependiendo del valor de estilo, el `s` parámetro puede incluir los siguientes elementos:  
  
 [ws] [$] [inicio de sesión] [dígitos,] dígitos [. dígitos fraccionarios] [e [signo] dígitos] [eb]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional. Espacio en blanco puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca. Puede aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|*$*|Un símbolo de moneda específico de la referencia cultural. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> o <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la <xref:System.Globalization.NumberFormatInfo> objeto devuelto por la <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> método de la `provider` parámetro. El símbolo de moneda puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Un signo opcional.|  
|*digits*|Una secuencia de dígitos que comprende del 0 al 9.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas.|  
|*dígitos fraccionarios*|Una secuencia de dígitos que comprende del 0 al 9.|  
  
 El `style` parámetro especifica el formato permitido de la `s` parámetro y puede tener uno o más <xref:System.Globalization.NumberStyles> combinadas mediante una operación OR bit a bit de constantes enumeradas. Si `style` es null, `s` se interpreta usando el <xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType> estilo.  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación como un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural utilizada en el análisis. Si `provider` es `null`, se usa la referencia cultural actual del subproceso.  
  
 Un <xref:System.Decimal> objeto tiene 29 dígitos de precisión. Si `s` representa un número que tiene más de 29 dígitos, pero tiene una parte fraccionaria y está dentro del intervalo de <xref:System.Decimal.MaxValue> y <xref:System.Decimal.MinValue>, el número se redondea, no se trunca a 29 dígitos utilizando el redondeo al más cercano.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupos son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un separador de grupos. Para obtener más información acerca de los separadores, vea <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Decimal.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Decimal%40%29> método para analizar la representación de cadena de un número que tiene un estilo determinado y se da formato usando las convenciones de una referencia cultural determinada.  
  
 [!code-csharp[System.Decimal.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.TryParse/cs/TryParse.cs#2)]
 [!code-vb[System.Decimal.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.TryParse/vb/TryParse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> no es un valor <see cref="T:System.Globalization.NumberStyles" />.  -o bien- <paramref name="style" /> es el valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="Overload:System.Decimal.Parse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly decimal Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal Zero" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el número cero (0).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la `Zero` campo.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.One" />
        <altmember cref="F:System.Decimal.MinusOne" />
        <altmember cref="F:System.Decimal.MaxValue" />
        <altmember cref="F:System.Decimal.MinValue" />
      </Docs>
    </Member>
  </Members>
</Type>