<Type Name="UriTemplateTable" FullName="System.UriTemplateTable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5219e55b5c96c0d5a7a1eb2a23576c2985f89d35" /><Meta Name="ms.sourcegitcommit" Value="b0551d7828f015124aca601dbb64bd913cc5067d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/13/2018" /><Meta Name="ms.locfileid" Value="53333513" /></Metadata><TypeSignature Language="C#" Value="public class UriTemplateTable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UriTemplateTable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.UriTemplateTable" />
  <TypeSignature Language="VB.NET" Value="Public Class UriTemplateTable" />
  <TypeSignature Language="C++ CLI" Value="public ref class UriTemplateTable" />
  <TypeSignature Language="F#" Value="type UriTemplateTable = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Web</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Una clase que representa un conjunto asociativo de objetos <see cref="T:System.UriTemplate" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UriTemplateTable> es un conjunto asociativo de objetos <xref:System.UriTemplate> enlazado a un objeto elegido por el desarrollador. Le permite hacer coincidir los identificadores uniformes de recursos (URI) del candidato con las plantillas del conjunto y recuperar los datos asociados a las plantillas correspondientes. Se puede cambiar el contenido de <xref:System.UriTemplateTable> hasta que se llame al método <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29>. En ese momento se producirá uno de los tipos siguientes de validación:  
  
-   Cuando se llama a <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> al pasar en `false`, <xref:System.UriTemplateTable> realiza una comprobación para asegurarse de que la tabla no contiene varias plantillas estructuralmente equivalentes. Si encuentra esas plantillas, inicia una excepción. Este tipo de validación se utiliza junto con <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> cuando desea asegurarse de que sólo una plantilla coincide con un URI de entrada.  
  
-   Cuando se llama a <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> al pasar en `true`, varias plantillas estructuralmente equivalentes pueden estar contenidas dentro de una <xref:System.UriTemplateTable>. Sin embargo, las cadenas de consulta de las plantillas no deben ser ambiguas; se permiten las cadenas de consulta idénticas. Para obtener más información acerca de las cadenas de consulta ambiguas, consulte [UriTemplate y UriTemplateTable](~/docs/framework/wcf/feature-details/uritemplate-and-uritemplatetable.md).  
  
   
  
## Examples  
 En el código siguiente se muestra cómo crear <xref:System.UriTemplateTable>, rellenarlo y utilizarlo para que coincida con un <xref:System.Uri> candidato.  
  
 [!code-csharp[UriTemplateTable#0](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/program.cs#0)]
 [!code-vb[UriTemplateTable#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/program1.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.UriTemplateTable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.UriTemplateTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el siguiente ejemplo se muestra cómo crear una instancia de la clase <xref:System.UriTemplateTable>.  
  
 [!code-csharp[UriTemplateTable#1](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/program.cs#1)]
 [!code-vb[UriTemplateTable#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate,object&gt;&gt; keyValuePairs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.UriTemplate, object&gt;&gt; keyValuePairs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.UriTemplate,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keyValuePairs As IEnumerable(Of KeyValuePair(Of UriTemplate, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ keyValuePairs);" />
      <MemberSignature Language="F#" Value="new UriTemplateTable : seq&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate, obj&gt;&gt; -&gt; UriTemplateTable" Usage="new System.UriTemplateTable keyValuePairs" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="keyValuePairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.UriTemplate,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePairs">Una colección de pares clave/valor que están compuestos de plantillas URI y datos asociados.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.UriTemplateTable" /> con la colección de pares clave/valor especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el siguiente ejemplo se muestra cómo crear una instancia de la clase <xref:System.UriTemplateTable>.  
  
 [!code-csharp[UriTemplateTable#2](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#2)]
 [!code-vb[UriTemplateTable#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable (Uri baseAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseAddress As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable(Uri ^ baseAddress);" />
      <MemberSignature Language="F#" Value="new UriTemplateTable : Uri -&gt; UriTemplateTable" Usage="new System.UriTemplateTable baseAddress" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Una instancia <see cref="T:System.Uri" /> que contiene la dirección base.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.UriTemplateTable" /> con la dirección base especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo muestra cómo llamar a este constructor.  
  
 [!code-csharp[UriTemplateTable#3](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/program.cs#3)]
 [!code-vb[UriTemplateTable#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/program1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable (Uri baseAddress, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate,object&gt;&gt; keyValuePairs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseAddress, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.UriTemplate, object&gt;&gt; keyValuePairs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.UriTemplate,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseAddress As Uri, keyValuePairs As IEnumerable(Of KeyValuePair(Of UriTemplate, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable(Uri ^ baseAddress, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ keyValuePairs);" />
      <MemberSignature Language="F#" Value="new UriTemplateTable : Uri * seq&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate, obj&gt;&gt; -&gt; UriTemplateTable" Usage="new System.UriTemplateTable (baseAddress, keyValuePairs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
        <Parameter Name="keyValuePairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.UriTemplate,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Una instancia <see cref="T:System.Uri" /> que contiene la dirección base.</param>
        <param name="keyValuePairs">Una colección de pares clave/valor que están compuestos de plantillas URI y datos asociados.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.UriTemplateTable" /> con la dirección base y la colección de pares clave/valor especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo muestra cómo llamar a este constructor.  
  
 [!code-csharp[UriTemplateTable#4](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#4)]
 [!code-vb[UriTemplateTable#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseAddress">
      <MemberSignature Language="C#" Value="public Uri BaseAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri BaseAddress" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.BaseAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property BaseAddress As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ BaseAddress { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BaseAddress : Uri with get, set" Usage="System.UriTemplateTable.BaseAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la dirección base para la instancia <see cref="T:System.UriTemplateTable" />.</summary>
        <value><see cref="T:System.Uri" /> que contiene la dirección base.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad <xref:System.UriTemplateTable.BaseAddress%2A> solo se puede establecer antes de llamar a <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29>, <xref:System.UriTemplateTable.Match%28System.Uri%29> o <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29>, de lo contrario se inicia <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se obtiene acceso a la propiedad <xref:System.UriTemplateTable.BaseAddress%2A>.  
  
 [!code-csharp[UriTemplateTable#5](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#5)]
 [!code-vb[UriTemplateTable#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.UriTemplateTable.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que especifica si <see cref="T:System.UriTemplateTable" /> es de solo lectura.</summary>
        <value><see langword="true" /> si la propiedad <see cref="T:System.UriTemplateTable" /> es de solo lectura; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UriTemplateTable> es de solo lectura después de que se llame el método <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29>.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se obtiene acceso a la propiedad <xref:System.UriTemplateTable.IsReadOnly%2A>.  
  
 [!code-csharp[UriTemplateTable#6](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#6)]
 [!code-vb[UriTemplateTable#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyValuePairs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate,object&gt;&gt; KeyValuePairs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.UriTemplate, object&gt;&gt; KeyValuePairs" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.KeyValuePairs" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyValuePairs As IList(Of KeyValuePair(Of UriTemplate, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ KeyValuePairs { System::Collections::Generic::IList&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyValuePairs : System.Collections.Generic.IList&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate, obj&gt;&gt;" Usage="System.UriTemplateTable.KeyValuePairs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Collections.Generic.KeyValuePair&lt;System.UriTemplate,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de pares de clave/valor que se componen de los objetos <see cref="T:System.UriTemplate" /> y sus datos asociados.</summary>
        <value>Una colección de pares de clave/valor que se componen de los objetos <see cref="T:System.UriTemplate" /> y sus datos asociados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada instancia <xref:System.UriTemplate> de la tabla tiene datos asociados. La propiedad <xref:System.UriTemplateTable.KeyValuePairs%2A> contiene una colección de pares clave/valor donde la clave es una instancia <xref:System.UriTemplate> y el valor son los datos asociados a <xref:System.UriTemplate>. Los valores solo se pueden agregar a la propiedad <xref:System.UriTemplateTable.KeyValuePairs%2A> antes de llamar a <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29>, <xref:System.UriTemplateTable.Match%28System.Uri%29> o <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29>, de lo contrario se inicia <xref:System.NotSupportedException>.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se obtiene acceso a la propiedad <xref:System.UriTemplateTable.KeyValuePairs%2A>.  
  
 [!code-csharp[UriTemplateTable#7](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#7)]
 [!code-vb[UriTemplateTable#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReadOnly">
      <MemberSignature Language="C#" Value="public void MakeReadOnly (bool allowDuplicateEquivalentUriTemplates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeReadOnly(bool allowDuplicateEquivalentUriTemplates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.MakeReadOnly(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeReadOnly (allowDuplicateEquivalentUriTemplates As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeReadOnly(bool allowDuplicateEquivalentUriTemplates);" />
      <MemberSignature Language="F#" Value="member this.MakeReadOnly : bool -&gt; unit" Usage="uriTemplateTable.MakeReadOnly allowDuplicateEquivalentUriTemplates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowDuplicateEquivalentUriTemplates" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowDuplicateEquivalentUriTemplates">Especifica si permitir instancias <see cref="T:System.UriTemplate" /> duplicadas equivalentes en <see cref="T:System.UriTemplateTable" />.</param>
        <summary>Hace que <see cref="T:System.UriTemplateTable" /> sea de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama al método <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29>, se produce uno de los tipos siguientes de validación:  
  
-   Cuando se llama a <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> al pasar en `false`, <xref:System.UriTemplateTable> realiza una comprobación para asegurarse de que la tabla no contiene varias plantillas estructuralmente equivalentes. Si encuentra esas plantillas, se inicia una excepción. Este tipo de validación se utiliza junto con <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> cuando desea asegurarse de que sólo una plantilla coincide con un URI de entrada.  
  
-   Cuando se llama a <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> al pasar en `true`, varias plantillas estructuralmente equivalentes pueden estar contenidas dentro de una <xref:System.UriTemplateTable>. Sin embargo, las cadenas de consulta de las plantillas no deben ser ambiguas; se permiten las cadenas de consulta idénticas. Este tipo de validación se utiliza junto con <xref:System.UriTemplateTable.Match%28System.Uri%29> cuando se permiten varias coincidencias de la plantilla en el URI del candidato.  
  
 Se admite solo la primera llamada a <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29>, las llamadas subsiguientes se omiten sin que se inicie ninguna excepción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;UriTemplateMatch&gt; Match (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.Collection`1&lt;class System.UriTemplateMatch&gt; Match(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.Match(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::Collection&lt;UriTemplateMatch ^&gt; ^ Match(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.Match : Uri -&gt; System.Collections.ObjectModel.Collection&lt;UriTemplateMatch&gt;" Usage="uriTemplateTable.Match uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.UriTemplateMatch&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">El URI del candidato.</param>
        <summary>Intenta hacer coincidir el <see cref="T:System.Uri" /> de un candidato con <see cref="T:System.UriTemplateTable" />.</summary>
        <returns>Colección de instancias de <see cref="T:System.UriTemplateMatch" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede devolver varias coincidencias.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar al método <xref:System.UriTemplateTable.Match%28System.Uri%29>.  
  
 [!code-csharp[UriTemplateTable#9](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#9)]
 [!code-vb[UriTemplateTable#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MatchSingle">
      <MemberSignature Language="C#" Value="public UriTemplateMatch MatchSingle (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.UriTemplateMatch MatchSingle(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.MatchSingle(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateMatch ^ MatchSingle(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MatchSingle : Uri -&gt; UriTemplateMatch" Usage="uriTemplateTable.MatchSingle uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriTemplateMatch</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">El URI del candidato.</param>
        <summary>Intenta hacer coincidir el <see cref="T:System.Uri" /> de un candidato con <see cref="T:System.UriTemplateTable" />.</summary>
        <returns>Una instancia <see cref="T:System.UriTemplateMatch" /> única.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve, a lo sumo, una coincidencia. Si se encuentra más de una coincidencia, se inicia una <xref:System.UriTemplateMatchException>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar al método <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29>.  
  
 [!code-csharp[UriTemplateTable#10](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#10)]
 [!code-vb[UriTemplateTable#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalBaseAddress">
      <MemberSignature Language="C#" Value="public Uri OriginalBaseAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri OriginalBaseAddress" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.OriginalBaseAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalBaseAddress As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ OriginalBaseAddress { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalBaseAddress : Uri" Usage="System.UriTemplateTable.OriginalBaseAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección base original.</summary>
        <value>La dirección base original.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>