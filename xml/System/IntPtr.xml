<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IntPtr.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86c560c7563290bc2d4237f4521628265386b3920ad.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">560c7563290bc2d4237f4521628265386b3920ad</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IntPtr">
          <source>A platform-specific type that is used to represent a pointer or a handle.</source>
          <target state="translated">Tipo específico de la plataforma que se usa para representar un puntero o un identificador.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type is designed to be an integer whose size is platform-specific.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> tipo está diseñado para ser un número entero cuyo tamaño es específico de la plataforma.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>That is, an instance of this type is expected to be 32-bits on 32-bit hardware and operating systems, and 64-bits on 64-bit hardware and operating systems.</source>
          <target state="translated">Es decir, una instancia de este tipo debe ser de 32 bits en sistemas operativos y hardware de 32 bits y 64 bits en sistemas operativos y hardware de 64 bits.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> tipo puede utilizarse con idiomas que admiten punteros y como un medio común para hacer referencia a los datos entre los lenguajes que no admiten punteros.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objects can also be used to hold handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objetos también pueden utilizarse para controlar identificadores.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>For example, instances of <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> are used extensively in the <ph id="ph2">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> class to hold file handles.</source>
          <target state="translated">Por ejemplo, las instancias de <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> se usan ampliamente en la <ph id="ph2">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> clase para contener los identificadores de archivos.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type is CLS-compliant, while the <ph id="ph2">&lt;xref:System.UIntPtr&gt;</ph> type is not.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> tipo es conforme a CLS, mientras que el <ph id="ph2">&lt;xref:System.UIntPtr&gt;</ph> no es de tipo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Only the <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> type is used in the common language runtime.</source>
          <target state="translated">Solo el <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> tipo se utiliza en common language runtime.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The <ph id="ph1">&lt;xref:System.UIntPtr&gt;</ph> type is provided mostly to maintain architectural symmetry with the <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.UIntPtr&gt;</ph> tipo sirve principalmente para mantener la simetría arquitectónica con el <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>This type implements the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface.</source>
          <target state="translated">Este tipo implementa la <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The following example uses managed pointers to reverse the characters in an array.</source>
          <target state="translated">En el ejemplo siguiente se utiliza punteros administrados para invertir los caracteres en una matriz.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>After it initializes a <ph id="ph1">&lt;xref:System.String&gt;</ph> object and gets its length, it does the following:</source>
          <target state="translated">Una vez que inicialice un <ph id="ph1">&lt;xref:System.String&gt;</ph> de objetos y obtiene su longitud, hace lo siguiente:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> method to copy the Unicode string to unmanaged memory as an ANSI (one-byte) character.</source>
          <target state="translated">Llamadas a la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> method para copiar la cadena de Unicode a memoria no administrada como un carácter de ANSI (un byte).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The method returns an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of the unmanaged string.</source>
          <target state="translated">El método devuelve un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objeto que apunta al principio de la cadena no administrada.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</source>
          <target state="translated">El ejemplo de Visual Basic usa este puntero directamente; en los ejemplos de C# y C++, se convierte en un puntero a un byte.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> method to allocate the same number of bytes as the unmanaged string occupies.</source>
          <target state="translated">Llamadas a la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> método para asignar el mismo número de bytes que se ocupa de la cadena no administrada.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The method returns an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of the unmanaged block of memory.</source>
          <target state="translated">El método devuelve un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objeto que apunta al principio del bloque de memoria no administrado.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</source>
          <target state="translated">El ejemplo de Visual Basic usa este puntero directamente; en los ejemplos de C# y C++, se convierte en un puntero a un byte.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The Visual Basic example defines a variable named <ph id="ph1">`offset`</ph> that is equal to the length of the ANSI string.</source>
          <target state="translated">En el ejemplo de Visual Basic se define una variable denominada <ph id="ph1">`offset`</ph> que sea igual a la longitud de la cadena ANSI.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>It is used to determine the offset into unmanaged memory to which the next charter in the ANSI string is copied.</source>
          <target state="translated">Se utiliza para determinar el desplazamiento en la memoria no administrada a la que se copia la carta siguiente en la cadena ANSI.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Because its starting value is the length of the string, the copy operation will copy a character from the start of the string to the end of the memory block.</source>
          <target state="translated">Dado que su valor inicial es la longitud de la cadena, la operación de copia copiará un carácter desde el principio de la cadena hasta el final del bloque de memoria.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The C# and C++ examples call the <ph id="ph1">&lt;xref:System.IntPtr.ToPointer%2A&gt;</ph> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and they add one less than the length of the string to the starting address of the ANSI string.</source>
          <target state="translated">La llamada de ejemplos de C# y C++ del <ph id="ph1">&lt;xref:System.IntPtr.ToPointer%2A&gt;</ph> método para obtener un puntero no administrado a la dirección inicial de la cadena y el bloque de memoria no administrada y agregan una menor que la longitud de la cadena a la dirección inicial de la cadena ANSI.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</source>
          <target state="translated">Dado que el puntero de cadena no administrada ahora apunta al final de la cadena, la operación de copia copiará un carácter desde el final de la cadena al principio del bloque de memoria.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>Uses a loop to copy each character from the string to the unmanaged block of memory.</source>
          <target state="translated">Usa un bucle para copiar cada carácter de la cadena en el bloque de memoria no administrada.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The Visual Basic example calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to read the byte (or one-byte character) at a specified offset from the managed pointer to the ANSI string.</source>
          <target state="translated">El ejemplo de Visual Basic llama el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método para leer los bytes (o caracteres de un byte) en un desplazamiento especificado desde el puntero administrado a la cadena ANSI.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The offset is incremented with each iteration of the loop.</source>
          <target state="translated">El desplazamiento se incrementa con cada iteración del bucle.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType&gt;</ph> method to write the byte to the memory address defined by the starting address of the unmanaged block of memory plus <ph id="ph2">`offset`</ph>.</source>
          <target state="translated">A continuación, se llama la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType&gt;</ph> método para escribir el byte en la dirección de memoria definido por la dirección inicial del bloque no administrado de memoria más <ph id="ph2">`offset`</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>It then decrements <ph id="ph1">`offset`</ph>.</source>
          <target state="translated">A continuación, se reduce <ph id="ph1">`offset`</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>The C# and C++ examples perform the copy operation, then decrement the pointer to the address of the next location in the unmanaged ANSI string and increment the pointer to the next address in the unmanaged block.</source>
          <target state="translated">Ejemplos de C++ y C# realizan la operación de copia, a continuación, disminuir el puntero a la dirección de la ubicación siguiente en la cadena ANSI no administrada e incrementar el puntero a la dirección siguiente en el bloque no administrado.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>All examples call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Llamar todos los ejemplos el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph> para convertir el bloque de memoria no administrada que contiene la cadena copiada de ANSI a Unicode administrado <ph id="ph2">&lt;xref:System.String&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>After displaying the original and reversed strings, all examples call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</source>
          <target state="translated">Después de mostrar las cadenas originales e invertidas, llame todos los ejemplos el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> método para liberar la memoria asignada para la cadena ANSI no administrada y el bloque de memoria no administrada.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IntPtr">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo es seguro para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.IntPtr">
          <source>Initializes a new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int32)">
          <source>A pointer or handle contained in a 32-bit signed integer.</source>
          <target state="translated">Puntero o identificador contenido en un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int32)">
          <source>Initializes a new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> using the specified 32-bit pointer or handle.</source>
          <target state="translated">Inicializa una nueva instancia de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> usando el puntero o identificador de 32 bits especificado.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int64)">
          <source>A pointer or handle contained in a 64-bit signed integer.</source>
          <target state="translated">Puntero o identificador contenido en un entero de 64 bits con signo.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int64)">
          <source>Initializes a new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> using the specified 64-bit pointer.</source>
          <target state="translated">Inicializa una nueva instancia de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> usando el puntero de 64 bits especificado.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.#ctor(System.Int64)">
          <source>An exception is only thrown if the value of <ph id="ph1">`value`</ph> requires more bits than the current platform supports.</source>
          <target state="translated">Solo se produce una excepción si el valor de <ph id="ph1">`value`</ph> requiere más bits de la plataforma actual admite.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Int64)">
          <source>On a 32-bit platform, <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is too large or too small to represent as an <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">En una plataforma de 32 bits, <ph id="ph1">&lt;paramref name="value" /&gt;</ph> es demasiado grande para representarse como un <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Void*)">
          <source>A pointer to an unspecified type.</source>
          <target state="translated">Puntero a un tipo no especificado.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.IntPtr.#ctor(System.Void*)">
          <source>Initializes a new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> using the specified pointer to an unspecified type.</source>
          <target state="translated">Inicializa una nueva instancia de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> usando el puntero especificado a un tipo no especificado.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.#ctor(System.Void*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.#ctor(System.Void*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>The pointer to add the offset to.</source>
          <target state="translated">Puntero al que se va a sumar el desplazamiento.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>The offset to add.</source>
          <target state="translated">Desplazamiento que se va a sumar.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>Adds an offset to the value of a pointer.</source>
          <target state="translated">Suma un desplazamiento al valor de un puntero.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>A new pointer that reflects the addition of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> to <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</source>
          <target state="translated">Nuevo puntero que es el resultado de sumar <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> a <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr.Add%2A&gt;</ph> method does not throw an exception if the result is too large to represent as a pointer on the specified platform.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IntPtr.Add%2A&gt;</ph> método no produce una excepción si el resultado es demasiado grande para representarse como un puntero en la plataforma especificada.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>Instead, the addition operation is performed in an unchecked context.</source>
          <target state="translated">En su lugar, la operación de suma se realiza en un contexto no comprobado.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.</source>
          <target state="translated">Lenguajes que no admiten operadores personalizados ni sobrecarga pueden usar este método para agregar un desplazamiento al valor de un puntero.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Add(System.IntPtr,System.Int32)">
          <source>The following example instantiates an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of a ten-element array, and then calls the <ph id="ph2">&lt;xref:System.IntPtr.Add%2A&gt;</ph> method to iterate the elements in the array.</source>
          <target state="translated">El ejemplo siguiente crea un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objeto que apunta al principio de una matriz de diez elementos y, a continuación, llama el <ph id="ph2">&lt;xref:System.IntPtr.Add%2A&gt;</ph> método para recorrer en iteración los elementos de la matriz.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Equals(System.Object)">
          <source>An object to compare with this instance or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a comparar con esta instancia o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Equals(System.Object)">
          <source>Returns a value indicating whether this instance is equal to a specified object.</source>
          <target state="translated">Devuelve un valor que indica si esta instancia equivale a un objeto especificado.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.IntPtr" /&gt;</ph> and equals the value of this instance; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> es una instancia de <ph id="ph3">&lt;see cref="T:System.IntPtr" /&gt;</ph> y es igual al valor de esta instancia; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IntPtr.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Devuelve el código hash de esta instancia.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IntPtr.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Código hash de un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The pointer to add the offset to.</source>
          <target state="translated">Puntero al que se va a sumar el desplazamiento.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The offset to add.</source>
          <target state="translated">Desplazamiento que se va a sumar.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>Adds an offset to the value of a pointer.</source>
          <target state="translated">Suma un desplazamiento al valor de un puntero.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>A new pointer that reflects the addition of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> to <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</source>
          <target state="translated">Nuevo puntero que es el resultado de sumar <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> a <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr.op_Addition%2A&gt;</ph> method defines the addition operation for <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IntPtr.op_Addition%2A&gt;</ph> método define la operación de suma para <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>It enables code such as the following.</source>
          <target state="translated">Permite que el código como el siguiente.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.IntPtr.Add%2A&gt;</ph> method instead.</source>
          <target state="translated">Los lenguajes que no admiten operadores personalizados pueden llamar el <ph id="ph1">&lt;xref:System.IntPtr.Add%2A&gt;</ph> método en su lugar.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The addition operation does not throw an exception if the result is too large to represent as a pointer on the specified platform.</source>
          <target state="translated">La operación de suma no produce una excepción si el resultado es demasiado grande para representarse como un puntero en la plataforma especificada.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>Instead, it is performed in an unchecked context.</source>
          <target state="translated">En su lugar, se realiza en un contexto no comprobado.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">El método equivalente para este operador es <ph id="ph1">&lt;xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source>The first pointer or handle to compare.</source>
          <target state="translated">Primer puntero o controlador que se va a comparar.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source>The second pointer or handle to compare.</source>
          <target state="translated">Segundo puntero o controlador que se va a comparar.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source>Determines whether two specified instances of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> are equal.</source>
          <target state="translated">Determina si dos instancias especificadas de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> son iguales.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value1" /&gt;</ph> equals <ph id="ph3">&lt;paramref name="value2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="value1" /&gt;</ph> es igual a <ph id="ph3">&lt;paramref name="value2" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">El método equivalente para este operador es <ph id="ph1">&lt;xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="T:System.IntPtr">
          <source>Converts a specified data type to an <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> value, or an <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph> value to a specified data type.</source>
          <target state="translated">Convierte un tipo de datos especificado en un valor <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> o un valor <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph> en un tipo de datos especificado.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr">
          <source>A 32-bit signed integer.</source>
          <target state="translated">Entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr">
          <source>Converts the value of a 32-bit signed integer to an <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Convierte el valor de un entero de 32 bits con signo en un <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> initialized to <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Nueva instancia de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> inicializada en <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr">
          <source>A 64-bit signed integer.</source>
          <target state="translated">Entero de 64 bits con signo.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr">
          <source>Converts the value of a 64-bit signed integer to an <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Convierte el valor de un entero de 64 bits con signo en un <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> initialized to <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Nueva instancia de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> inicializada en <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr">
          <source>On a 32-bit platform, <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is too large to represent as an <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">En una plataforma de 32 bits, <ph id="ph1">&lt;paramref name="value" /&gt;</ph> es demasiado grande para representarse como <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>The pointer or handle to convert.</source>
          <target state="translated">Puntero o controlador que se va a convertir.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>Converts the value of the specified <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> to a 32-bit signed integer.</source>
          <target state="translated">Convierte el valor del <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> especificado en un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>The contents of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Contenido de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>An exception is only thrown if the value of <ph id="ph1">`value`</ph> requires more bits than the current platform supports.</source>
          <target state="translated">Solo se produce una excepción si el valor de <ph id="ph1">`value`</ph> requiere más bits de la plataforma actual admite.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32">
          <source>On a 64-bit platform, the value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is too large to represent as a 32-bit signed integer.</source>
          <target state="translated">En una plataforma de 64 bits, el valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> es demasiado grande para representarse como un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64">
          <source>The pointer or handle to convert.</source>
          <target state="translated">Puntero o controlador que se va a convertir.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64">
          <source>Converts the value of the specified <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> to a 64-bit signed integer.</source>
          <target state="translated">Convierte el valor del <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> especificado en un entero de 64 bits con signo.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64">
          <source>The contents of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Contenido de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*">
          <source>The pointer or handle to convert.</source>
          <target state="translated">Puntero o controlador que se va a convertir.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*">
          <source>Converts the value of the specified <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> to a pointer to an unspecified type.</source>
          <target state="translated">Convierte el valor del <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> especificado en un puntero a un tipo no especificado.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API no es conforme a CLS.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*">
          <source>The contents of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Contenido de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>A pointer to an unspecified type.</source>
          <target state="translated">Puntero a un tipo no especificado.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>Converts the specified pointer to an unspecified type to an <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Convierte el puntero especificado a un tipo no especificado en un <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API no es conforme a CLS.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> initialized to <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Nueva instancia de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> inicializada en <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source>The first pointer or handle to compare.</source>
          <target state="translated">Primer puntero o controlador que se va a comparar.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source>The second pointer or handle to compare.</source>
          <target state="translated">Segundo puntero o controlador que se va a comparar.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source>Determines whether two specified instances of <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> are not equal.</source>
          <target state="translated">Determina si dos instancias especificadas de <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> no son iguales.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value1" /&gt;</ph> does not equal <ph id="ph3">&lt;paramref name="value2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="value1" /&gt;</ph> no es igual a <ph id="ph3">&lt;paramref name="value2" /&gt;</ph>; en caso contrario, es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">El método equivalente para este operador es <ph id="ph1">&lt;xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The pointer to subtract the offset from.</source>
          <target state="translated">Puntero del que se va a restar el desplazamiento.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The offset to subtract.</source>
          <target state="translated">Desplazamiento que se va a restar.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>Subtracts an offset from the value of a pointer.</source>
          <target state="translated">Resta un desplazamiento del valor de un puntero.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>A new pointer that reflects the subtraction of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> from <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</source>
          <target state="translated">Nuevo puntero que es el resultado de restar <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> de <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr.op_Subtraction%2A&gt;</ph> method defines the subtraction operation for <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IntPtr.op_Subtraction%2A&gt;</ph> método define la operación de resta para <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>It enables code such as the following.</source>
          <target state="translated">Permite que el código como el siguiente.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> method instead.</source>
          <target state="translated">Los lenguajes que no admiten operadores personalizados pueden llamar el <ph id="ph1">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> método en su lugar.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The subtraction operation does not throw an exception if the result is too small to represent as a pointer on the specified platform.</source>
          <target state="translated">La operación de resta no produce una excepción si el resultado es demasiado pequeño para representarse como un puntero en la plataforma especificada.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>Instead, it is performed in an unchecked context.</source>
          <target state="translated">En su lugar, se realiza en un contexto no comprobado.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">El método equivalente para este operador es <ph id="ph1">&lt;xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="P:System.IntPtr.Size">
          <source>Gets the size of this instance.</source>
          <target state="translated">Obtiene el tamaño de esta instancia.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IntPtr.Size">
          <source>The size of a pointer or handle in this process, measured in bytes.</source>
          <target state="translated">Tamaño de un puntero o identificador en este proceso, medido en bytes.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IntPtr.Size">
          <source>The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process.</source>
          <target state="translated">El valor de esta propiedad es 4 en un proceso de 32 bits y 8 en un proceso de 64 bits.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IntPtr.Size">
          <source>You can define the process type by setting the <ph id="ph1">&lt;see langword="/platform" /&gt;</ph> switch when you compile your code with the C# and Visual Basic compilers.</source>
          <target state="translated">Puede definir el tipo de proceso estableciendo el modificador <ph id="ph1">&lt;see langword="/platform" /&gt;</ph> cuando se compila el código con los compiladores de C# y Visual Basic.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>The pointer to subtract the offset from.</source>
          <target state="translated">Puntero del que se va a restar el desplazamiento.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>The offset to subtract.</source>
          <target state="translated">Desplazamiento que se va a restar.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>Subtracts an offset from the value of a pointer.</source>
          <target state="translated">Resta un desplazamiento del valor de un puntero.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>A new pointer that reflects the subtraction of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> from <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</source>
          <target state="translated">Nuevo puntero que es el resultado de restar <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> de <ph id="ph2">&lt;paramref name="pointer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> method does not throw an exception if the result is too small to represent as a pointer on the specified platform.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> método no produce una excepción si el resultado es demasiado pequeño para representarse como un puntero en la plataforma especificada.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>Instead, the subtraction operation is performed in an unchecked context.</source>
          <target state="translated">En su lugar, la operación de resta se realiza en un contexto no comprobado.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.</source>
          <target state="translated">Lenguajes que no admiten operadores personalizados ni sobrecarga pueden usar este método para restar un desplazamiento del valor de un puntero.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)">
          <source>The following example instantiates an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the end of a ten-element array, and then calls the <ph id="ph2">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> method to iterate the elements in the array in reverse order.</source>
          <target state="translated">El ejemplo siguiente crea un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objeto que apunta al final de una matriz de diez elementos y, a continuación, llama a la <ph id="ph2">&lt;xref:System.IntPtr.Subtract%2A&gt;</ph> método para recorrer en iteración los elementos de la matriz en orden inverso.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object to populate with data.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> que se va a rellenar con datos.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination for this serialization.</source>
          <target state="translated">Destino de esta serialización.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>(This parameter is not used; specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.)</source>
          <target state="translated">(Este parámetro no se usa; especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object with the data needed to serialize the current <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph> object.</source>
          <target state="translated">Rellena un objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> con los datos necesarios para serializar el objeto <ph id="ph2">&lt;see cref="T:System.IntPtr" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method populates the <ph id="ph1">`info`</ph> parameter with the value of the current <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> object.</source>
          <target state="translated">Este método rellena los <ph id="ph1">`info`</ph> parámetro con el valor del elemento actual <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt32">
          <source>Converts the value of this instance to a 32-bit signed integer.</source>
          <target state="translated">Convierte el valor de esta instancia a un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt32">
          <source>A 32-bit signed integer equal to the value of this instance.</source>
          <target state="translated">Entero de 32 bits con signo igual al valor de esta instancia.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt32">
          <source>On a 64-bit platform, the value of this instance is too large or too small to represent as a 32-bit signed integer.</source>
          <target state="translated">En una plataforma de 64 bits, el valor de esta instancia es demasiado grande para representarse como un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt64">
          <source>Converts the value of this instance to a 64-bit signed integer.</source>
          <target state="translated">Convierte el valor de esta instancia a un entero de 64 bits con signo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToInt64">
          <source>A 64-bit signed integer equal to the value of this instance.</source>
          <target state="translated">Entero de 64 bits con signo igual al valor de esta instancia.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToPointer">
          <source>Converts the value of this instance to a pointer to an unspecified type.</source>
          <target state="translated">Convierte el valor de esta instancia a un puntero a un tipo no especificado.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToPointer">
          <source>A pointer to <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph>; that is, a pointer to memory containing data of an unspecified type.</source>
          <target state="translated">Puntero a <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph>; es decir, puntero a memoria que contiene datos de un tipo no especificado.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>The following example uses managed pointers to reverse the characters in an array.</source>
          <target state="translated">En el ejemplo siguiente se utiliza punteros administrados para invertir los caracteres en una matriz.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>After it initializes a <ph id="ph1">&lt;xref:System.String&gt;</ph> object and gets its length, it does the following:</source>
          <target state="translated">Una vez que inicialice un <ph id="ph1">&lt;xref:System.String&gt;</ph> de objetos y obtiene su longitud, hace lo siguiente:</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> method to copy the Unicode string to unmanaged memory as ANSI (one-byte) characters.</source>
          <target state="translated">Llamadas a la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> method para copiar la cadena de Unicode a memoria no administrada como caracteres de ANSI (un byte).</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>The method returns an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of the unmanaged string.</source>
          <target state="translated">El método devuelve un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objeto que apunta al principio de la cadena no administrada.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> method to allocate the same number of bytes as the unmanaged string occupies.</source>
          <target state="translated">Llamadas a la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> método para asignar el mismo número de bytes que se ocupa de la cadena no administrada.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>The method returns an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> object that points to the beginning of the unmanaged block of memory.</source>
          <target state="translated">El método devuelve un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> objeto que apunta al principio del bloque de memoria no administrado.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Calls the <ph id="ph1">&lt;xref:System.IntPtr.ToPointer%2A&gt;</ph> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and adds one less than the length of the string to the starting address of the ANSI string.</source>
          <target state="translated">Llamadas a la <ph id="ph1">&lt;xref:System.IntPtr.ToPointer%2A&gt;</ph> método para obtener un puntero no administrado a la dirección inicial de la cadena y el bloque de memoria no administrada y agrega uno menor que la longitud de la cadena a la dirección inicial de la cadena ANSI.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</source>
          <target state="translated">Dado que el puntero de cadena no administrada ahora apunta al final de la cadena, la operación de copia copiará un carácter desde el final de la cadena al principio del bloque de memoria.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Uses a loop to copy each character from the string to the unmanaged block of memory.</source>
          <target state="translated">Usa un bucle para copiar cada carácter de la cadena en el bloque de memoria no administrada.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>After each copy operation, it decrements the pointer to the address of the next location in the unmanaged ANSI string and increments the pointer to the next address in the unmanaged block.</source>
          <target state="translated">Después de cada operación de copia, se reduce el puntero a la dirección de la ubicación siguiente en la cadena ANSI no administrada y aumenta el puntero a la dirección siguiente en el bloque no administrado.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>Calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Llamadas a la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph> para convertir el bloque de memoria no administrada que contiene la cadena copiada de ANSI a Unicode administrado <ph id="ph2">&lt;xref:System.String&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToPointer">
          <source>After displaying the original and reversed strings, calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType&gt;</ph> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</source>
          <target state="translated">Después de mostrar las cadenas originales e invertidas, llama a la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType&gt;</ph> método para liberar la memoria asignada para la cadena ANSI no administrada y el bloque de memoria no administrada.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="T:System.IntPtr">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object to its equivalent string representation.</source>
          <target state="translated">Convierte el valor numérico del objeto <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actual en su representación de cadena equivalente.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object to its equivalent string representation.</source>
          <target state="translated">Convierte el valor numérico del objeto <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actual en su representación de cadena equivalente.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString">
          <source>The string representation of the value of this instance.</source>
          <target state="translated">Representación de cadena del valor de esta instancia.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToString">
          <source>If the value of the <ph id="ph1">&lt;xref:System.IntPtr.Size%2A&gt;</ph> property for this instance is 4, then this method is equivalent to <ph id="ph2">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph>; otherwise, this method is equivalent to <ph id="ph3">&lt;xref:System.Int64.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si el valor de la <ph id="ph1">&lt;xref:System.IntPtr.Size%2A&gt;</ph> propiedad de esta instancia es 4, este método es equivalente a <ph id="ph2">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph>; en caso contrario, este método es equivalente a <ph id="ph3">&lt;xref:System.Int64.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString(System.String)">
          <source>A format specification that governs how the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object is converted.</source>
          <target state="translated">Especificación de formato que rige la conversión del objeto <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString(System.String)">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object to its equivalent string representation.</source>
          <target state="translated">Convierte el valor numérico del objeto <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actual en su representación de cadena equivalente.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IntPtr.ToString(System.String)">
          <source>The string representation of the value of the current <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> object.</source>
          <target state="translated">Representación de cadena del valor del objeto <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToString(System.String)">
          <source>If the <ph id="ph1">`format`</ph> parameter is <ph id="ph2">`null`</ph> or an empty string (""), the return value is formatted with the general format specifier ("G").</source>
          <target state="translated">Si el <ph id="ph1">`format`</ph> parámetro es <ph id="ph2">`null`</ph> o una cadena vacía (""), el valor devuelto se formatea con el especificador de formato general ("G").</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToString(System.String)">
          <source>For more information about numeric format specifiers, see the <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> topic.</source>
          <target state="translated">Para obtener más información acerca de los especificadores de formato numérico, consulte el <bpt id="p1">[</bpt>cadenas de formato numérico estándar<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> tema.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IntPtr.ToString(System.String)">
          <source>The return value is formatted using the invariant culture.</source>
          <target state="translated">El valor devuelto es el formato mediante la referencia cultural invariable.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="F:System.IntPtr.Zero">
          <source>A read-only field that represents a pointer or handle that has been initialized to zero.</source>
          <target state="translated">Campo de solo lectura que representa un puntero o identificador que se inicializó en cero.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>The value of this field is not equivalent to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">El valor de este campo no es equivalente a <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>Use this field to efficiently determine whether an instance of <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> has been set to a value other than zero.</source>
          <target state="translated">Utilice este campo para determinar de forma eficaz si una instancia de <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> se ha establecido en un valor distinto de cero.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>For example, assume the variable, ip, is an instance of <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph>.</source>
          <target state="translated">Por ejemplo, supongamos que la variable ip es una instancia de <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>You can determine if it has been set by comparing it to the value returned by a constructor, for example: " <ph id="ph1">`if ip != new IntPtr(0)...`</ph> ".</source>
          <target state="translated">Puede determinar si se ha configurado mediante la comparación con el valor devuelto por el constructor, por ejemplo: " <ph id="ph1">`if ip != new IntPtr(0)...`</ph> ".</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>However, invoking a constructor to get an unintialized pointer is inefficient.</source>
          <target state="translated">Sin embargo, la invocación de un constructor para obtener un puntero sin inicializar es ineficaz.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>It is better to code either " <ph id="ph1">`if ip != IntPtr.Zero...`</ph> ", or " <ph id="ph2">`if !IntPtr.Zero.Equals(ip)...`</ph> ".</source>
          <target state="translated">Es mejor codificar " <ph id="ph1">`if ip != IntPtr.Zero...`</ph> ", o " <ph id="ph2">`if !IntPtr.Zero.Equals(ip)...`</ph> ".</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>When calling the Windows API from managed code, you can pass <ph id="ph1">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> instead of <ph id="ph2">`null`</ph> if an argument is expected to be either a pointer or a <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Cuando se llama a la API de Windows desde el código administrado, puede pasar <ph id="ph1">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> en lugar de <ph id="ph2">`null`</ph> si se espera un argumento puede ser un puntero o un <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>For example, the following call to the Windows <ph id="ph1">`CreateFile`</ph> function supplies <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> for the <ph id="ph3">`pSecurityAttributes`</ph> and <ph id="ph4">`hTemplateFile`</ph> argument values.</source>
          <target state="translated">Por ejemplo, la siguiente llamada a las ventanas <ph id="ph1">`CreateFile`</ph> función fuentes <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> para el <ph id="ph3">`pSecurityAttributes`</ph> y <ph id="ph4">`hTemplateFile`</ph> valores de argumento.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>Although <ph id="ph1">&lt;xref:System.IntPtr.Zero&gt;</ph> is equivalent to <ph id="ph2">`null`</ph> for Windows API functions with parameters or return values that can be either pointers or <ph id="ph3">`null`</ph>, <ph id="ph4">&lt;xref:System.IntPtr.Zero&gt;</ph> is not equivalent to <ph id="ph5">`null`</ph>.</source>
          <target state="translated">Aunque <ph id="ph1">&lt;xref:System.IntPtr.Zero&gt;</ph> es equivalente a <ph id="ph2">`null`</ph> para las funciones de API de Windows con parámetros o valores devueltos que pueden ser ambos punteros o <ph id="ph3">`null`</ph>, <ph id="ph4">&lt;xref:System.IntPtr.Zero&gt;</ph> no es equivalente a <ph id="ph5">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>Passing <ph id="ph1">`null`</ph> to the <ph id="ph2">`IntPtr.Zero.Equals`</ph> method always returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Pasar <ph id="ph1">`null`</ph> a la <ph id="ph2">`IntPtr.Zero.Equals`</ph> método siempre devuelve <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>You can also test for a <ph id="ph1">`null`</ph> return value from Windows API function calls that return either a pointer or a <ph id="ph2">`null`</ph> by comparing the returned value with <ph id="ph3">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">También puede probar para una <ph id="ph1">`null`</ph> devolver valor de llamadas a funciones API de Windows que devuelven un puntero o un <ph id="ph2">`null`</ph> comparando el valor devuelto con <ph id="ph3">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>For example, the call to the <ph id="ph1">`GetWindow`</ph> function in the following example tries to retrieve the handle of a non-existent window.</source>
          <target state="translated">Por ejemplo, la llamada a la <ph id="ph1">`GetWindow`</ph> función en el ejemplo siguiente se intenta recuperar el identificador de una ventana no existente.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IntPtr.Zero">
          <source>If it were called from unmanaged code, the function would return <ph id="ph1">`null`</ph>, but when it is called from managed code, it returns <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si se llama desde código no administrado, la función devolvería <ph id="ph1">`null`</ph>, pero cuando se llama desde código administrado, devuelve <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>