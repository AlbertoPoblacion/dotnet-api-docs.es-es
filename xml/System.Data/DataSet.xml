<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DataSet.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe072e2a9f9609b7cc29be43e2c8071d5d8e731d0672.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2e2a9f9609b7cc29be43e2c8071d5d8e731d0672</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Represents an in-memory cache of data.</source>
          <target state="translated">Representa una caché de datos en memoria.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, which is an in-memory cache of data retrieved from a data source, is a major component of the ADO.NET architecture.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, que es una caché en memoria de datos recuperados de un origen de datos es un componente fundamental de la arquitectura de ADO.NET.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> consists of a collection of <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects that you can relate to each other with <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> consta de una colección de <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objetos que se pueden relacionar entre sí mediante <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>You can also enforce data integrity in the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Data.UniqueConstraint&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> objects.</source>
          <target state="translated">También se puede imponer la integridad de los datos en el <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> mediante el uso de la <ph id="ph2">&lt;xref:System.Data.UniqueConstraint&gt;</ph> y <ph id="ph3">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>For further details about working with <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objects, see <bpt id="p1">[</bpt>DataSets, DataTables, and DataViews<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre cómo trabajar con <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> los objetos, vea <bpt id="p1">[</bpt>conjuntos de datos, DataTable y DataView<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Whereas <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects contain the data, the <ph id="ph2">&lt;xref:System.Data.DataRelationCollection&gt;</ph> allows you to navigate though the table hierarchy.</source>
          <target state="translated">Mientras que <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objetos contienen los datos, la <ph id="ph2">&lt;xref:System.Data.DataRelationCollection&gt;</ph> le permite desplazarse por la jerarquía de tabla.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The tables are contained in a <ph id="ph1">&lt;xref:System.Data.DataTableCollection&gt;</ph> accessed through the <ph id="ph2">&lt;xref:System.Data.DataSet.Tables%2A&gt;</ph> property.</source>
          <target state="translated">Las tablas se encuentran en un <ph id="ph1">&lt;xref:System.Data.DataTableCollection&gt;</ph> tiene acceso a través del <ph id="ph2">&lt;xref:System.Data.DataSet.Tables%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>When accessing <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects, note that they are conditionally case sensitive.</source>
          <target state="translated">Al obtener acceso a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objetos, tenga en cuenta que son condicionalmente con diferenciación entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>For example, if one <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is named "mydatatable" and another is named "Mydatatable", a string used to search for one of the tables is regarded as case sensitive.</source>
          <target state="translated">Por ejemplo, si una <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> se denomina "mydatatable" y otro denominado "Mydatatable", se considerará como con diferenciación entre mayúsculas y minúsculas una cadena utilizada para buscar una de las tablas.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>However, if "mydatatable" exists and "Mydatatable" does not, the search string is regarded as case insensitive.</source>
          <target state="translated">Sin embargo, si existe "mydatatable" y "Mydatatable" no es así, la cadena de búsqueda se considerará como con diferenciación entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>For more information about working with <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects, see <bpt id="p1">[</bpt>Creating a DataTable<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre cómo trabajar con <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> los objetos, vea <bpt id="p1">[</bpt>crear un objeto DataTable<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>A <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can read and write data and schema as XML documents.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> puede leer y escribir datos y esquemas como documentos XML.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The data and schema can then be transported across HTTP and used by any application, on any platform that is XML-enabled.</source>
          <target state="translated">Los datos y el esquema, a continuación, se transmiten a través de HTTP y utilizar en cualquier aplicación en cualquier plataforma que sea compatible con XML.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>You can save the schema as an XML schema with the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method, and both schema and data can be saved using the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Puede guardar el esquema como un esquema XML con el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método y el esquema y los datos pueden guardarse con el <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>To read an XML document that includes both schema and data, use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method.</source>
          <target state="translated">Para leer un documento XML que incluye el esquema y datos, use la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In a typical multiple-tier implementation, the steps for creating and refreshing a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, and in turn, updating the original data are to:</source>
          <target state="translated">En una implementación típica de varios niveles, los pasos para crear y actualizar un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, y a su vez, actualizar los datos originales se encuentran en:</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Build and fill each <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> in a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with data from a data source using a <ph id="ph3">&lt;xref:System.Data.Common.DataAdapter&gt;</ph>.</source>
          <target state="translated">Construir y llenar cada <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con datos de un origen de datos mediante un <ph id="ph3">&lt;xref:System.Data.Common.DataAdapter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Change the data in individual <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects by adding, updating, or deleting <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> objects.</source>
          <target state="translated">Cambiar los datos de usuario individual <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objetos por agregar, actualizar o eliminar <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Invoke the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method to create a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> that features only the changes to the data.</source>
          <target state="translated">Invocar la <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método para crear un segundo <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> que incluye solo los cambios a los datos.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Call the <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.Common.DataAdapter&gt;</ph>, passing the second <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> as an argument.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> método de la <ph id="ph2">&lt;xref:System.Data.Common.DataAdapter&gt;</ph>, pasando el segundo <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> como un argumento.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Invoke the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method to merge the changes from the second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into the first.</source>
          <target state="translated">Invocar la <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método para combinar los cambios de la segunda <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en el primero.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Invoke the <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> on the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Invocar la <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Alternatively, invoke <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A&gt;</ph> to cancel the changes.</source>
          <target state="translated">O bien, invocar <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A&gt;</ph> para cancelar los cambios.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects inherit from <ph id="ph3">&lt;xref:System.ComponentModel.MarshalByValueComponent&gt;</ph>, and support the <ph id="ph4">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface for remoting.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objetos heredan de <ph id="ph3">&lt;xref:System.ComponentModel.MarshalByValueComponent&gt;</ph>y admite la <ph id="ph4">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interfaz para la comunicación remota.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>These are the only ADO.NET objects that can be remoted.</source>
          <target state="translated">Éstos son los únicos objetos ADO.NET a los que se puede tener acceso remoto.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Classes inherited from <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> are not finalized by the garbage collector, because the finalizer has been suppressed in <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Las clases heredan de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> no finalizan en el recolector de elementos no utilizados, porque se ha suprimido el finalizador en <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The derived class can call the <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method in its constructor to allow the class to be finalized by the garbage collector.</source>
          <target state="translated">La clase derivada puede llamar a la <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> método en su constructor para permitir que la clase de ser finalizados por el recolector de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The following example consists of several methods that, combined, create and fill a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> from the <bpt id="p1">**</bpt>Northwind<ept id="p1">**</ept> database.</source>
          <target state="translated">El siguiente ejemplo consta de varios métodos que, en combinación, crear y rellenar un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> desde el <bpt id="p1">**</bpt>Northwind<ept id="p1">**</ept> base de datos.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This type is safe for multithreaded read operations.</source>
          <target state="translated">Este tipo es seguro para operaciones de lectura multiproceso.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>You must synchronize any write operations.</source>
          <target state="translated">Debe sincronizar operaciones de escritura.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor">
          <source>This implementation of the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> constructor takes no parameters, and creates a default name, "NewDataSet," for the new instance.</source>
          <target state="translated">Esta implementación de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> constructor no toma ningún parámetro y crea un nombre predeterminado, "NewDataSet", para la nueva instancia.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor">
          <source>A name for the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is required to ensure that the XML representation of the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> always has a name for the document element, which is the highest-level element in a schema definition.</source>
          <target state="translated">Un nombre para el <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> es necesario para garantizar que la representación XML de la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> siempre tiene un nombre para el elemento de documento, que es el elemento de nivel superior en una definición de esquema.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, and adds two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects to it.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>y se agregan dos <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objetos a él.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Nombre del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.String)">
          <source>Initializes a new instance of a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class with the given name.</source>
          <target state="translated">Inicializa una nueva instancia de una clase <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> con el nombre dado.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor(System.String)">
          <source>A name for the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is required to ensure that the XML representation of the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> always has a name for the document element, which is the highest level element in a schema definition.</source>
          <target state="translated">Un nombre para el <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> es necesario para garantizar que la representación XML de la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> siempre tiene un nombre para el elemento de documento, que es el elemento de nivel superior en una definición de esquema.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor(System.String)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, to which two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects are added.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, para que dos <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> se agregan objetos.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The data needed to serialize or deserialize an object.</source>
          <target state="translated">Datos necesarios para serializar o deserializar un objeto.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The source and destination of a given serialized stream.</source>
          <target state="translated">Origen y destino de una secuencia de serialización dada.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class that has the given serialization information and context.</source>
          <target state="translated">Inicializa una nueva instancia de una clase <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> que contiene la información de serialización y el contexto especificados.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)">
          <source>The boolean value.</source>
          <target state="translated">Valor booleano.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Commits all the changes made to this <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> since it was loaded or since the last time <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was called.</source>
          <target state="translated">Confirma todos los cambios realizados en este <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> desde que se ha cargado o desde la última vez que se ha llamado a <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Both the <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> classes have <ph id="ph3">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> methods.</source>
          <target state="translated">Tanto el <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> clases tienen <ph id="ph3">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Calling <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> at the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> level causes the <ph id="ph3">&lt;xref:System.Data.DataRow.AcceptChanges%2A&gt;</ph> method for each <ph id="ph4">&lt;xref:System.Data.DataRow&gt;</ph> to be called.</source>
          <target state="translated">Al llamar a <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> en el <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> causas de nivel el <ph id="ph3">&lt;xref:System.Data.DataRow.AcceptChanges%2A&gt;</ph> método para cada <ph id="ph4">&lt;xref:System.Data.DataRow&gt;</ph> para llamarlo.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Similarly, invoking <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> on the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> causes <ph id="ph3">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> to be called on each table within the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Del mismo modo, invocar <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> hace <ph id="ph3">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> que se llame en cada tabla en la <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>In this manner, you have multiple levels at which the method can be invoked.</source>
          <target state="translated">De esta manera, tiene varios niveles en el que se puede invocar el método.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Calling the <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> enables you to invoke the method on all subordinate objects (for example, tables and rows) with one call.</source>
          <target state="translated">Llamar a la <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> de la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> permite invocar el método en todos los objetos subordinados (por ejemplo, tablas y filas) con una llamada.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>When you call <ph id="ph1">`AcceptChanges`</ph> on the <ph id="ph2">`DataSet`</ph>, any <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects still in edit-mode end their edits successfully.</source>
          <target state="translated">Cuando se llama a <ph id="ph1">`AcceptChanges`</ph> en el <ph id="ph2">`DataSet`</ph>, cualquier <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objetos todavía está en modo de edición finalización correctamente sus modificaciones.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataRow.RowState%2A&gt;</ph> property of each <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> also changes; <ph id="ph3">`Added`</ph> and <ph id="ph4">`Modified`</ph> rows become <ph id="ph5">`Unchanged`</ph>, and <ph id="ph6">`Deleted`</ph> rows are removed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataRow.RowState%2A&gt;</ph> propiedad de cada <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> también cambia; <ph id="ph3">`Added`</ph> y <ph id="ph4">`Modified`</ph> filas se convierten en <ph id="ph5">`Unchanged`</ph>, y <ph id="ph6">`Deleted`</ph> se quitan las filas.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>If the <ph id="ph1">`DataSet`</ph> contains <ph id="ph2">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> objects, invoking the <ph id="ph3">`AcceptChanges`</ph> method also causes the <ph id="ph4">&lt;xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A&gt;</ph> to be enforced.</source>
          <target state="translated">Si el <ph id="ph1">`DataSet`</ph> contiene <ph id="ph2">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> objetos, invocar el <ph id="ph3">`AcceptChanges`</ph> método también provoca la <ph id="ph4">&lt;xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A&gt;</ph> que se aplicará.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source><ph id="ph1">`AcceptChanges`</ph> and <ph id="ph2">`RejectChanges`</ph> only apply to <ph id="ph3">`DataRow`</ph> related changes (that is, Add, Remove, Delete, and Modify).</source>
          <target state="translated"><ph id="ph1">`AcceptChanges`</ph> y <ph id="ph2">`RejectChanges`</ph> sólo se aplican a <ph id="ph3">`DataRow`</ph> relacionadas con cambios (es decir, agregar, quitar, eliminar y modificar).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>They are not applicable to schema or structural changes.</source>
          <target state="translated">No son aplicables a cambios estructurales o de esquema.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Calling AcceptChanges will not replicate these changes back to the data source if the DataSet was filled using a DataAdapter.</source>
          <target state="translated">Llamar a AcceptChanges no replicará estos cambios en el origen de datos si se ha rellenado el conjunto de datos mediante un objeto DataAdapter.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>In that situation, call <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> instead.</source>
          <target state="translated">En esa situación, llame a <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> en su lugar.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>See <bpt id="p1">[</bpt>Updating Data Sources with DataAdapters<ept id="p1">](http://msdn.microsoft.com/library/33y2221y.aspx)</ept> for more information.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>actualizar orígenes de datos con DataAdapters<ept id="p1">](http://msdn.microsoft.com/library/33y2221y.aspx)</ept> para obtener más información.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>The following example adds a <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> to a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> in a <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se agrega un <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> a una <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> en un <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> method is then called on the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, which cascades to all <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objects that it contains.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> , a continuación, se llama el método en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, que se aplica en cascada a todos los <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objetos que contiene.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.BeginInit">
          <source>Begins the initialization of a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that is used on a form or used by another component.</source>
          <target state="translated">Activa la inicialización de un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> que se emplea en un formulario o que utiliza otro componente.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.BeginInit">
          <source>The initialization occurs at run time.</source>
          <target state="translated">La inicialización se produce en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.BeginInit">
          <source>The Visual Studio .NET design environment uses this method to start the initialization of a component that is used on a form or used by another component.</source>
          <target state="translated">El entorno de diseño de Visual Studio .NET utiliza este método para comenzar la inicialización de un componente que se emplea en un formulario o utilizado por otro componente.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.BeginInit">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> method ends the initialization.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> método termina la inicialización.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.BeginInit">
          <source>Using the <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">Mediante el <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> métodos impide que el control que se va a usar antes de que esté totalmente inicializado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.CaseSensitive">
          <source>Gets or sets a value indicating whether string comparisons within <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> objects are case-sensitive.</source>
          <target state="translated">Obtiene o establece un valor que indica si las comparaciones de cadena en los objetos <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> distinguen entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if string comparisons are case-sensitive; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si las comparaciones de cadenas distinguen entre mayúsculas y minúsculas; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> property affects how sorting, searching, and filtering operations are performed on each <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> object contained in a <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> when using the <ph id="ph4">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> propiedad afecta a cómo ordenar, buscar y filtrar las operaciones se realizan en cada <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objeto contenido en una <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> cuando se usa el <ph id="ph4">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source>By default, setting the <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> property for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> also sets the <ph id="ph3">&lt;xref:System.Data.DataTable.CaseSensitive%2A&gt;</ph> property of each associated <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph> to the same value.</source>
          <target state="translated">De forma predeterminada, establecer el <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> propiedad para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> también establece la <ph id="ph3">&lt;xref:System.Data.DataTable.CaseSensitive%2A&gt;</ph> propiedad de cada asociado <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph> en el mismo valor.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source>The following example toggles the <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se alterna el <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Clear">
          <source>Clears the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> of any data by removing all rows in all tables.</source>
          <target state="translated">Borra cualquier dato de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el procedimiento de quitar todas las filas de todas las tablas.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clear">
          <source>If the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is bound to an <ph id="ph2">&lt;xref:System.Xml.XmlDataDocument&gt;</ph>, calling <ph id="ph3">&lt;xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType&gt;</ph> raises the <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> está enlazado a un <ph id="ph2">&lt;xref:System.Xml.XmlDataDocument&gt;</ph>, si se llama <ph id="ph3">&lt;xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph4">&lt;xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType&gt;</ph> provoca la <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clear">
          <source>To avoid this situation, traverse each table, removing each row one at a time.</source>
          <target state="translated">Para evitar esta situación, recorrer cada tabla, eliminando una fila cada uno a la vez.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clear">
          <source>The following example clears the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> of all rows in all tables.</source>
          <target state="translated">En el ejemplo siguiente se borran los <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> de todas las filas de todas las tablas.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Clone">
          <source>Copies the structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, including all <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> schemas, relations, and constraints.</source>
          <target state="translated">Copia la estructura de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, incluidos todos los esquemas, relaciones y restricciones de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Clone">
          <source>Does not copy any data.</source>
          <target state="translated">No copia ningún dato.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Clone">
          <source>A new <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with the same schema as the current <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, but none of the data.</source>
          <target state="translated">Nuevo <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> con el mismo esquema que el <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> actual, pero sin ningún dato.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clone">
          <source>If these classes have been subclassed, the clone will also be of the same subclasses.</source>
          <target state="translated">Si estas clases se han derivado, el clon también será de las mismas subclases.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clone">
          <source>The following example creates a clone of a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object's schema.</source>
          <target state="translated">En el ejemplo siguiente se crea un clon de un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> esquema del objeto.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Copy">
          <source>Copies both the structure and data for this <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Copia la estructura y los datos para este objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Copy">
          <source>A new <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with the same structure (table schemas, relations, and constraints) and data as this <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Nuevo <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> con la misma estructura (esquemas, relaciones y restricciones de tabla) y datos que este <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Copy">
          <source>If these classes have been subclassed, the copy will also be of the same subclasses.</source>
          <target state="translated">Si estas clases se han subclasificado, la copia también será de las mismas subclases.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Copy">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.Copy%2A&gt;</ph> method to create a copy of the original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Data.DataSet.Copy%2A&gt;</ph> método para crear una copia del original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> with one result set per <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, in the same sequence as the tables appear in the <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph> collection.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> con un conjunto de resultados por cada <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, siguiendo la misma secuencia con la que aparecen las tablas en la colección <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In order to ensure the order of the result sets within the returned <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, if a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> within the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> is empty, it will be represented by an empty result set within the returned <ph id="ph4">`DataTableReader`</ph>.</source>
          <target state="translated">Para garantizar el orden de los conjuntos de resultados en el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, si un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> dentro de la <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> está vacío, se representará mediante un resultado vacío que se establece en el valor devuelto <ph id="ph4">`DataTableReader`</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This example, a Console application, creates three <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances and adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">En este ejemplo, una aplicación de consola, crea tres <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instancias y los agrega a un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> method and displays the contents of the returned <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</source>
          <target state="translated">El ejemplo se llama el <ph id="ph1">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> método y muestra el contenido de devuelto <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Note that the order of the result sets in the <ph id="ph1">`DataTableReader`</ph> is controlled by the order of the <ph id="ph2">`DataTable`</ph> instances passed as parameters.</source>
          <target state="translated">Tenga en cuenta que el orden del resultado se establece en el <ph id="ph1">`DataTableReader`</ph> está controlado por el orden de la <ph id="ph2">`DataTable`</ph> instancias pasan como parámetros.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This example shows how to use one of the overloaded versions of <ph id="ph1">`CreateDataReader`</ph>.</source>
          <target state="translated">Este ejemplo muestra cómo utilizar una de las versiones sobrecargadas de <ph id="ph1">`CreateDataReader`</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>For other examples that might be available, see the individual overload topics.</source>
          <target state="translated">Para obtener otros ejemplos, vea los temas individuales de sobrecarga.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The example displays the following code in the Console window:</source>
          <target state="translated">En el ejemplo se muestra el código siguiente en la ventana de consola:</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> with one result set per <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, in the same sequence as the tables appear in the <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph> collection.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> con un conjunto de resultados por cada <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, siguiendo la misma secuencia con la que aparecen las tablas en la colección <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> containing one or more result sets, corresponding to the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances contained within the source <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> que contiene uno o varios conjuntos de resultados, que se corresponden con las instancias de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> incluidas en el objeto <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> de origen.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader">
          <source>In order to ensure the order of the result sets within the returned <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, if a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> within the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> is empty, it is represented by an empty result set within the returned <ph id="ph4">`DataTableReader`</ph>.</source>
          <target state="translated">Para garantizar el orden de los conjuntos de resultados en el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, si un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> dentro de la <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> está vacío, se representa mediante un resultado vacío que se establece en el valor devuelto <ph id="ph4">`DataTableReader`</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader">
          <source>The following example creates three <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances, and adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crea tres <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instancias y los agrega a un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader">
          <source>The example then passes the filled <ph id="ph1">`DataSet`</ph> to a procedure that calls the <ph id="ph2">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> method, and proceeds to iterate through all the result sets contained within the <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph>.</source>
          <target state="translated">En el ejemplo a continuación, pasa el relleno <ph id="ph1">`DataSet`</ph> a un procedimiento que llama el <ph id="ph2">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> método y lleva a cabo para recorrer en iteración todos los conjuntos de resultados dentro de la <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader">
          <source>The example displays the results in the Console window.</source>
          <target state="translated">El ejemplo muestra los resultados en la ventana de consola.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>An array of DataTables providing the order of the result sets to be returned in the <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos DataTable que proporciona el orden de los conjuntos de resultados que va a devolver el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> with one result set per <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> con un conjunto de resultados por cada <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> containing one or more result sets, corresponding to the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances contained within the source <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> que contiene uno o varios conjuntos de resultados, que se corresponden con las instancias de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> incluidas en el objeto <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> de origen.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>The returned result sets are in the order specified by the <ph id="ph1">&lt;paramref name="dataTables" /&gt;</ph> parameter.</source>
          <target state="translated">Los conjuntos de resultados devueltos siguen el orden especificado por el parámetro <ph id="ph1">&lt;paramref name="dataTables" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>In order to ensure that the order of the result sets within the returned <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, if a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> within the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> is empty, it is represented by an empty result set within the returned <ph id="ph4">`DataTableReader`</ph>.</source>
          <target state="translated">Para asegurarse de que el orden del resultado se establece en el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, si un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> dentro de la <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> está vacío, se representa mediante un resultado vacío que se establece en el valor devuelto <ph id="ph4">`DataTableReader`</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>Because this overloaded version allows you to supply a list of <ph id="ph1">`DataTable`</ph> instances as parameters, you can specify the order in which the result sets appear within the returned <ph id="ph2">`DataTableReader`</ph>.</source>
          <target state="translated">Dado que esta versión sobrecargada permite proporcionar una lista de <ph id="ph1">`DataTable`</ph> instancias como parámetros, puede especificar el orden en el que los conjuntos de resultados aparecen en el valor devuelto <ph id="ph2">`DataTableReader`</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>This example, a Console application, creates three <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances and adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">En este ejemplo, una aplicación de consola, crea tres <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instancias y los agrega a un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> method and displays the contents of the returned <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</source>
          <target state="translated">El ejemplo se llama el <ph id="ph1">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> método y muestra el contenido de devuelto <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>Note that the order of the result sets in the <ph id="ph1">`DataTableReader`</ph> is controlled by the order of the <ph id="ph2">`DataTable`</ph> instances passed as parameters.</source>
          <target state="translated">Tenga en cuenta que el orden del resultado se establece en el <ph id="ph1">`DataTableReader`</ph> está controlado por el orden de la <ph id="ph2">`DataTable`</ph> instancias pasan como parámetros.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>The example displays the results in the Console window.</source>
          <target state="translated">El ejemplo muestra los resultados en la ventana de consola.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.DataSetName">
          <source>Gets or sets the name of the current <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtiene o establece el nombre del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DataSetName">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Nombre del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DataSetName">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the given <ph id="ph2">&lt;xref:System.Data.DataSet.DataSetName%2A&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con la determinada <ph id="ph2">&lt;xref:System.Data.DataSet.DataSetName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>Gets a custom view of the data contained in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to allow filtering, searching, and navigating using a custom <ph id="ph2">&lt;see cref="T:System.Data.DataViewManager" /&gt;</ph>.</source>
          <target state="translated">Obtiene una vista personalizada de los datos incluidos en <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, lo que permite filtrar, buscar y navegar mediante un <ph id="ph2">&lt;see cref="T:System.Data.DataViewManager" /&gt;</ph> personalizado.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataViewManager" /&gt;</ph> object.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataViewManager" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataViewManager&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Data.DataSet.DefaultViewManager%2A&gt;</ph> property allows you to create custom settings for each <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> in the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataViewManager&gt;</ph> devuelto por la <ph id="ph2">&lt;xref:System.Data.DataSet.DefaultViewManager%2A&gt;</ph> propiedad le permite crear una configuración personalizada para cada <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> en el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>When you obtain a <ph id="ph1">&lt;xref:System.Data.DataView&gt;</ph> from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, the sort order, filtering, and <ph id="ph3">&lt;xref:System.Data.DataViewRowState&gt;</ph> are configured according to the settings in the <ph id="ph4">&lt;xref:System.Data.DataSet.DefaultViewManager%2A&gt;</ph> property.</source>
          <target state="translated">Al obtener una <ph id="ph1">&lt;xref:System.Data.DataView&gt;</ph> desde una <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, el criterio de ordenación, filtrado, y <ph id="ph3">&lt;xref:System.Data.DataViewRowState&gt;</ph> se configuran según la configuración de la <ph id="ph4">&lt;xref:System.Data.DataSet.DefaultViewManager%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>The following example gets the default <ph id="ph1">&lt;xref:System.Data.DataViewManager&gt;</ph> for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, and adds a <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> to the <ph id="ph4">&lt;xref:System.Data.DataTableCollection&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se obtiene el valor predeterminado <ph id="ph1">&lt;xref:System.Data.DataViewManager&gt;</ph> para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>y agrega un <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> a la <ph id="ph4">&lt;xref:System.Data.DataTableCollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Determines the <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Determina la propiedad <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> para un objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This method can be called when deserializing a typed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> to determine its <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</source>
          <target state="translated">Este método puede llamarse al deserializar un tipo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> para determinar su <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> instance that is passed during deserialization of the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Instancia de <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> que se pasa durante la deserialización del objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)">
          <source>Determines the <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Determina la propiedad <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> para un objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> enumeration indicating whether schema information has been omitted from the payload.</source>
          <target state="translated">Enumeración <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> que indica si la información de esquema se ha omitido de la carga.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)">
          <source>This method can be called when deserializing a typed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> to determine its <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</source>
          <target state="translated">Este método puede llamarse al deserializar un tipo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> para determinar su <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that a <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>’s protected constructor <ph id="ph3">&lt;see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /&gt;</ph> is invoked with during deserialization in remoting scenarios.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> con el que se invoca al constructor protegido <ph id="ph3">&lt;see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /&gt;</ph> de un objeto <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> durante la deserialización en escenarios de comunicación remota.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that a <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>’s protected constructor <ph id="ph3">&lt;see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /&gt;</ph> is invoked with during deserialization in remoting scenarios.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> con el que se invoca al constructor protegido <ph id="ph3">&lt;see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /&gt;</ph> de un objeto <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> durante la deserialización en escenarios de comunicación remota.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Determines the <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Determina la propiedad <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> para un objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> enumeration indicating whether schema information has been omitted from the payload.</source>
          <target state="translated">Enumeración <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> que indica si la información de esquema se ha omitido de la carga.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method can be called when deserializing a typed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> to determine its <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</source>
          <target state="translated">Este método puede llamarse al deserializar un tipo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> para determinar su <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.EndInit">
          <source>Ends the initialization of a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that is used on a form or used by another component.</source>
          <target state="translated">Finaliza la inicialización de un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> que se emplea en un formulario o que utiliza otro componente.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.EndInit">
          <source>The initialization occurs at run time.</source>
          <target state="translated">La inicialización se produce en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.EndInit">
          <source>The Visual Studio .NET design environment uses this method to end the initialization of a component that is used on a form or used by another component.</source>
          <target state="translated">El entorno de diseño de Visual Studio .NET utiliza este método para finalizar la inicialización de un componente que se emplea en un formulario o utilizado por otro componente.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.EndInit">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> method starts the initialization.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> método comienza la inicialización.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.EndInit">
          <source>Using the <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">Mediante el <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> métodos impide que el control que se va a usar antes de que esté totalmente inicializado.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>Gets or sets a value indicating whether constraint rules are followed when attempting any update operation.</source>
          <target state="translated">Obtiene o establece un valor que indica si se siguen las reglas de restricción al intentar realizar cualquier operación de actualización.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if rules are enforced; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si se fuerzan las reglas; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>Constraints are set at the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> level (<ph id="ph2">&lt;xref:System.Data.DataTable.Constraints%2A&gt;</ph> property).</source>
          <target state="translated">Las restricciones se establecen en los <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> nivel (<ph id="ph2">&lt;xref:System.Data.DataTable.Constraints%2A&gt;</ph> propiedad).</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>For more information about creating constraints, see <bpt id="p1">[</bpt>DataTable Constraints<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre cómo crear restricciones, vea <bpt id="p1">[</bpt>restricciones de DataTable<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, one column, five rows, and one <ph id="ph2">&lt;xref:System.Data.UniqueConstraint&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una tabla, una columna, cinco filas y uno <ph id="ph2">&lt;xref:System.Data.UniqueConstraint&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph> and the values of each row are set to the same value.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad está establecida en <ph id="ph2">`false`</ph> y los valores de cada fila se establecen en el mismo valor.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is reset to <ph id="ph2">`true`</ph>, a <ph id="ph3">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad se restablece a <ph id="ph2">`true`</ph>, un <ph id="ph3">&lt;xref:System.Data.ConstraintException&gt;</ph> se genera.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>One or more constraints cannot be enforced.</source>
          <target state="translated">No se pueden forzar una o más restricciones.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>Gets the collection of customized user information associated with the <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtiene la colección de la información personalizada del usuario asociada a <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.PropertyCollection" /&gt;</ph> with all custom user information.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.PropertyCollection" /&gt;</ph> con toda la información personalizada del usuario.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ExtendedProperties%2A&gt;</ph> property enables you to store custom information with the <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ExtendedProperties%2A&gt;</ph> propiedad le permite almacenar información personalizada con el <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>For example, you might store a time when the data should be refreshed.</source>
          <target state="translated">Por ejemplo, podría almacenar una vez cuando se deben actualizar los datos.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>Extended properties must be of type <ph id="ph1">&lt;xref:System.String&gt;</ph> if you want them persisted when the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> is written as XML.</source>
          <target state="translated">Las propiedades extendidas deben ser del tipo <ph id="ph1">&lt;xref:System.String&gt;</ph> si desea conservar cuando la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> se escribe como XML.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>The following example adds a custom property to the <ph id="ph1">&lt;xref:System.Data.PropertyCollection&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Data.DataColumn.ExtendedProperties%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se agrega una propiedad personalizada a la <ph id="ph1">&lt;xref:System.Data.PropertyCollection&gt;</ph> devuelto por la <ph id="ph2">&lt;xref:System.Data.DataColumn.ExtendedProperties%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>The second example retrieves the custom property.</source>
          <target state="translated">El segundo ejemplo recupera la propiedad personalizada.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Gets a copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> containing all changes made to it since it was last loaded, or since <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was called.</source>
          <target state="translated">Obtiene una copia del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> que contiene todos los cambios que se le han realizado desde la última vez que se cargó o desde que se llamó a <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges">
          <source>Gets a copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that contains all changes made to it since it was loaded or since <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was last called.</source>
          <target state="translated">Obtiene una copia del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> que contiene todos los cambios que se le han realizado desde que se cargó o se llamó a <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> por última vez.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges">
          <source>A copy of the changes from this <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that can have actions performed on it and later be merged back in using <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>.</source>
          <target state="translated">Copia de los cambios de este objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en el que puede que se hayan realizado acciones y, posteriormente, se hayan vuelto a combinar mediante el método <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges">
          <source>If no changed rows are found, the method returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si no se encuentran filas modificadas, el método devuelve <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>Creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that contains a copy of all rows in the original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> that have pending changes.</source>
          <target state="translated">Crea un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> que contiene una copia de todas las filas en el original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> que tienen cambios pendientes.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>Relationship constraints can cause additional unchanged rows to be added to the new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> if the unchanged rows contain primary keys corresponding to foreign keys in the changed rows.</source>
          <target state="translated">Las restricciones de relación pueden provocar que se agregan al nuevo adicionales filas sin cambios <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> si las filas sin modificar contienen claves principales correspondientes a las claves externas de las filas modificadas.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>The method returns <ph id="ph1">`null`</ph> if there are no rows in the original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> that have pending changes.</source>
          <target state="translated">El método devuelve <ph id="ph1">`null`</ph> si no hay ninguna fila en el original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> que tienen cambios pendientes.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea un sencillo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una tabla, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>Two values are changed, and one row is added.</source>
          <target state="translated">Se cambian los dos valores y se agrega una fila.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>A subset of the changed data is created using the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method.</source>
          <target state="translated">Se crea un subconjunto de los datos modificados mediante el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>After reconciling errors, a new column is added to the subset, changing the schema.</source>
          <target state="translated">Después de reconciliar los errores, se agrega una nueva columna al subconjunto, cambiar el esquema.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called with the <ph id="ph2">`missingSchemaAction`</ph> set to <ph id="ph3">`MissingSchemaAction.Add`</ph>, the new column is added to the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> object's schema.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama con la <ph id="ph2">`missingSchemaAction`</ph> establecido en <ph id="ph3">`MissingSchemaAction.Add`</ph>, la nueva columna se agrega a la versión original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> esquema del objeto.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>Gets a copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> containing all changes made to it since it was last loaded, or since <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was called, filtered by <ph id="ph3">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</source>
          <target state="translated">Obtiene una copia del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> que contiene todos los cambios que se le han realizado desde la última vez que se cargó, o desde que se llamó a <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph>, filtrado por <ph id="ph3">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>A filtered copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that can have actions performed on it, and subsequently be merged back in using <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>.</source>
          <target state="translated">Copia filtrada del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en el que es posible que se hayan llevado a cabo acciones y que, por consiguiente, se puede volver a combinar mediante <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>If no rows of the desired <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> are found, the method returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si no se encuentran filas con el <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> deseado, el método devolverá <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is used to produce a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object that contains only the changes introduced into the original.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método se usa para producir un segundo <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objeto que contenga únicamente los cambios introducidos en el original.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>Use the <ph id="ph1">`rowStates`</ph> argument to specify the type of changes the new object should include.</source>
          <target state="translated">Use la <ph id="ph1">`rowStates`</ph> argumento para especificar el tipo de cambios que debe incluir el nuevo objeto.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>This returned copy is designed to be merged back in to this original <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Esta copia devuelta está diseñada se para volver a combinar para original <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>Relationship constraints may cause parent rows marked <ph id="ph1">`Unchanged`</ph> to be included.</source>
          <target state="translated">Las restricciones de relación pueden provocar filas primarias marcadas como <ph id="ph1">`Unchanged`</ph> van a incluir.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>If no rows of the desired <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> are found, the <ph id="ph2">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Si no hay filas de lo que se desea <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> se encuentran, el <ph id="ph2">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method to create a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object, which is then used to update a data source.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método para crear un segundo <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objeto, que, a continuación, se usa para actualizar un origen de datos.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)">
          <source>The specified schema set.</source>
          <target state="translated">Conjunto de esquemas especificado.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)">
          <source>Gets a copy of <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph> for the DataSet.</source>
          <target state="translated">Obtiene una copia de <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph> para el conjunto de datos.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)">
          <source>A copy of <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph>.</source>
          <target state="translated">Una copia de la clase <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that holds the serialized data associated with the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> que contiene los datos serializados asociados a la excepción <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that contains the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> que contiene el origen y el destino de la secuencia serializada asociada a la <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a serialization information object with the data needed to serialize the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Rellena un objeto de información de serialización con los datos necesarios para serializar <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;paramref name="info" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="info" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSchemaSerializable">
          <source>Returns a serializable <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XMLSchema" /&gt;</ph> instance.</source>
          <target state="translated">Devuelve una instancia serializable de <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XMLSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSchemaSerializable">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XMLSchema" /&gt;</ph> instance.</source>
          <target state="translated">Instancia de <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XMLSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> instance.</source>
          <target state="translated">Instancia de <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The streaming context.</source>
          <target state="translated">Contexto de transmisión por secuencias.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Deserializes the table data from the binary or XML stream.</source>
          <target state="translated">Deserializa los datos de la tabla a partir de la secuencia binaria o XML.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetXml">
          <source>Returns the XML representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Devuelve la representación XML de los datos almacenados en <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetXml">
          <source>A string that is a representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Cadena que es una representación de los datos almacenados en <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Calling this method is identical to calling <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> with <ph id="ph2">&lt;xref:System.Data.XmlWriteMode&gt;</ph> set to <ph id="ph3">&lt;xref:System.Data.XmlWriteMode.IgnoreSchema&gt;</ph>.</source>
          <target state="translated">Llamar a este método equivale a llamar a <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> con <ph id="ph2">&lt;xref:System.Data.XmlWriteMode&gt;</ph> establecido en <ph id="ph3">&lt;xref:System.Data.XmlWriteMode.IgnoreSchema&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source><ph id="ph1">&lt;xref:System.Data.DataSet.GetXml%2A&gt;</ph> returns XML as a string, and therefore requires more overhead than <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> to write XML to a file.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataSet.GetXml%2A&gt;</ph> Devuelve XML como una cadena y, por lo tanto, requiere más sobrecarga que <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> para escribir XML en un archivo.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>If you build a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> using schema inference and serialize it using XML or Web services, the column ordering may change.</source>
          <target state="translated">Si compila un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> utiliza la inferencia de esquema y serializar mediante servicios Web o XML, el orden de columna puede cambiar.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, adds sample data, and then displays the data in XML format.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, agrega datos de ejemplo y, a continuación, muestra los datos en formato XML.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>This sample demonstrates how to write data into an XML file from a DataSet and read data into DataSet from XML.</source>
          <target state="translated">Este ejemplo muestra cómo escribir datos en un archivo XML de un conjunto de datos y leer los datos en el conjunto de datos desde XML.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>This sample will create one dataset with two tables, use two ways to export a dataset into the XML files (WriteXml and GetXml), and use two ways (ReadXml and InferXmlSchema) to import a dataset from the XML files.</source>
          <target state="translated">En este ejemplo se crea un conjunto de datos con dos tablas, usar de dos maneras de exportar un conjunto de datos en los archivos XML (WriteXml y GetXml) y usar dos formas (ReadXml y InferXmlSchema) para importar un conjunto de datos de los archivos XML.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Before you compile and run the sample, you need to create four XML files in the sample directory.</source>
          <target state="translated">Antes de compilar y ejecutar el ejemplo, debe crear cuatro archivos XML en el directorio de ejemplo.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>First, create ElementsWithAttributes.xml:</source>
          <target state="translated">En primer lugar, cree ElementsWithAttributes.xml:</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Next, create ElementsWithChildElementsxml.xml:</source>
          <target state="translated">A continuación, cree ElementsWithChildElementsxml.xml:</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Now create ElementsWithOnlyAttributes.xml:</source>
          <target state="translated">Ahora cree ElementsWithOnlyAttributes.xml:</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>And finally, create RepeatingElements.xml:</source>
          <target state="translated">Y por último, cree RepeatingElements.xml:</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Now you can compile and run the following source code.</source>
          <target state="translated">Ahora puede compilar y ejecutar el siguiente código fuente.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source><bpt id="p1">[</bpt>How to Store Data of DataSet into XML File<ept id="p1">](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3)</ept> has Visual Basic and C# projects for this sample.</source>
          <target state="translated"><bpt id="p1">[</bpt>Cómo al almacén de datos del conjunto de datos en el archivo XML<ept id="p1">](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3)</ept> tiene proyectos de Visual Basic y C# de este ejemplo.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>Returns the XML Schema for the XML representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Devuelve el esquema XML para la representación XML de los datos almacenados en <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>String that is the XML Schema for the XML representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Cadena que es el esquema XML para la representación XML de los datos almacenados en <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>Calling this method is identical to calling <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph>, except that only the primary schema is written.</source>
          <target state="translated">Llamar a este método equivale a llamar a <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph>, excepto en que se escribe sólo el esquema principal.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXmlSchema">
          <source><ph id="ph1">&lt;xref:System.Data.DataSet.GetXmlSchema%2A&gt;</ph> returns XML as a string, and therefore requires more overhead than <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> to write XML to a file.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataSet.GetXmlSchema%2A&gt;</ph> Devuelve XML como una cadena y, por lo tanto, requiere más sobrecarga que <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> para escribir XML en un archivo.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>If you build a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> using schema inference and serialize it using XML or Web services, the column ordering may change.</source>
          <target state="translated">Si compila un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> utiliza la inferencia de esquema y serializar mediante servicios Web o XML, el orden de columna puede cambiar.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, and then displays the schema in XML format.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>y, a continuación, se muestra el esquema en formato XML.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes, including new, deleted, or modified rows.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> presenta cambios, incluyendo filas nuevas, eliminadas o modificadas.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes, including new, deleted, or modified rows.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> presenta cambios, incluyendo filas nuevas, eliminadas o modificadas.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> presenta cambios; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.HasChanges">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method to create a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object that is then used to update a data source.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método para crear un segundo <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objeto que, a continuación, se usa para actualizar un origen de datos.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes, including new, deleted, or modified rows, filtered by <ph id="ph2">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> presenta cambios, incluidas filas nuevas, eliminadas o modificadas, filtrados por <ph id="ph2">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> presenta cambios; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source>Examine the <ph id="ph1">&lt;xref:System.Data.DataSet.HasChanges%2A&gt;</ph> property of the <ph id="ph2">`DataSet`</ph> before invoking the <ph id="ph3">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method.</source>
          <target state="translated">Examine la <ph id="ph1">&lt;xref:System.Data.DataSet.HasChanges%2A&gt;</ph> propiedad de la <ph id="ph2">`DataSet`</ph> antes de invocar el <ph id="ph3">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method to create a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object, which is then used to update a data source.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método para crear un segundo <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objeto, que, a continuación, se usa para actualizar un origen de datos.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.HasErrors">
          <source>Gets a value indicating whether there are errors in any of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> objects within this <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtiene un valor que indica si hay errores en alguno de los objetos <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> de este <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if any table contains an error;otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si alguna tabla contiene errores; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>Each <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> in a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> also has a <ph id="ph3">&lt;xref:System.Data.DataTable.HasErrors%2A&gt;</ph> property.</source>
          <target state="translated">Cada <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> también tiene un <ph id="ph3">&lt;xref:System.Data.DataTable.HasErrors%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>Use the <ph id="ph1">`HasErrors`</ph> property of the <ph id="ph2">`DataSet`</ph> first, to determine if any table has errors, before checking individual <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objects.</source>
          <target state="translated">Use la <ph id="ph1">`HasErrors`</ph> propiedad de la <ph id="ph2">`DataSet`</ph> primero, para determinar si las tablas tienen errores, antes de comprobar individuales <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>If a <ph id="ph1">`DataTable`</ph> has errors, the <ph id="ph2">&lt;xref:System.Data.DataTable.GetErrors%2A&gt;</ph> method returns an array of <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects containing the errors.</source>
          <target state="translated">Si un <ph id="ph1">`DataTable`</ph> tiene errores, el <ph id="ph2">&lt;xref:System.Data.DataTable.GetErrors%2A&gt;</ph> método devuelve una matriz de <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objetos que contienen los errores.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.HasErrors%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object contains errors.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Data.DataSet.HasErrors%2A&gt;</ph> propiedad para determinar si un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objeto contiene errores.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>If so, the errors for each <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> in each <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> are printed.</source>
          <target state="translated">Si es así, los errores de cada <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> en cada uno de ellos <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> se imprimen.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Applies XML schema to the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Aplica el esquema XML al <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])">
          <source>The <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> from which to read the schema.</source>
          <target state="translated">Secuencia <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> desde la que se va a leer el esquema.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">Matriz de cadenas de identificador de recursos uniforme (URI) del espacio de nombres que se van a excluir de la deducción del esquema.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])">
          <source>Applies the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> to the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Aplica el esquema XML del objeto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> especificado al objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])">
          <source>The <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> from which to read the schema.</source>
          <target state="translated">Secuencia <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> desde la que se va a leer el esquema.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">Matriz de cadenas de identificador de recursos uniforme (URI) del espacio de nombres que se van a excluir de la deducción del esquema.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])">
          <source>Applies the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> to the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Aplica el esquema XML del objeto <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> especificado al objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>The name of the file (including the path) from which to read the schema.</source>
          <target state="translated">Nombre del archivo (incluida la ruta) desde el que se va a leer el esquema.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">Matriz de cadenas de identificador de recursos uniforme (URI) del espacio de nombres que se van a excluir de la deducción del esquema.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>Applies the XML schema from the specified file to the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Aplica el esquema XML del archivo especificado al <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> no está establecido en <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>For reading and writing files.</source>
          <target state="translated">Para leer y escribir en archivos.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])">
          <source>The <ph id="ph1">&lt;see langword="XMLReader" /&gt;</ph> from which to read the schema.</source>
          <target state="translated">Secuencia <ph id="ph1">&lt;see langword="XMLReader" /&gt;</ph> desde la que se va a leer el esquema.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">Matriz de cadenas de identificador de recursos uniforme (URI) del espacio de nombres que se van a excluir de la deducción del esquema.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])">
          <source>Applies the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> to the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Aplica el esquema XML del objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> especificado al objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="E:System.Data.DataSet.Initialized">
          <source>Occurs after the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> is initialized.</source>
          <target state="translated">Se produce después de inicializar <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataSet.Initialized">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Data.DataSet.IsInitialized%2A&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Data.DataSet.IsInitialized%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InitializeDerivedDataSet">
          <source>Deserialize all of the tables data of the DataSet from the binary or XML stream.</source>
          <target state="translated">Deserializa todos los datos de tablas del conjunto de datos a partir de la secuencia binaria o XML.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Inspects the format of the serialized representation of the <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Inspecciona el formato de la representación serializada de <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> represents a <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> serialized in its binary format, <ph id="ph4">&lt;see langword="false" /&gt;</ph> otherwise.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> especificado representa un objeto <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> serializado en su formato binario; en caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</source>
          <target state="translated">Este miembro admite la infraestructura de .NET Framework y no está prevista su utilización directa desde el código.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.IsInitialized">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> is initialized.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> está inicializado.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.IsInitialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate the component has completed initialization; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para indicar que el componente ha terminado la inicialización; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.IsInitialized">
          <source>Returns the status of the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> while it’s being constructed, for instance by Visual Studio.</source>
          <target state="translated">Devuelve el estado de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> mientras se construye, por ejemplo, Visual Studio.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.IsInitialized">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> method sets it to <ph id="ph2">`false`</ph> and <ph id="ph3">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> method sets it to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> método lo establece en <ph id="ph2">`false`</ph> y <ph id="ph3">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> método lo establece en <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>.</source>
          <target state="translated">Rellena un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> con valores de un origen de datos utilizando la interfaz <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> proporcionada.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method provides a technique for filling a single <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with data, retrieved from an <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> método proporciona una técnica para rellenar una sola <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> con datos, recuperados de un <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instancia.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an <ph id="ph1">`IDataReader`</ph> into multiple tables within a <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated">Este método proporciona la misma funcionalidad, pero permite cargar varios conjuntos de resultados de una <ph id="ph1">`IDataReader`</ph> en varias tablas dentro de un <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>If the <ph id="ph1">`DataSet`</ph> already contains rows, the incoming data from the data source is merged with the existing rows.</source>
          <target state="translated">Si el objeto <ph id="ph1">`DataSet`</ph> ya contiene filas, los datos de entrada del origen de datos se combinan con las filas existentes.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`Load`</ph> method can be used in several common scenarios, all centered around getting data from a specified data source and adding it to the current data container (in this case, a <ph id="ph2">`DataSet`</ph>).</source>
          <target state="translated">El <ph id="ph1">`Load`</ph> método se puede utilizar en varios escenarios comunes, todos los alrededor de obtener datos de un origen de datos especificado y lo agrega al contenedor de datos actual (en este caso, un <ph id="ph2">`DataSet`</ph>).</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>These scenarios describe standard usage for a <ph id="ph1">`DataSet`</ph>, describing its update and merge behavior.</source>
          <target state="translated">Estos escenarios describen el uso estándar para un <ph id="ph1">`DataSet`</ph>, que describe su actualización y comportamiento de mezcla.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>A <ph id="ph1">`DataSet`</ph> synchronizes or updates with a single primary data source.</source>
          <target state="translated">Un <ph id="ph1">`DataSet`</ph> sincroniza o actualiza con un origen de datos principal único.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`DataSet`</ph> tracks changes, allowing synchronization with the primary data source.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> realiza un seguimiento de cambios, permitiendo la sincronización con el origen de datos principal.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In addition, a <ph id="ph1">`DataSet`</ph> can accept incremental data from one or more secondary data sources.</source>
          <target state="translated">Además, un <ph id="ph1">`DataSet`</ph> puede aceptar los datos incrementales de uno o varios orígenes de datos secundarios.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`DataSet`</ph> isn't responsible for tracking changes in order to allow synchronization with the secondary data source.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> no es responsable de realizar el seguimiento de cambios para permitir la sincronización con el origen de datos secundario.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Given these two hypothetical data sources, a user is likely to require one of the following behaviors:</source>
          <target state="translated">Dados estos dos orígenes de datos hipotética, un usuario es probable que se requiera uno de los siguientes comportamientos:</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Initialize <ph id="ph1">`DataSet`</ph> from a primary data source.</source>
          <target state="translated">Inicializar <ph id="ph1">`DataSet`</ph> desde un origen de datos principal.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In this scenario, the user wants to initialize an empty <ph id="ph1">`DataSet`</ph> with values from the primary data source.</source>
          <target state="translated">En este escenario, el usuario desea inicializar vacío <ph id="ph1">`DataSet`</ph> con valores procedentes del origen de datos principal.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>One or more DataTable's contents are modified.</source>
          <target state="translated">Se modifica el contenido de uno o más de DataTable.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Later the user intends to propagate changes back to the primary data source.</source>
          <target state="translated">Más adelante la intención del usuario propagar los cambios en el origen de datos principal.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Preserve changes and re-synchronize from the primary data source.</source>
          <target state="translated">Conservar los cambios y volver a sincronizar desde el origen de datos principal.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In this scenario, the user wants to take the <ph id="ph1">`DataSet`</ph> filled in the previous scenario and perform an incremental synchronization with the primary data source, preserving modifications made in the <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated">En este escenario, el usuario quiere aprovechar la <ph id="ph1">`DataSet`</ph> rellena en el escenario anterior y realizar una sincronización incremental con el origen de datos principal, conservando las modificaciones realizadas en el <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Incremental data feed from secondary data sources.</source>
          <target state="translated">Fuente de datos incrementales de orígenes de datos secundaria.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In this scenario, the user wants to merge changes from one or more secondary data sources, and propagate those changes back to the primary data source.</source>
          <target state="translated">En este escenario, el usuario desea combinar los cambios de uno o varios orígenes de datos secundarios y propagar los cambios en el origen de datos principal.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`Load`</ph> method makes all these scenarios possible.</source>
          <target state="translated">El <ph id="ph1">`Load`</ph> método hace que todos estos escenarios posibles.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This method allows you to specify a load option parameter, indicating how rows already in a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> combine with rows being loaded.</source>
          <target state="translated">Este método le permite especificar un parámetro de opción de carga, que indica cómo filas ya está en un <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> combinar con filas que se va a cargar.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The following table describes the three load options provided by the <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> enumeration.</source>
          <target state="translated">En la tabla siguiente se describe las opciones de tres carga proporcionadas por el <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In each case, the description indicates the behavior when the primary key of a row in the incoming data matches the primary key of an existing row.</source>
          <target state="translated">En cada caso, la descripción indica el comportamiento cuando la clave principal de una fila en los datos de entrada coincide con la clave principal de una fila existente.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Load Option</source>
          <target state="translated">Opción de carga</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source><ph id="ph1">`PreserveChanges`</ph> (default)</source>
          <target state="translated"><ph id="ph1">`PreserveChanges`</ph> (valor predeterminado)</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Updates the original version of the row with the value of the incoming row.</source>
          <target state="translated">Actualiza la versión original de la fila con el valor de la fila entrante.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Updates the current and original versions of the row with the value of the incoming row.</source>
          <target state="translated">Actualiza las versiones actuales y originales de la fila con el valor de la fila entrante.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Updates the current version of the row with the value of the incoming row.</source>
          <target state="translated">Actualiza la versión actual de la fila con el valor de la fila entrante.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In general, the <ph id="ph1">`PreserveChanges`</ph> and <ph id="ph2">`OverwriteChanges`</ph> options are intended for scenarios in which the user needs to synchronize the <ph id="ph3">`DataSet`</ph> and its changes with the primary data source.</source>
          <target state="translated">En general, la <ph id="ph1">`PreserveChanges`</ph> y <ph id="ph2">`OverwriteChanges`</ph> opciones están pensadas para escenarios en los que el usuario necesita para sincronizar el <ph id="ph3">`DataSet`</ph> y sus cambios con el origen de datos principal.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`Upsert`</ph> option facilitates aggregating changes from one or more secondary data sources.</source>
          <target state="translated">El <ph id="ph1">`Upsert`</ph> opción facilita la adición de cambios desde uno o varios orígenes de datos secundarios.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> that provides one or more result sets.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> que proporciona uno o varios conjuntos de resultados.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>A value from the <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> enumeration that indicates how rows already in the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances within the <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> will be combined with incoming rows that share the same primary key.</source>
          <target state="translated">Valor de la enumeración <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> que indica cómo se van a combinar las filas que ya se encuentran en las instancias de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, incluidas en el objeto <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, con las filas de entrada con las que comparten la misma clave principal.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances, from which the <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /&gt;</ph> method retrieves name and namespace information.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> de las que el método <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /&gt;</ph> recupera la información sobre el espacio de nombres y el nombre.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>Each of these tables must be a member of the <ph id="ph1">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph> contained by this <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Cada una de estas tablas debe ser un miembro de la colección <ph id="ph1">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph> que incluye este objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>, using an array of <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances to supply the schema and namespace information.</source>
          <target state="translated">Rellena un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> de valores de un origen de datos utilizando la interfaz <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> proporcionada, que usa una matriz de instancias de <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> para suministrar la información sobre el espacio de nombres y el esquema.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method provides a technique for filling a single <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with data, retrieved from an <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> método proporciona una técnica para rellenar una sola <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> con datos, recuperados de un <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instancia.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> into multiple tables within a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Este método proporciona la misma funcionalidad, pero permite cargar varios conjuntos de resultados de una <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> en varias tablas dentro de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The load operation will fail with an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> if any of the source data columns in the incoming <ph id="ph2">`reader`</ph> are computed columns.</source>
          <target state="translated">Se producirá un error de la operación de carga con una <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> si cualquiera de las columnas de datos de origen en la entrada <ph id="ph2">`reader`</ph> son columnas calculadas.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The <ph id="ph1">`loadOption`</ph> parameter allows you to specify how you want the imported data to interact with existing data, and can be any of the values from the <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> enumeration.</source>
          <target state="translated">El <ph id="ph1">`loadOption`</ph> parámetro le permite especificar cómo desea que los datos importados para interactuar con los datos existentes y puede ser cualquiera de los valores de la <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>See the documentation for the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph><ph id="ph2">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method for more information on using this parameter.</source>
          <target state="translated">Consulte la documentación de la <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> <ph id="ph2">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> método para obtener más información sobre el uso de este parámetro.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The <ph id="ph1">`tables`</ph> parameter allows you to specify an array of <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instances, indicating the order of the tables corresponding to each result set loaded from the reader.</source>
          <target state="translated">El <ph id="ph1">`tables`</ph> parámetro le permite especificar una matriz de <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instancias, que indica el orden de las tablas correspondientes a cada conjunto de resultados cargado del lector.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method fills each supplied <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instance with data from a single result set from the source data reader.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> método rellena cada proporcionado <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instancia con datos de un único conjunto de resultados de la lectura de datos de origen.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>After each result set, the <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method moves on to the next result set within the reader, until there are no more result sets.</source>
          <target state="translated">Después de cada conjunto de resultados, el <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> método pasa a lo siguiente que se establece en el lector, hasta que no haya ningún conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The name resolution scheme for this method is the same as that followed by the <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> class.</source>
          <target state="translated">El esquema de resolución de nombres para este método es el mismo que seguido por el <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> método de la <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, adds two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instances to the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>, and then fills the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> using the <ph id="ph5">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method, retrieving data from a <ph id="ph6">&lt;xref:System.Data.DataTableReader&gt;</ph> that contains two result sets.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, agrega dos <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instancias para el <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>y, a continuación, rellena la <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> mediante la <ph id="ph5">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> método, recuperación de datos desde un <ph id="ph6">&lt;xref:System.Data.DataTableReader&gt;</ph> que contiene dos conjuntos de resultados.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>Finally, the example displays the contents of the tables in the console window.</source>
          <target state="translated">Por último, en el ejemplo se muestra el contenido de las tablas en la ventana de consola.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> that provides one or more result sets.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> que proporciona uno o varios conjuntos de resultados.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>A value from the <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> enumeration that indicates how rows already in the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances within the <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> will be combined with incoming rows that share the same primary key.</source>
          <target state="translated">Valor de la enumeración <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> que indica cómo se van a combinar las filas que ya se encuentran en las instancias de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, incluidas en el objeto <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph>, con las filas de entrada con las que comparten la misma clave principal.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>An array of strings, from which the <ph id="ph1">&lt;see langword="Load" /&gt;</ph> method retrieves table name information.</source>
          <target state="translated">Matriz de cadenas de las que el método <ph id="ph1">&lt;see langword="Load" /&gt;</ph> recupera la información sobre el nombre de tabla.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>, using an array of strings to supply the names for the tables within the <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Rellena un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> de valores de un origen de datos utilizando la interfaz <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> proporcionada, que usa una matriz de cadenas para suministrar los nombres para las tablas de <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method provides a technique for filling a single <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with data, retrieved from an <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> método proporciona una técnica para rellenar una sola <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> con datos, recuperados de un <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instancia.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an <ph id="ph1">`IDataReader`</ph> into multiple tables within a <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated">Este método proporciona la misma funcionalidad, pero permite cargar varios conjuntos de resultados de una <ph id="ph1">`IDataReader`</ph> en varias tablas dentro de un <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The load operation will fail with an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> if any of the source data columns in the incoming <ph id="ph2">`reader`</ph> are computed columns.</source>
          <target state="translated">Se producirá un error de la operación de carga con una <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> si cualquiera de las columnas de datos de origen en la entrada <ph id="ph2">`reader`</ph> son columnas calculadas.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The <ph id="ph1">`loadOption`</ph> parameter allows you to specify how you want the imported data to interact with existing data, and can be any of the values from the <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> enumeration.</source>
          <target state="translated">El <ph id="ph1">`loadOption`</ph> parámetro le permite especificar cómo desea que los datos importados para interactuar con los datos existentes y puede ser cualquiera de los valores de la <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>See the documentation for the <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method for more information on using this parameter.</source>
          <target state="translated">Consulte la documentación de la <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> método para obtener más información sobre el uso de este parámetro.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The <ph id="ph1">`tables`</ph> parameter allows you to specify an array of table names, indicating the order of the tables corresponding to each result set loaded from the reader.</source>
          <target state="translated">El <ph id="ph1">`tables`</ph> parámetro le permite especificar una matriz de nombres de tabla, que indica el orden de las tablas correspondientes a cada conjunto de resultados cargado del lector.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The <ph id="ph1">`Load`</ph> method attempts to find a table within the <ph id="ph2">`DataSet`</ph> matching the name found in the array of table names, in order.</source>
          <target state="translated">El <ph id="ph1">`Load`</ph> método intenta buscar una tabla dentro de la <ph id="ph2">`DataSet`</ph> que coincida con el nombre se encuentra en la matriz de nombres de tabla, en orden.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>If a matching table is found, that table is loaded with the content of the current result set.</source>
          <target state="translated">Si se encuentra una tabla de búsqueda de coincidencias, esa tabla se carga con el contenido del conjunto de resultados actual.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>If no matching table is found, a table is created using the name supplied in the array of table names, and the new table's schema is inferred from the result set.</source>
          <target state="translated">Si no se encuentra ninguna tabla de búsqueda de coincidencias, se crea una tabla con el nombre proporcionado en la matriz de nombres de tabla y esquema de la tabla nueva se deduce del conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>After each result set, the <ph id="ph1">`Load`</ph> method moves on to the next result set within the reader, until there are no more result sets.</source>
          <target state="translated">Después de cada conjunto de resultados, el <ph id="ph1">`Load`</ph> método pasa a lo siguiente que se establece en el lector, hasta que no haya ningún conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The default namespace associated with <ph id="ph1">`DataSet`</ph>, if any, is associated with each newly created <ph id="ph2">`DataTable`</ph>.</source>
          <target state="translated">El espacio de nombres predeterminado asociado a <ph id="ph1">`DataSet`</ph>, si existe, está asociado a cada uno recién creado <ph id="ph2">`DataTable`</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The name resolution scheme for this method is the same as that followed by the <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> class.</source>
          <target state="translated">El esquema de resolución de nombres para este método es el mismo que seguido por el <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> método de la <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The following Console application example first creates tables and loads data from a reader into a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, using the <ph id="ph2">`Load`</ph> method.</source>
          <target state="translated">El siguiente ejemplo de aplicación de consola crea tablas en primer lugar y carga los datos desde un lector en un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, usando la <ph id="ph2">`Load`</ph> método.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The example then adds tables to a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and attempts to fill the tables with data from a <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</source>
          <target state="translated">En el ejemplo, a continuación, agrega tablas a una <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> e intenta rellenar las tablas con datos de un <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>In this example, because the parameters passed to the <ph id="ph1">`Load`</ph> method indicate a table name that does not exist, the <ph id="ph2">`Load`</ph> method creates a new table to match the name passed as a parameter.</source>
          <target state="translated">En este ejemplo, dado que los parámetros se pasan a la <ph id="ph1">`Load`</ph> método indicar un nombre de tabla que no existe, la <ph id="ph2">`Load`</ph> método crea una nueva tabla para que coincida con el nombre pasado como parámetro.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>Once the data has been loaded, the example displays the contents of all its tables in the Console window.</source>
          <target state="translated">Una vez que se han cargado los datos, en el ejemplo se muestra el contenido de todas sus tablas en la ventana de consola.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> that provides one or more result sets.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> que proporciona uno o varios conjuntos de resultados.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>A value from the <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> enumeration that indicates how rows already in the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances within the <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> will be combined with incoming rows that share the same primary key.</source>
          <target state="translated">Valor de la enumeración <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> que indica cómo se van a combinar las filas que ya se encuentran en las instancias de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, incluidas en el objeto <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, con las filas de entrada con las que comparten la misma clave principal.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.FillErrorEventHandler" /&gt;</ph> delegate to call when an error occurs while loading data.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Data.FillErrorEventHandler" /&gt;</ph> al que se va a llamar cuando se produzca un error mientras se cargan los datos.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances, from which the <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /&gt;</ph> method retrieves name and namespace information.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> de las que el método <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /&gt;</ph> recupera la información sobre el espacio de nombres y el nombre.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>, using an array of <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances to supply the schema and namespace information.</source>
          <target state="translated">Rellena un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> de valores de un origen de datos utilizando la interfaz <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> proporcionada, que usa una matriz de instancias de <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> para suministrar la información sobre el espacio de nombres y el esquema.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method provides a technique for filling a single <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with data, retrieved from an <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> método proporciona una técnica para rellenar una sola <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> con datos, recuperados de un <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instancia.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> into multiple tables within a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Este método proporciona la misma funcionalidad, pero permite cargar varios conjuntos de resultados de una <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> en varias tablas dentro de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The load operation will fail with an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> if any of the source data columns in the incoming <ph id="ph2">`reader`</ph> are computed columns.</source>
          <target state="translated">Se producirá un error de la operación de carga con una <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> si cualquiera de las columnas de datos de origen en la entrada <ph id="ph2">`reader`</ph> son columnas calculadas.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">`loadOption`</ph> parameter allows you to specify how you want the imported data to interact with existing data, and can be any of the values from the <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> enumeration.</source>
          <target state="translated">El <ph id="ph1">`loadOption`</ph> parámetro le permite especificar cómo desea que los datos importados para interactuar con los datos existentes y puede ser cualquiera de los valores de la <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>See the documentation for the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph><ph id="ph2">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method for more information on using this parameter.</source>
          <target state="translated">Consulte la documentación de la <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> <ph id="ph2">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> método para obtener más información sobre el uso de este parámetro.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">`errorHandler`</ph> parameter is a <ph id="ph2">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> delegate that refers to a procedure that is called when an error occurs while loading data.</source>
          <target state="translated">El <ph id="ph1">`errorHandler`</ph> parámetro es un <ph id="ph2">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> delegado que hace referencia a un procedimiento que se llama cuando se produce un error al cargar los datos.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> parameter passed to the procedure provides properties that allow you to retrieve information about the error that occurred, the current row of data, and the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> being filled.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> parámetro que se pasa al procedimiento proporciona propiedades que permiten recuperar información sobre el error que se ha producido, la fila actual de datos, y el <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> se llena.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>Using this delegate mechanism, rather than a simpler try/catch block, allows you to determine the error, handle the situation, and continue processing if you like.</source>
          <target state="translated">Mediante este mecanismo delegado, en lugar de un bloque try/catch más sencillo, le permite determinar el error, controlar la situación y seguir procesando si lo desea.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> parameter supplies a <ph id="ph2">&lt;xref:System.Data.FillErrorEventArgs.Continue%2A&gt;</ph> property: set this property to <ph id="ph3">`true`</ph> to indicate that you have handled the error and wish to continue processing; set the property to <ph id="ph4">`false`</ph> to indicate that you wish to halt processing.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> parámetro proporciona un <ph id="ph2">&lt;xref:System.Data.FillErrorEventArgs.Continue%2A&gt;</ph> propiedad: establezca esta propiedad en <ph id="ph3">`true`</ph> para indicar que se han controlado el error y desea seguir procesando; establezca la propiedad en <ph id="ph4">`false`</ph> para indicar que desea detener el procesamiento.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>Be aware that setting the property to <ph id="ph1">`false`</ph> causes the code that triggered the problem to throw an exception.</source>
          <target state="translated">Tenga en cuenta que establecer la propiedad en <ph id="ph1">`false`</ph> hace que el código que desencadena el problema para producir una excepción.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">`tables`</ph> parameter allows you to specify an array of <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instances, indicating the order of the tables corresponding to each result set loaded from the reader.</source>
          <target state="translated">El <ph id="ph1">`tables`</ph> parámetro le permite especificar una matriz de <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instancias, que indica el orden de las tablas correspondientes a cada conjunto de resultados cargado del lector.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method fills each supplied <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instance with data from a single result set from the source data reader.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> método rellena cada proporcionado <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instancia con datos de un único conjunto de resultados de la lectura de datos de origen.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>After each result set, the <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method moves on to the next result set within the reader, until there are no more result sets.</source>
          <target state="translated">Después de cada conjunto de resultados, el <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> método pasa a lo siguiente que se establece en el lector, hasta que no haya ningún conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The name resolution scheme for this method is the same as that followed by the <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> class.</source>
          <target state="translated">El esquema de resolución de nombres para este método es el mismo que seguido por el <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> método de la <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The following example adds a table to a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, and then attempts to use the <ph id="ph2">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method to load data from a <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph> that contains an incompatible schema.</source>
          <target state="translated">En el ejemplo siguiente se agrega una tabla a un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>y, a continuación, intenta usar la <ph id="ph2">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> método para cargar datos desde un <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph> que contiene un esquema incompatible.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>Rather than trapping the error, this example uses a <ph id="ph1">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> delegate to investigate and handle the error.</source>
          <target state="translated">En lugar de interceptar el error, este ejemplo se utiliza un <ph id="ph1">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> delegado para investigar y controlar el error.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The output is displayed in the console window.</source>
          <target state="translated">El resultado se muestra en la ventana de consola.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Locale">
          <source>Gets or sets the locale information used to compare strings within the table.</source>
          <target state="translated">Obtiene o establece la información de configuración regional que se utiliza para comparar cadenas de la tabla.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>A <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> that contains data about the user's machine locale.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> que contiene datos sobre la configuración regional del equipo del usuario.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>The default is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> property specifies the locale for which sorting applies.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> propiedad especifica la configuración regional para que la ordenación se aplica.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>By default, setting the <ph id="ph1">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> also sets the <ph id="ph3">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> for each <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph> object in that <ph id="ph5">`DataSet`</ph> to the same value.</source>
          <target state="translated">De forma predeterminada, establecer el <ph id="ph1">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> también establece la <ph id="ph3">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> para cada <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph> objeto en el que <ph id="ph5">`DataSet`</ph> en el mismo valor.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>In columns that contain expressions, the <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture&gt;</ph> is used.</source>
          <target state="translated">En las columnas que contienen expresiones, el <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture&gt;</ph> se utiliza.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>The <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture&gt;</ph> is ignored.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture&gt;</ph> se omite.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>The following example gets the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> and prints the <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DisplayName%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.EnglishName%2A&gt;</ph> properties.</source>
          <target state="translated">En el ejemplo siguiente se obtiene la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> e imprime el <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DisplayName%2A&gt;</ph> y <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.EnglishName%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, or array of <ph id="ph3">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects into the current <ph id="ph4">&lt;see langword="DataSet" /&gt;</ph> or <ph id="ph5">&lt;see langword="DataTable" /&gt;</ph>.</source>
          <target state="translated">Combina el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, el objeto <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> o la matriz de objetos <ph id="ph3">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> que se especifique en el objeto <ph id="ph4">&lt;see langword="DataSet" /&gt;</ph> o <ph id="ph5">&lt;see langword="DataTable" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The array of <ph id="ph1">&lt;see langword="DataRow" /&gt;</ph> objects to be merged into the <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see langword="DataRow" /&gt;</ph> que se va a combinar en el <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>Merges an array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects into the current <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Combina una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> en el <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se utiliza para combinar dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objetos que tienen esquemas muy similares.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Una combinación se utiliza normalmente en una aplicación cliente para incorporar los cambios más recientes de un origen de datos en otra <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Esto permite que la aplicación cliente tener un actualizar <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con los datos más recientes desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama normalmente al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y finalmente actualizar existente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">En este escenario, el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método se invoca por primera vez.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Ese método devuelve un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimizado para la validación y la combinación.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Éste es el segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objeto contiene solo el <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> y <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objetos que se han cambiado, lo que da lugar a un subconjunto de la versión original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>This subset is generally smaller and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Este subconjunto normalmente es más pequeña y, por tanto, más eficaz pasar a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">El componente de nivel intermedio, a continuación, actualiza el origen de datos original con los cambios mediante procedimientos almacenados.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">El nivel intermedio puede volver a enviar un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> que incluya datos originales y los datos más recientes desde el origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Por ejemplo, si el origen de datos crea automáticamente valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> puede volver a combinar en original de la aplicación cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con el <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama, los esquemas de los dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> se comparan objetos porque es posible que hayan cambiado.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Por ejemplo, en un escenario de negocio a negocio, es podrán que un proceso automatizado ha agregado nuevas columnas a un esquema XML.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si el origen de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos de esquema (agregado <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objetos) que faltan en el destino, los elementos de esquema pueden agregarse al destino estableciendo la <ph id="ph3">`missingSchemaAction`</ph> argumento pasado a <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">En ese caso, el texto combinado <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene el esquema agregado y los datos.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Después de combinar los esquemas, se combinan los datos.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Al combinar un nuevo origen <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> en el destino, cualquier fila de origen con un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valo <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, o <ph id="ph5">`Deleted`</ph> se hacen coincidir con las filas de destino con los mismos valores de clave principales.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>Source rows with a <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Filas de origen con un <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> valo <ph id="ph2">`Added`</ph> coincidan con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Durante una combinación, se deshabilitan las restricciones.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>If any constraints cannot be enabled at the end of a merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si las restricciones no se puede habilitar al final de una combinación, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">En este caso, el <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad está establecida en <ph id="ph2">`false`</ph>, y se marcan todas las filas que no son válidas en error.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Los errores deben resolverse antes de intentar restablecer la <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> cuyos datos y esquema se van a combinar.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> and its schema into the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Combina un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> especificado y su esquema en el objeto <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se utiliza para combinar dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objetos que tienen esquemas muy similares.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Una combinación se utiliza normalmente en una aplicación cliente para incorporar los cambios más recientes de un origen de datos en otra <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Esto permite que la aplicación cliente tener un actualizar <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con los datos más recientes desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama normalmente al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y finalmente actualizar existente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">En este escenario, el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método se invoca por primera vez.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Ese método devuelve un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimizado para la validación y la combinación.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Éste es el segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objeto contiene solo el <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> y <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objetos que se han cambiado, lo que da lugar a un subconjunto de la versión original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">El componente de nivel intermedio, a continuación, actualiza el origen de datos original con los cambios mediante procedimientos almacenados.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">El nivel intermedio puede volver a enviar un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> que incluya datos originales y los datos más recientes desde el origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Por ejemplo, si el origen de datos crea automáticamente valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> puede volver a combinar en original de la aplicación cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con el <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama, los esquemas de los dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> se comparan objetos porque es posible que hayan cambiado.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Por ejemplo, en un escenario de negocio a negocio, es podrán que un proceso automatizado ha agregado nuevas columnas a un esquema XML.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si el origen de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos de esquema (agregado <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objetos) que faltan en el destino, los elementos de esquema pueden agregarse al destino estableciendo la <ph id="ph3">`missingSchemaAction`</ph> argumento pasado a <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">En ese caso, el texto combinado <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene el esquema agregado y los datos.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Después de combinar los esquemas, se combinan los datos.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Al combinar un nuevo origen <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> en el destino, cualquier fila de origen con un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valo <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, o <ph id="ph5">`Deleted`</ph> se hacen coincidir con las filas de destino con los mismos valores de clave principales.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Filas de origen con un <ph id="ph1">`DataRowState`</ph> valo <ph id="ph2">`Added`</ph> coincidan con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Durante una combinación, se deshabilitan las restricciones.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si las restricciones no se puede habilitar al final de la combinación, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">En este caso, el <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad está establecida en <ph id="ph2">`false`</ph>, y se marcan todas las filas que no son válidas en error.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Los errores deben resolverse antes de intentar restablecer la <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph>, Update, and <ph id="ph2">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> methods on a <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph>, actualización, y <ph id="ph2">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> métodos en un <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>One or more constraints cannot be enabled.</source>
          <target state="translated">No se pueden habilitar una o más restricciones.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The <ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> cuyos datos y esquema se van a combinar.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> and its schema into the current <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Combina un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> especificado y su esquema en el objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se utiliza para combinar dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objetos que tienen esquemas muy similares.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Una combinación se utiliza normalmente en una aplicación cliente para incorporar los cambios más recientes de un origen de datos en otra <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Esto permite que la aplicación cliente tener un actualizar <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con los datos más recientes desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama normalmente al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y finalmente actualizar existente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">En este escenario, el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método se invoca por primera vez.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Ese método devuelve un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimizado para la validación y la combinación.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Éste es el segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objeto contiene solo el <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> y <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objetos que se han cambiado, lo que da lugar a un subconjunto de la versión original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">El componente de nivel intermedio, a continuación, actualiza el origen de datos original con los cambios mediante procedimientos almacenados.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">El nivel intermedio puede volver a enviar un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> que incluya datos originales y los datos más recientes desde el origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Por ejemplo, si el origen de datos crea automáticamente valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> puede volver a combinar en original de la aplicación cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con el <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama, los esquemas de los dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> se comparan objetos porque es posible que hayan cambiado.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Por ejemplo, en un escenario de negocio a negocio, es podrán que un proceso automatizado ha agregado nuevas columnas a un esquema XML.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si el origen de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos de esquema (agregado <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objetos) que faltan en el destino, los elementos de esquema pueden agregarse al destino estableciendo la <ph id="ph3">`missingSchemaAction`</ph> argumento pasado a <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">En ese caso, el texto combinado <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene el esquema agregado y los datos.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Después de combinar los esquemas, se combinan los datos.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Al combinar un nuevo origen <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> en el destino, cualquier fila de origen con un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valo <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, o <ph id="ph5">`Deleted`</ph> se hacen coincidir con las filas de destino con los mismos valores de clave principales.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Filas de origen con un <ph id="ph1">`DataRowState`</ph> valo <ph id="ph2">`Added`</ph> coincidan con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Durante una combinación, se deshabilitan las restricciones.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si las restricciones no se puede habilitar al final de la combinación, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">En este caso, el <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad está establecida en <ph id="ph2">`false`</ph>, y se marcan todas las filas que no son válidas en error.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Los errores deben resolverse antes de intentar restablecer la <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea un sencillo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una tabla, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is created that is identical to the first.</source>
          <target state="translated">Un segundo <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> se crea que es idéntico al primero.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>Two rows are added to the second table, which is then merged into the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Se agregan dos filas a la segunda tabla, que se combina entonces en el <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;paramref name="table" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="table" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> cuyos datos y esquema se van a combinar.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to preserve changes in the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para conservar los cambios realizados en el objeto <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> actual; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> and its schema into the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>, preserving or discarding any changes in this <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> according to the given argument.</source>
          <target state="translated">Combina un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> y su esquema en el <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> actual, conservando o descartando cualquier cambio efectuado en este <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> de acuerdo con el argumento especificado.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se utiliza para combinar dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objetos que tienen esquemas muy similares.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Una combinación se utiliza normalmente en una aplicación cliente para incorporar los cambios más recientes de un origen de datos en otra <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Esto permite que la aplicación cliente tener un actualizar <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con los datos más recientes desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama normalmente al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y finalmente actualizar existente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">En este escenario, el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método se invoca por primera vez.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Ese método devuelve un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimizado para la validación y la combinación.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Éste es el segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objeto contiene solo el <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> y <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objetos que se han cambiado, lo que da lugar a un subconjunto de la versión original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">El componente de nivel intermedio, a continuación, actualiza el origen de datos original con los cambios mediante procedimientos almacenados.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">El nivel intermedio puede volver a enviar un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> que incluya datos originales y los datos más recientes desde el origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Por ejemplo, si el origen de datos crea automáticamente valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> puede volver a combinar en original de la aplicación cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con el <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama, los esquemas de los dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> se comparan objetos porque es posible que hayan cambiado.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Por ejemplo, en un escenario de negocio a negocio, es podrán que un proceso automatizado ha agregado nuevas columnas a un esquema XML.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si el origen de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos de esquema (agregado <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objetos) que faltan en el destino, los elementos de esquema pueden agregarse al destino estableciendo la <ph id="ph3">`missingSchemaAction`</ph> argumento pasado a <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">En ese caso, el texto combinado <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene el esquema agregado y los datos.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Después de combinar los esquemas, se combinan los datos.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Al combinar un nuevo origen <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> en el destino, cualquier fila de origen con un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valo <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, o <ph id="ph5">`Deleted`</ph> se hacen coincidir con las filas de destino con los mismos valores de clave principales.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Filas de origen con un <ph id="ph1">`DataRowState`</ph> valo <ph id="ph2">`Added`</ph> coincidan con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Durante una combinación, se deshabilitan las restricciones.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si las restricciones no se puede habilitar al final de la combinación, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">En este caso, el <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad está establecida en <ph id="ph2">`false`</ph>, y se marcan todas las filas que no son válidas en error.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Los errores deben resolverse antes de intentar restablecer la <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea un sencillo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una tabla, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>After adding ten rows, two values are changed, and one row is added.</source>
          <target state="translated">Después de agregar diez filas, se cambian los dos valores y se agrega una fila.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>A subset of the changed data is created using the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method.</source>
          <target state="translated">Se crea un subconjunto de los datos modificados mediante el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>After reconciling errors, the subset data is merged into the original <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Después de reconciliar los errores, se combinan los datos del subconjunto en la versión original <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects to be merged into the <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> que se va a combinar en el <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to preserve changes in the <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para conservar los cambios realizados en <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>Merges an array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects into the current <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, preserving or discarding changes in the <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> and handling an incompatible schema according to the given arguments.</source>
          <target state="translated">Combina una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> en el <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> actual, conservando o descartando los cambios efectuados en el <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> y controlando un esquema incompatible de acuerdo con los argumentos especificados.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se utiliza para combinar dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objetos que tienen esquemas muy similares.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Una combinación se utiliza normalmente en una aplicación cliente para incorporar los cambios más recientes de un origen de datos en otra <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Esto permite que la aplicación cliente tener un actualizar <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con los datos más recientes desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama normalmente al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y finalmente actualizar existente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">En este escenario, el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método se invoca por primera vez.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Ese método devuelve un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimizado para la validación y la combinación.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Éste es el segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objeto contiene solo el <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> y <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objetos que se han cambiado, lo que da lugar a un subconjunto de la versión original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">El componente de nivel intermedio, a continuación, actualiza el origen de datos original con los cambios mediante procedimientos almacenados.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">El nivel intermedio puede volver a enviar un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> que incluya datos originales y los datos más recientes desde el origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Por ejemplo, si el origen de datos crea automáticamente valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> puede volver a combinar en original de la aplicación cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con el <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>To facilitate explanation of the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method, we use "target" to signify the current <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, and "source" to name the second (parameter) <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Para facilitar la explicación de la <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método, se utiliza "destino para indicar que el actual" <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>y "origen" para denominar al segundo (parámetro) <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The target <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is so named because it is the object upon which an action (the merge) occurs.</source>
          <target state="translated">El destino <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se denomina así porque es el objeto en el que se produce una acción (la combinación).</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is called a "source" because the information it contains does not change, but instead is merged into the current <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se denomina "origen" porque la información que contiene no cambia, pero en su lugar, se combina con la actual <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama, los esquemas de los dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> se comparan objetos porque es posible que hayan cambiado.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Por ejemplo, en un escenario de negocio a negocio, es podrán que un proceso automatizado ha agregado nuevas columnas a un esquema XML.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si el origen de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos de esquema (agregado <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objetos) que faltan en el destino, los elementos de esquema pueden agregarse al destino estableciendo la <ph id="ph3">`missingSchemaAction`</ph> argumento pasado a <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">En ese caso, el texto combinado <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene el esquema agregado y los datos.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Después de combinar los esquemas, se combinan los datos.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Al combinar un nuevo origen <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> en el destino, cualquier fila de origen con un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valo <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, o <ph id="ph5">`Deleted`</ph> se hacen coincidir con las filas de destino con los mismos valores de clave principales.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Filas de origen con un <ph id="ph1">`DataRowState`</ph> valo <ph id="ph2">`Added`</ph> coincidan con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Durante una combinación, se deshabilitan las restricciones.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si las restricciones no se puede habilitar al final de la combinación, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">En este caso, el <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad está establecida en <ph id="ph2">`false`</ph>, y se marcan todas las filas que no son válidas en error.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Los errores deben resolverse antes de intentar restablecer la <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> cuyos datos y esquema se van a combinar.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to preserve changes in the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para conservar los cambios realizados en el objeto <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> actual; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> and its schema with the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>, preserving or discarding changes in the current <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> and handling an incompatible schema according to the given arguments.</source>
          <target state="translated">Combina un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> especificado y su esquema con el <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> actual, conservando o descartando los cambios efectuados en el <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> actual y controlando un esquema incompatible de acuerdo con los argumentos especificados.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se utiliza para combinar dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objetos que tienen esquemas muy similares.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Una combinación se utiliza normalmente en una aplicación cliente para incorporar los cambios más recientes de un origen de datos en otra <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Esto permite que la aplicación cliente tener un actualizar <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con los datos más recientes desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama normalmente al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y finalmente actualizar existente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">En este escenario, el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método se invoca por primera vez.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Ese método devuelve un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimizado para la validación y la combinación.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Éste es el segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objeto contiene solo el <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> y <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objetos que se han cambiado, lo que da lugar a un subconjunto de la versión original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">El componente de nivel intermedio, a continuación, actualiza el origen de datos original con los cambios mediante procedimientos almacenados.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">El nivel intermedio puede volver a enviar un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> que incluya datos originales y los datos más recientes desde el origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Por ejemplo, si el origen de datos crea automáticamente valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> puede volver a combinar en original de la aplicación cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con el <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>To facilitate explanation of the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method, we use "target" to signify the current <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, and "source" to name the second (parameter) <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Para facilitar la explicación de la <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método, se utiliza "destino para indicar que el actual" <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>y "origen" para denominar al segundo (parámetro) <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The target <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is so named because it is the object upon which an action (the merge) occurs.</source>
          <target state="translated">El destino <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se denomina así porque es el objeto en el que se produce una acción (la combinación).</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is called a "source" because the information it contains does not change, but instead is merged into the current <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se denomina "origen" porque la información que contiene no cambia, pero en su lugar, se combina con la actual <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama, los esquemas de los dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> se comparan objetos porque es posible que hayan cambiado.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Por ejemplo, en un escenario de negocio a negocio, es podrán que un proceso automatizado ha agregado nuevas columnas a un esquema XML.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si el origen de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos de esquema (agregado <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objetos) que faltan en el destino, los elementos de esquema pueden agregarse al destino estableciendo la <ph id="ph3">`missingSchemaAction`</ph> argumento pasado a <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">En ese caso, el texto combinado <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene el esquema agregado y los datos.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Después de combinar los esquemas, se combinan los datos.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Al combinar un nuevo origen <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> en el destino, cualquier fila de origen con un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valo <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, o <ph id="ph5">`Deleted`</ph> se hacen coincidir con las filas de destino con los mismos valores de clave principales.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Filas de origen con un <ph id="ph1">`DataRowState`</ph> valo <ph id="ph2">`Added`</ph> coincidan con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Durante una combinación, se deshabilitan las restricciones.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si las restricciones no se puede habilitar al final de la combinación, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">En este caso, el <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad está establecida en <ph id="ph2">`false`</ph>, y se marcan todas las filas que no son válidas en error.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Los errores deben resolverse antes de intentar restablecer la <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea un sencillo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una tabla, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Two values are changed, and one row is added.</source>
          <target state="translated">Se cambian los dos valores y se agrega una fila.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>A subset of the changed data is created using the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method.</source>
          <target state="translated">Se crea un subconjunto de los datos modificados mediante el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>After reconciling errors, a new column is added to the subset, changing the schema.</source>
          <target state="translated">Después de reconciliar los errores, se agrega una nueva columna al subconjunto, cambiar el esquema.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called with the <ph id="ph2">`missingSchemaAction`</ph> set to <ph id="ph3">`MissingSchemaAction.Add`</ph>, the new column is added to the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> object's schema.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama con la <ph id="ph2">`missingSchemaAction`</ph> establecido en <ph id="ph3">`MissingSchemaAction.Add`</ph>, la nueva columna se agrega a la versión original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> esquema del objeto.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;see langword="DataTable" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataTable" /&gt;</ph> cuyos datos y esquema se van a combinar.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to preserve changes in the <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para conservar los cambios realizados en <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> and its schema into the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>, preserving or discarding changes in the <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> and handling an incompatible schema according to the given arguments.</source>
          <target state="translated">Combina un <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> especificado y su esquema en el <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> actual, conservando o descartando los cambios efectuados en el <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> y controlando un esquema incompatible de acuerdo con los argumentos especificados.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se utiliza para combinar dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objetos que tienen esquemas muy similares.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Una combinación se utiliza normalmente en una aplicación cliente para incorporar los cambios más recientes de un origen de datos en otra <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Esto permite que la aplicación cliente tener un actualizar <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con los datos más recientes desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama normalmente al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y finalmente actualizar existente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>iOn a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">En este escenario, el <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> método se invoca por primera vez.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Ese método devuelve un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimizado para la validación y la combinación.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Éste es el segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objeto contiene solo el <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> y <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objetos que se han cambiado, lo que da lugar a un subconjunto de la versión original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">El componente de nivel intermedio, a continuación, actualiza el origen de datos original con los cambios mediante procedimientos almacenados.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">El nivel intermedio puede volver a enviar un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> que incluya datos originales y los datos más recientes desde el origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Por ejemplo, si el origen de datos crea automáticamente valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> puede volver a combinar en original de la aplicación cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con el <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> método se llama, los esquemas de los dos <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> se comparan objetos porque es posible que hayan cambiado.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Por ejemplo, en un escenario de negocio a negocio, es podrán que un proceso automatizado ha agregado nuevas columnas a un esquema XML.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si el origen de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos de esquema (agregado <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objetos) que faltan en el destino, los elementos de esquema pueden agregarse al destino estableciendo la <ph id="ph3">`missingSchemaAction`</ph> argumento pasado a <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">En ese caso, el texto combinado <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene el esquema agregado y los datos.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Después de combinar los esquemas, se combinan los datos.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Al combinar un nuevo origen <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> en el destino, cualquier fila de origen con un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valo <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, o <ph id="ph5">`Deleted`</ph> se hacen coincidir con las filas de destino con los mismos valores de clave principales.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Filas de origen con un <ph id="ph1">`DataRowState`</ph> valo <ph id="ph2">`Added`</ph> coincidan con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Durante una combinación, se deshabilitan las restricciones.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si las restricciones no se puede habilitar al final de la combinación, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">En este caso, el <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad está establecida en <ph id="ph2">`false`</ph>, y se marcan todas las filas que no son válidas en error.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Los errores deben resolverse antes de intentar restablecer la <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propiedad <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea un sencillo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una tabla, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is created that is nearly identical to the first except that a new <ph id="ph2">`DataColumn`</ph> is added to the table.</source>
          <target state="translated">Un segundo <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> se crea que es casi idéntico al primero excepto en que un nuevo <ph id="ph2">`DataColumn`</ph> se agrega a la tabla.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Two rows are added to the second table, which is then merged into the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph2">`preserveChanges`</ph> argument set to <ph id="ph3">`false`</ph>, and the <ph id="ph4">`missingSchemaAction`</ph> argument set to <ph id="ph5">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Se agregan dos filas a la segunda tabla, que se combina entonces en el <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con el <ph id="ph2">`preserveChanges`</ph> establecido en <ph id="ph3">`false`</ph>y el <ph id="ph4">`missingSchemaAction`</ph> establecido en <ph id="ph5">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="E:System.Data.DataSet.MergeFailed">
          <source>Occurs when a target and source <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> have the same primary key value, and <ph id="ph2">&lt;see cref="P:System.Data.DataSet.EnforceConstraints" /&gt;</ph> is set to true.</source>
          <target state="translated">Se produce cuando unos <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> de origen y de destino tienen el mismo valor de clave principal y <ph id="ph2">&lt;see cref="P:System.Data.DataSet.EnforceConstraints" /&gt;</ph> se establece en true.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataSet.MergeFailed">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>NIB: Consuming Events<ept id="p1">](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)</ept>.</source>
          <target state="translated">Para obtener más información sobre el control de eventos, vea <bpt id="p1">[</bpt>NIB: consumir eventos<ept id="p1">](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)</ept>.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataSet.MergeFailed">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Data.DataSet.MergeFailed&gt;</ph> event.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Data.DataSet.MergeFailed&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Namespace">
          <source>Gets or sets the namespace of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtiene o establece el espacio de nombres del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>The namespace of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Espacio de nombres de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph> property is used when reading and writing an XML document into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> using the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph> propiedad se utiliza al leer y escribir un documento XML en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> mediante la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>, o <ph id="ph6">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>The namespace of an XML document is used to scope XML attributes and elements when read into a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El espacio de nombres de un documento XML se usa para especificar atributos XML y los elementos cuando se leen en un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>For example, if a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains a schema that was read from a document with the namespace "myCompany," and an attempt is made to read data only from a document with a different namespace, any data that does not correspond to the existing schema is ignored.</source>
          <target state="translated">Por ejemplo, si un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene un esquema que se han leído desde un documento con el espacio de nombres "myCompany" y se realiza un intento para leer datos sólo de un documento con un espacio de nombres diferente, se omite cualquier dato que no se corresponde con el esquema existente.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>The following example sets the <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method.</source>
          <target state="translated">El ejemplo siguiente se establece la <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> antes de llamar a la <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Namespace">
          <source>The namespace already has data.</source>
          <target state="translated">El espacio de nombres ya tiene datos.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.ComponentModel.PropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.ComponentModel.PropertyChangedEventArgs" /&gt;</ph> que contiene los datos del evento.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> event.</source>
          <target state="translated">Genera el evento <ph id="ph1">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Para obtener información general, vea <bpt id="p1">[</bpt>controlar y provocar eventos<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> in a derived class, be sure to call the base class' <ph id="ph2">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">Al reemplazar <ph id="ph1">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> en una clase derivada, asegúrese de llamar a la clase base <ph id="ph2">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> being removed.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> que se va a quitar.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)">
          <source>Occurs when a <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> object is removed from a <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">Se produce cuando se quita un objeto <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> de un <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)">
          <source>This method should be overridden by subclasses to restrict tables being removed</source>
          <target state="translated">Este método se debe reemplazar por subclases para restringir las tablas que se va a quitar</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> being removed.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> que se va a quitar.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)">
          <source>Occurs when a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> is removed from a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Se produce cuando se quita un <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> de un <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)">
          <source>This method can be overridden by subclasses to restrict tables from being removed.</source>
          <target state="translated">Este método puede reemplazarse por subclases para restringir las tablas que se va a quitar.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)">
          <source>The following example shows a class derived from the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph2">&lt;xref:System.Data.DataSet.OnRemoveTable%2A&gt;</ph> method overridden.</source>
          <target state="translated">En el ejemplo siguiente se muestra una clase derivada de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con el <ph id="ph2">&lt;xref:System.Data.DataSet.OnRemoveTable%2A&gt;</ph> se invalida el método.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Prefix">
          <source>Gets or sets an XML prefix that aliases the namespace of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtiene o establece un prefijo XML que crea alias para el espacio de nombres del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Prefix">
          <source>The XML prefix for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> namespace.</source>
          <target state="translated">Prefijo XML para el espacio de nombres de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Prefix">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> property is used throughout an XML document to identify elements which belong to the namespace of the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object (as set by the <ph id="ph3">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph> property).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> propiedad se utiliza a lo largo de un documento XML para identificar los elementos que pertenecen al espacio de nombres de la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objeto (tal como lo establece el <ph id="ph3">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph> propiedad).</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Prefix">
          <source>The following example sets the <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method.</source>
          <target state="translated">El ejemplo siguiente se establece la <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> antes de llamar a la <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.RaisePropertyChanging(System.String)">
          <source>The name of the property that is about to change.</source>
          <target state="translated">Nombre de la propiedad que se va a cambiar.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.RaisePropertyChanging(System.String)">
          <source>Sends a notification that the specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> property is about to change.</source>
          <target state="translated">Envía una notificación que indica que se va a cambiar la propiedad especificada de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lee esquema y datos XML en el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>An object that derives from <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">Objeto que deriva de <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">Lee los datos y el esquema XML en el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> utilizado para leer los datos.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método proporciona una manera para leer datos, o los datos y el esquema en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> desde un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método sólo lee el esquema.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Para leer los datos y el esquema, utilice uno de los <ph id="ph1">`ReadXML`</ph> sobrecargas que incluye el <ph id="ph2">`mode`</ph> parámetro y establezca su valor en <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Para escribir datos XML, o el esquema y los datos de la <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`WriteXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Para escribir únicamente el esquema, use la <ph id="ph1">`WriteXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si se especifica un esquema en línea, el esquema en línea se utiliza para extender la estructura relacional existente antes de cargar los datos.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con distintos tipos de datos) se produce una excepción.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si no se puede ampliar el esquema a través de la inferencia para exponer todos los datos, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> no asocia un elemento XML con su correspondiente <ph id="ph2">`DataColumn`</ph> o <ph id="ph3">`DataTable`</ph> cuando tienen escape los caracteres XML válidos, como ("_") en el XML serializado.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> sólo inserta caracteres de escape los caracteres XML no válidos en los nombres de elemento XML y, por tanto, solo puede utilizar el mismo.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Cuando se escapan caracteres válidos en el nombre de elemento XML, el elemento se omite durante el procesamiento.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si el esquema XML para un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> incluye <ph id="ph2">`targetNamespace`</ph>, no se pueden leer datos y pueden aparecer excepciones al llamar a <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> para cargar el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> con XML que contenga elementos con un espacio de nombres sin calificación.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema, as the following example demonstrates.</source>
          <target state="translated">Para leer elementos no calificados, establezca <ph id="ph1">`elementFormDefault`</ph> igual a "qualified" en el esquema XML, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> especificando <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea primero una sencilla <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> esquema y los datos se escriben en el disco mediante la invocación de la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se crea y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método se usa para rellenar con el esquema y los datos.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> from which to read the schema and data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> desde el que se van a leer el esquema y los datos.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</source>
          <target state="translated">Lee los datos y el esquema XML en el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> utilizado para leer los datos.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método proporciona una manera para leer datos, o los datos y el esquema en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> desde un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método sólo lee el esquema.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Para leer los datos y el esquema, utilice uno de los <ph id="ph1">`ReadXML`</ph> sobrecargas que incluye el <ph id="ph2">`mode`</ph> parámetro y establezca su valor en <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Para escribir datos XML, o el esquema y los datos de la <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`WriteXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Para escribir únicamente el esquema, use la <ph id="ph1">`WriteXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si se especifica un esquema en línea, el esquema en línea se utiliza para extender la estructura relacional existente antes de cargar los datos.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con distintos tipos de datos) se produce una excepción.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si no se puede ampliar el esquema a través de la inferencia para exponer todos los datos, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> no asocia un elemento XML con su correspondiente <ph id="ph2">`DataColumn`</ph> o <ph id="ph3">`DataTable`</ph> cuando tienen escape los caracteres XML válidos, como ("_") en el XML serializado.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> sólo inserta caracteres de escape los caracteres XML no válidos en los nombres de elemento XML y, por tanto, solo puede utilizar el mismo.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Cuando se escapan caracteres válidos en el nombre de elemento XML, el elemento se omite durante el procesamiento.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si el esquema XML para un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> incluye <ph id="ph2">`targetNamespace`</ph>, no se pueden leer datos y pueden aparecer excepciones al llamar a <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> para cargar el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> con XML que contenga elementos con un espacio de nombres sin calificación.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Para leer elementos no calificados, establezca <ph id="ph1">`elementFormDefault`</ph> igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>Classes that inherit from the <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class include the <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph> classes.</source>
          <target state="translated">Las clases que heredan de la <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> clase incluye el <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> y <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph> clases.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> especificando <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea primero una sencilla <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> esquema y los datos se escriben en el disco mediante la invocación de la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se crea y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método se usa para rellenar con el esquema y los datos.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The filename (including the path) from which to read.</source>
          <target state="translated">Nombre del archivo (incluida la ruta) desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified file.</source>
          <target state="translated">Lee el esquema y los datos XML del <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el archivo especificado.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilizado para leer los datos.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método proporciona una manera para leer datos, o los datos y el esquema en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> desde un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método sólo lee el esquema.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Para leer los datos y el esquema, utilice uno de los <ph id="ph1">`ReadXML`</ph> sobrecargas que incluye el <ph id="ph2">`mode`</ph> parámetro y establezca su valor en <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Para escribir datos XML, o el esquema y los datos de la <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`WriteXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Para escribir únicamente el esquema, use la <ph id="ph1">`WriteXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si se especifica un esquema en línea, el esquema en línea se utiliza para extender la estructura relacional existente antes de cargar los datos.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con distintos tipos de datos) se produce una excepción.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si no se puede ampliar el esquema a través de la inferencia para exponer todos los datos, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> no asocia un elemento XML con su correspondiente <ph id="ph2">`DataColumn`</ph> o <ph id="ph3">`DataTable`</ph> cuando tienen escape los caracteres XML válidos, como ("_") en el XML serializado.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> sólo inserta caracteres de escape los caracteres XML no válidos en los nombres de elemento XML y, por tanto, solo puede utilizar el mismo.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Cuando se escapan caracteres válidos en el nombre de elemento XML, el elemento se omite durante el procesamiento.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes a <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si el esquema XML para un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> incluye un <ph id="ph2">`targetNamespace`</ph>, no se pueden leer datos y pueden aparecer excepciones al llamar a <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> para cargar el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> con XML que contenga elementos con un espacio de nombres sin calificación.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Para leer elementos no calificados, establezca <ph id="ph1">`elementFormDefault`</ph> igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> especificando <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea primero una sencilla <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> esquema y los datos se escriben en el disco mediante la invocación de la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se crea y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método se usa para rellenar con el esquema y los datos.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> no está establecido en <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>for reading and writing files.</source>
          <target state="translated">Para leer y escribir en archivos.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> from which to read.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated">Lee los datos y el esquema XML en el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilizado para leer los datos.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método proporciona una manera para leer datos, o los datos y el esquema en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> desde un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método sólo lee el esquema.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Para leer los datos y el esquema, utilice uno de los <ph id="ph1">`ReadXML`</ph> sobrecargas que incluye el <ph id="ph2">`mode`</ph> parámetro y establezca su valor en <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Para escribir datos XML, o el esquema y los datos de la <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`WriteXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Para escribir únicamente el esquema, use la <ph id="ph1">`WriteXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si se especifica un esquema en línea, el esquema en línea se utiliza para extender la estructura relacional existente antes de cargar los datos.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con distintos tipos de datos) se produce una excepción.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si no se puede ampliar el esquema a través de la inferencia para exponer todos los datos, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> no asocia un elemento XML con su correspondiente <ph id="ph2">`DataColumn`</ph> o <ph id="ph3">`DataTable`</ph> cuando tienen escape los caracteres XML válidos, como ("_") en el XML serializado.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> sólo inserta caracteres de escape los caracteres XML no válidos en los nombres de elemento XML y, por tanto, solo puede utilizar el mismo.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Cuando se escapan caracteres válidos en el nombre de elemento XML, el elemento se omite durante el procesamiento.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes a <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si el esquema XML para un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> incluye un <ph id="ph2">`targetNamespace`</ph>, no se pueden leer datos y pueden aparecer excepciones al llamar a <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> para cargar el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> con XML que contenga elementos con un espacio de nombres sin calificación.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Para leer elementos no calificados, establezca <ph id="ph1">`elementFormDefault`</ph> igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> inherits from <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> hereda de <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> especificando <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea primero una sencilla <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> esquema y los datos se escriben en el disco mediante la invocación de la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se crea y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método se usa para rellenar con el esquema y los datos.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> from which to read.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</source>
          <target state="translated">Lee el esquema y los datos XML del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> y la enumeración <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilizado para leer los datos.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método proporciona una manera para leer datos, o los datos y el esquema en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> desde un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método sólo lee el esquema.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Para leer los datos y el esquema, utilice uno de los <ph id="ph1">`ReadXML`</ph> sobrecargas que incluye el <ph id="ph2">`mode`</ph> parámetro y establezca su valor en <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Para escribir datos XML, o el esquema y los datos de la <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`WriteXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Para escribir únicamente el esquema, use la <ph id="ph1">`WriteXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>When you use <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and you set <ph id="ph2">&lt;xref:System.Data.XmlReadMode&gt;</ph> to <ph id="ph3">`Diffgram`</ph>, the content of the target <ph id="ph4">`DataSet`</ph> and the original <ph id="ph5">`DataSet`</ph> may differ because of how the diffgram is generated and processed.</source>
          <target state="translated">Cuando usas <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> y establece <ph id="ph2">&lt;xref:System.Data.XmlReadMode&gt;</ph> a <ph id="ph3">`Diffgram`</ph>, el contenido del destino <ph id="ph4">`DataSet`</ph> y la versión original <ph id="ph5">`DataSet`</ph> puede diferir dependiendo de cómo se genera y se procesa el diffgram.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>For more information on diffgrams, see <bpt id="p1">[</bpt>DiffGrams<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre diffgrams, vea <bpt id="p1">[</bpt>DiffGrams<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md)</ept>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si se especifica un esquema en línea, el esquema en línea se utiliza para extender la estructura relacional existente antes de cargar los datos.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con distintos tipos de datos) se produce una excepción.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si no se puede ampliar el esquema a través de la inferencia para exponer todos los datos, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> no asocia un elemento XML con su correspondiente <ph id="ph2">`DataColumn`</ph> o <ph id="ph3">`DataTable`</ph> cuando tienen escape los caracteres XML válidos, como ("_") en el XML serializado.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> sólo inserta caracteres de escape los caracteres XML no válidos en los nombres de elemento XML y, por tanto, solo puede utilizar el mismo.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Cuando se escapan caracteres válidos en el nombre de elemento XML, el elemento se omite durante el procesamiento.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si el esquema XML para un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> incluye <ph id="ph2">`targetNamespace`</ph>, no se pueden leer datos y pueden aparecer excepciones al llamar a <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> para cargar el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> con XML que contenga elementos con un espacio de nombres sin calificación.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Para leer elementos no calificados, establezca <ph id="ph1">`elementFormDefault`</ph> igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> especificando <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> from which to read.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</source>
          <target state="translated">Lee el esquema y los datos XML del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> y la enumeración <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilizado para leer los datos.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método proporciona una manera para leer datos, o los datos y el esquema en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> desde un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método sólo lee el esquema.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Para leer los datos y el esquema, utilice uno de los <ph id="ph1">`ReadXML`</ph> sobrecargas que incluye el <ph id="ph2">`mode`</ph> parámetro y establezca su valor en <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Para escribir datos XML, o el esquema y los datos de la <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`WriteXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Para escribir únicamente el esquema, use la <ph id="ph1">`WriteXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si se especifica un esquema en línea, el esquema en línea se utiliza para extender la estructura relacional existente antes de cargar los datos.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con distintos tipos de datos) se produce una excepción.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si no se puede ampliar el esquema a través de la inferencia para exponer todos los datos, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> no asocia un elemento XML con su correspondiente <ph id="ph2">`DataColumn`</ph> o <ph id="ph3">`DataTable`</ph> cuando tienen escape los caracteres XML válidos, como ("_") en el XML serializado.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> sólo inserta caracteres de escape los caracteres XML no válidos en los nombres de elemento XML y, por tanto, solo puede utilizar el mismo.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Cuando se escapan caracteres válidos en el nombre de elemento XML, el elemento se omite durante el procesamiento.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si el esquema XML para un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> incluye <ph id="ph2">`targetNamespace`</ph>, no se pueden leer datos y pueden aparecer excepciones al llamar a <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> para cargar el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> con XML que contenga elementos con un espacio de nombres sin calificación.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Para leer elementos no calificados, establezca <ph id="ph1">`elementFormDefault`</ph> igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> especificando <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The filename (including the path) from which to read.</source>
          <target state="translated">Nombre del archivo (incluida la ruta) desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified file and <ph id="ph2">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</source>
          <target state="translated">Lee el esquema y los datos XML del <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el archivo y el <ph id="ph2">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilizado para leer los datos.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método proporciona una manera para leer datos, o los datos y el esquema en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> desde un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método sólo lee el esquema.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Para leer los datos y el esquema, utilice uno de los <ph id="ph1">`ReadXML`</ph> sobrecargas que incluye el <ph id="ph2">`mode`</ph> parámetro y establezca su valor en <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Para escribir datos XML, o el esquema y los datos de la <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`WriteXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Para escribir únicamente el esquema, use la <ph id="ph1">`WriteXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si se especifica un esquema en línea, el esquema en línea se utiliza para extender la estructura relacional existente antes de cargar los datos.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con distintos tipos de datos) se produce una excepción.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si no se puede ampliar el esquema a través de la inferencia para exponer todos los datos, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> no asocia un elemento XML con su correspondiente <ph id="ph2">`DataColumn`</ph> o <ph id="ph3">`DataTable`</ph> cuando tienen escape los caracteres XML válidos, como ("_") en el XML serializado.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> sólo inserta caracteres de escape los caracteres XML no válidos en los nombres de elemento XML y, por tanto, solo puede utilizar el mismo.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Cuando se escapan caracteres válidos en el nombre de elemento XML, el elemento se omite durante el procesamiento.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes a <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si el esquema XML para un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> incluye un <ph id="ph2">`targetNamespace`</ph>, no se pueden leer datos y pueden aparecer excepciones al llamar a <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> para cargar el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> con XML que contenga elementos con un espacio de nombres sin calificación.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Para leer elementos no calificados, establezca <ph id="ph1">`elementFormDefault`</ph> igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> especificando <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> no está establecido en <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>for reading and writing files.</source>
          <target state="translated">Para leer y escribir en archivos.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> from which to read.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</source>
          <target state="translated">Lee el esquema y los datos XML del objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> y la enumeración <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilizado para leer los datos.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método proporciona una manera para leer datos, o los datos y el esquema en un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> desde un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método sólo lee el esquema.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Para leer los datos y el esquema, utilice uno de los <ph id="ph1">`ReadXML`</ph> sobrecargas que incluye el <ph id="ph2">`mode`</ph> parámetro y establezca su valor en <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Para escribir datos XML, o el esquema y los datos de la <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`WriteXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Para escribir únicamente el esquema, use la <ph id="ph1">`WriteXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si se especifica un esquema en línea, el esquema en línea se utiliza para extender la estructura relacional existente antes de cargar los datos.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con distintos tipos de datos) se produce una excepción.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si no se puede ampliar el esquema a través de la inferencia para exponer todos los datos, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> no asocia un elemento XML con su correspondiente <ph id="ph2">`DataColumn`</ph> o <ph id="ph3">`DataTable`</ph> cuando tienen escape los caracteres XML válidos, como ("_") en el XML serializado.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">El <ph id="ph1">`DataSet`</ph> sólo inserta caracteres de escape los caracteres XML no válidos en los nombres de elemento XML y, por tanto, solo puede utilizar el mismo.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Cuando se escapan caracteres válidos en el nombre de elemento XML, el elemento se omite durante el procesamiento.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes a <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si el esquema XML para un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> incluye un <ph id="ph2">`targetNamespace`</ph>, no se pueden leer datos y pueden aparecer excepciones al llamar a <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> para cargar el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> con XML que contenga elementos con un espacio de nombres sin calificación.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Para leer elementos no calificados, establezca <ph id="ph1">`elementFormDefault`</ph> igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> especificando <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Reads an XML schema into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lee un esquema XML en el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> from which to read.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>Reads the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> into the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lee el esquema XML del objeto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> especificado en el objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método para crear el esquema para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">El esquema incluye definiciones de tabla, relaciones y restricciones.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir un esquema en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">El esquema XML se escribe mediante el estándar XSD.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">Pueden dañarse los datos si el DataType y los tipos xs: Type no coinciden.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>No exception will be thrown.</source>
          <target state="translated">No se producirá ninguna excepción.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> normalmente se llama al método antes de invocar el <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método que se usa para rellenar el <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>Classes that derive from the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> class include <ph id="ph2">&lt;xref:System.IO.BufferedStream&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.NetworkStream&gt;</ph>.</source>
          <target state="translated">Las clases que derivan de la <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> clase incluir <ph id="ph2">&lt;xref:System.IO.BufferedStream&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream&gt;</ph>, y <ph id="ph5">&lt;xref:System.Net.Sockets.NetworkStream&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is be thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object to read an XML schema with, and invokes the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method with the object.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> para leer un esquema XML del objeto e invoca el <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método con el objeto.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> from which to read.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>Reads the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> into the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lee el esquema XML del objeto <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> especificado en el objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método para crear el esquema para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">El esquema incluye definiciones de tabla, relaciones y restricciones.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir un esquema en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">El esquema XML se escribe mediante el estándar XSD.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">Pueden dañarse los datos si el DataType y los tipos xs: Type no coinciden.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>No exception will be thrown.</source>
          <target state="translated">No se producirá ninguna excepción.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> normalmente se llama al método antes de invocar el <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método que se usa para rellenar el <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>Classes that inherit from the <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class include the <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph> classes.</source>
          <target state="translated">Las clases que heredan de la <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> clase incluye el <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> y <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph> clases.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is be thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object to read a schema with, and invokes the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method with the object.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> para leer un esquema de objeto e invoca el <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método con el objeto.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>The file name (including the path) from which to read.</source>
          <target state="translated">Nombre del archivo (incluida la ruta) desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>Reads the XML schema from the specified file into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lee el esquema XML del archivo especificado en el <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método para crear el esquema para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">El esquema incluye definiciones de tabla, relaciones y restricciones.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir un esquema en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">El esquema XML se escribe mediante el estándar XSD.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">Pueden dañarse los datos si el DataType y los tipos xs: Type no coinciden.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>No exception will be thrown.</source>
          <target state="translated">No se producirá ninguna excepción.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> normalmente se llama al método antes de invocar el <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método que se usa para rellenar el <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> no está establecido en <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>for reading and writing files.</source>
          <target state="translated">Para leer y escribir en archivos.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> from which to read.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> desde el que se va a leer.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Reads the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> into the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lee el esquema XML del objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> especificado en el objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método para crear el esquema para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">El esquema incluye definiciones de tabla, relaciones y restricciones.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">El esquema XML se escribe mediante el estándar XSD.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">Pueden dañarse los datos si el DataType y los tipos xs: Type no coinciden.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>No exception will be thrown.</source>
          <target state="translated">No se producirá ninguna excepción.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> normalmente se llama al método antes de invocar el <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método que se usa para rellenar el <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader?displayProperty=nameWithType&gt;</ph> class is abstract.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Xml.XmlReader?displayProperty=nameWithType&gt;</ph> clase es abstracta.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>A class that inherits from the <ph id="ph1">`XmlReader`</ph> is the <ph id="ph2">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Una clase que hereda de la <ph id="ph1">`XmlReader`</ph> es la <ph id="ph2">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is be thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</source>
          <target state="translated">Si el esquema para su <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contiene elementos del mismo nombre y tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> con <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> object.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object, created with a file path and file name, is used to create an <ph id="ph2">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> that is passed as an argument to the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto creado con una ruta de acceso y nombre de archivo, de modo que se utiliza para crear un <ph id="ph2">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> que se pasa como argumento a la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)">
          <source>The specified XML reader.</source>
          <target state="translated">Lector XML especificado.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)">
          <source>Ignores attributes and returns an empty DataSet.</source>
          <target state="translated">Omite los atributos y devuelve un conjunto de datos vacío.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.RejectChanges">
          <source>Rolls back all the changes made to the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> since it was created, or since the last time <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was called.</source>
          <target state="translated">Deshace todos los cambios realizados en el <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> desde que se ha creado o desde que se ha llamado por última vez a <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>Invoke the <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> to call the <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> method on all <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objects contained by the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Invocar la <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> para llamar a la <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> método en todos los <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objetos que contiene el <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source><ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> objects contained by the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> can each be set into edit mode by invoking the <ph id="ph3">&lt;xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> objetos que contiene el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> puede se pueden establecer en modo de edición invocando el <ph id="ph3">&lt;xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>After invoking the <ph id="ph1">&lt;xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType&gt;</ph> method, changes can be rejected by calling the <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> on the <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> to which the <ph id="ph4">&lt;xref:System.Data.DataRow&gt;</ph> objects belong.</source>
          <target state="translated">Después de invocar el <ph id="ph1">&lt;xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType&gt;</ph> método, se rechazan los cambios mediante una llamada a la <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> en el <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> a la que el <ph id="ph4">&lt;xref:System.Data.DataRow&gt;</ph> objetos pertenecen.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> method is called, any rows still in edit-mode cancel their edits.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> se llama al método, las filas en modo de edición cancela sus modificaciones.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>New rows are removed.</source>
          <target state="translated">Se quitan las nuevas filas.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>Modified and deleted rows return back to their original state (<ph id="ph1">`DataRowState.Unchanged`</ph>).</source>
          <target state="translated">Devuelven filas modificadas y eliminadas vuelven a su estado original (<ph id="ph1">`DataRowState.Unchanged`</ph>).</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>AcceptChanges and RejectChanges only apply to <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> related changes (that is, <ph id="ph2">`Add`</ph>, <ph id="ph3">`Remove`</ph>, <ph id="ph4">`Delete`</ph>, and <ph id="ph5">`Modify`</ph>).</source>
          <target state="translated">AcceptChanges y RejectChanges sólo se aplican a <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> otros cambios relacionados (es decir, <ph id="ph2">`Add`</ph>, <ph id="ph3">`Remove`</ph>, <ph id="ph4">`Delete`</ph>, y <ph id="ph5">`Modify`</ph>).</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>They are not applicable to schema or structural changes.</source>
          <target state="translated">No son aplicables a cambios estructurales o de esquema.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>The following example shows a class derived from the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se muestra una clase derivada de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A&gt;</ph> event is invoked from within a function.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A&gt;</ph> evento se invoca desde dentro de una función.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Relations">
          <source>Get the collection of relations that link tables and allow navigation from parent tables to child tables.</source>
          <target state="translated">Obtiene la colección de relaciones que vincula las tablas y permite la navegación desde las tablas primarias a las secundarias.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Relations">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRelationCollection" /&gt;</ph> that contains a collection of <ph id="ph2">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> objects.</source>
          <target state="translated">Elemento <ph id="ph1">&lt;see cref="T:System.Data.DataRelationCollection" /&gt;</ph> que contiene una colección de objetos <ph id="ph2">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Relations">
          <source>An empty collection is returned if no <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> objects exist.</source>
          <target state="translated">Si no existe ningún objeto <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph>, se devuelve una colección vacía.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Relations">
          <source>The following example prints the column name of all child tables through the <ph id="ph1">&lt;xref:System.Data.DataSet.Relations%2A&gt;</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se imprime el nombre de columna de todas las tablas secundarias mediante la <ph id="ph1">&lt;xref:System.Data.DataSet.Relations%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.RemotingFormat">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> used during remoting.</source>
          <target state="translated">Obtiene o establece una enumeración <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph> para el objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> utilizado durante la comunicación remota.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.RemotingFormat">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph> object.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Reset">
          <source>Clears all tables and removes all relations, foreign constraints, and tables from the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Borra todas las tablas y quita todas las relaciones, restricciones externas y tablas de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Reset">
          <source>Subclasses should override <ph id="ph1">&lt;see cref="M:System.Data.DataSet.Reset" /&gt;</ph> to restore a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to its original state.</source>
          <target state="translated">Las subclases deben reemplazar a <ph id="ph1">&lt;see cref="M:System.Data.DataSet.Reset" /&gt;</ph> para restaurar el estado original de un <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtiene o establece una enumeración <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> para un objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtiene o establece una enumeración <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> para un objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>A <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> serializes its schema and instance data by default in Web services and remoting scenarios.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> serializa sus esquema y datos de instancia de forma predeterminada en los servicios Web y escenarios de comunicación remota.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>Setting the <ph id="ph1">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph> property of a typed <ph id="ph2">`DataSet`</ph> to <ph id="ph3">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> causes schema information to be excluded from the serialization payload.</source>
          <target state="translated">Establecer el <ph id="ph1">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph> propiedad de un tipo <ph id="ph2">`DataSet`</ph> a <ph id="ph3">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> hace que la información de esquema que desea excluir de la carga de serialización.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> is supported only for a typed <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> se admite solo para un tipo <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>For an un-typed <ph id="ph1">`DataSet`</ph> this property can only be set to <ph id="ph2">&lt;xref:System.Data.SchemaSerializationMode.IncludeSchema&gt;</ph>.</source>
          <target state="translated">Para una sin tipo <ph id="ph1">`DataSet`</ph> sólo se puede establecer esta propiedad en <ph id="ph2">&lt;xref:System.Data.SchemaSerializationMode.IncludeSchema&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> should only be used in cases where the schema information of the underlying typed <ph id="ph2">`DataTables`</ph>, <ph id="ph3">`DataRelations`</ph> and <ph id="ph4">`Constraints`</ph> has not been modified.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> solo debe usarse en casos donde se escribió la información del esquema de subyacente <ph id="ph2">`DataTables`</ph>, <ph id="ph3">`DataRelations`</ph> y <ph id="ph4">`Constraints`</ph> no se ha modificado.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>If modifications have occurred, complete schema information should be serialized with <ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.IncludeSchema&gt;</ph>.</source>
          <target state="translated">Si las modificaciones realizadas se debe serializar la información de esquema se produjo, completo con <ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.IncludeSchema&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> is supported in version 2.0 of the .NET Framework or later.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> se admite en la versión 2.0 de .NET Framework o una versión posterior.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>When <ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> is set, only the top level runtime properties present on the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> are serialized.</source>
          <target state="translated">Cuando <ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> se establece, solo las propiedades de tiempo de ejecución de nivel superior está presentes en el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> se serializan.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>In addition, they are serialized only if they happen to be different from the default values.</source>
          <target state="translated">Además, se serializan solo si se producen sea distinto de los valores predeterminados.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>None of the <ph id="ph1">`Tables`</ph>, <ph id="ph2">`Relations`</ph> or <ph id="ph3">`Constraints`</ph> are serialized.</source>
          <target state="translated">Ninguno de los <ph id="ph1">`Tables`</ph>, <ph id="ph2">`Relations`</ph> o <ph id="ph3">`Constraints`</ph> se serializan.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>The serialized runtime properties include <ph id="ph1">&lt;xref:System.Data.DataSet.DataSetName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph>.</source>
          <target state="translated">Las propiedades en tiempo de ejecución serializada incluyen <ph id="ph1">&lt;xref:System.Data.DataSet.DataSetName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph>, y <ph id="ph6">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>These properties are serialized to make sure that overall runtime data integrity is preserved.</source>
          <target state="translated">Estas propiedades se serializan para asegurarse de que se conserva la integridad de los datos en tiempo de ejecución total.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source>Gets a value indicating whether <ph id="ph1">&lt;see cref="P:System.Data.DataSet.Relations" /&gt;</ph> property should be persisted.</source>
          <target state="translated">Obtiene un valor que indica si se debe conservar la propiedad <ph id="ph1">&lt;see cref="P:System.Data.DataSet.Relations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value has been changed from its default; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el valor de propiedad ha cambiado con respecto a su valor predeterminado; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source>You typically use this method if you are either creating a designer for the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, or creating your own control incorporating the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Este método utiliza normalmente si se está creando un diseñador para el <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, o crear su propio control que incorpore el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source>The following examples show a class derived from the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> class.</source>
          <target state="translated">Los ejemplos siguientes muestra una clase derivada de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Reset%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ShouldSerializeRelations%2A&gt;</ph> methods are invoked from within functions in the derived class.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.Reset%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.ShouldSerializeRelations%2A&gt;</ph> métodos se invocan desde dentro de las funciones en la clase derivada.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source>Gets a value indicating whether <ph id="ph1">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph> property should be persisted.</source>
          <target state="translated">Obtiene un valor que indica si se debe conservar la propiedad <ph id="ph1">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value has been changed from its default; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el valor de propiedad ha cambiado con respecto a su valor predeterminado; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source>You typically use this method only if you are either creating a designer for the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, or creating your own control incorporating the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Este método utiliza normalmente sólo si se está creando un diseñador para el <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, o crear su propio control que incorpore el <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source>The following example shows a class derived from the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se muestra una clase derivada de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ShouldSerializeTables%2A&gt;</ph> method is called from within functions in the derived class.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.ShouldSerializeTables%2A&gt;</ph> método se llama desde dentro de las funciones en la clase derivada.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Site">
          <source>Gets or sets an <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtiene o establece una interfaz <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> para el objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Site">
          <source>An <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Estructura <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> para la colección <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Site">
          <source>Sites bind a <ph id="ph1">&lt;xref:System.ComponentModel.Component&gt;</ph> to a <ph id="ph2">&lt;xref:System.ComponentModel.Container&gt;</ph> and enable communication between them, as well as provide a way for the container to manage its components.</source>
          <target state="translated">Sitios de enlazan un <ph id="ph1">&lt;xref:System.ComponentModel.Component&gt;</ph> a una <ph id="ph2">&lt;xref:System.ComponentModel.Container&gt;</ph> y habilitar la comunicación entre ellos, así como proporcionar una manera para que el contenedor administrar sus componentes.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph>.</source>
          <target state="translated">Para una descripción de este miembro, vea <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Tables">
          <source>Gets the collection of tables contained in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtiene la colección de tablas incluidas en <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph> contained by this <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Colección <ph id="ph1">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph> que contiene este objeto <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>An empty collection is returned if no <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> objects exist.</source>
          <target state="translated">Si no existe ningún objeto <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, se devuelve una colección vacía.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>To add tables to the collection, use <ph id="ph1">&lt;xref:System.Data.DataTableCollection.Add%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.DataTableCollection&gt;</ph>.</source>
          <target state="translated">Para agregar tablas a la colección, use <ph id="ph1">&lt;xref:System.Data.DataTableCollection.Add%2A&gt;</ph> método de la <ph id="ph2">&lt;xref:System.Data.DataTableCollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>To remove tables, use the <ph id="ph1">&lt;xref:System.Data.DataTableCollection.Remove%2A&gt;</ph> method.</source>
          <target state="translated">Para quitar tablas, utilice la <ph id="ph1">&lt;xref:System.Data.DataTableCollection.Remove%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>The following example returns the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object's <ph id="ph2">&lt;xref:System.Data.DataTableCollection&gt;</ph>, and prints the columns and rows in each table.</source>
          <target state="translated">El ejemplo siguiente devuelve el <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Data.DataTableCollection&gt;</ph>e imprime las columnas y filas de cada tabla.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Writes XML data, and optionally the schema, from the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Escribe datos XML y, de forma opcional, el esquema del <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object used to write to a file.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> utilizado para escribir en un archivo.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>Writes the current data for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">Escribe los datos actuales para el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">El <ph id="ph1">`WriteXml`</ph> método proporciona una forma de escribir datos, o los datos y el esquema de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método escribe sólo el esquema.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Para escribir los datos y el esquema, utilice una de las sobrecargas que incluye el <ph id="ph1">`mode`</ph> parámetro y establezca su valor en <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Para leer datos XML, o el esquema y los datos en el <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`ReadXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Para leer únicamente el esquema, utilice la <ph id="ph1">`ReadXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> object.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>The object is then used with the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method to write an XML document.</source>
          <target state="translated">A continuación, se utiliza el objeto con el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método para escribir un documento XML.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object with which to write.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> con el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>Writes the current data for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</source>
          <target state="translated">Escribe los datos actuales para el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">El <ph id="ph1">`WriteXml`</ph> método proporciona una forma de escribir datos, o los datos y el esquema de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método escribe sólo el esquema.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Para escribir los datos y el esquema, utilice una de las sobrecargas que incluye el <ph id="ph1">`mode`</ph> parámetro y establezca su valor en <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Para leer datos XML, o el esquema y los datos en el <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`ReadXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Para leer únicamente el esquema, utilice la <ph id="ph1">`ReadXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>The file name (including the path) to which to write.</source>
          <target state="translated">Nombre del archivo (incluida la ruta) en el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>Writes the current data for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to the specified file.</source>
          <target state="translated">Escribe los datos actuales para el <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en el archivo especificado.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">El <ph id="ph1">`WriteXml`</ph> método proporciona una forma de escribir datos, o los datos y el esquema de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método escribe sólo el esquema.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Para escribir los datos y el esquema, utilice una de las sobrecargas que incluye el <ph id="ph1">`mode`</ph> parámetro y establezca su valor en <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Para leer datos XML, o el esquema y los datos en el <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`ReadXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Para leer únicamente el esquema, utilice la <ph id="ph1">`ReadXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> no está establecido en <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>for reading and writing files.</source>
          <target state="translated">Para leer y escribir en archivos.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> with which to write.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> con el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>Writes the current data for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">Escribe los datos actuales para el <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en el <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">El <ph id="ph1">`WriteXml`</ph> método proporciona una forma de escribir datos, o los datos y el esquema de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método escribe sólo el esquema.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Para escribir los datos y el esquema, utilice una de las sobrecargas que incluye el <ph id="ph1">`mode`</ph> parámetro y establezca su valor en <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Para leer datos XML, o el esquema y los datos en el <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`ReadXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Para leer únicamente el esquema, utilice la <ph id="ph1">`ReadXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object used to write to a file.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> utilizado para escribir en un archivo.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">Escribe los datos actuales y, de forma opcional, el esquema para el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> y la enumeración <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">Para escribir el esquema, establezca el valor del parámetro <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> en <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">El <ph id="ph1">`WriteXml`</ph> método proporciona una forma de escribir datos, o los datos y el esquema de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método escribe sólo el esquema.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Para escribir los datos y el esquema, establezca el <ph id="ph1">`mode`</ph> parámetro <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Para leer datos XML, o el esquema y los datos en el <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`ReadXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Para leer únicamente el esquema, utilice la <ph id="ph1">`ReadXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object used to write the document.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> que se utiliza para escribir el documento.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">Escribe los datos actuales y, de forma opcional, el esquema para el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> y la enumeración <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">Para escribir el esquema, establezca el valor del parámetro <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> en <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">El <ph id="ph1">`WriteXml`</ph> método proporciona una forma de escribir datos, o los datos y el esquema de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método escribe sólo el esquema.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Para escribir los datos y el esquema, establezca el <ph id="ph1">`mode`</ph> parámetro <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Para leer datos XML, o el esquema y los datos en el <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`ReadXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Para leer únicamente el esquema, utilice la <ph id="ph1">`ReadXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">En el ejemplo siguiente se crea primero una sencilla <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> con una <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, dos columnas y diez filas.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> esquema y los datos se escriben en el disco mediante la invocación de la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Un segundo <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se crea y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> método se usa para rellenar con el esquema y los datos.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>The file name (including the path) to which to write.</source>
          <target state="translated">Nombre del archivo (incluida la ruta) en el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to the specified file using the specified <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">Escribe los datos actuales y, de forma opcional, el esquema para el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en el archivo indicado mediante la enumeración <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> especificada.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">Para escribir el esquema, establezca el valor del parámetro <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> en <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">El <ph id="ph1">`WriteXml`</ph> método proporciona una forma de escribir datos, o los datos y el esquema de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método escribe sólo el esquema.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Para escribir los datos y el esquema, establezca el <ph id="ph1">`mode`</ph> parámetro <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Para leer datos XML, o el esquema y los datos en el <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`ReadXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Para leer únicamente el esquema, utilice la <ph id="ph1">`ReadXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method to write an XML document.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método para escribir un documento XML.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> no está establecido en <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>for reading and writing files.</source>
          <target state="translated">Para leer y escribir en archivos.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> with which to write.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> con el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">Escribe los datos actuales y, de forma opcional, el esquema para el objeto <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> mediante el objeto <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> y la enumeración <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">Para escribir el esquema, establezca el valor del parámetro <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> en <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">El <ph id="ph1">`WriteXml`</ph> método proporciona una forma de escribir datos, o los datos y el esquema de un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML, mientras que la <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método escribe sólo el esquema.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Para escribir los datos y el esquema, establezca el <ph id="ph1">`mode`</ph> parámetro <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Tenga en cuenta que lo mismo puede decirse de la <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> métodos, respectivamente.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Para leer datos XML, o el esquema y los datos en el <ph id="ph1">`DataSet`</ph>, use el <ph id="ph2">`ReadXml`</ph> método.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Para leer únicamente el esquema, utilice la <ph id="ph1">`ReadXmlSchema`</ph> método.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se producirá si un tipo de columna en la <ph id="ph2">`DataRow`</ph> que se leen o escriben en implementa <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> y no implementa <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> object that is used to create a new <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> objeto que se usa para crear un nuevo <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> object is used with the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method to write an XML document.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> objeto se usa con el <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método para escribir un documento XML.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema.</source>
          <target state="translated">Escribe la estructura del <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> como un esquema XML.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object used to write to a file.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> utilizado para escribir en un archivo.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">Escribe la estructura <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> como un esquema XML al objeto <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> to an XML document.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método para escribir el esquema para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">El esquema incluye definiciones de tabla, relaciones y restricciones.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir un esquema en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">El esquema XML se escribe mediante el estándar XSD.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir los datos en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>Classes that derive from the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> class include <ph id="ph2">&lt;xref:System.IO.BufferedStream&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.NetworkStream&gt;</ph>.</source>
          <target state="translated">Las clases que derivan de la <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> clase incluir <ph id="ph2">&lt;xref:System.IO.BufferedStream&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream&gt;</ph>, y <ph id="ph5">&lt;xref:System.Net.Sockets.NetworkStream&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object that is passed to the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema to disk.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto que se pasa a la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método para escribir el esquema en el disco.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object with which to write.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> con el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object.</source>
          <target state="translated">Escribe la estructura <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> como un esquema XML al objeto <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> to an XML document.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método para escribir el esquema para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">El esquema incluye definiciones de tabla, relaciones y restricciones.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir un esquema en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">El esquema XML se escribe mediante el estándar XSD.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir los datos en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>Classes the derive from the <ph id="ph1">&lt;xref:System.IO.TextWriter?displayProperty=nameWithType&gt;</ph> class include the <ph id="ph2">&lt;xref:System.Web.HttpWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.StreamWriter?displayProperty=nameWithType&gt;</ph>, and <ph id="ph6">&lt;xref:System.IO.StringWriter?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Las clases que derivan de la <ph id="ph1">&lt;xref:System.IO.TextWriter?displayProperty=nameWithType&gt;</ph> clase incluye el <ph id="ph2">&lt;xref:System.Web.HttpWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.StreamWriter?displayProperty=nameWithType&gt;</ph>, y <ph id="ph6">&lt;xref:System.IO.StringWriter?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> object to that is used to create a new <ph id="ph2">&lt;xref:System.IO.StringWriter?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> objeto para el que se usa para crear un nuevo <ph id="ph2">&lt;xref:System.IO.StringWriter?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The <ph id="ph1">&lt;xref:System.IO.StringWriter&gt;</ph> is passed to the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method, and the resulting string is printed to the console window.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.StringWriter&gt;</ph> se pasa a la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método y la cadena resultante se imprime en la ventana de consola.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>The file name (including the path) to which to write.</source>
          <target state="translated">Nombre del archivo (incluida la ruta) en el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to a file.</source>
          <target state="translated">Escribe la estructura del <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> como un esquema XML en un archivo.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> to an XML document.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método para escribir el esquema para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">El esquema incluye definiciones de tabla, relaciones y restricciones.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir un esquema en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">El esquema XML se escribe mediante el estándar XSD.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir los datos en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> no está establecido en <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>for reading and writing files.</source>
          <target state="translated">Para leer y escribir en archivos.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> to write to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> en el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to an <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> object.</source>
          <target state="translated">Escribe la estructura del <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> como un esquema XML en un objeto <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> to an XML document.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método para escribir el esquema para un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> en un documento XML.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">El esquema incluye definiciones de tabla, relaciones y restricciones.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir un esquema en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">El esquema XML se escribe mediante el estándar XSD.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Para escribir los datos en un documento XML, utilice el <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>One class that inherits from the <ph id="ph1">&lt;xref:System.Xml.XmlWriter?displayProperty=nameWithType&gt;</ph> class is the <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> class.</source>
          <target state="translated">Una clase que hereda de la <ph id="ph1">&lt;xref:System.Xml.XmlWriter?displayProperty=nameWithType&gt;</ph> clase es la <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> object with the specified path.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> objeto con la ruta de acceso especificada.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object is used to create an <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto se usa para crear un <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method is then invoked with the <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> object to write the schema to the disk.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> , a continuación, se invoca el método con el <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> objeto que se va a escribir el esquema en el disco.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object to write to.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> en el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})">
          <source>A delegate used to convert <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to string.</source>
          <target state="translated">Un delegado usado para convertir <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en una cadena.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">Escribe la estructura <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> como un esquema XML al objeto <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object to write to.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> en el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})">
          <source>A delegate used to convert <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to string.</source>
          <target state="translated">Un delegado usado para convertir <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en una cadena.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</source>
          <target state="translated">Escribe la estructura de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> como un esquema XML en el objeto <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})">
          <source>The name of the file to write to.</source>
          <target state="translated">Nombre del archivo en el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})">
          <source>A delegate used to convert <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to string.</source>
          <target state="translated">Un delegado usado para convertir <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en una cadena.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to a file.</source>
          <target state="translated">Escribe la estructura del <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> como un esquema XML en un archivo.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> object to write to.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> en el que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})">
          <source>A delegate used to convert <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to string.</source>
          <target state="translated">Un delegado usado para convertir <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en una cadena.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">Escribe la estructura de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> como un esquema XML en el objeto <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> especificado.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>