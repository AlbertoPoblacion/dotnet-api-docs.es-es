<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="90351397491a239c122190dd82c7d221c7fd69d3" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48689843" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una caché de datos en memoria.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet>, que es una caché en memoria de datos recuperados de un origen de datos es un componente fundamental de la arquitectura de ADO.NET. El <xref:System.Data.DataSet> consta de una colección de <xref:System.Data.DataTable> objetos que se pueden relacionar entre sí con <xref:System.Data.DataRelation> objetos. También se puede imponer la integridad de los datos en el <xref:System.Data.DataSet> utilizando el <xref:System.Data.UniqueConstraint> y <xref:System.Data.ForeignKeyConstraint> objetos. Para obtener más información sobre cómo trabajar con <xref:System.Data.DataSet> objetos, vea [DataSet, DataTable y DataView](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 Mientras que <xref:System.Data.DataTable> objetos contienen los datos, el <xref:System.Data.DataRelationCollection> permite desplazarse por la jerarquía de la tabla. Las tablas contenidas en un <xref:System.Data.DataTableCollection> tiene acceso a través del <xref:System.Data.DataSet.Tables%2A> propiedad. Al obtener acceso a <xref:System.Data.DataTable> objetos, tenga en cuenta que son condicionalmente distingue mayúsculas de minúsculas. Por ejemplo, si uno <xref:System.Data.DataTable> se denomina "mydatatable" y otro se denomina "Mydatatable", se considerará una cadena utilizada para buscar una de las tablas como distingue mayúsculas de minúsculas. Sin embargo, si existe "mydatatable" y "Mydatatable" no es así, la cadena de búsqueda se considerará como con diferenciación entre mayúsculas y minúsculas. Para obtener más información sobre cómo trabajar con <xref:System.Data.DataTable> objetos, vea [crear un objeto DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Un <xref:System.Data.DataSet> pueden leer y escribir datos y el esquema como documentos XML. Los datos y esquemas, a continuación, se transmite a través de HTTP y utilizar en cualquier aplicación en cualquier plataforma que sea compatible con XML. Puede guardar el esquema como esquema XML con el <xref:System.Data.DataSet.WriteXmlSchema%2A> método y el esquema y los datos se pueden guardar mediante el <xref:System.Data.DataSet.WriteXml%2A> método. Para leer un documento XML que incluye el esquema y los datos, use el <xref:System.Data.DataSet.ReadXml%2A> método.  
  
 En una implementación típica de varios niveles, los pasos para crear y actualizar un <xref:System.Data.DataSet>, y a su vez, actualizar los datos originales son:  
  
1.  Crear y llenar cada <xref:System.Data.DataTable> en un <xref:System.Data.DataSet> con los datos de un origen de datos mediante un <xref:System.Data.Common.DataAdapter>.  
  
2.  Cambiar los datos de usuario individual <xref:System.Data.DataTable> objetos mediante la adición, actualización o eliminación de <xref:System.Data.DataRow> objetos.  
  
3.  Invocar el <xref:System.Data.DataSet.GetChanges%2A> método para crear un segundo <xref:System.Data.DataSet> que incluye solo los cambios a los datos.  
  
4.  Llame a la <xref:System.Data.Common.DataAdapter.Update%2A> método de la <xref:System.Data.Common.DataAdapter>, pasando el segundo <xref:System.Data.DataSet> como argumento.  
  
5.  Invocar el <xref:System.Data.DataSet.Merge%2A> método para combinar los cambios de la segunda <xref:System.Data.DataSet> en la primera.  
  
6.  Invocar el <xref:System.Data.DataSet.AcceptChanges%2A> en el <xref:System.Data.DataSet>. Como alternativa, invocar <xref:System.Data.DataSet.RejectChanges%2A> para cancelar los cambios.  
  
> [!NOTE]
>  El <xref:System.Data.DataSet> y <xref:System.Data.DataTable> objetos heredan de <xref:System.ComponentModel.MarshalByValueComponent>y admiten la <xref:System.Runtime.Serialization.ISerializable> interfaz para la comunicación remota. Éstos son los únicos objetos ADO.NET a los que se puede tener acceso remoto.  
  
> [!NOTE]
>  Las clases heredan <xref:System.Data.DataSet> no finalizado por el recolector de elementos no utilizados, porque se ha suprimido el finalizador en <xref:System.Data.DataSet>. La clase derivada puede llamar a la <xref:System.GC.ReRegisterForFinalize%2A> método en su constructor para permitir que la clase de ser finalizados por el recolector de elementos no utilizados.  
  
   
  
## Examples  
 En el siguiente ejemplo consta de varios métodos que, en combinación, crear y rellenar un <xref:System.Data.DataSet> desde el **Northwind** base de datos.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para las operaciones de lectura multiproceso. Debe sincronizar operaciones de escritura.</threadsafe>
    <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación de la <xref:System.Data.DataSet> constructor no toma ningún parámetro y crea un nombre predeterminado, "NewDataSet", para la nueva instancia.  
  
 Un nombre para el <xref:System.Data.DataSet> es necesario para asegurarse de que la representación XML de la <xref:System.Data.DataSet> siempre tiene un nombre para el elemento de documento, que es el elemento de nivel superior en una definición de esquema.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Data.DataSet>y se agregan dos <xref:System.Data.DataTable> objetos a él.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">Nombre del objeto <see cref="T:System.Data.DataSet" />.</param>
        <summary>Inicializa una nueva instancia de una clase <see cref="T:System.Data.DataSet" /> con el nombre dado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nombre para el <xref:System.Data.DataSet> es necesario para asegurarse de que la representación XML de la <xref:System.Data.DataSet> siempre tiene un nombre para el elemento de documento, que es el elemento de nivel superior en una definición de esquema.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Data.DataSet>, dos <xref:System.Data.DataTable> se agregan objetos.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Datos necesarios para serializar o deserializar un objeto.</param>
        <param name="context">Origen y destino de una secuencia de serialización dada.</param>
        <summary>Inicializa una nueva instancia de una clase <see cref="T:System.Data.DataSet" /> que contiene la información de serialización y el contexto especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <param name="ConstructSchema">Valor booleano.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Confirma todos los cambios realizados en este <see cref="T:System.Data.DataSet" /> desde que se ha cargado o desde la última vez que se ha llamado a <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto el <xref:System.Data.DataRow> y <xref:System.Data.DataTable> clases tienen <xref:System.Data.DataSet.AcceptChanges%2A> métodos. Una llamada a <xref:System.Data.DataTable.AcceptChanges%2A> en el <xref:System.Data.DataTable> hace que el nivel del <xref:System.Data.DataRow.AcceptChanges%2A> método para cada <xref:System.Data.DataRow> llamarse. Invocar de forma similar, <xref:System.Data.DataSet.AcceptChanges%2A> en el <xref:System.Data.DataSet> hace <xref:System.Data.DataTable.AcceptChanges%2A> llamará en cada tabla dentro de la <xref:System.Data.DataSet>. De esta manera, dispone de varios niveles en la que se puede invocar el método. Una llamada a la <xref:System.Data.DataSet.AcceptChanges%2A> de la <xref:System.Data.DataSet> permite invocar el método en todos los objetos subordinados (por ejemplo, tablas y filas) con una llamada.  
  
 Cuando se llama a `AcceptChanges` en el `DataSet`, cualquier <xref:System.Data.DataRow> objetos todavía en modo de edición finalización correctamente sus modificaciones. El <xref:System.Data.DataRow.RowState%2A> propiedad de cada uno <xref:System.Data.DataRow> también cambia; `Added` y `Modified` filas se convierten en `Unchanged`, y `Deleted` se quitan las filas.  
  
 Si el `DataSet` contiene <xref:System.Data.ForeignKeyConstraint> objetos, invocar el `AcceptChanges` también hace que el método la <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> aplicándose.  
  
> [!NOTE]
>  `AcceptChanges` y `RejectChanges` solo se aplican a `DataRow` relacionados con los cambios (es decir, agregar, quitar, eliminar y modificar). No son aplicables a los cambios estructurales o de esquema.  
>   
>  Llamar a AcceptChanges no replicará estos cambios en el origen de datos si se ha rellenado el conjunto de datos mediante un objeto DataAdapter. En esa situación, llame a <xref:System.Data.Common.DataAdapter.Update%2A> en su lugar. Consulte [actualizar orígenes de datos con objetos DataAdapter](http://msdn.microsoft.com/library/33y2221y.aspx) para obtener más información.  
  
   
  
## Examples  
 En el ejemplo siguiente se agrega un <xref:System.Data.DataRow> a un <xref:System.Data.DataTable> en un <xref:System.Data.DataSet>. El <xref:System.Data.DataSet.AcceptChanges%2A> , a continuación, se llama al método en el <xref:System.Data.DataSet>, qué cascadas a todos los <xref:System.Data.DataTable> objetos que contiene.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Activa la inicialización de un objeto <see cref="T:System.Data.DataSet" /> que se emplea en un formulario o que utiliza otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El entorno de diseño de Visual Studio. NET, usa este método para iniciar la inicialización de un componente que se emplea en un formulario o utilizado por otro componente. El <xref:System.Data.DataSet.EndInit%2A> método termina la inicialización. Mediante el <xref:System.Data.DataSet.BeginInit%2A> y <xref:System.Data.DataSet.EndInit%2A> métodos impide que el control que se va a usar antes de inicializarse completamente.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si las comparaciones de cadena en los objetos <see cref="T:System.Data.DataTable" /> distinguen entre mayúsculas y minúsculas.</summary>
        <value>
          <see langword="true" /> si las comparaciones de cadenas distinguen entre mayúsculas y minúsculas; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.CaseSensitive%2A> propiedad afecta a cómo ordenar, buscar y filtrar las operaciones se realizan en cada <xref:System.Data.DataTable> objeto contenido en un <xref:System.Data.DataSet> cuando se usa el <xref:System.Data.DataTable.Select%2A> método.  
  
 De forma predeterminada, establecer el <xref:System.Data.DataSet.CaseSensitive%2A> propiedad para un <xref:System.Data.DataSet> también establece la <xref:System.Data.DataTable.CaseSensitive%2A> propiedad de cada uno asociado <xref:System.Data.DataTable> en el mismo valor.  
  
   
  
## Examples  
 En el ejemplo siguiente se alterna el <xref:System.Data.DataSet.CaseSensitive%2A> propiedad.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra cualquier dato de <see cref="T:System.Data.DataSet" /> mediante el procedimiento de quitar todas las filas de todas las tablas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Data.DataSet> está enlazado a un <xref:System.Xml.XmlDataDocument>, al llamar a <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> o <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> provoca la <xref:System.NotSupportedException>. Para evitar esta situación, recorrer cada tabla, eliminando una fila cada vez.  
  
   
  
## Examples  
 El siguiente ejemplo se borra el <xref:System.Data.DataSet> de todas las filas de todas las tablas.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia la estructura de <see cref="T:System.Data.DataSet" />, incluidos todos los esquemas, relaciones y restricciones de <see cref="T:System.Data.DataTable" />. No copia ningún dato.</summary>
        <returns>Nuevo <see cref="T:System.Data.DataSet" /> con el mismo esquema que el <see cref="T:System.Data.DataSet" /> actual, pero sin ningún dato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si estas clases se han subclasificado, el clon también será de las mismas subclases.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un clon de un <xref:System.Data.DataSet> esquema del objeto.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia la estructura y los datos para este objeto <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Nuevo <see cref="T:System.Data.DataSet" /> con la misma estructura (esquemas, relaciones y restricciones de tabla) y datos que este <see cref="T:System.Data.DataSet" />.  
  
 <block subset="none" type="note"><para>  
 Si estas clases se han subclasificado, la copia también será de las mismas subclases.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Data.DataSet.Copy%2A> método para crear una copia del original <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Data.DataTableReader" /> con un conjunto de resultados por cada <see cref="T:System.Data.DataTable" />, siguiendo la misma secuencia con la que aparecen las tablas en la colección <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con el fin de garantizar el orden de los conjuntos de resultados en el valor devuelto <xref:System.Data.DataTableReader>, si un <xref:System.Data.DataTable> dentro de la <xref:System.Data.DataSet> está vacío, se representará mediante un conjunto en el valor devuelto de resultados vacío `DataTableReader`.  
  
   
  
## Examples  
 En este ejemplo, una aplicación de consola, crea tres <xref:System.Data.DataTable> instancias y los agrega a un <xref:System.Data.DataSet>. El ejemplo llama a la <xref:System.Data.DataSet.CreateDataReader%2A> método y muestra el contenido devuelto del <xref:System.Data.DataTableReader>. Tenga en cuenta que el orden del resultado se establece en el `DataTableReader` está controlado por el orden de los `DataTable` instancias pasan como parámetros.  
  
> [!NOTE]
>  En este ejemplo se muestra cómo usar una de las versiones sobrecargadas de `CreateDataReader`. Para obtener otros ejemplos, vea los temas individuales de sobrecarga.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 En el ejemplo se muestra el código siguiente en la ventana de consola:  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Data.DataTableReader" /> con un conjunto de resultados por cada <see cref="T:System.Data.DataTable" />, siguiendo la misma secuencia con la que aparecen las tablas en la colección <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <returns>Objeto <see cref="T:System.Data.DataTableReader" /> que contiene uno o varios conjuntos de resultados, que se corresponden con las instancias de <see cref="T:System.Data.DataTable" /> incluidas en el objeto <see cref="T:System.Data.DataSet" /> de origen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con el fin de garantizar el orden de los conjuntos de resultados en el valor devuelto <xref:System.Data.DataTableReader>, si un <xref:System.Data.DataTable> dentro de la <xref:System.Data.DataSet> está vacío, se representa mediante un conjunto en el valor devuelto de resultados vacío `DataTableReader`.  
  
   
  
## Examples  
 En el siguiente ejemplo crea tres <xref:System.Data.DataTable> instancias y los agrega a un <xref:System.Data.DataSet>. El ejemplo a continuación, pasa el relleno `DataSet` a un procedimiento que llama el <xref:System.Data.DataSet.CreateDataReader%2A> método y se inicia para recorrer en iteración todos los conjuntos de resultados dentro de la <xref:System.Data.DataTableReader>. El ejemplo muestra los resultados en la ventana de consola.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Matriz de objetos DataTable que proporciona el orden de los conjuntos de resultados que va a devolver el objeto <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Devuelve un objeto <see cref="T:System.Data.DataTableReader" /> con un conjunto de resultados por cada <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Objeto <see cref="T:System.Data.DataTableReader" /> que contiene uno o varios conjuntos de resultados, que se corresponden con las instancias de <see cref="T:System.Data.DataTable" /> incluidas en el objeto <see cref="T:System.Data.DataSet" /> de origen. Los conjuntos de resultados devueltos siguen el orden especificado por el parámetro <paramref name="dataTables" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para asegurarse de que el orden del resultado se establece en el valor devuelto <xref:System.Data.DataTableReader>, si un <xref:System.Data.DataTable> dentro de la <xref:System.Data.DataSet> está vacío, se representa mediante un conjunto en el valor devuelto de resultados vacío `DataTableReader`. Dado que esta versión sobrecargada permite proporcionar una lista de `DataTable` instancias como parámetros, puede especificar el orden en que los conjuntos de resultados aparecen en el valor devuelto `DataTableReader`.  
  
   
  
## Examples  
 En este ejemplo, una aplicación de consola, crea tres <xref:System.Data.DataTable> instancias y los agrega a un <xref:System.Data.DataSet>. El ejemplo llama a la <xref:System.Data.DataSet.CreateDataReader%2A> método y muestra el contenido devuelto del <xref:System.Data.DataTableReader>. Tenga en cuenta que el orden del resultado se establece en el `DataTableReader` está controlado por el orden de los `DataTable` instancias pasan como parámetros. El ejemplo muestra los resultados en la ventana de consola.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDataSetNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del objeto <see cref="T:System.Data.DataSet" /> actual.</summary>
        <value>Nombre del objeto <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Data.DataSet> con el dado <xref:System.Data.DataSet.DataSetName%2A>.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una vista personalizada de los datos incluidos en <see cref="T:System.Data.DataSet" />, lo que permite filtrar, buscar y navegar mediante un <see cref="T:System.Data.DataViewManager" /> personalizado.</summary>
        <value>Un objeto <see cref="T:System.Data.DataViewManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataViewManager> devuelto por la <xref:System.Data.DataSet.DefaultViewManager%2A> propiedad le permite crear una configuración personalizada para cada <xref:System.Data.DataTable> en el <xref:System.Data.DataSet>.  
  
 Cuando obtienen un <xref:System.Data.DataView> desde un <xref:System.Data.DataTable>, el criterio de ordenación, filtrado, y <xref:System.Data.DataViewRowState> están configurados según la configuración de la <xref:System.Data.DataSet.DefaultViewManager%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el valor predeterminado <xref:System.Data.DataViewManager> para un <xref:System.Data.DataSet>y agrega un <xref:System.Data.DataTable> a la <xref:System.Data.DataTableCollection>.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina la propiedad <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> para un objeto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede llamarse al deserializar un tipo <xref:System.Data.DataSet> para determinar su <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Instancia de <see cref="T:System.Xml.XmlReader" /> que se pasa durante la deserialización del objeto <see cref="T:System.Data.DataSet" />.</param>
        <summary>Determina la propiedad <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> para un objeto <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Enumeración <see cref="T:System.Data.SchemaSerializationMode" /> que indica si la información de esquema se ha omitido de la carga.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede llamarse al deserializar un tipo <xref:System.Data.DataSet> para determinar su <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con el que se invoca al constructor protegido <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> de un objeto <see langword="DataSet" /> durante la deserialización en escenarios de comunicación remota.</param>
        <param name="context">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> con el que se invoca al constructor protegido <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> de un objeto <see langword="DataSet" /> durante la deserialización en escenarios de comunicación remota.</param>
        <summary>Determina la propiedad <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> para un objeto <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Enumeración <see cref="T:System.Data.SchemaSerializationMode" /> que indica si la información de esquema se ha omitido de la carga.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede llamarse al deserializar un tipo <xref:System.Data.DataSet> para determinar su <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Finaliza la inicialización de un objeto <see cref="T:System.Data.DataSet" /> que se emplea en un formulario o que utiliza otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El entorno de diseño de Visual Studio. NET, usa este método para finalizar la inicialización de un componente que se emplea en un formulario o utilizado por otro componente. El <xref:System.Data.DataSet.BeginInit%2A> método comienza la inicialización. Mediante el <xref:System.Data.DataSet.BeginInit%2A> y <xref:System.Data.DataSet.EndInit%2A> métodos impide que el control que se va a usar antes de inicializarse completamente.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetEnforceConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se siguen las reglas de restricción al intentar realizar cualquier operación de actualización.</summary>
        <value>
          <see langword="true" /> si se fuerzan las reglas; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las restricciones se establecen en el <xref:System.Data.DataTable> nivel (<xref:System.Data.DataTable.Constraints%2A> propiedad). Para obtener más información sobre cómo crear restricciones, vea [restricciones de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Data.DataSet> con una tabla, una columna, cinco filas y uno <xref:System.Data.UniqueConstraint>. El <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad está establecida en `false` y los valores de cada fila se establecen en el mismo valor. Cuando el <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad se restablece a `true`, un <xref:System.Data.ConstraintException> se genera.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">No se pueden forzar una o más restricciones.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de la información personalizada del usuario asociada a <see langword="DataSet" />.</summary>
        <value>
          <see cref="T:System.Data.PropertyCollection" /> con toda la información personalizada del usuario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.ExtendedProperties%2A> propiedad le permite almacenar información personalizada con el `DataSet`. Por ejemplo, podría almacenar un tiempo de cuándo se deben actualizar los datos.  
  
 Propiedades extendidas deben ser de tipo <xref:System.String> si desea conservar cuando la <xref:System.Data.DataSet> se escribe como XML.  
  
   
  
## Examples  
 En el ejemplo siguiente se agrega una propiedad personalizada a la <xref:System.Data.PropertyCollection> devuelto por la <xref:System.Data.DataColumn.ExtendedProperties%2A> propiedad. El segundo ejemplo recupera la propiedad personalizada.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene una copia del objeto <see cref="T:System.Data.DataSet" /> que contiene todos los cambios que se le han realizado desde la última vez que se cargó o desde que se llamó a <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una copia del objeto <see cref="T:System.Data.DataSet" /> que contiene todos los cambios que se le han realizado desde que se cargó o se llamó a <see cref="M:System.Data.DataSet.AcceptChanges" /> por última vez.</summary>
        <returns>Copia de los cambios de este objeto <see cref="T:System.Data.DataSet" /> en el que puede que se hayan realizado acciones y, posteriormente, se hayan vuelto a combinar mediante el método <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Si no se encuentran filas modificadas, el método devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuevo <xref:System.Data.DataSet> que contiene una copia de todas las filas en el original <xref:System.Data.DataSet> que tienen cambios pendientes. Las restricciones de relación pueden hacer que las filas sin cambios adicionales que se agregarán a la nueva <xref:System.Data.DataSet> si las filas sin modificar contienen claves principales correspondientes a las claves externas de las filas modificadas. El método devuelve `null` si no hay ninguna fila en el original <xref:System.Data.DataSet> que tienen cambios pendientes.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una sencilla <xref:System.Data.DataSet> con una tabla, dos columnas y diez filas. Se cambian los dos valores y se agrega una fila. Se crea un subconjunto de los datos modificados utilizando el <xref:System.Data.DataSet.GetChanges%2A> método. Después de reconciliar los errores, se agrega una nueva columna al subconjunto, cambiar el esquema. Cuando el <xref:System.Data.DataSet.Merge%2A> se llama al método con el `missingSchemaAction` establecido en `MissingSchemaAction.Add`, la nueva columna se agrega a la versión original <xref:System.Data.DataSet> esquema del objeto.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Uno de los valores de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtiene una copia del objeto <see cref="T:System.Data.DataSet" /> que contiene todos los cambios que se le han realizado desde la última vez que se cargó, o desde que se llamó a <see cref="M:System.Data.DataSet.AcceptChanges" />, filtrado por <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Copia filtrada del objeto <see cref="T:System.Data.DataSet" /> en el que es posible que se hayan llevado a cabo acciones y que, por consiguiente, se puede volver a combinar mediante <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Si no se encuentran filas con el <see cref="T:System.Data.DataRowState" /> deseado, el método devolverá <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.GetChanges%2A> método se usa para producir un segundo <xref:System.Data.DataSet> objeto que contiene solo los cambios introducidos en el original. Use el `rowStates` argumento para especificar el tipo de cambios que debe incluir el nuevo objeto.  
  
 Esto devuelve la copia está diseñada para ser a combinar original <xref:System.Data.DataSet>. Las restricciones de relación pueden provocar filas primarias marcadas como `Unchanged` incluirán. Si no hay filas de la deseada <xref:System.Data.DataRowState> se encuentran, el <xref:System.Data.DataSet.GetChanges%2A> devuelve del método `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Data.DataSet.GetChanges%2A> método para crear un segundo <xref:System.Data.DataSet> objeto, que, a continuación, se usa para actualizar un origen de datos.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Conjunto de esquemas especificado.</param>
        <summary>Obtiene una copia de <see cref="T:System.Xml.Schema.XmlSchemaSet" /> para el conjunto de datos.</summary>
        <returns>Una copia de la clase <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados asociados a la excepción <see cref="T:System.Data.DataSet" />.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene el origen y el destino de la secuencia serializada asociada a la <see cref="T:System.Data.DataSet" />.</param>
        <summary>Rellena un objeto de información de serialización con los datos necesarios para serializar <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="info" /> es <see langword="null" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una instancia serializable de <see cref="T:System.Xml.Schema.XmlSchema" />.</summary>
        <returns>Instancia de <see cref="T:System.Xml.Schema.XmlSchema" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Instancia de <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Contexto de transmisión por secuencias.</param>
        <summary>Deserializa los datos de la tabla a partir de la secuencia binaria o XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la representación XML de los datos almacenados en <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Cadena que es una representación de los datos almacenados en <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método es idéntico a llamar a <xref:System.Data.DataSet.WriteXml%2A> con <xref:System.Data.XmlWriteMode> establecido en <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A> Devuelve el XML como una cadena y, por lo tanto, requiere más sobrecarga que <xref:System.Data.DataSet.WriteXml%2A> para escribir XML en un archivo.  
  
 Si compila un <xref:System.Data.DataSet> utiliza la inferencia de esquema y serializar mediante servicios Web o XML, la columna de ordenación puede cambiar.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Data.DataSet> y <xref:System.Data.DataTable>, agrega datos de ejemplo y, a continuación, muestra los datos en formato XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 Este ejemplo muestra cómo escribir datos en un archivo XML de un conjunto de datos y leer datos en el conjunto de datos desde XML. En este ejemplo se crea un conjunto de datos con dos tablas, usar de dos maneras de exportar un conjunto de datos en los archivos XML (WriteXml y GetXml) y usar dos formas (ReadXml y InferXmlSchema) para importar un conjunto de datos de los archivos XML.  
  
 Antes de compilar y ejecutar el ejemplo, deberá crear cuatro archivos XML en el directorio de ejemplo. En primer lugar, cree ElementsWithAttributes.xml:  
  
```xml  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 A continuación, cree ElementsWithChildElementsxml.xml:  
  
```xml  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Ahora cree ElementsWithOnlyAttributes.xml:  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 Y por último, cree RepeatingElements.xml:  
  
```  
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Ahora puede compilar y ejecutar el siguiente código fuente.  [Cómo Store datos del conjunto de datos en el archivo XML](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) tiene proyectos de Visual Basic y C# para este ejemplo.  
  
```  
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el esquema XML para la representación XML de los datos almacenados en <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Cadena que es el esquema XML para la representación XML de los datos almacenados en <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método es idéntico a llamar a <xref:System.Data.DataSet.WriteXmlSchema%2A>, excepto en que se escribe solo el esquema principal.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> Devuelve el XML como una cadena y, por lo tanto, requiere más sobrecarga que <xref:System.Data.DataSet.WriteXmlSchema%2A> para escribir XML en un archivo.  
  
 Si compila un <xref:System.Data.DataSet> utiliza la inferencia de esquema y serializar mediante servicios Web o XML, la columna de ordenación puede cambiar.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Data.DataSet> y <xref:System.Data.DataTable>y, a continuación, se muestra el esquema en formato XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Data.DataSet" /> presenta cambios, incluyendo filas nuevas, eliminadas o modificadas.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Data.DataSet" /> presenta cambios, incluyendo filas nuevas, eliminadas o modificadas.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Data.DataSet" /> presenta cambios; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Data.DataSet.GetChanges%2A> método para crear un segundo <xref:System.Data.DataSet> objeto que, a continuación, se usa para actualizar un origen de datos.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Uno de los valores de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtiene un valor que indica si <see cref="T:System.Data.DataSet" /> presenta cambios, incluidas filas nuevas, eliminadas o modificadas, filtrados por <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Data.DataSet" /> presenta cambios; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Examine el <xref:System.Data.DataSet.HasChanges%2A> propiedad de la `DataSet` antes de invocar el <xref:System.Data.DataSet.GetChanges%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Data.DataSet.GetChanges%2A> método para crear un segundo <xref:System.Data.DataSet> objeto, que, a continuación, se usa para actualizar un origen de datos.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si hay errores en alguno de los objetos <see cref="T:System.Data.DataTable" /> de este <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see langword="true" /> si alguna tabla contiene errores; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada <xref:System.Data.DataTable> en un <xref:System.Data.DataSet> también tiene un <xref:System.Data.DataTable.HasErrors%2A> propiedad. Use la `HasErrors` propiedad de la `DataSet` primero, para determinar si las tablas tienen errores, antes de comprobar individuales <xref:System.Data.DataTable> objetos. Si un `DataTable` tiene errores, el <xref:System.Data.DataTable.GetErrors%2A> método devuelve una matriz de <xref:System.Data.DataRow> objetos que contiene los errores.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Data.DataSet.HasErrors%2A> propiedad para determinar si un <xref:System.Data.DataSet> objeto contiene errores. Si es así, los errores para cada <xref:System.Data.DataRow> en cada <xref:System.Data.DataTable> se imprimen.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica el esquema XML al <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">Secuencia <see langword="Stream" /> desde la que se va a leer el esquema.</param>
        <param name="nsArray">Matriz de cadenas de identificador de recursos uniforme (URI) del espacio de nombres que se van a excluir de la deducción del esquema.</param>
        <summary>Aplica el esquema XML del objeto <see cref="T:System.IO.Stream" /> especificado al objeto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">Secuencia <see langword="TextReader" /> desde la que se va a leer el esquema.</param>
        <param name="nsArray">Matriz de cadenas de identificador de recursos uniforme (URI) del espacio de nombres que se van a excluir de la deducción del esquema.</param>
        <summary>Aplica el esquema XML del objeto <see cref="T:System.IO.TextReader" /> especificado al objeto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo (incluida la ruta) desde el que se va a leer el esquema.</param>
        <param name="nsArray">Matriz de cadenas de identificador de recursos uniforme (URI) del espacio de nombres que se van a excluir de la deducción del esquema.</param>
        <summary>Aplica el esquema XML del archivo especificado al <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> no está establecido en <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">Secuencia <see langword="XMLReader" /> desde la que se va a leer el esquema.</param>
        <param name="nsArray">Matriz de cadenas de identificador de recursos uniforme (URI) del espacio de nombres que se van a excluir de la deducción del esquema.</param>
        <summary>Aplica el esquema XML del objeto <see cref="T:System.Xml.XmlReader" /> especificado al objeto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce después de inicializar <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deserializa todos los datos de tablas del conjunto de datos a partir de la secuencia binaria o XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Objeto <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <summary>Inspecciona el formato de la representación serializada de <see langword="DataSet" />.</summary>
        <returns>Es <see langword="true" /> si el objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> especificado representa un objeto <see langword="DataSet" /> serializado en su formato binario; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro admite la infraestructura de .NET Framework y no está prevista su utilización directa desde el código.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Data.DataSet" /> está inicializado.</summary>
        <value>
          <see langword="true" /> para indicar que el componente ha terminado la inicialización; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Devuelve el estado de la <xref:System.Data.DataSet> mientras se construye, por ejemplo, Visual Studio. El <xref:System.Data.DataSet.BeginInit%2A> método lo establece en `false` y <xref:System.Data.DataSet.EndInit%2A> método lo establece en `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rellena un objeto <see cref="T:System.Data.DataSet" /> con valores de un origen de datos utilizando la interfaz <see cref="T:System.Data.IDataReader" /> proporcionada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataTable.Load%2A> método proporciona una técnica para rellenar una sola <xref:System.Data.DataTable> con datos recuperados de un <xref:System.Data.IDataReader> instancia. Este método proporciona la misma funcionalidad, pero le permite cargar varios conjuntos de resultados de una `IDataReader` en varias tablas dentro de un `DataSet`.  
  
 Si el objeto `DataSet` ya contiene filas, los datos de entrada del origen de datos se combinan con las filas existentes.  
  
 El `Load` método puede utilizarse en varios escenarios comunes, todo en torno a la obtención de datos de un origen de datos especificado y lo agrega al contenedor de datos actual (en este caso, un `DataSet`). Estos escenarios describen el uso estándar para un `DataSet`, que describe su actualización y el comportamiento de combinación.  
  
 Un `DataSet` sincroniza o actualiza con un origen de datos principal única. El `DataSet` realiza el seguimiento de cambios, lo que permite la sincronización con el origen de datos principal. Además, un `DataSet` puede aceptar datos incrementales de uno o varios orígenes de datos secundario. El `DataSet` no es responsable del seguimiento de cambios con el fin de permitir la sincronización con el origen de datos secundario.  
  
 Dados estos dos orígenes de datos hipotética, un usuario es probable que se necesita uno de los comportamientos siguientes:  
  
-   Inicializar `DataSet` desde un origen de datos principal. En este escenario, el usuario desea inicializar vacío `DataSet` con valores procedentes del origen de datos principal. Se modifica el contenido de uno o varios de DataTable. Más adelante la intención del usuario propagar los cambios en el origen de datos principal.  
  
-   Conservar los cambios realizados y volver a sincronizar desde el origen de datos principal. En este escenario, el usuario desea tomar el `DataSet` rellena en el escenario anterior y realizar una sincronización incremental con el origen de datos principal, conservando las modificaciones realizadas en el `DataSet`.  
  
-   Fuente de datos incrementales desde orígenes de datos secundaria. En este escenario, el usuario desea combinar los cambios de uno o varios orígenes de datos secundaria y propagar los cambios en el origen de datos principal.  
  
 El `Load` método hace que todos estos escenarios posibles. Este método le permite especificar un parámetro de opción de carga, que indica cómo las filas ya está en un <xref:System.Data.DataTable> combinar con las filas que se está cargadas. En la tabla siguiente se describe las opciones de tres carga proporcionadas por el <xref:System.Data.LoadOption> enumeración. En cada caso, la descripción indica el comportamiento cuando la clave principal de una fila en los datos de entrada coincide con la clave principal de una fila existente.  
  
|Opción de carga|Descripción|  
|-----------------|-----------------|  
|`PreserveChanges` (valor predeterminado)|Actualiza la versión original de la fila con el valor de la fila entrante.|  
|`OverwriteChanges`|Actualiza las versiones actuales y originales de la fila con el valor de la fila entrante.|  
|`Upsert`|Actualiza la versión actual de la fila con el valor de la fila entrante.|  
  
 En general, el `PreserveChanges` y `OverwriteChanges` opciones están pensadas para escenarios en los que el usuario necesita para sincronizar el `DataSet` y sus cambios con el origen de datos principal. El `Upsert` opción facilita la adición de cambios desde uno o varios orígenes de datos secundario.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> que proporciona uno o varios conjuntos de resultados.</param>
        <param name="loadOption">Valor de la enumeración <see cref="T:System.Data.LoadOption" /> que indica cómo se van a combinar las filas que ya se encuentran en las instancias de <see cref="T:System.Data.DataTable" />, incluidas en el objeto <see cref="T:System.Data.DataSet" />, con las filas de entrada con las que comparten la misma clave principal.</param>
        <param name="tables">Matriz de instancias de <see cref="T:System.Data.DataTable" /> de las que el método <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> recupera la información sobre el espacio de nombres y el nombre. Cada una de estas tablas debe ser un miembro de la colección <see cref="T:System.Data.DataTableCollection" /> que incluye este objeto <see cref="T:System.Data.DataSet" />.</param>
        <summary>Rellena un objeto <see cref="T:System.Data.DataSet" /> de valores de un origen de datos utilizando la interfaz <see cref="T:System.Data.IDataReader" /> proporcionada, que usa una matriz de instancias de <see cref="T:System.Data.DataTable" /> para suministrar la información sobre el espacio de nombres y el esquema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataTable.Load%2A> método proporciona una técnica para rellenar una sola <xref:System.Data.DataTable> con datos recuperados de un <xref:System.Data.IDataReader> instancia. Este método proporciona la misma funcionalidad, pero le permite cargar varios conjuntos de resultados de una <xref:System.Data.IDataReader> en varias tablas dentro de un <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  La operación de carga se producirá un error con un <xref:System.InvalidOperationException> si cualquiera de las columnas de entrada de datos de origen `reader` son columnas calculadas.  
  
 El `loadOption` parámetro le permite especificar cómo desea que los datos importados para interactuar con los datos existentes y puede ser cualquiera de los valores de la <xref:System.Data.LoadOption> enumeración. Consulte la documentación de la <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> método para obtener más información sobre el uso de este parámetro.  
  
 El `tables` parámetro le permite especificar una matriz de <xref:System.Data.DataTable> instancias, que indica el orden de las tablas correspondientes a cada conjunto de resultados cargado desde el lector. El <xref:System.Data.DataSet.Load%2A> método rellenos cada proporcionados <xref:System.Data.DataTable> instancia con datos de un único conjunto de resultados de la lectura de datos de origen. Después de cada conjunto de resultados, el <xref:System.Data.DataSet.Load%2A> método continúa con el siguiente resultado establecer dentro del lector, hasta que no hay ningún conjunto de resultados.  
  
 El esquema de resolución de nombres para este método es el mismo que ha seguido el <xref:System.Data.Common.DbDataAdapter.Fill%2A> método de la <xref:System.Data.Common.DbDataAdapter> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Data.DataSet>, agrega dos <xref:System.Data.DataTable> instancias para el <xref:System.Data.DataSet>y, a continuación, rellena el <xref:System.Data.DataSet> utilizando el <xref:System.Data.DataSet.Load%2A> método, la recuperación de datos desde un <xref:System.Data.DataTableReader> que contiene dos conjuntos de resultados. Por último, en el ejemplo se muestra el contenido de las tablas en la ventana de consola.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> que proporciona uno o varios conjuntos de resultados.</param>
        <param name="loadOption">Valor de la enumeración <see cref="T:System.Data.LoadOption" /> que indica cómo se van a combinar las filas que ya se encuentran en las instancias de <see cref="T:System.Data.DataTable" />, incluidas en el objeto <see langword="DataSet" />, con las filas de entrada con las que comparten la misma clave principal.</param>
        <param name="tables">Matriz de cadenas de las que el método <see langword="Load" /> recupera la información sobre el nombre de tabla.</param>
        <summary>Rellena un objeto <see cref="T:System.Data.DataSet" /> de valores de un origen de datos utilizando la interfaz <see cref="T:System.Data.IDataReader" /> proporcionada, que usa una matriz de cadenas para suministrar los nombres para las tablas de <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataTable.Load%2A> método proporciona una técnica para rellenar una sola <xref:System.Data.DataTable> con datos recuperados de un <xref:System.Data.IDataReader> instancia. Este método proporciona la misma funcionalidad, pero le permite cargar varios conjuntos de resultados de una `IDataReader` en varias tablas dentro de un `DataSet`.  
  
> [!NOTE]
>  La operación de carga se producirá un error con un <xref:System.InvalidOperationException> si cualquiera de las columnas de entrada de datos de origen `reader` son columnas calculadas.  
  
 El `loadOption` parámetro le permite especificar cómo desea que los datos importados para interactuar con los datos existentes y puede ser cualquiera de los valores de la <xref:System.Data.LoadOption> enumeración. Consulte la documentación de la <xref:System.Data.DataTable.Load%2A> método para obtener más información sobre el uso de este parámetro.  
  
 El `tables` parámetro le permite especificar una matriz de nombres de tabla, que indica el orden de las tablas correspondientes a cada conjunto de resultados cargado desde el lector. El `Load` método intenta buscar una tabla dentro de la `DataSet` que coincide con el nombre se encuentra en la matriz de nombres de tabla, en orden. Si se encuentra una tabla de búsqueda de coincidencias, esa tabla se carga con el contenido del conjunto de resultados actual. Si no se encuentra ninguna tabla coincidente, se crea una tabla con el nombre proporcionado en la matriz de nombres de tabla y esquema de la tabla nueva se deduce del conjunto de resultados. Después de cada conjunto de resultados, el `Load` método continúa con el siguiente resultado establecer dentro del lector, hasta que no hay ningún conjunto de resultados.  
  
 El espacio de nombres predeterminado asociado con `DataSet`, si existe, asociado con cada uno recién creado `DataTable`. El esquema de resolución de nombres para este método es el mismo que ha seguido el <xref:System.Data.Common.DbDataAdapter.Fill%2A> método de la <xref:System.Data.Common.DbDataAdapter> clase.  
  
   
  
## Examples  
 El siguiente ejemplo de aplicación de consola crea tablas en primer lugar y carga los datos de un lector en un <xref:System.Data.DataSet>, usando la `Load` método. En el ejemplo, a continuación, agrega tablas a una <xref:System.Data.DataSet> e intenta rellenar las tablas con datos de un <xref:System.Data.DataTableReader>. En este ejemplo, dado que los parámetros pasados a la `Load` método indicar un nombre de tabla no existe, el `Load` método crea una nueva tabla para que coincida con el nombre pasado como parámetro. Una vez que se han cargado los datos, en el ejemplo se muestra el contenido de todas sus tablas en la ventana de consola.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> que proporciona uno o varios conjuntos de resultados.</param>
        <param name="loadOption">Valor de la enumeración <see cref="T:System.Data.LoadOption" /> que indica cómo se van a combinar las filas que ya se encuentran en las instancias de <see cref="T:System.Data.DataTable" />, incluidas en el objeto <see cref="T:System.Data.DataSet" />, con las filas de entrada con las que comparten la misma clave principal.</param>
        <param name="errorHandler">Delegado <see cref="T:System.Data.FillErrorEventHandler" /> al que se va a llamar cuando se produzca un error mientras se cargan los datos.</param>
        <param name="tables">Matriz de instancias de <see cref="T:System.Data.DataTable" /> de las que el método <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> recupera la información sobre el espacio de nombres y el nombre.</param>
        <summary>Rellena un objeto <see cref="T:System.Data.DataSet" /> de valores de un origen de datos utilizando la interfaz <see cref="T:System.Data.IDataReader" /> proporcionada, que usa una matriz de instancias de <see cref="T:System.Data.DataTable" /> para suministrar la información sobre el espacio de nombres y el esquema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataTable.Load%2A> método proporciona una técnica para rellenar una sola <xref:System.Data.DataTable> con datos recuperados de un <xref:System.Data.IDataReader> instancia. Este método proporciona la misma funcionalidad, pero le permite cargar varios conjuntos de resultados de una <xref:System.Data.IDataReader> en varias tablas dentro de un <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  La operación de carga se producirá un error con un <xref:System.InvalidOperationException> si cualquiera de las columnas de entrada de datos de origen `reader` son columnas calculadas.  
  
 El `loadOption` parámetro le permite especificar cómo desea que los datos importados para interactuar con los datos existentes y puede ser cualquiera de los valores de la <xref:System.Data.LoadOption> enumeración. Consulte la documentación de la <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> método para obtener más información sobre el uso de este parámetro.  
  
 El `errorHandler` parámetro es un <xref:System.Data.FillErrorEventHandler> delegado que hace referencia a un procedimiento que se llama cuando se produce un error al cargar los datos. El <xref:System.Data.FillErrorEventArgs> parámetro pasado al procedimiento proporciona propiedades que permiten recuperar información sobre el error que se ha producido, la fila actual de datos, y el <xref:System.Data.DataTable> se llena. Mediante este mecanismo de delegado, en lugar de un bloque try/catch más sencillo, le permite determinar el error, controlar la situación y continuar procesando si lo desea. El <xref:System.Data.FillErrorEventArgs> parámetro proporciona un <xref:System.Data.FillErrorEventArgs.Continue%2A> propiedad: establezca esta propiedad en `true` para indicar que ha controlado el error y desea seguir procesando; establezca la propiedad en `false` para indicar que desea detener el procesamiento. Tenga en cuenta que establecer la propiedad en `false` hace que el código que desencadena el problema para producir una excepción.  
  
 El `tables` parámetro le permite especificar una matriz de <xref:System.Data.DataTable> instancias, que indica el orden de las tablas correspondientes a cada conjunto de resultados cargado desde el lector. El <xref:System.Data.DataSet.Load%2A> método rellenos cada proporcionados <xref:System.Data.DataTable> instancia con datos de un único conjunto de resultados de la lectura de datos de origen. Después de cada conjunto de resultados, el <xref:System.Data.DataSet.Load%2A> método continúa con el siguiente resultado establecer dentro del lector, hasta que no hay ningún conjunto de resultados.  
  
 El esquema de resolución de nombres para este método es el mismo que ha seguido el <xref:System.Data.Common.DbDataAdapter.Fill%2A> método de la <xref:System.Data.Common.DbDataAdapter> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se agrega una tabla a un <xref:System.Data.DataSet>y, a continuación, intenta usar el <xref:System.Data.DataSet.Load%2A> método para cargar datos desde un <xref:System.Data.DataTableReader> que contiene un esquema incompatible. En lugar de interceptar el error, este ejemplo se usa un <xref:System.Data.FillErrorEventHandler> delegado para investigar y controlar el error. El resultado se muestra en la ventana de consola.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la información de configuración regional que se utiliza para comparar cadenas de la tabla.</summary>
        <value>
          <see cref="T:System.Globalization.CultureInfo" /> que contiene datos sobre la configuración regional del equipo del usuario. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Locale%2A> propiedad especifica la configuración regional para ordenar los que se aplica.  
  
 De forma predeterminada, establecer el <xref:System.Data.DataSet.Locale%2A> para un <xref:System.Data.DataSet> también establece la <xref:System.Data.DataSet.Locale%2A> para cada <xref:System.Data.DataTable> objeto en el que `DataSet` en el mismo valor.  
  
> [!NOTE]
>  En las columnas que contienen expresiones, el <xref:System.StringComparison.InvariantCulture> se utiliza. El <xref:System.StringComparison.CurrentCulture> se omite.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el <xref:System.Globalization.CultureInfo> para un <xref:System.Data.DataSet> e imprime el <xref:System.Globalization.CultureInfo.DisplayName%2A> y <xref:System.Globalization.CultureInfo.EnglishName%2A> propiedades.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Combina el objeto <see cref="T:System.Data.DataSet" />, el objeto <see cref="T:System.Data.DataTable" /> o la matriz de objetos <see cref="T:System.Data.DataRow" /> que se especifique en el objeto <see langword="DataSet" /> o <see langword="DataTable" /> actual.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">Matriz de objetos <see langword="DataRow" /> que se va a combinar en el <see langword="DataSet" />.</param>
        <summary>Combina una matriz de objetos <see cref="T:System.Data.DataRow" /> en el <see cref="T:System.Data.DataSet" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Merge%2A> método se usa para combinar dos <xref:System.Data.DataSet> objetos que tienen esquemas muy similares. Una combinación se usa normalmente en una aplicación cliente para incorporar los cambios más recientes desde un origen de datos en una existente <xref:System.Data.DataSet>. Esto permite que la aplicación cliente tener un actualizado <xref:System.Data.DataSet> con los datos más recientes del origen de datos.  
  
 El <xref:System.Data.DataSet.Merge%2A> normalmente se llama al método al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y, por último, actualizar los existentes <xref:System.Data.DataSet>.  
  
 En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio. En este escenario, el <xref:System.Data.DataSet.GetChanges%2A> primero se invoca el método. Ese método devuelve un segundo <xref:System.Data.DataSet> optimizado para la validación y la combinación. Este segundo <xref:System.Data.DataSet> objeto contiene solo el <xref:System.Data.DataTable> y <xref:System.Data.DataRow> objetos que se han cambiado, lo que resulta en un subconjunto del original <xref:System.Data.DataSet>. Este subconjunto normalmente es más pequeña y, por tanto, más eficaz pasar a un componente de nivel intermedio. El componente de nivel intermedio, a continuación, actualiza el origen de datos con los cambios a través de procedimientos almacenados. El nivel intermedio, a continuación, puede enviar un nuevo <xref:System.Data.DataSet> que incluya datos originales y los datos más recientes del origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos. (Por ejemplo, si el origen de datos crea automáticamente los valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <xref:System.Data.DataSet> puede volver a combinarse en original de la aplicación cliente <xref:System.Data.DataSet> con el <xref:System.Data.DataSet.Merge%2A> método.  
  
 Cuando el <xref:System.Data.DataSet.Merge%2A> llama el método, los esquemas de los dos <xref:System.Data.DataSet> se comparan objetos porque es posible que se ha cambiado. Por ejemplo, en un escenario de negocio a negocio, nuevas columnas es posible que se agregaron a un esquema XML mediante un proceso automatizado. Si el origen <xref:System.Data.DataSet> contiene elementos de esquema (agregado <xref:System.Data.DataColumn> objetos) que faltan en el destino, se pueden agregar los elementos de esquema para el destino estableciendo el `missingSchemaAction` argumento `MissingSchemaAction.Add`. En ese caso, el combinada <xref:System.Data.DataSet> contiene el esquema se ha agregado y los datos.  
  
 Después de combinar los esquemas, se combinan los datos.  
  
 Al combinar un nuevo origen <xref:System.Data.DataSet> en el destino, cualquier fila de origen con un <xref:System.Data.DataRowState> valor `Unchanged`, `Modified`, o `Deleted` coinciden con las filas de destino con los mismos valores de clave principales. Filas de origen con un <xref:System.Data.DataRowState> valor `Added` se hacen coincidir con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.  
  
 Durante una combinación, se deshabilitan las restricciones. Si no se puede habilitar las restricciones al final de una combinación, un <xref:System.Data.ConstraintException> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones. En este caso, el <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad está establecida en `false`, y se marcan todas las filas que no son válidas en error. Los errores deben resolverse antes de intentar restablecer la <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> cuyos datos y esquema se van a combinar.</param>
        <summary>Combina un objeto <see cref="T:System.Data.DataSet" /> especificado y su esquema en el objeto <see langword="DataSet" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Merge%2A> método se usa para combinar dos <xref:System.Data.DataSet> objetos que tienen esquemas muy similares. Una combinación se usa normalmente en una aplicación cliente para incorporar los cambios más recientes desde un origen de datos en una existente <xref:System.Data.DataSet>. Esto permite que la aplicación cliente tener un actualizado <xref:System.Data.DataSet> con los datos más recientes del origen de datos.  
  
 El <xref:System.Data.DataSet.Merge%2A> normalmente se llama al método al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y, por último, actualizar los existentes <xref:System.Data.DataSet>.  
  
 En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio. En este escenario, el <xref:System.Data.DataSet.GetChanges%2A> primero se invoca el método. Ese método devuelve un segundo <xref:System.Data.DataSet> optimizado para la validación y la combinación. Este segundo <xref:System.Data.DataSet> objeto contiene solo el <xref:System.Data.DataTable> y <xref:System.Data.DataRow> objetos que se han cambiado, lo que resulta en un subconjunto del original <xref:System.Data.DataSet>. Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio. El componente de nivel intermedio, a continuación, actualiza el origen de datos con los cambios a través de procedimientos almacenados. El nivel intermedio, a continuación, puede enviar un nuevo <xref:System.Data.DataSet> que incluya datos originales y los datos más recientes del origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos. (Por ejemplo, si el origen de datos crea automáticamente los valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <xref:System.Data.DataSet> puede volver a combinarse en original de la aplicación cliente <xref:System.Data.DataSet> con el <xref:System.Data.DataSet.Merge%2A> método.  
  
 Cuando el <xref:System.Data.DataSet.Merge%2A> llama el método, los esquemas de los dos <xref:System.Data.DataSet> se comparan objetos porque es posible que se ha cambiado. Por ejemplo, en un escenario de negocio a negocio, nuevas columnas es posible que se agregaron a un esquema XML mediante un proceso automatizado. Si el origen <xref:System.Data.DataSet> contiene elementos de esquema (agregado <xref:System.Data.DataColumn> objetos) que faltan en el destino, se pueden agregar los elementos de esquema para el destino estableciendo el `missingSchemaAction` argumento `MissingSchemaAction.Add`. En ese caso, el combinada <xref:System.Data.DataSet> contiene el esquema se ha agregado y los datos.  
  
 Después de combinar los esquemas, se combinan los datos.  
  
 Al combinar un nuevo origen <xref:System.Data.DataSet> en el destino, cualquier fila de origen con un <xref:System.Data.DataRowState> valor `Unchanged`, `Modified`, o `Deleted` coinciden con las filas de destino con los mismos valores de clave principales. Filas de origen con un `DataRowState` valor `Added` se hacen coincidir con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.  
  
 Durante una combinación, se deshabilitan las restricciones. Si no se puede habilitar las restricciones al final de la combinación, un <xref:System.Data.ConstraintException> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones. En este caso, el <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad está establecida en `false`, y se marcan todas las filas que no son válidas en error. Los errores deben resolverse antes de intentar restablecer la <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Data.DataSet.GetChanges%2A>, actualización, y <xref:System.Data.DataSet.Merge%2A> métodos en un <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">No se pueden habilitar una o más restricciones.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataSet" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> cuyos datos y esquema se van a combinar.</param>
        <summary>Combina un objeto <see cref="T:System.Data.DataTable" /> especificado y su esquema en el objeto <see cref="T:System.Data.DataSet" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Merge%2A> método se usa para combinar dos <xref:System.Data.DataSet> objetos que tienen esquemas muy similares. Una combinación se usa normalmente en una aplicación cliente para incorporar los cambios más recientes desde un origen de datos en una existente <xref:System.Data.DataSet>. Esto permite que la aplicación cliente tener un actualizado <xref:System.Data.DataSet> con los datos más recientes del origen de datos.  
  
 El <xref:System.Data.DataSet.Merge%2A> normalmente se llama al método al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y, por último, actualizar los existentes <xref:System.Data.DataSet>.  
  
 En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio. En este escenario, el <xref:System.Data.DataSet.GetChanges%2A> primero se invoca el método. Ese método devuelve un segundo <xref:System.Data.DataSet> optimizado para la validación y la combinación. Este segundo <xref:System.Data.DataSet> objeto contiene solo el <xref:System.Data.DataTable> y <xref:System.Data.DataRow> objetos que se han cambiado, lo que resulta en un subconjunto del original <xref:System.Data.DataSet>. Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio. El componente de nivel intermedio, a continuación, actualiza el origen de datos con los cambios a través de procedimientos almacenados. El nivel intermedio, a continuación, puede enviar un nuevo <xref:System.Data.DataSet> que incluya datos originales y los datos más recientes del origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos. (Por ejemplo, si el origen de datos crea automáticamente los valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <xref:System.Data.DataSet> puede volver a combinarse en original de la aplicación cliente <xref:System.Data.DataSet> con el <xref:System.Data.DataSet.Merge%2A> método.  
  
 Cuando el <xref:System.Data.DataSet.Merge%2A> llama el método, los esquemas de los dos <xref:System.Data.DataSet> se comparan objetos porque es posible que se ha cambiado. Por ejemplo, en un escenario de negocio a negocio, nuevas columnas es posible que se agregaron a un esquema XML mediante un proceso automatizado. Si el origen <xref:System.Data.DataSet> contiene elementos de esquema (agregado <xref:System.Data.DataColumn> objetos) que faltan en el destino, se pueden agregar los elementos de esquema para el destino estableciendo el `missingSchemaAction` argumento `MissingSchemaAction.Add`. En ese caso, el combinada <xref:System.Data.DataSet> contiene el esquema se ha agregado y los datos.  
  
 Después de combinar los esquemas, se combinan los datos.  
  
 Al combinar un nuevo origen <xref:System.Data.DataSet> en el destino, cualquier fila de origen con un <xref:System.Data.DataRowState> valor `Unchanged`, `Modified`, o `Deleted` coinciden con las filas de destino con los mismos valores de clave principales. Filas de origen con un `DataRowState` valor `Added` se hacen coincidir con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.  
  
 Durante una combinación, se deshabilitan las restricciones. Si no se puede habilitar las restricciones al final de la combinación, un <xref:System.Data.ConstraintException> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones. En este caso, el <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad está establecida en `false`, y se marcan todas las filas que no son válidas en error. Los errores deben resolverse antes de intentar restablecer la <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una sencilla <xref:System.Data.DataSet> con una tabla, dos columnas y diez filas. Un segundo <xref:System.Data.DataTable> se crea que es idéntico al primero. Se agregan dos filas a la segunda tabla, que, a continuación, se combina en el <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="table" /> es <see langword="null" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> cuyos datos y esquema se van a combinar.</param>
        <param name="preserveChanges">
          <see langword="true" /> para conservar los cambios realizados en el objeto <see langword="DataSet" /> actual; de lo contrario, <see langword="false" />.</param>
        <summary>Combina un <see cref="T:System.Data.DataSet" /> y su esquema en el <see langword="DataSet" /> actual, conservando o descartando cualquier cambio efectuado en este <see langword="DataSet" /> de acuerdo con el argumento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Merge%2A> método se usa para combinar dos <xref:System.Data.DataSet> objetos que tienen esquemas muy similares. Una combinación se usa normalmente en una aplicación cliente para incorporar los cambios más recientes desde un origen de datos en una existente <xref:System.Data.DataSet>. Esto permite que la aplicación cliente tener un actualizado <xref:System.Data.DataSet> con los datos más recientes del origen de datos.  
  
 El <xref:System.Data.DataSet.Merge%2A> normalmente se llama al método al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y, por último, actualizar los existentes <xref:System.Data.DataSet>.  
  
 En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio. En este escenario, el <xref:System.Data.DataSet.GetChanges%2A> primero se invoca el método. Ese método devuelve un segundo <xref:System.Data.DataSet> optimizado para la validación y la combinación. Este segundo <xref:System.Data.DataSet> objeto contiene solo el <xref:System.Data.DataTable> y <xref:System.Data.DataRow> objetos que se han cambiado, lo que resulta en un subconjunto del original <xref:System.Data.DataSet>. Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio. El componente de nivel intermedio, a continuación, actualiza el origen de datos con los cambios a través de procedimientos almacenados. El nivel intermedio, a continuación, puede enviar un nuevo <xref:System.Data.DataSet> que incluya datos originales y los datos más recientes del origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos. (Por ejemplo, si el origen de datos crea automáticamente los valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <xref:System.Data.DataSet> puede volver a combinarse en original de la aplicación cliente <xref:System.Data.DataSet> con el <xref:System.Data.DataSet.Merge%2A> método.  
  
 Cuando el <xref:System.Data.DataSet.Merge%2A> llama el método, los esquemas de los dos <xref:System.Data.DataSet> se comparan objetos porque es posible que se ha cambiado. Por ejemplo, en un escenario de negocio a negocio, nuevas columnas es posible que se agregaron a un esquema XML mediante un proceso automatizado. Si el origen <xref:System.Data.DataSet> contiene elementos de esquema (agregado <xref:System.Data.DataColumn> objetos) que faltan en el destino, se pueden agregar los elementos de esquema para el destino estableciendo el `missingSchemaAction` argumento `MissingSchemaAction.Add`. En ese caso, el combinada <xref:System.Data.DataSet> contiene el esquema se ha agregado y los datos.  
  
 Después de combinar los esquemas, se combinan los datos.  
  
 Al combinar un nuevo origen <xref:System.Data.DataSet> en el destino, cualquier fila de origen con un <xref:System.Data.DataRowState> valor `Unchanged`, `Modified`, o `Deleted` coinciden con las filas de destino con los mismos valores de clave principales. Filas de origen con un `DataRowState` valor `Added` se hacen coincidir con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.  
  
 Durante una combinación, se deshabilitan las restricciones. Si no se puede habilitar las restricciones al final de la combinación, un <xref:System.Data.ConstraintException> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones. En este caso, el <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad está establecida en `false`, y se marcan todas las filas que no son válidas en error. Los errores deben resolverse antes de intentar restablecer la <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una sencilla <xref:System.Data.DataSet> con una tabla, dos columnas y diez filas. Después de agregar diez filas, se cambian los dos valores y se agrega una fila. Se crea un subconjunto de los datos modificados utilizando el <xref:System.Data.DataSet.GetChanges%2A> método. Después de reconciliar los errores, se combinan los datos de subconjunto en el original <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">Matriz de objetos <see cref="T:System.Data.DataRow" /> que se va a combinar en el <see langword="DataSet" />.</param>
        <param name="preserveChanges">
          <see langword="true" /> para conservar los cambios realizados en <see langword="DataSet" />; de lo contrario, <see langword="false" />.</param>
        <param name="missingSchemaAction">Uno de los valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Combina una matriz de objetos <see cref="T:System.Data.DataRow" /> en el <see cref="T:System.Data.DataSet" /> actual, conservando o descartando los cambios efectuados en el <see langword="DataSet" /> y controlando un esquema incompatible de acuerdo con los argumentos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Merge%2A> método se usa para combinar dos <xref:System.Data.DataSet> objetos que tienen esquemas muy similares. Una combinación se usa normalmente en una aplicación cliente para incorporar los cambios más recientes desde un origen de datos en una existente <xref:System.Data.DataSet>. Esto permite que la aplicación cliente tener un actualizado <xref:System.Data.DataSet> con los datos más recientes del origen de datos.  
  
 El <xref:System.Data.DataSet.Merge%2A> normalmente se llama al método al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y, por último, actualizar los existentes <xref:System.Data.DataSet>.  
  
 En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio. En este escenario, el <xref:System.Data.DataSet.GetChanges%2A> primero se invoca el método. Ese método devuelve un segundo <xref:System.Data.DataSet> optimizado para la validación y la combinación. Este segundo <xref:System.Data.DataSet> objeto contiene solo el <xref:System.Data.DataTable> y <xref:System.Data.DataRow> objetos que se han cambiado, lo que resulta en un subconjunto del original <xref:System.Data.DataSet>. Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio. El componente de nivel intermedio, a continuación, actualiza el origen de datos con los cambios a través de procedimientos almacenados. El nivel intermedio, a continuación, puede enviar un nuevo <xref:System.Data.DataSet> que incluya datos originales y los datos más recientes del origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos. (Por ejemplo, si el origen de datos crea automáticamente los valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <xref:System.Data.DataSet> puede volver a combinarse en original de la aplicación cliente <xref:System.Data.DataSet> con el <xref:System.Data.DataSet.Merge%2A> método.  
  
 Para facilitar la explicación de la <xref:System.Data.DataSet.Merge%2A> método, usamos "target" para indicar que el actual <xref:System.Data.DataSet>y "origen" nombre de la segunda (parámetro) a <xref:System.Data.DataSet>. El destino <xref:System.Data.DataSet> se denomina así porque es el objeto en el que se produce una acción (la combinación). El segundo <xref:System.Data.DataSet> se denomina un "origen" porque la información que contiene no cambia, pero en su lugar, se combina con la actual <xref:System.Data.DataSet>.  
  
 Cuando el <xref:System.Data.DataSet.Merge%2A> llama el método, los esquemas de los dos <xref:System.Data.DataSet> se comparan objetos porque es posible que se ha cambiado. Por ejemplo, en un escenario de negocio a negocio, nuevas columnas es posible que se agregaron a un esquema XML mediante un proceso automatizado. Si el origen <xref:System.Data.DataSet> contiene elementos de esquema (agregado <xref:System.Data.DataColumn> objetos) que faltan en el destino, se pueden agregar los elementos de esquema para el destino estableciendo el `missingSchemaAction` argumento `MissingSchemaAction.Add`. En ese caso, el combinada <xref:System.Data.DataSet> contiene el esquema se ha agregado y los datos.  
  
 Después de combinar los esquemas, se combinan los datos.  
  
 Al combinar un nuevo origen <xref:System.Data.DataSet> en el destino, cualquier fila de origen con un <xref:System.Data.DataRowState> valor `Unchanged`, `Modified`, o `Deleted` coinciden con las filas de destino con los mismos valores de clave principales. Filas de origen con un `DataRowState` valor `Added` se hacen coincidir con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.  
  
 Durante una combinación, se deshabilitan las restricciones. Si no se puede habilitar las restricciones al final de la combinación, un <xref:System.Data.ConstraintException> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones. En este caso, el <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad está establecida en `false`, y se marcan todas las filas que no son válidas en error. Los errores deben resolverse antes de intentar restablecer la <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> cuyos datos y esquema se van a combinar.</param>
        <param name="preserveChanges">
          <see langword="true" /> para conservar los cambios realizados en el objeto <see langword="DataSet" /> actual; de lo contrario, <see langword="false" />.</param>
        <param name="missingSchemaAction">Uno de los valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Combina un <see cref="T:System.Data.DataSet" /> especificado y su esquema con el <see langword="DataSet" /> actual, conservando o descartando los cambios efectuados en el <see langword="DataSet" /> actual y controlando un esquema incompatible de acuerdo con los argumentos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Merge%2A> método se usa para combinar dos <xref:System.Data.DataSet> objetos que tienen esquemas muy similares. Una combinación se usa normalmente en una aplicación cliente para incorporar los cambios más recientes desde un origen de datos en una existente <xref:System.Data.DataSet>. Esto permite que la aplicación cliente tener un actualizado <xref:System.Data.DataSet> con los datos más recientes del origen de datos.  
  
 El <xref:System.Data.DataSet.Merge%2A> normalmente se llama al método al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y, por último, actualizar los existentes <xref:System.Data.DataSet>.  
  
 En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio. En este escenario, el <xref:System.Data.DataSet.GetChanges%2A> primero se invoca el método. Ese método devuelve un segundo <xref:System.Data.DataSet> optimizado para la validación y la combinación. Este segundo <xref:System.Data.DataSet> objeto contiene solo el <xref:System.Data.DataTable> y <xref:System.Data.DataRow> objetos que se han cambiado, lo que resulta en un subconjunto del original <xref:System.Data.DataSet>. Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio. El componente de nivel intermedio, a continuación, actualiza el origen de datos con los cambios a través de procedimientos almacenados. El nivel intermedio, a continuación, puede enviar un nuevo <xref:System.Data.DataSet> que incluya datos originales y los datos más recientes del origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos. (Por ejemplo, si el origen de datos crea automáticamente los valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <xref:System.Data.DataSet> puede volver a combinarse en original de la aplicación cliente <xref:System.Data.DataSet> con el <xref:System.Data.DataSet.Merge%2A> método.  
  
 Para facilitar la explicación de la <xref:System.Data.DataSet.Merge%2A> método, usamos "target" para indicar que el actual <xref:System.Data.DataSet>y "origen" nombre de la segunda (parámetro) a <xref:System.Data.DataSet>. El destino <xref:System.Data.DataSet> se denomina así porque es el objeto en el que se produce una acción (la combinación). El segundo <xref:System.Data.DataSet> se denomina un "origen" porque la información que contiene no cambia, pero en su lugar, se combina con la actual <xref:System.Data.DataSet>.  
  
 Cuando el <xref:System.Data.DataSet.Merge%2A> llama el método, los esquemas de los dos <xref:System.Data.DataSet> se comparan objetos porque es posible que se ha cambiado. Por ejemplo, en un escenario de negocio a negocio, nuevas columnas es posible que se agregaron a un esquema XML mediante un proceso automatizado. Si el origen <xref:System.Data.DataSet> contiene elementos de esquema (agregado <xref:System.Data.DataColumn> objetos) que faltan en el destino, se pueden agregar los elementos de esquema para el destino estableciendo el `missingSchemaAction` argumento `MissingSchemaAction.Add`. En ese caso, el combinada <xref:System.Data.DataSet> contiene el esquema se ha agregado y los datos.  
  
 Después de combinar los esquemas, se combinan los datos.  
  
 Al combinar un nuevo origen <xref:System.Data.DataSet> en el destino, cualquier fila de origen con un <xref:System.Data.DataRowState> valor `Unchanged`, `Modified`, o `Deleted` coinciden con las filas de destino con los mismos valores de clave principales. Filas de origen con un `DataRowState` valor `Added` se hacen coincidir con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.  
  
 Durante una combinación, se deshabilitan las restricciones. Si no se puede habilitar las restricciones al final de la combinación, un <xref:System.Data.ConstraintException> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones. En este caso, el <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad está establecida en `false`, y se marcan todas las filas que no son válidas en error. Los errores deben resolverse antes de intentar restablecer la <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una sencilla <xref:System.Data.DataSet> con una tabla, dos columnas y diez filas. Se cambian los dos valores y se agrega una fila. Se crea un subconjunto de los datos modificados utilizando el <xref:System.Data.DataSet.GetChanges%2A> método. Después de reconciliar los errores, se agrega una nueva columna al subconjunto, cambiar el esquema. Cuando el <xref:System.Data.DataSet.Merge%2A> se llama al método con el `missingSchemaAction` establecido en `MissingSchemaAction.Add`, la nueva columna se agrega a la versión original <xref:System.Data.DataSet> esquema del objeto.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataSet" /> es <see langword="null" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">
          <see langword="DataTable" /> cuyos datos y esquema se van a combinar.</param>
        <param name="preserveChanges">Uno de los valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <param name="missingSchemaAction">
          <see langword="true" /> para conservar los cambios realizados en <see langword="DataSet" />; de lo contrario, <see langword="false" />.</param>
        <summary>Combina un <see cref="T:System.Data.DataTable" /> especificado y su esquema en el <see langword="DataSet" /> actual, conservando o descartando los cambios efectuados en el <see langword="DataSet" /> y controlando un esquema incompatible de acuerdo con los argumentos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Merge%2A> método se usa para combinar dos <xref:System.Data.DataSet> objetos que tienen esquemas muy similares. Una combinación se usa normalmente en una aplicación cliente para incorporar los cambios más recientes desde un origen de datos en una existente <xref:System.Data.DataSet>. Esto permite que la aplicación cliente tener un actualizado <xref:System.Data.DataSet> con los datos más recientes del origen de datos.  
  
 El <xref:System.Data.DataSet.Merge%2A> normalmente se llama al método al final de una serie de procedimientos que incluyen la validación de cambios, reconciliar los errores, actualizar el origen de datos con los cambios y, por último, actualizar los existentes <xref:System.Data.DataSet>.  
  
 En una aplicación cliente, es habitual tener un solo botón en el que el usuario puede hacer clic para recopila los datos modificados y validarlos antes de enviarlo a un componente de nivel intermedio. En este escenario, el <xref:System.Data.DataSet.GetChanges%2A> primero se invoca el método. Ese método devuelve un segundo <xref:System.Data.DataSet> optimizado para la validación y la combinación. Este segundo <xref:System.Data.DataSet> objeto contiene solo el <xref:System.Data.DataTable> y <xref:System.Data.DataRow> objetos que se han cambiado, lo que resulta en un subconjunto del original <xref:System.Data.DataSet>. Este subconjunto normalmente es más pequeño y, por tanto, más eficazmente pasan a un componente de nivel intermedio. El componente de nivel intermedio, a continuación, actualiza el origen de datos con los cambios a través de procedimientos almacenados. El nivel intermedio, a continuación, puede enviar un nuevo <xref:System.Data.DataSet> que incluya datos originales y los datos más recientes del origen de datos (ejecutando de nuevo la consulta original), o bien puede volver a enviar el subconjunto con los cambios que se realizaron a él desde el origen de datos. (Por ejemplo, si el origen de datos crea automáticamente los valores de clave principales única, estos valores se pueden propagar a la aplicación cliente.) En cualquier caso, el valor devuelto <xref:System.Data.DataSet> puede volver a combinarse en original de la aplicación cliente <xref:System.Data.DataSet> con el <xref:System.Data.DataSet.Merge%2A> método.  
  
 Cuando el <xref:System.Data.DataSet.Merge%2A> llama el método, los esquemas de los dos <xref:System.Data.DataSet> se comparan objetos porque es posible que se ha cambiado. Por ejemplo, en un escenario de negocio a negocio, nuevas columnas es posible que se agregaron a un esquema XML mediante un proceso automatizado. Si el origen <xref:System.Data.DataSet> contiene elementos de esquema (agregado <xref:System.Data.DataColumn> objetos) que faltan en el destino, se pueden agregar los elementos de esquema para el destino estableciendo el `missingSchemaAction` argumento `MissingSchemaAction.Add`. En ese caso, el combinada <xref:System.Data.DataSet> contiene el esquema se ha agregado y los datos.  
  
 Después de combinar los esquemas, se combinan los datos.  
  
 Al combinar un nuevo origen <xref:System.Data.DataSet> en el destino, cualquier fila de origen con un <xref:System.Data.DataRowState> valor `Unchanged`, `Modified`, o `Deleted` coinciden con las filas de destino con los mismos valores de clave principales. Filas de origen con un `DataRowState` valor `Added` se hacen coincidir con las nuevas filas de destino con los mismos valores de clave principales que las nuevas filas de origen.  
  
 Durante una combinación, se deshabilitan las restricciones. Si no se puede habilitar las restricciones al final de la combinación, un <xref:System.Data.ConstraintException> se genera y se retienen los datos combinados mientras estén deshabilitadas las restricciones. En este caso, el <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad está establecida en `false`, y se marcan todas las filas que no son válidas en error. Los errores deben resolverse antes de intentar restablecer la <xref:System.Data.DataSet.EnforceConstraints%2A> propiedad `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una sencilla <xref:System.Data.DataSet> con una tabla, dos columnas y diez filas. Un segundo <xref:System.Data.DataTable> se crea que es casi idéntico al primero, salvo que un nuevo `DataColumn` se agrega a la tabla. Se agregan dos filas a la segunda tabla, que, a continuación, se combina en el <xref:System.Data.DataSet> con el `preserveChanges` establecido en `false`y el `missingSchemaAction` establecido en `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataSet" /> es <see langword="null" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetMergeFailedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando unos <see cref="T:System.Data.DataRow" /> de origen y de destino tienen el mismo valor de clave principal y <see cref="P:System.Data.DataSet.EnforceConstraints" /> se establece en true.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de cómo controlar eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Data.DataSet.MergeFailed> eventos.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el espacio de nombres del objeto <see cref="T:System.Data.DataSet" />.</summary>
        <value>Espacio de nombres de <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Namespace%2A> propiedad se utiliza al documentan de lectura y escritura de un documento XML en el <xref:System.Data.DataSet> utilizando el <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, o <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos.  
  
 El espacio de nombres de un documento XML se utiliza para definir el ámbito de atributos y elementos al leerlas en XML una <xref:System.Data.DataSet>. Por ejemplo, si un <xref:System.Data.DataSet> contiene un esquema que ha leído un documento con el espacio de nombres "myCompany" y se intenta leer los datos solo desde un documento con un espacio de nombres diferente, se omite cualquier dato que no corresponden al esquema existente.  
  
   
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Data.DataSet.Prefix%2A> antes de llamar a la <xref:System.Data.DataSet.ReadXml%2A> método.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El espacio de nombres ya tiene datos.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Objeto <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener información general, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> método.</para>
        </block>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">Objeto <see cref="T:System.Data.DataRelation" /> que se va a quitar.</param>
        <summary>Se produce cuando se quita un objeto <see cref="T:System.Data.DataRelation" /> de un <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe reemplazarse por las subclases para restringir las tablas que se va a quitar  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Objeto <see cref="T:System.Data.DataTable" /> que se va a quitar.</param>
        <summary>Se produce cuando se quita un <see cref="T:System.Data.DataTable" /> de un <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por las subclases para restringir las tablas que se quite.  
  
   
  
## Examples  
 El ejemplo siguiente muestra una clase derivada de la <xref:System.Data.DataSet> con el <xref:System.Data.DataSet.OnRemoveTable%2A> método reemplazado.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetPrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un prefijo XML que crea alias para el espacio de nombres del objeto <see cref="T:System.Data.DataSet" />.</summary>
        <value>Prefijo XML para el espacio de nombres de <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.Prefix%2A> propiedad se utiliza a lo largo de un documento XML para identificar los elementos que pertenecen al espacio de nombres de los <xref:System.Data.DataSet> objeto (como lo establece el <xref:System.Data.DataSet.Namespace%2A> propiedad).  
  
   
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Data.DataSet.Prefix%2A> antes de llamar a la <xref:System.Data.DataSet.ReadXml%2A> método.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad que se va a cambiar.</param>
        <summary>Envía una notificación que indica que se va a cambiar la propiedad especificada de <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee esquema y datos XML en el objeto <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Objeto que deriva de <see cref="T:System.IO.Stream" />.</param>
        <summary>Lee los datos y el esquema XML en el objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.IO.Stream" /> especificado.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> utilizado para leer los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.ReadXml%2A> método proporciona una manera de leer datos, o los datos y el esquema en un <xref:System.Data.DataSet> desde un documento XML, mientras que el <xref:System.Data.DataSet.ReadXmlSchema%2A> método sólo lee el esquema. Para leer los datos y el esquema, use uno de los `ReadXML` sobrecargas que incluye el `mode` parámetro y establezca su valor en `ReadSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.WriteXml%2A> y <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para escribir datos XML, o el esquema y los datos desde el `DataSet`, utilice el `WriteXml` método. Para escribir únicamente el esquema, utilice el `WriteXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si se especifica un esquema en línea, el esquema en línea se usa para extender la estructura relacional existente antes de cargar los datos. Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con diferentes tipos de datos) se produce una excepción.  
  
 Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML. Si no se pueden ampliar el esquema por inferencia para exponer todos los datos, se produce una excepción.  
  
> [!NOTE]
>  El `DataSet` no asocia un elemento XML con sus correspondientes `DataColumn` o `DataTable` cuando son caracteres de escape los caracteres XML legales como ("_") en el XML serializado. El `DataSet` sólo escapes de caracteres XML no válidos en nombres de elementos XML y, por tanto, solo puede usar el mismo. Cuando se escapan los caracteres válidos en nombre del elemento XML, el elemento se omite durante el procesamiento.  
  
 Si el esquema XML para un <xref:System.Data.DataSet> incluye `targetNamespace`, no se pueden leer los datos y que produzcan excepciones al llamar a <xref:System.Data.DataSet.ReadXml%2A> para cargar el <xref:System.Data.DataSet> con XML que contenga elementos con un espacio de nombres sin calificación. Para leer elementos incompletos, establezca `elementFormDefault` igual a "qualified" en el esquema XML, como se muestra en el ejemplo siguiente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
   
  
## Examples  
 El ejemplo siguiente crea primero una sencilla <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, dos columnas y diez filas. El <xref:System.Data.DataSet> esquema y los datos se escriben en el disco mediante la invocación del <xref:System.Data.DataSet.WriteXml%2A> método. Un segundo <xref:System.Data.DataSet> se crea y <xref:System.Data.DataSet.ReadXml%2A> método se utiliza para llenarlo con datos y esquema.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="TextReader" /> desde el que se van a leer el esquema y los datos.</param>
        <summary>Lee los datos y el esquema XML en el objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> utilizado para leer los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.ReadXml%2A> método proporciona una manera de leer datos, o los datos y el esquema en un <xref:System.Data.DataSet> desde un documento XML, mientras que el <xref:System.Data.DataSet.ReadXmlSchema%2A> método sólo lee el esquema. Para leer los datos y el esquema, use uno de los `ReadXML` sobrecargas que incluye el `mode` parámetro y establezca su valor en `ReadSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.WriteXml%2A> y <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para escribir datos XML, o el esquema y los datos desde el `DataSet`, utilice el `WriteXml` método. Para escribir únicamente el esquema, utilice el `WriteXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si se especifica un esquema en línea, el esquema en línea se usa para extender la estructura relacional existente antes de cargar los datos. Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con diferentes tipos de datos) se produce una excepción.  
  
 Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML. Si no se pueden ampliar el esquema por inferencia para exponer todos los datos, se produce una excepción.  
  
> [!NOTE]
>  El `DataSet` no asocia un elemento XML con sus correspondientes `DataColumn` o `DataTable` cuando son caracteres de escape los caracteres XML legales como ("_") en el XML serializado. El `DataSet` sólo escapes de caracteres XML no válidos en nombres de elementos XML y, por tanto, solo puede usar el mismo. Cuando se escapan los caracteres válidos en nombre del elemento XML, el elemento se omite durante el procesamiento.  
  
 Si el esquema XML para un <xref:System.Data.DataSet> incluye `targetNamespace`, no se pueden leer los datos y que produzcan excepciones al llamar a <xref:System.Data.DataSet.ReadXml%2A> para cargar el <xref:System.Data.DataSet> con XML que contenga elementos con un espacio de nombres sin calificación. Para leer elementos incompletos, establezca `elementFormDefault` igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Las clases que heredan de la <xref:System.IO.TextReader> clase incluir la <xref:System.IO.StreamReader> y <xref:System.IO.StringReader> clases.  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
   
  
## Examples  
 El ejemplo siguiente crea primero una sencilla <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, dos columnas y diez filas. El <xref:System.Data.DataSet> esquema y los datos se escriben en el disco mediante la invocación del <xref:System.Data.DataSet.WriteXml%2A> método. Un segundo <xref:System.Data.DataSet> se crea y <xref:System.Data.DataSet.ReadXml%2A> método se utiliza para llenarlo con datos y esquema.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo (incluida la ruta) desde el que se va a leer.</param>
        <summary>Lee el esquema y los datos XML del <see cref="T:System.Data.DataSet" /> mediante el archivo especificado.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilizado para leer los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.ReadXml%2A> método proporciona una manera de leer datos, o los datos y el esquema en un <xref:System.Data.DataSet> desde un documento XML, mientras que el <xref:System.Data.DataSet.ReadXmlSchema%2A> método sólo lee el esquema. Para leer los datos y el esquema, use uno de los `ReadXML` sobrecargas que incluye el `mode` parámetro y establezca su valor en `ReadSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.WriteXml%2A> y <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para escribir datos XML, o el esquema y los datos desde el `DataSet`, utilice el `WriteXml` método. Para escribir únicamente el esquema, utilice el `WriteXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si se especifica un esquema en línea, el esquema en línea se usa para extender la estructura relacional existente antes de cargar los datos. Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con diferentes tipos de datos) se produce una excepción.  
  
 Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML. Si no se pueden ampliar el esquema por inferencia para exponer todos los datos, se produce una excepción.  
  
> [!NOTE]
>  El `DataSet` no asocia un elemento XML con sus correspondientes `DataColumn` o `DataTable` cuando son caracteres de escape los caracteres XML legales como ("_") en el XML serializado. El `DataSet` sólo escapes de caracteres XML no válidos en nombres de elementos XML y, por tanto, solo puede usar el mismo. Cuando se escapan los caracteres válidos en nombre del elemento XML, el elemento se omite durante el procesamiento.  
  
 Si el esquema XML para un <xref:System.Data.DataSet> incluye un `targetNamespace`, no se pueden leer los datos y que produzcan excepciones al llamar a <xref:System.Data.DataSet.ReadXml%2A> para cargar el <xref:System.Data.DataSet> con XML que contenga elementos con un espacio de nombres sin calificación. Para leer elementos incompletos, establezca `elementFormDefault` igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
   
  
## Examples  
 El ejemplo siguiente crea primero una sencilla <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, dos columnas y diez filas. El <xref:System.Data.DataSet> esquema y los datos se escriben en el disco mediante la invocación del <xref:System.Data.DataSet.WriteXml%2A> método. Un segundo <xref:System.Data.DataSet> se crea y <xref:System.Data.DataSet.ReadXml%2A> método se utiliza para llenarlo con datos y esquema.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> no está establecido en <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Objeto <see cref="T:System.Xml.XmlReader" /> desde el que se va a leer.</param>
        <summary>Lee los datos y el esquema XML en el objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.Xml.XmlReader" /> especificado.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilizado para leer los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.ReadXml%2A> método proporciona una manera de leer datos, o los datos y el esquema en un <xref:System.Data.DataSet> desde un documento XML, mientras que el <xref:System.Data.DataSet.ReadXmlSchema%2A> método sólo lee el esquema. Para leer los datos y el esquema, use uno de los `ReadXML` sobrecargas que incluye el `mode` parámetro y establezca su valor en `ReadSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.WriteXml%2A> y <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para escribir datos XML, o el esquema y los datos desde el `DataSet`, utilice el `WriteXml` método. Para escribir únicamente el esquema, utilice el `WriteXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si se especifica un esquema en línea, el esquema en línea se usa para extender la estructura relacional existente antes de cargar los datos. Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con diferentes tipos de datos) se produce una excepción.  
  
 Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML. Si no se pueden ampliar el esquema por inferencia para exponer todos los datos, se produce una excepción.  
  
> [!NOTE]
>  El `DataSet` no asocia un elemento XML con sus correspondientes `DataColumn` o `DataTable` cuando son caracteres de escape los caracteres XML legales como ("_") en el XML serializado. El `DataSet` sólo escapes de caracteres XML no válidos en nombres de elementos XML y, por tanto, solo puede usar el mismo. Cuando se escapan los caracteres válidos en nombre del elemento XML, el elemento se omite durante el procesamiento.  
  
 Si el esquema XML para un <xref:System.Data.DataSet> incluye un `targetNamespace`, no se pueden leer los datos y que produzcan excepciones al llamar a <xref:System.Data.DataSet.ReadXml%2A> para cargar el <xref:System.Data.DataSet> con XML que contenga elementos con un espacio de nombres sin calificación. Para leer elementos incompletos, establezca `elementFormDefault` igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> hereda de <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
   
  
## Examples  
 El ejemplo siguiente crea primero una sencilla <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, dos columnas y diez filas. El <xref:System.Data.DataSet> esquema y los datos se escriben en el disco mediante la invocación del <xref:System.Data.DataSet.WriteXml%2A> método. Un segundo <xref:System.Data.DataSet> se crea y <xref:System.Data.DataSet.ReadXml%2A> método se utiliza para llenarlo con datos y esquema.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">Objeto <see cref="T:System.IO.Stream" /> desde el que se va a leer.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lee el esquema y los datos XML del objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.IO.Stream" /> y la enumeración <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilizado para leer los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.ReadXml%2A> método proporciona una manera de leer datos, o los datos y el esquema en un <xref:System.Data.DataSet> desde un documento XML, mientras que el <xref:System.Data.DataSet.ReadXmlSchema%2A> método sólo lee el esquema. Para leer los datos y el esquema, use uno de los `ReadXML` sobrecargas que incluye el `mode` parámetro y establezca su valor en `ReadSchema`.  
  
 Lo mismo puede decirse de la <xref:System.Data.DataSet.WriteXml%2A> y <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para escribir datos XML, o el esquema y los datos desde el `DataSet`, utilice el `WriteXml` método. Para escribir únicamente el esquema, utilice el `WriteXmlSchema` método.  
  
> [!NOTE]
>  Cuando usas <xref:System.Data.DataSet.ReadXml%2A> y establecer <xref:System.Data.XmlReadMode> a `Diffgram`, el contenido del destino `DataSet` y original `DataSet` puede diferir dependiendo de cómo el diffgram se genera y se procesan. Para obtener más información sobre diffgrams, vea [DiffGrams](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si se especifica un esquema en línea, el esquema en línea se usa para extender la estructura relacional existente antes de cargar los datos. Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con diferentes tipos de datos) se produce una excepción.  
  
 Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML. Si no se pueden ampliar el esquema por inferencia para exponer todos los datos, se produce una excepción.  
  
> [!NOTE]
>  El `DataSet` no asocia un elemento XML con sus correspondientes `DataColumn` o `DataTable` cuando son caracteres de escape los caracteres XML legales como ("_") en el XML serializado. El `DataSet` sólo escapes de caracteres XML no válidos en nombres de elementos XML y, por tanto, solo puede usar el mismo. Cuando se escapan los caracteres válidos en nombre del elemento XML, el elemento se omite durante el procesamiento.  
  
 Si el esquema XML para un <xref:System.Data.DataSet> incluye `targetNamespace`, no se pueden leer los datos y que produzcan excepciones al llamar a <xref:System.Data.DataSet.ReadXml%2A> para cargar el <xref:System.Data.DataSet> con XML que contenga elementos con un espacio de nombres sin calificación. Para leer elementos incompletos, establezca `elementFormDefault` igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Objeto <see cref="T:System.IO.TextReader" /> desde el que se va a leer.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lee el esquema y los datos XML del objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.IO.TextReader" /> y la enumeración <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilizado para leer los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.ReadXml%2A> método proporciona una manera de leer datos, o los datos y el esquema en un <xref:System.Data.DataSet> desde un documento XML, mientras que el <xref:System.Data.DataSet.ReadXmlSchema%2A> método sólo lee el esquema. Para leer los datos y el esquema, use uno de los `ReadXML` sobrecargas que incluye el `mode` parámetro y establezca su valor en `ReadSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.WriteXml%2A> y <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para escribir datos XML, o el esquema y los datos desde el `DataSet`, utilice el `WriteXml` método. Para escribir únicamente el esquema, utilice el `WriteXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si se especifica un esquema en línea, el esquema en línea se usa para extender la estructura relacional existente antes de cargar los datos. Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con diferentes tipos de datos) se produce una excepción.  
  
 Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML. Si no se pueden ampliar el esquema por inferencia para exponer todos los datos, se produce una excepción.  
  
> [!NOTE]
>  El `DataSet` no asocia un elemento XML con sus correspondientes `DataColumn` o `DataTable` cuando son caracteres de escape los caracteres XML legales como ("_") en el XML serializado. El `DataSet` sólo escapes de caracteres XML no válidos en nombres de elementos XML y, por tanto, solo puede usar el mismo. Cuando se escapan los caracteres válidos en nombre del elemento XML, el elemento se omite durante el procesamiento.  
  
 Si el esquema XML para un <xref:System.Data.DataSet> incluye `targetNamespace`, no se pueden leer los datos y que produzcan excepciones al llamar a <xref:System.Data.DataSet.ReadXml%2A> para cargar el <xref:System.Data.DataSet> con XML que contenga elementos con un espacio de nombres sin calificación. Para leer elementos incompletos, establezca `elementFormDefault` igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo (incluida la ruta) desde el que se va a leer.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lee el esquema y los datos XML del <see cref="T:System.Data.DataSet" /> mediante el archivo y el <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilizado para leer los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.ReadXml%2A> método proporciona una manera de leer datos, o los datos y el esquema en un <xref:System.Data.DataSet> desde un documento XML, mientras que el <xref:System.Data.DataSet.ReadXmlSchema%2A> método sólo lee el esquema. Para leer los datos y el esquema, use uno de los `ReadXML` sobrecargas que incluye el `mode` parámetro y establezca su valor en `ReadSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.WriteXml%2A> y <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para escribir datos XML, o el esquema y los datos desde el `DataSet`, utilice el `WriteXml` método. Para escribir únicamente el esquema, utilice el `WriteXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si se especifica un esquema en línea, el esquema en línea se usa para extender la estructura relacional existente antes de cargar los datos. Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con diferentes tipos de datos) se produce una excepción.  
  
 Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML. Si no se pueden ampliar el esquema por inferencia para exponer todos los datos, se produce una excepción.  
  
> [!NOTE]
>  El `DataSet` no asocia un elemento XML con sus correspondientes `DataColumn` o `DataTable` cuando son caracteres de escape los caracteres XML legales como ("_") en el XML serializado. El `DataSet` sólo escapes de caracteres XML no válidos en nombres de elementos XML y, por tanto, solo puede usar el mismo. Cuando se escapan los caracteres válidos en nombre del elemento XML, el elemento se omite durante el procesamiento.  
  
 Si el esquema XML para un <xref:System.Data.DataSet> incluye un `targetNamespace`, no se pueden leer los datos y que produzcan excepciones al llamar a <xref:System.Data.DataSet.ReadXml%2A> para cargar el <xref:System.Data.DataSet> con XML que contenga elementos con un espacio de nombres sin calificación. Para leer elementos incompletos, establezca `elementFormDefault` igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> no está establecido en <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Objeto <see cref="T:System.Xml.XmlReader" /> desde el que se va a leer.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lee el esquema y los datos XML del objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.Xml.XmlReader" /> y la enumeración <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilizado para leer los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.DataSet.ReadXml%2A> método proporciona una manera de leer datos, o los datos y el esquema en un <xref:System.Data.DataSet> desde un documento XML, mientras que el <xref:System.Data.DataSet.ReadXmlSchema%2A> método sólo lee el esquema. Para leer los datos y el esquema, use uno de los `ReadXML` sobrecargas que incluye el `mode` parámetro y establezca su valor en `ReadSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.WriteXml%2A> y <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para escribir datos XML, o el esquema y los datos desde el `DataSet`, utilice el `WriteXml` método. Para escribir únicamente el esquema, utilice el `WriteXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si se especifica un esquema en línea, el esquema en línea se usa para extender la estructura relacional existente antes de cargar los datos. Si hay algún conflicto (por ejemplo, la misma columna en la misma tabla definida con diferentes tipos de datos) se produce una excepción.  
  
 Si no se especifica ningún esquema en línea, la estructura relacional se extiende por inferencia, según sea necesario, según la estructura del documento XML. Si no se pueden ampliar el esquema por inferencia para exponer todos los datos, se produce una excepción.  
  
> [!NOTE]
>  El `DataSet` no asocia un elemento XML con sus correspondientes `DataColumn` o `DataTable` cuando son caracteres de escape los caracteres XML legales como ("_") en el XML serializado. El `DataSet` sólo escapes de caracteres XML no válidos en nombres de elementos XML y, por tanto, solo puede usar el mismo. Cuando se escapan los caracteres válidos en nombre del elemento XML, el elemento se omite durante el procesamiento.  
  
 Si el esquema XML para un <xref:System.Data.DataSet> incluye un `targetNamespace`, no se pueden leer los datos y que produzcan excepciones al llamar a <xref:System.Data.DataSet.ReadXml%2A> para cargar el <xref:System.Data.DataSet> con XML que contenga elementos con un espacio de nombres sin calificación. Para leer elementos incompletos, establezca `elementFormDefault` igual a "qualified" en el esquema XML como se muestra en el ejemplo siguiente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee un esquema XML en el objeto <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Objeto <see cref="T:System.IO.Stream" /> desde el que se va a leer.</param>
        <summary>Lee el esquema XML del objeto <see cref="T:System.IO.Stream" /> especificado en el objeto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Data.DataSet.ReadXmlSchema%2A> método para crear el esquema para un <xref:System.Data.DataSet>. El esquema incluye definiciones de tabla, relaciones y restricciones. Para escribir un esquema en un documento XML, utilice el <xref:System.Data.DataSet.WriteXmlSchema%2A> método.  
  
 El esquema XML se escribe mediante el estándar XSD.  
  
> [!NOTE]
>  Pueden dañarse los datos si el DataType y los tipos xs: Type no coinciden. No se producirá ninguna excepción.  
  
 El <xref:System.Data.DataSet.ReadXmlSchema%2A> normalmente se llama al método antes de invocar el <xref:System.Data.DataSet.ReadXml%2A> método que se utiliza para rellenar el <xref:System.Data.DataSet>.  
  
 Las clases que derivan de la <xref:System.IO.Stream> clase incluir <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, y <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXmlSchema%2A>. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileStream> para leer un esquema XML de objeto e invoca el <xref:System.Data.DataSet.ReadXmlSchema%2A> método con el objeto.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Objeto <see cref="T:System.IO.TextReader" /> desde el que se va a leer.</param>
        <summary>Lee el esquema XML del objeto <see cref="T:System.IO.TextReader" /> especificado en el objeto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Data.DataSet.ReadXmlSchema%2A> método para crear el esquema para un <xref:System.Data.DataSet>. El esquema incluye definiciones de tabla, relaciones y restricciones. Para escribir un esquema en un documento XML, utilice el <xref:System.Data.DataSet.WriteXmlSchema%2A> método.  
  
 El esquema XML se escribe mediante el estándar XSD.  
  
> [!NOTE]
>  Pueden dañarse los datos si el DataType y los tipos xs: Type no coinciden. No se producirá ninguna excepción.  
  
 El <xref:System.Data.DataSet.ReadXmlSchema%2A> normalmente se llama al método antes de invocar el <xref:System.Data.DataSet.ReadXml%2A> método que se utiliza para rellenar el <xref:System.Data.DataSet>.  
  
 Las clases que heredan de la <xref:System.IO.TextReader> clase incluir la <xref:System.IO.StreamReader> y <xref:System.IO.StringReader> clases.  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXmlSchema%2A>. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.StreamReader> para leer un esquema de objeto e invoca el <xref:System.Data.DataSet.ReadXmlSchema%2A> método con el objeto.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo (incluida la ruta) desde el que se va a leer.</param>
        <summary>Lee el esquema XML del archivo especificado en el <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Data.DataSet.ReadXmlSchema%2A> método para crear el esquema para un <xref:System.Data.DataSet>. El esquema incluye definiciones de tabla, relaciones y restricciones. Para escribir un esquema en un documento XML, utilice el <xref:System.Data.DataSet.WriteXmlSchema%2A> método.  
  
 El esquema XML se escribe mediante el estándar XSD.  
  
> [!NOTE]
>  Pueden dañarse los datos si el DataType y los tipos xs: Type no coinciden. No se producirá ninguna excepción.  
  
 El <xref:System.Data.DataSet.ReadXmlSchema%2A> normalmente se llama al método antes de invocar el <xref:System.Data.DataSet.ReadXml%2A> método que se utiliza para rellenar el <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXmlSchema%2A>. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> no está establecido en <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Objeto <see cref="T:System.Xml.XmlReader" /> desde el que se va a leer.</param>
        <summary>Lee el esquema XML del objeto <see cref="T:System.Xml.XmlReader" /> especificado en el objeto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Data.DataSet.ReadXmlSchema%2A> método para crear el esquema para un <xref:System.Data.DataSet>. El esquema incluye definiciones de tabla, relaciones y restricciones.  
  
 El esquema XML se escribe mediante el estándar XSD.  
  
> [!NOTE]
>  Pueden dañarse los datos si el DataType y los tipos xs: Type no coinciden. No se producirá ninguna excepción.  
  
 El <xref:System.Data.DataSet.ReadXmlSchema%2A> normalmente se llama al método antes de invocar el <xref:System.Data.DataSet.ReadXml%2A> método que se utiliza para rellenar el <xref:System.Data.DataSet>.  
  
 La <xref:System.Xml.XmlReader?displayProperty=nameWithType> clase es abstracta. Una clase que hereda de la `XmlReader` es la <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> clase.  
  
> [!NOTE]
>  Si el esquema para su <xref:System.Data.DataSet> contiene elementos del mismo nombre, pero un tipo diferente, en el mismo espacio de nombres, se produce una excepción al intentar leer el esquema en el <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXmlSchema%2A>. No se produce esta excepción si está utilizando la versión 1.0 de .NET Framework.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Data.DataSet> y <xref:System.IO.FileStream?displayProperty=nameWithType> objeto. El <xref:System.IO.FileStream> objeto creado con una ruta de acceso y nombre de archivo, se usa para crear un <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> que se pasa como argumento a la <xref:System.Data.DataSet.ReadXmlSchema%2A> método.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lector XML especificado.</param>
        <summary>Omite los atributos y devuelve un conjunto de datos vacío.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deshace todos los cambios realizados en el <see cref="T:System.Data.DataSet" /> desde que se ha creado o desde que se ha llamado por última vez a <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invocar el <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> para llamar a la <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> método en todos los <xref:System.Data.DataTable> los objetos que contiene el <xref:System.Data.DataSet>.  
  
 <xref:System.Data.DataRow> los objetos que contiene el <xref:System.Data.DataSet> cada uno se puede establecer en modo de edición invocando el <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> método. Después de invocar el <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> método, se pueden rechazar los cambios mediante una llamada a la <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> en el <xref:System.Data.DataTable> a la que el <xref:System.Data.DataRow> pertenecen los objetos.  
  
 Cuando el <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> se llama al método, cualquier fila sigue en modo de edición cancela sus modificaciones. Se quitan las nuevas filas. Devuelven las filas modificadas y eliminadas a su estado original (`DataRowState.Unchanged`).  
  
 Objetos Acceptchange y Rejectchange solo se aplica a <xref:System.Data.DataRow> otros cambios relacionados (es decir, `Add`, `Remove`, `Delete`, y `Modify`). No son aplicables a los cambios estructurales o de esquema.  
  
   
  
## Examples  
 El ejemplo siguiente muestra una clase derivada de la <xref:System.Data.DataSet> clase. El <xref:System.Data.DataSet.RejectChanges%2A> evento se invoca desde dentro de una función.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de relaciones que vincula las tablas y permite la navegación desde las tablas primarias a las secundarias.</summary>
        <value>Elemento <see cref="T:System.Data.DataRelationCollection" /> que contiene una colección de objetos <see cref="T:System.Data.DataRelation" />. Si no existe ningún objeto <see cref="T:System.Data.DataRelation" />, se devuelve una colección vacía.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente imprime el nombre de columna de todas las tablas secundarias mediante la <xref:System.Data.DataSet.Relations%2A> propiedad.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una enumeración <see cref="T:System.Data.SerializationFormat" /> para el objeto <see cref="T:System.Data.DataSet" /> utilizado durante la comunicación remota.</summary>
        <value>Un objeto <see cref="T:System.Data.SerializationFormat" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra todas las tablas y quita todas las relaciones, restricciones externas y tablas de <see cref="T:System.Data.DataSet" />. Las subclases deben reemplazar a <see cref="M:System.Data.DataSet.Reset" /> para restaurar el estado original de un <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una enumeración <see cref="T:System.Data.SchemaSerializationMode" /> para un objeto <see cref="T:System.Data.DataSet" />.</summary>
        <value>Obtiene o establece una enumeración <see cref="T:System.Data.SchemaSerializationMode" /> para un objeto <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.DataSet> serializa sus esquema y datos de instancia de forma predeterminada en los servicios Web y escenarios de comunicación remota. Establecer el <xref:System.Data.DataSet.SchemaSerializationMode%2A> propiedad de un tipo `DataSet` a <xref:System.Data.SchemaSerializationMode.ExcludeSchema> hace que la información de esquema que se excluirán de la carga de serialización.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> se admite solo para un tipo `DataSet`. Para sin tipo `DataSet` sólo se puede establecer esta propiedad en <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> solo debe usarse en casos donde la información del esquema de la base de tipo `DataTables`, `DataRelations` y `Constraints` no ha sido modificado. Si las modificaciones realizadas se debe serializar la información de esquema completa, se produjo con <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> se admite en la versión 2.0 de .NET Framework o posterior.  
  
 Cuando <xref:System.Data.SchemaSerializationMode.ExcludeSchema> se establece, solo las propiedades de tiempo de ejecución de nivel superior está presentes en el <xref:System.Data.DataSet> se serializan. Además, se serializan solo si se producen sea distinto de los valores predeterminados. Ninguno de los `Tables`, `Relations` o `Constraints` se serializan. Las propiedades en tiempo de ejecución serializada incluyen <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, y <xref:System.Data.DataSet.CaseSensitive%2A>. Estas propiedades se serializan para asegurarse de que se conserva la integridad de los datos en tiempo de ejecución general.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un valor que indica si se debe conservar la propiedad <see cref="P:System.Data.DataSet.Relations" />.</summary>
        <returns>
          <see langword="true" /> si el valor de propiedad ha cambiado con respecto a su valor predeterminado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, utilice este método si se está creando un diseñador para el <xref:System.Data.DataSet>, o crear su propio control que incorpore el <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Los ejemplos siguientes muestran una clase derivada de la <xref:System.Data.DataSet> clase. El <xref:System.Data.DataSet.Reset%2A> y <xref:System.Data.DataSet.ShouldSerializeRelations%2A> métodos se invocan desde dentro de las funciones de la clase derivada.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un valor que indica si se debe conservar la propiedad <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <returns>
          <see langword="true" /> si el valor de propiedad ha cambiado con respecto a su valor predeterminado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, utilice este método solo si se está creando un diseñador para el <xref:System.Data.DataSet>, o crear su propio control que incorpore el <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra una clase derivada de la <xref:System.Data.DataSet> clase. El <xref:System.Data.DataSet.ShouldSerializeTables%2A> método se llama desde dentro de las funciones de la clase derivada.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una interfaz <see cref="T:System.ComponentModel.ISite" /> para el objeto <see cref="T:System.Data.DataSet" />.</summary>
        <value>Estructura <see cref="T:System.ComponentModel.ISite" /> para la colección <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sitios de enlazan un <xref:System.ComponentModel.Component> a un <xref:System.ComponentModel.Container> y habilitar la comunicación entre ellos, así como proporcionar una forma para el contenedor administrar sus componentes.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>Para una descripción de este miembro, vea <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Data.DataSet> se convierte en una interfaz <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Para una descripción de este miembro, vea <see cref="M:System.ComponentModel.IListSource.GetList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Data.DataSet> se convierte en una interfaz <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Para una descripción de este miembro, vea <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Data.DataSet> se convierte en una interfaz <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Objeto <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Data.DataSet> se convierte en una interfaz <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objeto <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Data.DataSet> se convierte en una interfaz <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetTablesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de tablas incluidas en <see cref="T:System.Data.DataSet" />.</summary>
        <value>Colección <see cref="T:System.Data.DataTableCollection" /> que contiene este objeto <see cref="T:System.Data.DataSet" />. Si no existe ningún objeto <see cref="T:System.Data.DataTable" />, se devuelve una colección vacía.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para agregar tablas a la colección, utilice <xref:System.Data.DataTableCollection.Add%2A> método de la <xref:System.Data.DataTableCollection>. Para quitar las tablas, use la <xref:System.Data.DataTableCollection.Remove%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente devuelve el <xref:System.Data.DataSet> del objeto <xref:System.Data.DataTableCollection>e imprime las columnas y filas de cada tabla.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe datos XML y, de forma opcional, el esquema del <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Objeto <see cref="T:System.IO.Stream" /> utilizado para escribir en un archivo.</param>
        <summary>Escribe los datos actuales para el objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `WriteXml` método proporciona una manera de escribir datos sólo, o los datos y esquema a partir de un <xref:System.Data.DataSet> en un documento XML, mientras que el <xref:System.Data.DataSet.WriteXmlSchema%2A> método sólo escribe el esquema. Para escribir los datos y el esquema, utilice una de las sobrecargas que incluye el `mode` parámetro y establezca su valor en `WriteSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.ReadXml%2A> y <xref:System.Data.DataSet.ReadXmlSchema%2A> métodos, respectivamente. Para leer datos XML, o el esquema y los datos del `DataSet`, utilice el `ReadXml` método. Para leer únicamente el esquema, utilice el `ReadXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileStream?displayProperty=nameWithType> objeto. A continuación, se usa el objeto con el <xref:System.Data.DataSet.WriteXml%2A> método para escribir un documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objeto <see cref="T:System.IO.TextWriter" /> con el que se va a escribir.</param>
        <summary>Escribe los datos actuales para el objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `WriteXml` método proporciona una manera de escribir datos sólo, o los datos y esquema a partir de un <xref:System.Data.DataSet> en un documento XML, mientras que el <xref:System.Data.DataSet.WriteXmlSchema%2A> método sólo escribe el esquema. Para escribir los datos y el esquema, utilice una de las sobrecargas que incluye el `mode` parámetro y establezca su valor en `WriteSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.ReadXml%2A> y <xref:System.Data.DataSet.ReadXmlSchema%2A> métodos, respectivamente. Para leer datos XML, o el esquema y los datos del `DataSet`, utilice el `ReadXml` método. Para leer únicamente el esquema, utilice el `ReadXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo (incluida la ruta) en el que se va a escribir.</param>
        <summary>Escribe los datos actuales para el <see cref="T:System.Data.DataSet" /> en el archivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `WriteXml` método proporciona una manera de escribir datos sólo, o los datos y esquema a partir de un <xref:System.Data.DataSet> en un documento XML, mientras que el <xref:System.Data.DataSet.WriteXmlSchema%2A> método sólo escribe el esquema. Para escribir los datos y el esquema, utilice una de las sobrecargas que incluye el `mode` parámetro y establezca su valor en `WriteSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.ReadXml%2A> y <xref:System.Data.DataSet.ReadXmlSchema%2A> métodos, respectivamente. Para leer datos XML, o el esquema y los datos del `DataSet`, utilice el `ReadXml` método. Para leer únicamente el esquema, utilice el `ReadXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> no está establecido en <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> con el que se va a escribir.</param>
        <summary>Escribe los datos actuales para el <see cref="T:System.Data.DataSet" /> en el <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `WriteXml` método proporciona una manera de escribir datos sólo, o los datos y esquema a partir de un <xref:System.Data.DataSet> en un documento XML, mientras que el <xref:System.Data.DataSet.WriteXmlSchema%2A> método sólo escribe el esquema. Para escribir los datos y el esquema, utilice una de las sobrecargas que incluye el `mode` parámetro y establezca su valor en `WriteSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.ReadXml%2A> y <xref:System.Data.DataSet.ReadXmlSchema%2A> métodos, respectivamente. Para leer datos XML, o el esquema y los datos del `DataSet`, utilice el `ReadXml` método. Para leer únicamente el esquema, utilice el `ReadXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Objeto <see cref="T:System.IO.Stream" /> utilizado para escribir en un archivo.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Escribe los datos actuales y, de forma opcional, el esquema para el objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.IO.Stream" /> y la enumeración <see cref="T:System.Data.XmlWriteMode" /> especificados. Para escribir el esquema, establezca el valor del parámetro <paramref name="mode" /> en <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `WriteXml` método proporciona una manera de escribir datos sólo, o los datos y esquema a partir de un <xref:System.Data.DataSet> en un documento XML, mientras que el <xref:System.Data.DataSet.WriteXmlSchema%2A> método sólo escribe el esquema. Para escribir los datos y el esquema, establezca el `mode` parámetro `WriteSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.ReadXml%2A> y <xref:System.Data.DataSet.ReadXmlSchema%2A> métodos, respectivamente. Para leer datos XML, o el esquema y los datos del `DataSet`, utilice el `ReadXml` método. Para leer únicamente el esquema, utilice el `ReadXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Objeto <see cref="T:System.IO.TextWriter" /> que se utiliza para escribir el documento.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Escribe los datos actuales y, de forma opcional, el esquema para el objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.IO.TextWriter" /> y la enumeración <see cref="T:System.Data.XmlWriteMode" /> especificados. Para escribir el esquema, establezca el valor del parámetro <paramref name="mode" /> en <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `WriteXml` método proporciona una manera de escribir datos sólo, o los datos y esquema a partir de un <xref:System.Data.DataSet> en un documento XML, mientras que el <xref:System.Data.DataSet.WriteXmlSchema%2A> método sólo escribe el esquema. Para escribir los datos y el esquema, establezca el `mode` parámetro `WriteSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.ReadXml%2A> y <xref:System.Data.DataSet.ReadXmlSchema%2A> métodos, respectivamente. Para leer datos XML, o el esquema y los datos del `DataSet`, utilice el `ReadXml` método. Para leer únicamente el esquema, utilice el `ReadXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 El ejemplo siguiente crea primero una sencilla <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, dos columnas y diez filas. El <xref:System.Data.DataSet> esquema y los datos se escriben en el disco mediante la invocación del <xref:System.Data.DataSet.WriteXml%2A> método. Un segundo <xref:System.Data.DataSet> se crea y <xref:System.Data.DataSet.ReadXml%2A> método se utiliza para llenarlo con datos y esquema.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo (incluida la ruta) en el que se va a escribir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Escribe los datos actuales y, de forma opcional, el esquema para el objeto <see cref="T:System.Data.DataSet" /> en el archivo indicado mediante la enumeración <see cref="T:System.Data.XmlWriteMode" /> especificada. Para escribir el esquema, establezca el valor del parámetro <paramref name="mode" /> en <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `WriteXml` método proporciona una manera de escribir datos sólo, o los datos y esquema a partir de un <xref:System.Data.DataSet> en un documento XML, mientras que el <xref:System.Data.DataSet.WriteXmlSchema%2A> método sólo escribe el esquema. Para escribir los datos y el esquema, establezca el `mode` parámetro `WriteSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.ReadXml%2A> y <xref:System.Data.DataSet.ReadXmlSchema%2A> métodos, respectivamente. Para leer datos XML, o el esquema y los datos del `DataSet`, utilice el `ReadXml` método. Para leer únicamente el esquema, utilice el `ReadXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Data.DataSet.WriteXml%2A> método para escribir un documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> no está establecido en <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> con el que se va a escribir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Escribe los datos actuales y, de forma opcional, el esquema para el objeto <see cref="T:System.Data.DataSet" /> mediante el objeto <see cref="T:System.Xml.XmlWriter" /> y la enumeración <see cref="T:System.Data.XmlWriteMode" /> especificados. Para escribir el esquema, establezca el valor del parámetro <paramref name="mode" /> en <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `WriteXml` método proporciona una manera de escribir datos sólo, o los datos y esquema a partir de un <xref:System.Data.DataSet> en un documento XML, mientras que el <xref:System.Data.DataSet.WriteXmlSchema%2A> método sólo escribe el esquema. Para escribir los datos y el esquema, establezca el `mode` parámetro `WriteSchema`.  
  
 Tenga en cuenta que el mismo es cierto para el <xref:System.Data.DataSet.ReadXml%2A> y <xref:System.Data.DataSet.ReadXmlSchema%2A> métodos, respectivamente. Para leer datos XML, o el esquema y los datos del `DataSet`, utilice el `ReadXml` método. Para leer únicamente el esquema, utilice el `ReadXmlSchema` método.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se producirá si un tipo de columna en la `DataRow` que se leen o escriben a implements <xref:System.Dynamic.IDynamicMetaObjectProvider> y no implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileStream?displayProperty=nameWithType> objeto que se usa para crear un nuevo <xref:System.Xml.XmlTextWriter>. El <xref:System.Xml.XmlTextWriter> objeto se usa con el <xref:System.Data.DataSet.WriteXml%2A> método para escribir un documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe la estructura del <see cref="T:System.Data.DataSet" /> como un esquema XML.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Objeto <see cref="T:System.IO.Stream" /> utilizado para escribir en un archivo.</param>
        <summary>Escribe la estructura <see cref="T:System.Data.DataSet" /> como un esquema XML al objeto <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Data.DataSet.WriteXmlSchema%2A> método para escribir el esquema para un <xref:System.Data.DataSet> a un documento XML. El esquema incluye definiciones de tabla, relaciones y restricciones. Para escribir un esquema en un documento XML, utilice el <xref:System.Data.DataSet.WriteXmlSchema%2A> método.  
  
 El esquema XML se escribe mediante el estándar XSD.  
  
 Para escribir los datos en un documento XML, utilice el <xref:System.Data.DataSet.WriteXml%2A> método.  
  
 Las clases que derivan de la <xref:System.IO.Stream> clase incluir <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, y <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.IO.FileStream> objeto que se pasa a la <xref:System.Data.DataSet.WriteXmlSchema%2A> método para escribir el esquema en el disco.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objeto <see cref="T:System.IO.TextWriter" /> con el que se va a escribir.</param>
        <summary>Escribe la estructura <see cref="T:System.Data.DataSet" /> como un esquema XML al objeto <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Data.DataSet.WriteXmlSchema%2A> método para escribir el esquema para un <xref:System.Data.DataSet> a un documento XML. El esquema incluye definiciones de tabla, relaciones y restricciones. Para escribir un esquema en un documento XML, utilice el <xref:System.Data.DataSet.WriteXmlSchema%2A> método.  
  
 El esquema XML se escribe mediante el estándar XSD.  
  
 Para escribir los datos en un documento XML, utilice el <xref:System.Data.DataSet.WriteXml%2A> método.  
  
 Las clases que derivan de la <xref:System.IO.TextWriter?displayProperty=nameWithType> clase incluir la <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, y <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Text.StringBuilder?displayProperty=nameWithType> objeto al que se usa para crear un nuevo <xref:System.IO.StringWriter?displayProperty=nameWithType>. El <xref:System.IO.StringWriter> se pasa a la <xref:System.Data.DataSet.WriteXmlSchema%2A> método y la cadena resultante se imprime en la ventana de consola.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo (incluida la ruta) en el que se va a escribir.</param>
        <summary>Escribe la estructura del <see cref="T:System.Data.DataSet" /> como un esquema XML en un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Data.DataSet.WriteXmlSchema%2A> método para escribir el esquema para un <xref:System.Data.DataSet> a un documento XML. El esquema incluye definiciones de tabla, relaciones y restricciones. Para escribir un esquema en un documento XML, utilice el <xref:System.Data.DataSet.WriteXmlSchema%2A> método.  
  
 El esquema XML se escribe mediante el estándar XSD.  
  
 Para escribir los datos en un documento XML, utilice el <xref:System.Data.DataSet.WriteXml%2A> método.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> no está establecido en <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> en el que se va a escribir.</param>
        <summary>Escribe la estructura del <see cref="T:System.Data.DataSet" /> como un esquema XML en un objeto <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Data.DataSet.WriteXmlSchema%2A> método para escribir el esquema para un <xref:System.Data.DataSet> a un documento XML. El esquema incluye definiciones de tabla, relaciones y restricciones. Para escribir un esquema en un documento XML, utilice el <xref:System.Data.DataSet.WriteXmlSchema%2A> método.  
  
 El esquema XML se escribe mediante el estándar XSD.  
  
 Para escribir los datos en un documento XML, utilice el <xref:System.Data.DataSet.WriteXml%2A> método.  
  
 Una clase que hereda de la <xref:System.Xml.XmlWriter?displayProperty=nameWithType> clase es el <xref:System.Xml.XmlTextWriter> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.IO.FileStream?displayProperty=nameWithType> objeto con la ruta de acceso especificada. El <xref:System.IO.FileStream> objeto se usa para crear un <xref:System.Xml.XmlTextWriter> objeto. El <xref:System.Data.DataSet.WriteXmlSchema%2A> , a continuación, se invoca el método con el <xref:System.Xml.XmlTextWriter> objeto para escribir el esquema en el disco.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6d4c4b69-8919-4224-8a65-6cca1c61b48f">Uso de conjuntos de datos en ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">Un objeto <see cref="T:System.IO.Stream" /> en el que se va a escribir.</param>
        <param name="multipleTargetConverter">Un delegado usado para convertir <see cref="T:System.Type" /> en una cadena.</param>
        <summary>Escribe la estructura <see cref="T:System.Data.DataSet" /> como un esquema XML al objeto <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Un objeto <see cref="T:System.IO.TextWriter" /> en el que se va a escribir.</param>
        <param name="multipleTargetConverter">Un delegado usado para convertir <see cref="T:System.Type" /> en una cadena.</param>
        <summary>Escribe la estructura de <see cref="T:System.Data.DataSet" /> como un esquema XML en el objeto <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre del archivo en el que se va a escribir.</param>
        <param name="multipleTargetConverter">Un delegado usado para convertir <see cref="T:System.Type" /> en una cadena.</param>
        <summary>Escribe la estructura del <see cref="T:System.Data.DataSet" /> como un esquema XML en un archivo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Un objeto <see cref="T:System.Xml.XmlWriter" /> en el que se va a escribir.</param>
        <param name="multipleTargetConverter">Un delegado usado para convertir <see cref="T:System.Type" /> en una cadena.</param>
        <summary>Escribe la estructura de <see cref="T:System.Data.DataSet" /> como un esquema XML en el objeto <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>